{"Benchmarks": [{"name": "4", "annotation": "\u0420\u0430\u0437\u0434\u0435\u043b ACKNOWLEDGEMENTS \u0432 \u043a\u043e\u043d\u0446\u0435 \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u043f\u0430\u043a\u0435\u0442\u0430", "group_ids": [{"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 986, "position": [605275, 605462], "check": 1, "intersection": 188, "FP_dupl": 17500, "FN_dupl": 0, "F": 0.02103378831953457, "Prec_Dupl": 0.010628674807779286, "Recall_Dupl": 1.0}, {"name2": "This  work is based on the previously proposed LDAP C API Concurrency Extensions draft (draft-zeilenga-ldap-c-api-concurrency-00.txt) effort.  OpenLDAP Software is developed and\u2029maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 985, "position": [531546, 531876], "check": 1, "intersection": 331, "FP_dupl": 3195, "FN_dupl": 0, "F": 0.1716359865180192, "Prec_Dupl": 0.09387407827566648, "Recall_Dupl": 1.0}, {"name2": "This  work is based on the previously proposed LDAP C API Concurrency Extensions draft (draft-zeilenga-ldap-c-api-concurrency-00.txt) effort.  OpenLDAP Software is developed and\u2029maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 984, "position": [495688, 496018], "check": 1, "intersection": 331, "FP_dupl": 3195, "FN_dupl": 0, "F": 0.1716359865180192, "Prec_Dupl": 0.09387407827566648, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 185, "position": [1079235, 1079422], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 184, "position": [1062662, 1062849], "check": 1, "intersection": 188, "FP_dupl": 2502, "FN_dupl": 0, "F": 0.13064628214037524, "Prec_Dupl": 0.06988847583643122, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 183, "position": [1059975, 1060162], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 182, "position": [1057288, 1057475], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 181, "position": [1054353, 1054540], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 180, "position": [1051418, 1051605], "check": 1, "intersection": 188, "FP_dupl": 21925, "FN_dupl": 0, "F": 0.016860230482937985, "Prec_Dupl": 0.008501786279564057, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 179, "position": [1040363, 1040550], "check": 1, "intersection": 188, "FP_dupl": 21925, "FN_dupl": 0, "F": 0.016860230482937985, "Prec_Dupl": 0.008501786279564057, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 178, "position": [1029308, 1029495], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 177, "position": [1018253, 1018440], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 176, "position": [1007198, 1007385], "check": 1, "intersection": 188, "FP_dupl": 3231, "FN_dupl": 0, "F": 0.10424175214859996, "Prec_Dupl": 0.05498683825680024, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 175, "position": [1005490, 1005677], "check": 1, "intersection": 188, "FP_dupl": 3231, "FN_dupl": 0, "F": 0.10424175214859996, "Prec_Dupl": 0.05498683825680024, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 174, "position": [1003782, 1003969], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 173, "position": [995002, 995189], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 172, "position": [986222, 986409], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Initially  developed  by SysNet s.n.c.  OpenLDAP is developed and maintained by The OpenLDAP Project (http://www.openldap.org/).  OpenLDAP is derived from University of Michigan\u2029LDAP 3.3 Release.", "id_dupl": 171, "position": [977434, 977629], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 170, "position": [968222, 968409], "check": 1, "intersection": 188, "FP_dupl": 27694, "FN_dupl": 0, "F": 0.013395083719273245, "Prec_Dupl": 0.00674270138440571, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 169, "position": [966683, 966870], "check": 1, "intersection": 188, "FP_dupl": 27694, "FN_dupl": 0, "F": 0.013395083719273245, "Prec_Dupl": 0.00674270138440571, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 168, "position": [957903, 958090], "check": 1, "intersection": 188, "FP_dupl": 27694, "FN_dupl": 0, "F": 0.013395083719273245, "Prec_Dupl": 0.00674270138440571, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 167, "position": [949123, 949310], "check": 1, "intersection": 188, "FP_dupl": 27694, "FN_dupl": 0, "F": 0.013395083719273245, "Prec_Dupl": 0.00674270138440571, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 166, "position": [940343, 940530], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 165, "position": [933876, 934063], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 164, "position": [925096, 925283], "check": 1, "intersection": 188, "FP_dupl": 3231, "FN_dupl": 0, "F": 0.10424175214859996, "Prec_Dupl": 0.05498683825680024, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 163, "position": [923388, 923575], "check": 1, "intersection": 188, "FP_dupl": 3231, "FN_dupl": 0, "F": 0.10424175214859996, "Prec_Dupl": 0.05498683825680024, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 162, "position": [921680, 921867], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 161, "position": [920395, 920582], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 160, "position": [919110, 919297], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 159, "position": [917825, 918012], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 158, "position": [916540, 916727], "check": 1, "intersection": 188, "FP_dupl": 21925, "FN_dupl": 0, "F": 0.016860230482937985, "Prec_Dupl": 0.008501786279564057, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 157, "position": [905485, 905672], "check": 1, "intersection": 188, "FP_dupl": 21925, "FN_dupl": 0, "F": 0.016860230482937985, "Prec_Dupl": 0.008501786279564057, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 156, "position": [894430, 894617], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 155, "position": [888505, 888692], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 154, "position": [877450, 877637], "check": 1, "intersection": 188, "FP_dupl": 17500, "FN_dupl": 0, "F": 0.02103378831953457, "Prec_Dupl": 0.010628674807779286, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 153, "position": [859765, 859952], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 152, "position": [854718, 854905], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 151, "position": [849671, 849858], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 150, "position": [844624, 844811], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 149, "position": [839577, 839764], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 148, "position": [834530, 834717], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 147, "position": [825750, 825937], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.\u2029", "id_dupl": 146, "position": [816970, 817158], "check": 1, "intersection": 189, "FP_dupl": 21924, "FN_dupl": 0, "F": 0.016949152542372885, "Prec_Dupl": 0.008547008547008548, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 145, "position": [805915, 806102], "check": 1, "intersection": 188, "FP_dupl": 21925, "FN_dupl": 0, "F": 0.016860230482937985, "Prec_Dupl": 0.008501786279564057, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 144, "position": [794860, 795047], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 143, "position": [788448, 788635], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.\u2029", "id_dupl": 142, "position": [784009, 784197], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 141, "position": [781306, 781493], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 140, "position": [778603, 778790], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 139, "position": [772191, 772378], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 138, "position": [769814, 770001], "check": 1, "intersection": 188, "FP_dupl": 203, "FN_dupl": 0, "F": 0.6493955094991364, "Prec_Dupl": 0.48081841432225064, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 137, "position": [768091, 768278], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 136, "position": [764196, 764383], "check": 1, "intersection": 188, "FP_dupl": 3710, "FN_dupl": 0, "F": 0.09202153695545766, "Prec_Dupl": 0.04822986146741919, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 135, "position": [760301, 760488], "check": 1, "intersection": 188, "FP_dupl": 203, "FN_dupl": 0, "F": 0.6493955094991364, "Prec_Dupl": 0.48081841432225064, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 134, "position": [758027, 758214], "check": 1, "intersection": 188, "FP_dupl": 3710, "FN_dupl": 0, "F": 0.09202153695545766, "Prec_Dupl": 0.04822986146741919, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 133, "position": [754132, 754319], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 132, "position": [748207, 748394], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 131, "position": [739427, 739614], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 130, "position": [730647, 730834], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 129, "position": [721867, 722054], "check": 1, "intersection": 188, "FP_dupl": 9352, "FN_dupl": 0, "F": 0.03865131578947369, "Prec_Dupl": 0.019706498951781972, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 128, "position": [719541, 719728], "check": 1, "intersection": 188, "FP_dupl": 9352, "FN_dupl": 0, "F": 0.03865131578947369, "Prec_Dupl": 0.019706498951781972, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 127, "position": [716975, 717162], "check": 1, "intersection": 188, "FP_dupl": 9352, "FN_dupl": 0, "F": 0.03865131578947369, "Prec_Dupl": 0.019706498951781972, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 126, "position": [714650, 714837], "check": 1, "intersection": 188, "FP_dupl": 9352, "FN_dupl": 0, "F": 0.03865131578947369, "Prec_Dupl": 0.019706498951781972, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 125, "position": [712330, 712517], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 124, "position": [707891, 708078], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 123, "position": [703452, 703639], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 122, "position": [699013, 699200], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 121, "position": [694741, 694928], "check": 1, "intersection": 188, "FP_dupl": 2068, "FN_dupl": 0, "F": 0.15384615384615385, "Prec_Dupl": 0.08333333333333333, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 120, "position": [692488, 692675], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 119, "position": [690235, 690422], "check": 1, "intersection": 188, "FP_dupl": 2068, "FN_dupl": 0, "F": 0.15384615384615385, "Prec_Dupl": 0.08333333333333333, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 118, "position": [687982, 688169], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 117, "position": [685729, 685916], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 116, "position": [681457, 681644], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 115, "position": [677185, 677372], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 114, "position": [672913, 673100], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 113, "position": [668641, 668828], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 112, "position": [667102, 667289], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 111, "position": [665563, 665750], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 110, "position": [664024, 664211], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 109, "position": [662485, 662672], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 108, "position": [660946, 661133], "check": 1, "intersection": 188, "FP_dupl": 27694, "FN_dupl": 0, "F": 0.013395083719273245, "Prec_Dupl": 0.00674270138440571, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 107, "position": [659407, 659594], "check": 1, "intersection": 188, "FP_dupl": 27694, "FN_dupl": 0, "F": 0.013395083719273245, "Prec_Dupl": 0.00674270138440571, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 106, "position": [650627, 650814], "check": 1, "intersection": 188, "FP_dupl": 27694, "FN_dupl": 0, "F": 0.013395083719273245, "Prec_Dupl": 0.00674270138440571, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 105, "position": [641847, 642034], "check": 1, "intersection": 188, "FP_dupl": 27694, "FN_dupl": 0, "F": 0.013395083719273245, "Prec_Dupl": 0.00674270138440571, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 104, "position": [633067, 633254], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 103, "position": [630132, 630319], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 102, "position": [628424, 628611], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 101, "position": [622499, 622686], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 100, "position": [616574, 616761], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 99, "position": [610649, 610836], "check": 1, "intersection": 188, "FP_dupl": 2502, "FN_dupl": 0, "F": 0.13064628214037524, "Prec_Dupl": 0.06988847583643122, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 98, "position": [607962, 608149], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 97, "position": [587590, 587777], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.\u2029", "id_dupl": 96, "position": [581123, 581311], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 95, "position": [578188, 578375], "check": 1, "intersection": 188, "FP_dupl": 9352, "FN_dupl": 0, "F": 0.03865131578947369, "Prec_Dupl": 0.019706498951781972, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 94, "position": [575862, 576049], "check": 1, "intersection": 188, "FP_dupl": 9352, "FN_dupl": 0, "F": 0.03865131578947369, "Prec_Dupl": 0.019706498951781972, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 93, "position": [573296, 573483], "check": 1, "intersection": 188, "FP_dupl": 9352, "FN_dupl": 0, "F": 0.03865131578947369, "Prec_Dupl": 0.019706498951781972, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 92, "position": [570971, 571158], "check": 1, "intersection": 188, "FP_dupl": 9352, "FN_dupl": 0, "F": 0.03865131578947369, "Prec_Dupl": 0.019706498951781972, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 91, "position": [568651, 568838], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 90, "position": [566255, 566442], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 89, "position": [563859, 564046], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 88, "position": [557392, 557579], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 87, "position": [550925, 551112], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 86, "position": [544513, 544700], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 85, "position": [538101, 538288], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 84, "position": [528166, 528353], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 83, "position": [521699, 521886], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 82, "position": [515232, 515419], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 81, "position": [508765, 508952], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 80, "position": [502298, 502485], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 79, "position": [492308, 492495], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 78, "position": [489798, 489985], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 77, "position": [487288, 487475], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 76, "position": [484778, 484965], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 75, "position": [482268, 482455], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 74, "position": [475801, 475988], "check": 1, "intersection": 188, "FP_dupl": 2502, "FN_dupl": 0, "F": 0.13064628214037524, "Prec_Dupl": 0.06988847583643122, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 73, "position": [473114, 473301], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 72, "position": [470427, 470614], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 71, "position": [468101, 468288], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 70, "position": [465535, 465722], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 69, "position": [463210, 463397], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 68, "position": [460277, 460464], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 67, "position": [457344, 457531], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 66, "position": [454411, 454598], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 65, "position": [451478, 451665], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 64, "position": [448545, 448732], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 63, "position": [445612, 445799], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 62, "position": [442679, 442866], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 61, "position": [440046, 440233], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 60, "position": [437413, 437600], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 59, "position": [434780, 434967], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 58, "position": [432147, 432334], "check": 1, "intersection": 188, "FP_dupl": 21925, "FN_dupl": 0, "F": 0.016860230482937985, "Prec_Dupl": 0.008501786279564057, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 57, "position": [421092, 421279], "check": 1, "intersection": 188, "FP_dupl": 21925, "FN_dupl": 0, "F": 0.016860230482937985, "Prec_Dupl": 0.008501786279564057, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 56, "position": [410037, 410224], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 55, "position": [401257, 401444], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 54, "position": [392477, 392664], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 53, "position": [383697, 383884], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 52, "position": [381136, 381323], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 51, "position": [378575, 378762], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 50, "position": [376014, 376201], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 49, "position": [373453, 373640], "check": 1, "intersection": 188, "FP_dupl": 2083, "FN_dupl": 0, "F": 0.15290768605124033, "Prec_Dupl": 0.08278291501541171, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 48, "position": [371182, 371369], "check": 1, "intersection": 188, "FP_dupl": 2083, "FN_dupl": 0, "F": 0.15290768605124033, "Prec_Dupl": 0.08278291501541171, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 47, "position": [350704, 350891], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 46, "position": [344292, 344479], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 45, "position": [338253, 338440], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 44, "position": [332871, 333058], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 43, "position": [331365, 331552], "check": 1, "intersection": 188, "FP_dupl": 25991, "FN_dupl": 0, "F": 0.014260249554367202, "Prec_Dupl": 0.00718132854578097, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 42, "position": [323036, 323223], "check": 1, "intersection": 188, "FP_dupl": 25991, "FN_dupl": 0, "F": 0.014260249554367202, "Prec_Dupl": 0.00718132854578097, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 41, "position": [311228, 311415], "check": 1, "intersection": 188, "FP_dupl": 25991, "FN_dupl": 0, "F": 0.014260249554367202, "Prec_Dupl": 0.00718132854578097, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 40, "position": [305189, 305376], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 39, "position": [296860, 297047], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 38, "position": [285052, 285239], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 37, "position": [273244, 273431], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 36, "position": [264915, 265102], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 35, "position": [256586, 256773], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 34, "position": [248257, 248444], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 33, "position": [239928, 240115], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 32, "position": [231599, 231786], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 31, "position": [223270, 223457], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 30, "position": [214941, 215128], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 29, "position": [206612, 206799], "check": 1, "intersection": 188, "FP_dupl": 47047, "FN_dupl": 0, "F": 0.007928642220019821, "Prec_Dupl": 0.003980099502487562, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 28, "position": [194804, 194991], "check": 1, "intersection": 188, "FP_dupl": 47047, "FN_dupl": 0, "F": 0.007928642220019821, "Prec_Dupl": 0.003980099502487562, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 27, "position": [182996, 183183], "check": 1, "intersection": 188, "FP_dupl": 47047, "FN_dupl": 0, "F": 0.007928642220019821, "Prec_Dupl": 0.003980099502487562, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 26, "position": [171188, 171375], "check": 1, "intersection": 188, "FP_dupl": 47047, "FN_dupl": 0, "F": 0.007928642220019821, "Prec_Dupl": 0.003980099502487562, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 25, "position": [159380, 159567], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 24, "position": [147572, 147759], "check": 1, "intersection": 188, "FP_dupl": 47047, "FN_dupl": 0, "F": 0.007928642220019821, "Prec_Dupl": 0.003980099502487562, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 23, "position": [135764, 135951], "check": 1, "intersection": 188, "FP_dupl": 47047, "FN_dupl": 0, "F": 0.007928642220019821, "Prec_Dupl": 0.003980099502487562, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 22, "position": [123956, 124143], "check": 1, "intersection": 188, "FP_dupl": 47047, "FN_dupl": 0, "F": 0.007928642220019821, "Prec_Dupl": 0.003980099502487562, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 21, "position": [112148, 112335], "check": 1, "intersection": 188, "FP_dupl": 47047, "FN_dupl": 0, "F": 0.007928642220019821, "Prec_Dupl": 0.003980099502487562, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 20, "position": [100340, 100527], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 19, "position": [88532, 88719], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 18, "position": [82493, 82680], "check": 1, "intersection": 188, "FP_dupl": 25991, "FN_dupl": 0, "F": 0.014260249554367202, "Prec_Dupl": 0.00718132854578097, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 17, "position": [74164, 74351], "check": 1, "intersection": 188, "FP_dupl": 25991, "FN_dupl": 0, "F": 0.014260249554367202, "Prec_Dupl": 0.00718132854578097, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 16, "position": [62356, 62543], "check": 1, "intersection": 188, "FP_dupl": 25991, "FN_dupl": 0, "F": 0.014260249554367202, "Prec_Dupl": 0.00718132854578097, "Recall_Dupl": 1.0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 15, "position": [56317, 56504], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 14, "position": [50278, 50465], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 13, "position": [44239, 44426], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 12, "position": [38200, 38387], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 11, "position": [32161, 32348], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 10, "position": [26122, 26309], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 9, "position": [20083, 20270], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 8, "position": [14044, 14231], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 7, "position": [8005, 8192], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "5", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u0432\u0441\u0435\u0445 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432 \u043a\u043e\u043c\u0430\u043d\u0434 ::ldap::modify \u0438 ::ldap::modifyMulti", "group_ids": [{"name2": "No attributes will be added if this argument is empty.", "id_dupl": 191, "position": [362837, 362891], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "No attributes will be deleted if this argument is empty. If no value is specified, the whole set of values for an attribute will be deleted.", "id_dupl": 190, "position": [362672, 362812], "check": 1, "intersection": 57, "FP_dupl": 221, "FN_dupl": 84, "F": 0.2720763723150358, "Prec_Dupl": 0.20503597122302158, "Recall_Dupl": 0.40425531914893614}, {"name2": "No  attributes  will  be  changed  if this argument is empty. The dictionary contains the new attributes and their values. They replace all attributes known to the\u2029object.", "id_dupl": 189, "position": [362473, 362644], "check": 1, "intersection": 172, "FP_dupl": 106, "FN_dupl": 0, "F": 0.7644444444444444, "Prec_Dupl": 0.6187050359712231, "Recall_Dupl": 1.0}, {"name2": "No attributes will be added if this argument is empty. The dictionary values are the values for the new attributes.", "id_dupl": 188, "position": [361732, 361847], "check": 1, "intersection": 53, "FP_dupl": 0, "FN_dupl": 63, "F": 0.6272189349112427, "Prec_Dupl": 1.0, "Recall_Dupl": 0.45689655172413796}, {"name2": "No  attributes  will  be deleted if this argument is empty. The dictionary values are restrictions on the deletion. An attribute listed here will be deleted if and\u2029only if its current value at the server matches the value specified in the dictionary, or if the value in the dictionary is the empty string.", "id_dupl": 187, "position": [361396, 361701], "check": 1, "intersection": 53, "FP_dupl": 0, "FN_dupl": 253, "F": 0.29526462395543174, "Prec_Dupl": 1.0, "Recall_Dupl": 0.17320261437908496}, {"name2": "No attributes will be changed if this argument is empty. The dictionary contains the new attributes and their values. They replace  all  attributes  known  to  the\u2029object.", "id_dupl": 186, "position": [361194, 361365], "check": 1, "intersection": 172, "FP_dupl": 112, "FN_dupl": 0, "F": 0.7543859649122806, "Prec_Dupl": 0.6056338028169014, "Recall_Dupl": 1.0}]}, {"name": "6", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043a\u043b\u044e\u0447\u0435\u0432\u044b\u0445 \u0441\u043b\u043e\u0432 \u0434\u043b\u044f TLS_REQCERT <level>, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u043e\u043f\u0446\u0438\u0435\u0439 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u043f\u0440\u0438 \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u0438  OpenLDAP \u0441 TLS(Transport Layer Security)", "group_ids": [{"name2": "The  server  certificate  is  requested. If no certificate is provided, the session proceeds normally. If a bad certificate is provided, it will be ignored and the\u2029session proceeds normally.", "id_dupl": 821, "position": [1077388, 1077578], "check": 1, "intersection": 137, "FP_dupl": 0, "FN_dupl": 54, "F": 0.8353658536585367, "Prec_Dupl": 1.0, "Recall_Dupl": 0.7172774869109948}, {"name2": "These  keywords  are  equivalent.  The server certificate is requested. If no certificate is provided, or a bad certificate is provided, the session is immediately\u2029terminated. This is the default setting.", "id_dupl": 193, "position": [1077778, 1077982], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The server certificate is requested. If no certificate is provided, the session proceeds normally. If a bad certificate is provided,  the  session  is  immediately\u2029terminated.", "id_dupl": 192, "position": [1077587, 1077762], "check": 1, "intersection": 133, "FP_dupl": 0, "FN_dupl": 43, "F": 0.86084142394822, "Prec_Dupl": 1.0, "Recall_Dupl": 0.7556818181818182}]}, {"name": "7", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 ldap_sync_intermediate_f", "group_ids": [{"name2": "In case of LDAP_SYNC_CAPI_DELETES,  the  \"deletes\"  phase  is\u2029being  entered;  this  means that the following sequence of results will consist in entries in \"delete\" sync state.", "id_dupl": 195, "position": [973186, 973363], "check": 1, "intersection": 126, "FP_dupl": 12, "FN_dupl": 52, "F": 0.7974683544303798, "Prec_Dupl": 0.9130434782608695, "Recall_Dupl": 0.7078651685393258}, {"name2": "In case of LDAP_SYNC_CAPI_PRESENTS, the \"present\" phase is being\u2029entered; this means that the following sequence of results will consist in entries in \"present\" sync state.", "id_dupl": 194, "position": [973012, 973184], "check": 1, "intersection": 123, "FP_dupl": 12, "FN_dupl": 50, "F": 0.7987012987012987, "Prec_Dupl": 0.9111111111111111, "Recall_Dupl": 0.7109826589595376}]}, {"name": "8", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043a\u043e\u043c\u0430\u043d\u0434 \u043f\u0430\u043a\u0435\u0442\u0430 ldap,( \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u044e\u0449\u0438\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0432 \u0432\u0438\u0434\u0435 \"a list of OIDs\" \u0438 \u044f\u0432\u043b\u044f\u044e\u0449\u0438\u0445\u0441\u044f \u044d\u043a\u0441\u043f\u0435\u0440\u0438\u043c\u0435\u043d\u0442\u0430\u043b\u044c\u043d\u044b\u043c\u0438).", "group_ids": [{"name2": "Returns the supported LDAP extensions as list of OIDs. Only valid in a bound state.  This is currently experimental and subject to change.", "id_dupl": 197, "position": [365799, 365937], "check": 1, "intersection": 98, "FP_dupl": 14, "FN_dupl": 41, "F": 0.7808764940239042, "Prec_Dupl": 0.875, "Recall_Dupl": 0.7050359712230215}, {"name2": "Return the supported controls advertised by the server as a list of OIDs. Only valid in a bound state.  This is currently experimental and subject to change.", "id_dupl": 196, "position": [365605, 365762], "check": 1, "intersection": 98, "FP_dupl": 14, "FN_dupl": 60, "F": 0.725925925925926, "Prec_Dupl": 0.875, "Recall_Dupl": 0.620253164556962}]}, {"name": "9", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 ldap.conf", "group_ids": [{"name2": "Specifies  the  name(s)  of  an  LDAP server(s) to which the LDAP library should connect.  Each server's name can be specified as a domain-style name or an IP address and\u2029optionally followed by a ':' and the port number the ldap server is listening on.  A space separated list of hosts may be provided.  HOST is deprecated in favor of URI.", "id_dupl": 199, "position": [1068189, 1068528], "check": 1, "intersection": 91, "FP_dupl": 24, "FN_dupl": 249, "F": 0.39999999999999997, "Prec_Dupl": 0.7913043478260869, "Recall_Dupl": 0.2676470588235294}, {"name2": "Specifies the URI(s) of an LDAP server(s) to which the LDAP library should connect.  The URI scheme may be any of ldap, ldaps or ldapi, which refer to LDAP over TCP, LDAP\u2029over SSL (TLS) and LDAP over IPC (UNIX domain sockets), respectively.  Each server's name can be specified as a domain-style name or an IP address  literal.   Optionally,\u2029the  server's name can followed by a ':' and the port number the LDAP server is listening on.  If no port number is provided, the default port for the scheme is used (389\u2029for ldap://, 636 for ldaps://).  For LDAP over IPC, name is the name of the socket, and no port is required, nor allowed; note that  directory  separators  must  be  URL-\u2029encoded, like any other characters that are special to URLs; so the socket\u2029\u2029/usr/local/var/ldapi\u2029\u2029must be specified as\u2029\u2029ldapi://%2Fusr%2Flocal%2Fvar%2Fldapi\u2029\u2029A space separated list of URIs may be provided.", "id_dupl": 198, "position": [1066361, 1067250], "check": 1, "intersection": 85, "FP_dupl": 25, "FN_dupl": 805, "F": 0.16999999999999998, "Prec_Dupl": 0.7727272727272727, "Recall_Dupl": 0.09550561797752809}]}, {"name": "10", "annotation": "\u041e\u043f\u0446\u0438\u0438 \u043c\u0435\u0442\u043e\u0434\u0430 ber_sockbuf_ctrl() \u043f\u0430\u043a\u0435\u0442\u0430 LBER_SOCKBUF", "group_ids": [{"name2": "Sets the maximum allowed size of an incoming message; arg must be a ber_len_t *.  The return value will be 1.", "id_dupl": 201, "position": [336465, 336574], "check": 1, "intersection": 105, "FP_dupl": 1, "FN_dupl": 5, "F": 0.9722222222222223, "Prec_Dupl": 0.9905660377358491, "Recall_Dupl": 0.9545454545454546}, {"name2": "Returns the maximum allowed size of an incoming message; arg must be a ber_len_t *.  The return value will be 1.", "id_dupl": 200, "position": [336322, 336434], "check": 1, "intersection": 105, "FP_dupl": 1, "FN_dupl": 8, "F": 0.9589041095890412, "Prec_Dupl": 0.9905660377358491, "Recall_Dupl": 0.9292035398230089}]}, {"name": "11", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 ldap.conf", "group_ids": [{"name2": "Specifies the default bind DN to use when performing ldap operations.  The bind DN must be specified as a Distinguished Name in LDAP format.  This is a user-only option.", "id_dupl": 203, "position": [1067443, 1067612], "check": 1, "intersection": 113, "FP_dupl": 0, "FN_dupl": 57, "F": 0.7985865724381626, "Prec_Dupl": 1.0, "Recall_Dupl": 0.6647058823529411}, {"name2": "Specifies the default base DN to use when performing ldap operations.  The base must be specified as a Distinguished Name in LDAP format.", "id_dupl": 202, "position": [1067278, 1067415], "check": 1, "intersection": 110, "FP_dupl": 0, "FN_dupl": 28, "F": 0.8870967741935484, "Prec_Dupl": 1.0, "Recall_Dupl": 0.7971014492753623}]}, {"name": "12", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043a\u043e\u043c\u0430\u043d\u0434 \u043f\u0430\u043a\u0435\u0442\u0430 ldap(\u043f\u043e\u0437\u0432\u043e\u043b\u044f\u044e\u0449\u0438\u0445 \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u0442\u044c \u043d\u043e\u0432\u044b\u0435 \u043e\u0431\u044a\u0435\u043a\u0442\u044b) \u0438 \u0438\u0445 \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u043e\u0432", "group_ids": [{"name2": "This  command is the preferred one to create a new object using the specified dn. The attributes of the new object are set to the values in the dictionary attrValueTuples\u2029(which is keyed by the attribute names).  Each tuple is a list containing multiple values.  The command blocks until the operation has completed. Its result is the  empty\u2029string.", "id_dupl": 205, "position": [363376, 363725], "check": 1, "intersection": 99, "FP_dupl": 0, "FN_dupl": 251, "F": 0.44097995545657015, "Prec_Dupl": 1.0, "Recall_Dupl": 0.28285714285714286}, {"name2": "This command creates a new object using the specified dn. The attributes of the new object are  set  to  the  values  in  the  list  attrValueTuples.   Multiple  valuated\u2029attributes may be specified using multiple tuples.  The command blocks until the operation has completed. Its result is the empty string.", "id_dupl": 204, "position": [363023, 363331], "check": 1, "intersection": 105, "FP_dupl": 0, "FN_dupl": 204, "F": 0.5072463768115942, "Prec_Dupl": 1.0, "Recall_Dupl": 0.33980582524271846}]}, {"name": "13", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 ldap.conf", "group_ids": [{"name2": "Specifies a time limit (in seconds) to use when performing searches.  The number should be a non-negative integer.  TIMELIMIT of zero (0) specifies unlimited search  time\u2029to  be  used.   Please note that the server may still apply any server-side limit on the duration of a search operation.  VERSION {2|3} Specifies what version of the LDAP\u2029protocol should be used.", "id_dupl": 207, "position": [1069515, 1069881], "check": 1, "intersection": 112, "FP_dupl": 0, "FN_dupl": 255, "F": 0.46764091858037576, "Prec_Dupl": 1.0, "Recall_Dupl": 0.30517711171662126}, {"name2": "Specifies  a  size limit (number of entries) to use when performing searches.  The number should be a non-negative integer.  SIZELIMIT of zero (0) specifies a request for\u2029unlimited search size.  Please note that the server may still apply any server-side limit on the amount of entries that can be returned by a search operation.", "id_dupl": 206, "position": [1069150, 1069479], "check": 1, "intersection": 112, "FP_dupl": 0, "FN_dupl": 218, "F": 0.5067873303167422, "Prec_Dupl": 1.0, "Recall_Dupl": 0.3393939393939394}]}, {"name": "14", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043a\u043e\u043c\u0430\u043d\u0434 \u043f\u0430\u043a\u0435\u0442\u0430 ldap, (\u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u044e\u0449\u0438\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u0440\u0438 \u0437\u0430\u0432\u0435\u0440\u0448\u043d\u0435\u043d\u0438\u0438 \u043a\u043e\u043c\u0430\u043d\u0434\u044b ldap::bind)", "group_ids": [{"name2": "This command returns the username used in the bind operation if a handle has successfully completed a ::ldap::bind.  If no bound was done or it failed, an empty string is\u2029returned.", "id_dupl": 209, "position": [364978, 365158], "check": 1, "intersection": 91, "FP_dupl": 0, "FN_dupl": 90, "F": 0.6691176470588235, "Prec_Dupl": 1.0, "Recall_Dupl": 0.5027624309392266}, {"name2": "This command returns 1 if a handle has successfully completed a ::ldap::bind.  If no bind was done or it failed, a 0 is returned.", "id_dupl": 208, "position": [364817, 364946], "check": 1, "intersection": 90, "FP_dupl": 0, "FN_dupl": 40, "F": 0.8181818181818181, "Prec_Dupl": 1.0, "Recall_Dupl": 0.6923076923076923}]}, {"name": "12", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043e\u043f\u0446\u0438\u0439 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 LDAP.CONF", "group_ids": [{"name2": "Specifies  the  name(s)  of  an  LDAP server(s) to which the LDAP library should connect.  Each server's name can be specified as a domain-style name or an IP address and\u2029optionally followed by a ':' and the port number the ldap server is listening on.  A space separated list of hosts may be provided.  HOST is deprecated in favor of URI.", "id_dupl": 205, "position": [1068189, 1068528], "check": 1, "intersection": 91, "FP_dupl": 24, "FN_dupl": 249, "F": 0.39999999999999997, "Prec_Dupl": 0.7913043478260869, "Recall_Dupl": 0.2676470588235294}, {"name2": "Specifies the URI(s) of an LDAP server(s) to which the LDAP library should connect.  The URI scheme may be any of ldap, ldaps or ldapi, which refer to LDAP over TCP, LDAP\u2029over SSL (TLS) and LDAP over IPC (UNIX domain sockets), respectively.  Each server's name can be specified as a domain-style name or an IP address  literal.   Optionally,\u2029the  server's name can followed by a ':' and the port number the LDAP server is listening on.  If no port number is provided, the default port for the scheme is used (389\u2029for ldap://, 636 for ldaps://).  For LDAP over IPC, name is the name of the socket, and no port is required, nor allowed; note that  directory  separators  must  be  URL-\u2029encoded, like any other characters that are special to URLs; so the socket\u2029\u2029/usr/local/var/ldapi\u2029\u2029must be specified as\u2029\u2029ldapi://%2Fusr%2Flocal%2Fvar%2Fldapi\u2029\u2029A space separated list of URIs may be provided.", "id_dupl": 204, "position": [1066361, 1067250], "check": 1, "intersection": 85, "FP_dupl": 25, "FN_dupl": 805, "F": 0.16999999999999998, "Prec_Dupl": 0.7727272727272727, "Recall_Dupl": 0.09550561797752809}]}, {"name": "13", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430 msg  \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u0441\u0438\u043d\u0445\u0440\u043e\u043d\u0438\u0437\u0430\u0446\u0438\u0438 \u043f\u0430\u043a\u0435\u0442\u0430 LDAP_SYNC", "group_ids": [{"name2": "The msg argument is the LDAPMessage that contains the response; it can be parsed using the regular client API routines,  like  ldap_parse_result(3).  ", "id_dupl": 208, "position": [974202, 974352], "check": 1, "intersection": 72, "FP_dupl": 0, "FN_dupl": 79, "F": 0.6457399103139013, "Prec_Dupl": 1.0, "Recall_Dupl": 0.4768211920529801}, {"name2": "The msg argument is the LDAPMessage that contains the searchResultReference; it can  be  parsed  using\u2029the regular client API routines, like ldap_parse_reference(3).", "id_dupl": 207, "position": [972356, 972521], "check": 1, "intersection": 54, "FP_dupl": 14, "FN_dupl": 112, "F": 0.4615384615384615, "Prec_Dupl": 0.7941176470588235, "Recall_Dupl": 0.3253012048192771}, {"name2": "The msg argument is the LDAPMessage that contains the searchResultEntry; it can  be  parsed  using  the  regular\u2029client  API  routines, like ldap_get_dn(3), ldap_first_attribute(3), and so on.", "id_dupl": 206, "position": [971481, 971673], "check": 1, "intersection": 54, "FP_dupl": 14, "FN_dupl": 139, "F": 0.41379310344827586, "Prec_Dupl": 0.7941176470588235, "Recall_Dupl": 0.27979274611398963}]}, {"name": "14", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435  \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u0441\u0438\u043d\u0445\u0440\u043e\u043d\u0438\u0437\u0430\u0446\u0438\u0438 \u043f\u0430\u043a\u0435\u0442\u0430 LDAP_SYNC", "group_ids": [{"name2": "A  function that is called whenever a searchResultDone is returned.  In refreshAndPersist this can only occur when the server decides that the search must be interrupted.", "id_dupl": 211, "position": [974031, 974201], "check": 1, "intersection": 38, "FP_dupl": 0, "FN_dupl": 133, "F": 0.3636363636363636, "Prec_Dupl": 1.0, "Recall_Dupl": 0.2222222222222222}, {"name2": "A function that is called whenever a search reference is returned.", "id_dupl": 210, "position": [972288, 972354], "check": 1, "intersection": 37, "FP_dupl": 0, "FN_dupl": 30, "F": 0.7115384615384616, "Prec_Dupl": 1.0, "Recall_Dupl": 0.5522388059701493}, {"name2": "A function that is called whenever an entry is returned.", "id_dupl": 209, "position": [971423, 971479], "check": 1, "intersection": 13, "FP_dupl": 55, "FN_dupl": 44, "F": 0.20799999999999996, "Prec_Dupl": 0.19117647058823528, "Recall_Dupl": 0.22807017543859648}]}, {"name": "15", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 referralsp \u0438 serverctrlsp \u043f\u0430\u043a\u0435\u0442\u043e\u0432, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0445 \u0434\u043b\u044f \u0438\u0437\u0432\u043b\u0435\u0447\u0435\u043d\u0438\u044f \u0438\u043d\u0444\u0440\u043c\u0430\u0446\u0438\u0438 \u0438\u0437 result message \u043f\u0430\u043a\u0435\u0442\u043e\u0432 LDAP_PARSE_REFERENCE \u0438 LDAP_PARSE_RESULT", "group_ids": [{"name2": "The  serverctrlsp  parameter  will be filled in with an allocated array of controls copied from the parsed message. The array should be freed using ldap_controls_free(3).  If no\u2029controls were returned, *serverctrlsp is set to NULL", "id_dupl": 219, "position": [766531, 766761], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The  serverctrlsp  parameter  will be filled in with an allocated array of controls copied from the parsed message. The array should be freed using ldap_controls_free(3).  If no\u2029controls were returned, *serverctrlsp is set to NULL.", "id_dupl": 218, "position": [762636, 762867], "check": 1, "intersection": 232, "FP_dupl": 3666, "FN_dupl": 0, "F": 0.11234866828087166, "Prec_Dupl": 0.059517701385325805, "Recall_Dupl": 1.0}, {"name2": "The  serverctrlsp parameter will be filled in with an allocated array of controls copied from the parsed message. The array should be freed by calling ldap_controls_free(3).  If\u2029serverctrlsp is NULL, no controls are returned.  If no controls were returned, *serverctrlsp is set to NULL.", "id_dupl": 217, "position": [759519, 759805], "check": 1, "intersection": 57, "FP_dupl": 0, "FN_dupl": 230, "F": 0.33139534883720934, "Prec_Dupl": 1.0, "Recall_Dupl": 0.1986062717770035}, {"name2": "The  serverctrlsp  parameter  will be filled in with an allocated array of controls copied from the parsed message. The array should be freed using ldap_controls_free(3).  If no\u2029controls were returned, *serverctrlsp is set to NULL.", "id_dupl": 216, "position": [756467, 756698], "check": 1, "intersection": 232, "FP_dupl": 3666, "FN_dupl": 0, "F": 0.11234866828087166, "Prec_Dupl": 0.059517701385325805, "Recall_Dupl": 1.0}, {"name2": "The referralsp parameter will be filled in with an allocated array of referral strings from the parsed message. This array should be freed using ldap_memvfree(3).  If no  refer\u2010\u2029rals were returned, *referralsp is set to NULL.", "id_dupl": 216, "position": [766304, 766529], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The referralsp parameter will be filled in with an allocated array of referral strings from the parsed message. This array should be freed using ldap_memvfree(3).  If no  refer\u2010\u2029rals were returned, *referralsp is set to NULL.", "id_dupl": 215, "position": [762409, 762634], "check": 1, "intersection": 226, "FP_dupl": 3672, "FN_dupl": 0, "F": 0.10960232783705141, "Prec_Dupl": 0.05797845048742945, "Recall_Dupl": 1.0}, {"name2": "The referralsp parameter will be filled in with an allocated array of character strings. The strings are copies of the referrals contained  in  the  parsed  message.  The  array\u2029should be freed by calling ldap_value_free(3).  If referralsp is NULL, no referrals are returned.  If no referrals were returned, *referralsp is set to NULL.", "id_dupl": 213, "position": [759182, 759517], "check": 1, "intersection": 61, "FP_dupl": 0, "FN_dupl": 275, "F": 0.3073047858942065, "Prec_Dupl": 1.0, "Recall_Dupl": 0.18154761904761904}, {"name2": "The referralsp parameter will be filled in with an allocated array of referral strings from the parsed message. This array should be freed using ldap_memvfree(3).  If no  refer\u2010\u2029rals were returned, *referralsp is set to NULL", "id_dupl": 212, "position": [756240, 756464], "check": 1, "intersection": 225, "FP_dupl": 3673, "FN_dupl": 0, "F": 0.10914382731021101, "Prec_Dupl": 0.05772190867111339, "Recall_Dupl": 1.0}]}, {"name": "16", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 ldap_sync_intermediate_f", "group_ids": [{"name2": "In case of LDAP_SYNC_CAPI_PRESENTS_IDSET, the message\u2029contains a set of UUIDs of entries that are present; it replaces a \"presents\" phase.", "id_dupl": 949, "position": [973365, 973503], "check": 1, "intersection": 52, "FP_dupl": 0, "FN_dupl": 87, "F": 0.5445026178010471, "Prec_Dupl": 1.0, "Recall_Dupl": 0.37410071942446044}, {"name2": "In case of LDAP_SYNC_CAPI_DELETES_IDSET, the message contains  a  set  of  UUIDs  of\u2029entries  that  have been deleted; it replaces a \"deletes\" phase.", "id_dupl": 949, "position": [973505, 973654], "check": 1, "intersection": 58, "FP_dupl": 0, "FN_dupl": 92, "F": 0.5576923076923077, "Prec_Dupl": 1.0, "Recall_Dupl": 0.38666666666666666}]}, {"name": "17", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u0432\u0438\u0434\u043e\u0432 \u0444\u0443\u043d\u043a\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u043e\u0441\u0442\u0438 \u043f\u0430\u043a\u0435\u0442\u0430 LDAP_SYNC", "group_ids": [{"name2": "The refreshAndPersist functionality is obtained by calling ldap_sync_init(3) with mode set to  LDAP_SYNC_REFRESH_AND_PERSIST,  or,  which  is  equivalent,  by  directly  calling\u2029ldap_sync_init_refresh_and_persist(3) and, after a successful return, by repeatedly polling with ldap_sync_poll(3) according to the desired pattern.", "id_dupl": 223, "position": [976052, 976378], "check": 1, "intersection": 51, "FP_dupl": 0, "FN_dupl": 276, "F": 0.2698412698412699, "Prec_Dupl": 1.0, "Recall_Dupl": 0.1559633027522936}, {"name2": "The refreshOnly functionality is obtained by periodically calling ldap_sync_init(3) with mode set to  LDAP_SYNC_REFRESH_ONLY,  or,  which  is  equivalent,  by  directly  calling\u2029ldap_sync_init_refresh_only(3).  The state of the search, and the consistency of the search parameters, is preserved across calls by passing the ldap_sync_t structure as left by\u2029the previous call.", "id_dupl": 222, "position": [975656, 976030], "check": 1, "intersection": 51, "FP_dupl": 0, "FN_dupl": 324, "F": 0.23943661971830985, "Prec_Dupl": 1.0, "Recall_Dupl": 0.136}]}, {"name": "18", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 <properties>  \u043e\u043f\u0446\u0438\u0438 SASL_SECPROPS \u043f\u0430\u043a\u0435\u0442\u0430 LDAP.CONF", "group_ids": [{"name2": "specifies the maximum acceptable security strength factor as an integer (see minssf description).  The default is INT_MAX.", "id_dupl": 225, "position": [1071813, 1071935], "check": 1, "intersection": 50, "FP_dupl": 0, "FN_dupl": 73, "F": 0.5780346820809249, "Prec_Dupl": 1.0, "Recall_Dupl": 0.4065040650406504}, {"name2": "specifies  the  minimum  acceptable security strength factor as an integer approximating the effective key length used for encryption.  0 (zero) implies no protec\u2010\u2029tion, 1 implies integrity protection only, 56 allows DES or other weak ciphers, 112 allows triple DES and other strong ciphers, 128 allows RC4, Blowfish and  other\u2029modern strong ciphers.  The default is 0.", "id_dupl": 224, "position": [1071412, 1071781], "check": 1, "intersection": 50, "FP_dupl": 0, "FN_dupl": 320, "F": 0.2380952380952381, "Prec_Dupl": 1.0, "Recall_Dupl": 0.13513513513513514}]}, {"name": "19", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u044b ldap_sync_t \u043f\u0430\u043a\u0435\u0442\u0430 LDAP_SYNC", "group_ids": [{"name2": "The requested size limit (in entries); by default 0, to indicate no limit.", "id_dupl": 227, "position": [970771, 970845], "check": 1, "intersection": 36, "FP_dupl": 5, "FN_dupl": 39, "F": 0.6206896551724138, "Prec_Dupl": 0.8780487804878049, "Recall_Dupl": 0.48}, {"name2": "The requested time limit (in seconds); by default 0, to indicate no limit.", "id_dupl": 226, "position": [970678, 970752], "check": 1, "intersection": 36, "FP_dupl": 5, "FN_dupl": 39, "F": 0.6206896551724138, "Prec_Dupl": 0.8780487804878049, "Recall_Dupl": 0.48}]}, {"name": "20", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043e\u043f\u0446\u0438\u0439 GSSAPI OPTIONS \u043f\u0430\u043a\u0435\u0442\u0430 LDAP.CONF", "group_ids": [{"name2": "Specifies if GSSAPI encryption (GSS_C_INTEG_FLAG and GSS_C_CONF_FLAG) should be used. The default is off.", "id_dupl": 229, "position": [1072435, 1072540], "check": 1, "intersection": 36, "FP_dupl": 1, "FN_dupl": 70, "F": 0.5034965034965034, "Prec_Dupl": 0.972972972972973, "Recall_Dupl": 0.33962264150943394}, {"name2": "Specifies if GSSAPI signing (GSS_C_INTEG_FLAG) should be used.  The default is off.", "id_dupl": 228, "position": [1072294, 1072377], "check": 1, "intersection": 37, "FP_dupl": 1, "FN_dupl": 47, "F": 0.6065573770491804, "Prec_Dupl": 0.9736842105263158, "Recall_Dupl": 0.44047619047619047}]}, {"name": "21", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 b, e, I \u043c\u0435\u0442\u043e\u0434\u0430 ber_scanf() \u0432 LBER_DECODER \u0438 \u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 b, e, I \u043c\u0435\u0442\u043e\u0434\u0430 ber_printf() \u0432 LBER_ENCODER", "group_ids": [{"name2": "Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.", "id_dupl": 982, "position": [269343, 269425], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Integer.  An ber_int_t parameter should be supplied.  An integer element is output.", "id_dupl": 981, "position": [269526, 269609], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.", "id_dupl": 980, "position": [261014, 261096], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.", "id_dupl": 979, "position": [252685, 252767], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Integer.  An ber_int_t parameter should be supplied.  An integer element is output.", "id_dupl": 978, "position": [244539, 244622], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.", "id_dupl": 977, "position": [236027, 236109], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.", "id_dupl": 976, "position": [236114, 236205], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.", "id_dupl": 975, "position": [227785, 227876], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.", "id_dupl": 974, "position": [219456, 219547], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Enumeration.  A pointer to a ber_int_t should be supplied.", "id_dupl": 973, "position": [316631, 316689], "check": 1, "intersection": 59, "FP_dupl": 26120, "FN_dupl": 0, "F": 0.004497294001067155, "Prec_Dupl": 0.002253714809580198, "Recall_Dupl": 1.0}, {"name2": "Boolean.  A pointer to a ber_int_t should be supplied.", "id_dupl": 972, "position": [290396, 290450], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Boolean.  A pointer to a ber_int_t should be supplied.", "id_dupl": 971, "position": [200148, 200202], "check": 1, "intersection": 55, "FP_dupl": 47180, "FN_dupl": 0, "F": 0.0023260731655741175, "Prec_Dupl": 0.001164390811897957, "Recall_Dupl": 1.0}, {"name2": "Boolean.  A pointer to a ber_int_t should be supplied.", "id_dupl": 970, "position": [176532, 176586], "check": 1, "intersection": 55, "FP_dupl": 47180, "FN_dupl": 0, "F": 0.0023260731655741175, "Prec_Dupl": 0.001164390811897957, "Recall_Dupl": 1.0}, {"name2": "Boolean.  A pointer to a ber_int_t should be supplied.", "id_dupl": 969, "position": [152916, 152970], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Enumeration.  A pointer to a ber_int_t should be supplied.", "id_dupl": 968, "position": [129359, 129417], "check": 1, "intersection": 59, "FP_dupl": 47176, "FN_dupl": 0, "F": 0.0024950310821668714, "Prec_Dupl": 0.0012490737800359903, "Recall_Dupl": 1.0}, {"name2": "Enumeration.  A pointer to a ber_int_t should be supplied.", "id_dupl": 967, "position": [93935, 93993], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Boolean.  A pointer to a ber_int_t should be supplied.", "id_dupl": 966, "position": [67700, 67754], "check": 1, "intersection": 55, "FP_dupl": 26124, "FN_dupl": 0, "F": 0.004193031943279713, "Prec_Dupl": 0.002100920585201879, "Recall_Dupl": 1.0}, {"name2": "Integer.  An ber_int_t parameter should be supplied.  An integer element is output.", "id_dupl": 304, "position": [327647, 327730], "check": 1, "intersection": 84, "FP_dupl": 26095, "FN_dupl": 0, "F": 0.006396832045082435, "Prec_Dupl": 0.0032086787119446885, "Recall_Dupl": 1.0}, {"name2": "Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.", "id_dupl": 303, "position": [327551, 327642], "check": 1, "intersection": 92, "FP_dupl": 26087, "FN_dupl": 0, "F": 0.007003920672985421, "Prec_Dupl": 0.0035142671607013257, "Recall_Dupl": 1.0}, {"name2": "Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.", "id_dupl": 302, "position": [327464, 327546], "check": 1, "intersection": 83, "FP_dupl": 26096, "FN_dupl": 0, "F": 0.006320919960399056, "Prec_Dupl": 0.0031704801558501087, "Recall_Dupl": 1.0}, {"name2": "Integer.  An ber_int_t parameter should be supplied.  An integer element is output.", "id_dupl": 301, "position": [301471, 301554], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.", "id_dupl": 300, "position": [301375, 301466], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.", "id_dupl": 299, "position": [301288, 301370], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.", "id_dupl": 297, "position": [269430, 269521], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Integer.  An ber_int_t parameter should be supplied.  An integer element is output.", "id_dupl": 295, "position": [261197, 261280], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.", "id_dupl": 294, "position": [261101, 261192], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Integer.  An ber_int_t parameter should be supplied.  An integer element is output.", "id_dupl": 292, "position": [252868, 252951], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.", "id_dupl": 291, "position": [252772, 252863], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.", "id_dupl": 288, "position": [244443, 244534], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "An ber_int_t parameter should be supplied.  A boolean element is output.", "id_dupl": 287, "position": [244366, 244438], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Integer.  An ber_int_t parameter should be supplied.  An integer element is output.", "id_dupl": 286, "position": [236210, 236293], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Integer.  An ber_int_t parameter should be supplied.  An integer element is output", "id_dupl": 283, "position": [227881, 227963], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.", "id_dupl": 281, "position": [227698, 227780], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Integer.  An ber_int_t parameter should be supplied.  An integer element is output.", "id_dupl": 280, "position": [219552, 219635], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.", "id_dupl": 278, "position": [219369, 219451], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Integer.  An ber_int_t parameter should be supplied.  An integer element is output.", "id_dupl": 277, "position": [211223, 211306], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.", "id_dupl": 276, "position": [211127, 211218], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.", "id_dupl": 275, "position": [211040, 211122], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Integer.  An ber_int_t parameter should be supplied.  An integer element is output.", "id_dupl": 274, "position": [78775, 78858], "check": 1, "intersection": 84, "FP_dupl": 26095, "FN_dupl": 0, "F": 0.006396832045082435, "Prec_Dupl": 0.0032086787119446885, "Recall_Dupl": 1.0}, {"name2": "Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.", "id_dupl": 273, "position": [78679, 78770], "check": 1, "intersection": 92, "FP_dupl": 26087, "FN_dupl": 0, "F": 0.007003920672985421, "Prec_Dupl": 0.0035142671607013257, "Recall_Dupl": 1.0}, {"name2": "Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.", "id_dupl": 272, "position": [78592, 78674], "check": 1, "intersection": 83, "FP_dupl": 26096, "FN_dupl": 0, "F": 0.006320919960399056, "Prec_Dupl": 0.0031704801558501087, "Recall_Dupl": 1.0}, {"name2": "Integer.  A pointer to a ber_int_t should be supplied.", "id_dupl": 271, "position": [316694, 316748], "check": 1, "intersection": 55, "FP_dupl": 26124, "FN_dupl": 0, "F": 0.004193031943279713, "Prec_Dupl": 0.002100920585201879, "Recall_Dupl": 1.0}, {"name2": "Boolean.  A pointer to a ber_int_t should be supplied.", "id_dupl": 269, "position": [316572, 316626], "check": 1, "intersection": 55, "FP_dupl": 26124, "FN_dupl": 0, "F": 0.004193031943279713, "Prec_Dupl": 0.002100920585201879, "Recall_Dupl": 1.0}, {"name2": "Integer.  A pointer to a ber_int_t should be supplied.", "id_dupl": 268, "position": [290518, 290572], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Enumeration.  A pointer to a ber_int_t should be supplied.", "id_dupl": 267, "position": [290455, 290513], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Integer.  A pointer to a ber_int_t should be supplied.", "id_dupl": 265, "position": [278710, 278764], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Enumeration.  A pointer to a ber_int_t should be supplied.", "id_dupl": 264, "position": [278647, 278705], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Boolean.  A pointer to a ber_int_t should be supplied.", "id_dupl": 263, "position": [278588, 278642], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Integer.  A pointer to a ber_int_t should be supplied.", "id_dupl": 262, "position": [200270, 200324], "check": 1, "intersection": 55, "FP_dupl": 47180, "FN_dupl": 0, "F": 0.0023260731655741175, "Prec_Dupl": 0.001164390811897957, "Recall_Dupl": 1.0}, {"name2": "Enumeration.  A pointer to a ber_int_t should be supplied.", "id_dupl": 261, "position": [200207, 200265], "check": 1, "intersection": 59, "FP_dupl": 47176, "FN_dupl": 0, "F": 0.0024950310821668714, "Prec_Dupl": 0.0012490737800359903, "Recall_Dupl": 1.0}, {"name2": "Integer.  A pointer to a ber_int_t should be supplied.", "id_dupl": 259, "position": [188462, 188516], "check": 1, "intersection": 55, "FP_dupl": 47180, "FN_dupl": 0, "F": 0.0023260731655741175, "Prec_Dupl": 0.001164390811897957, "Recall_Dupl": 1.0}, {"name2": "Enumeration.  A pointer to a ber_int_t should be supplied.", "id_dupl": 258, "position": [188399, 188457], "check": 1, "intersection": 59, "FP_dupl": 47176, "FN_dupl": 0, "F": 0.0024950310821668714, "Prec_Dupl": 0.0012490737800359903, "Recall_Dupl": 1.0}, {"name2": "Boolean.  A pointer to a ber_int_t should be supplied.", "id_dupl": 257, "position": [188340, 188394], "check": 1, "intersection": 55, "FP_dupl": 47180, "FN_dupl": 0, "F": 0.0023260731655741175, "Prec_Dupl": 0.001164390811897957, "Recall_Dupl": 1.0}, {"name2": "Integer.  A pointer to a ber_int_t should be supplied.", "id_dupl": 256, "position": [176654, 176708], "check": 1, "intersection": 55, "FP_dupl": 47180, "FN_dupl": 0, "F": 0.0023260731655741175, "Prec_Dupl": 0.001164390811897957, "Recall_Dupl": 1.0}, {"name2": "Enumeration.  A pointer to a ber_int_t should be supplied.", "id_dupl": 255, "position": [176591, 176649], "check": 1, "intersection": 59, "FP_dupl": 47176, "FN_dupl": 0, "F": 0.0024950310821668714, "Prec_Dupl": 0.0012490737800359903, "Recall_Dupl": 1.0}, {"name2": "Integer.  A pointer to a ber_int_t should be supplied.", "id_dupl": 253, "position": [164846, 164900], "check": 1, "intersection": 55, "FP_dupl": 47180, "FN_dupl": 0, "F": 0.0023260731655741175, "Prec_Dupl": 0.001164390811897957, "Recall_Dupl": 1.0}, {"name2": "Enumeration.  A pointer to a ber_int_t should be supplied.", "id_dupl": 252, "position": [164783, 164841], "check": 1, "intersection": 59, "FP_dupl": 47176, "FN_dupl": 0, "F": 0.0024950310821668714, "Prec_Dupl": 0.0012490737800359903, "Recall_Dupl": 1.0}, {"name2": "Boolean.  A pointer to a ber_int_t should be supplied.", "id_dupl": 251, "position": [164724, 164778], "check": 1, "intersection": 55, "FP_dupl": 47180, "FN_dupl": 0, "F": 0.0023260731655741175, "Prec_Dupl": 0.001164390811897957, "Recall_Dupl": 1.0}, {"name2": "Integer.  A pointer to a ber_int_t should be supplied.", "id_dupl": 250, "position": [153038, 153092], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Enumeration.  A pointer to a ber_int_t should be supplied.", "id_dupl": 249, "position": [152975, 153033], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Integer.  A pointer to a ber_int_t should be supplied.", "id_dupl": 247, "position": [141230, 141284], "check": 1, "intersection": 55, "FP_dupl": 47180, "FN_dupl": 0, "F": 0.0023260731655741175, "Prec_Dupl": 0.001164390811897957, "Recall_Dupl": 1.0}, {"name2": "Enumeration.  A pointer to a ber_int_t should be supplied.", "id_dupl": 246, "position": [141167, 141225], "check": 1, "intersection": 59, "FP_dupl": 47176, "FN_dupl": 0, "F": 0.0024950310821668714, "Prec_Dupl": 0.0012490737800359903, "Recall_Dupl": 1.0}, {"name2": "Boolean.  A pointer to a ber_int_t should be supplied.", "id_dupl": 245, "position": [141108, 141162], "check": 1, "intersection": 55, "FP_dupl": 47180, "FN_dupl": 0, "F": 0.0023260731655741175, "Prec_Dupl": 0.001164390811897957, "Recall_Dupl": 1.0}, {"name2": "Integer.  A pointer to a ber_int_t should be supplied.", "id_dupl": 244, "position": [129422, 129476], "check": 1, "intersection": 55, "FP_dupl": 47180, "FN_dupl": 0, "F": 0.0023260731655741175, "Prec_Dupl": 0.001164390811897957, "Recall_Dupl": 1.0}, {"name2": "Boolean.  A pointer to a ber_int_t should be supplied.", "id_dupl": 242, "position": [129300, 129354], "check": 1, "intersection": 55, "FP_dupl": 47180, "FN_dupl": 0, "F": 0.0023260731655741175, "Prec_Dupl": 0.001164390811897957, "Recall_Dupl": 1.0}, {"name2": "Integer.  A pointer to a ber_int_t should be supplied.", "id_dupl": 241, "position": [117614, 117668], "check": 1, "intersection": 55, "FP_dupl": 47180, "FN_dupl": 0, "F": 0.0023260731655741175, "Prec_Dupl": 0.001164390811897957, "Recall_Dupl": 1.0}, {"name2": "Enumeration.  A pointer to a ber_int_t should be supplied.", "id_dupl": 240, "position": [117551, 117609], "check": 1, "intersection": 59, "FP_dupl": 47176, "FN_dupl": 0, "F": 0.0024950310821668714, "Prec_Dupl": 0.0012490737800359903, "Recall_Dupl": 1.0}, {"name2": "Boolean.  A pointer to a ber_int_t should be supplied.", "id_dupl": 239, "position": [117492, 117546], "check": 1, "intersection": 55, "FP_dupl": 47180, "FN_dupl": 0, "F": 0.0023260731655741175, "Prec_Dupl": 0.001164390811897957, "Recall_Dupl": 1.0}, {"name2": "Integer.  A pointer to a ber_int_t should be supplied.", "id_dupl": 238, "position": [105806, 105860], "check": 1, "intersection": 55, "FP_dupl": 47180, "FN_dupl": 0, "F": 0.0023260731655741175, "Prec_Dupl": 0.001164390811897957, "Recall_Dupl": 1.0}, {"name2": "Enumeration.  A pointer to a ber_int_t should be supplied.", "id_dupl": 237, "position": [105743, 105801], "check": 1, "intersection": 59, "FP_dupl": 47176, "FN_dupl": 0, "F": 0.0024950310821668714, "Prec_Dupl": 0.0012490737800359903, "Recall_Dupl": 1.0}, {"name2": "Boolean.  A pointer to a ber_int_t should be supplied.", "id_dupl": 236, "position": [105684, 105738], "check": 1, "intersection": 55, "FP_dupl": 47180, "FN_dupl": 0, "F": 0.0023260731655741175, "Prec_Dupl": 0.001164390811897957, "Recall_Dupl": 1.0}, {"name2": "Integer.  A pointer to a ber_int_t should be supplied.", "id_dupl": 235, "position": [93998, 94052], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Boolean.  A pointer to a ber_int_t should be supplied.", "id_dupl": 233, "position": [93876, 93930], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Integer.  A pointer to a ber_int_t should be supplied.", "id_dupl": 232, "position": [67822, 67876], "check": 1, "intersection": 55, "FP_dupl": 26124, "FN_dupl": 0, "F": 0.004193031943279713, "Prec_Dupl": 0.002100920585201879, "Recall_Dupl": 1.0}, {"name2": "Enumeration.  A pointer to a ber_int_t should be supplied.", "id_dupl": 231, "position": [67759, 67817], "check": 1, "intersection": 59, "FP_dupl": 26120, "FN_dupl": 0, "F": 0.004497294001067155, "Prec_Dupl": 0.002253714809580198, "Recall_Dupl": 1.0}]}, {"name": "22", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043c\u0435\u0442\u043e\u0434\u043e\u0432 \u043f\u0430\u043a\u0435\u0442\u0430 LDAP_COMPARE \u0438 LDAP_DELETE (\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u044b\u0439\u0445 \u0438 \u0430\u0441\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u044b\u0445)", "group_ids": [{"name2": "The ldap_delete() routine is used to perform an LDAP delete operation asynchronously. It takes the same parameters as ldap_delete_s(), but returns the message id of the  request\u2029it initiated. The result of the delete can be obtained by a subsequent call to ldap_result(3).", "id_dupl": 320, "position": [491127, 491399], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ldap_delete_s() routine is used to perform an LDAP delete operation synchronously. It takes dn, the DN of the entry to be deleted.  It returns an LDAP error code, indicating\u2029the success or failure of the operation.", "id_dupl": 319, "position": [490907, 491125], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ldap_delete() routine is used to perform an LDAP delete operation asynchronously. It takes the same parameters as ldap_delete_s(), but returns the message id of the  request\u2029it initiated. The result of the delete can be obtained by a subsequent call to ldap_result(3).", "id_dupl": 318, "position": [488617, 488889], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ldap_delete_s() routine is used to perform an LDAP delete operation synchronously. It takes dn, the DN of the entry to be deleted.  It returns an LDAP error code, indicating\u2029the success or failure of the operation.", "id_dupl": 317, "position": [488397, 488615], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ldap_delete() routine is used to perform an LDAP delete operation asynchronously. It takes the same parameters as ldap_delete_s(), but returns the message id of the  request\u2029it initiated. The result of the delete can be obtained by a subsequent call to ldap_result(3).", "id_dupl": 316, "position": [486107, 486379], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ldap_delete_s() routine is used to perform an LDAP delete operation synchronously. It takes dn, the DN of the entry to be deleted.  It returns an LDAP error code, indicating\u2029the success or failure of the operation.", "id_dupl": 315, "position": [485887, 486105], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ldap_delete() routine is used to perform an LDAP delete operation asynchronously. It takes the same parameters as ldap_delete_s(), but returns the message id of the  request\u2029it initiated. The result of the delete can be obtained by a subsequent call to ldap_result(3).", "id_dupl": 314, "position": [483597, 483869], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ldap_delete_s() routine is used to perform an LDAP delete operation synchronously. It takes dn, the DN of the entry to be deleted.  It returns an LDAP error code, indicating\u2029the success or failure of the operation.", "id_dupl": 313, "position": [483377, 483595], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ldap_compare_ext() routine is used to perform an LDAP compare operation asynchronously.  It takes the same parameters as ldap_compare_ext_s(), but provides the message id of\u2029the request it initiated in the integer pointed to msgidp.  The result of the compare can be obtained by a subsequent call to ldap_result(3).", "id_dupl": 312, "position": [441608, 441927], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The  ldap_compare_ext_s()  routine  is used to perform an LDAP compare operation synchronously.  It takes dn, the DN of the entry upon which to perform the compare, and attr and\u2029value, the attribute description and value to compare to those found in the entry.  It returns a code, which will be LDAP_COMPARE_TRUE if the entry contains the attribute  value\u2029and LDAP_COMPARE_FALSE if it does not.  Otherwise, an error code is returned that indicates the nature of the problem.  See ldap(3) for details.", "id_dupl": 311, "position": [441106, 441606], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ldap_compare_ext() routine is used to perform an LDAP compare operation asynchronously.  It takes the same parameters as ldap_compare_ext_s(), but provides the message id of\u2029the request it initiated in the integer pointed to msgidp.  The result of the compare can be obtained by a subsequent call to ldap_result(3).", "id_dupl": 310, "position": [438975, 439294], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The  ldap_compare_ext_s()  routine  is used to perform an LDAP compare operation synchronously.  It takes dn, the DN of the entry upon which to perform the compare, and attr and\u2029value, the attribute description and value to compare to those found in the entry.  It returns a code, which will be LDAP_COMPARE_TRUE if the entry contains the attribute  value\u2029and LDAP_COMPARE_FALSE if it does not.  Otherwise, an error code is returned that indicates the nature of the problem.  See ldap(3) for details.", "id_dupl": 309, "position": [438473, 438973], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ldap_compare_ext() routine is used to perform an LDAP compare operation asynchronously.  It takes the same parameters as ldap_compare_ext_s(), but provides the message id of\u2029the request it initiated in the integer pointed to msgidp.  The result of the compare can be obtained by a subsequent call to ldap_result(3).", "id_dupl": 308, "position": [436342, 436661], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The  ldap_compare_ext_s()  routine  is used to perform an LDAP compare operation synchronously.  It takes dn, the DN of the entry upon which to perform the compare, and attr and\u2029value, the attribute description and value to compare to those found in the entry.  It returns a code, which will be LDAP_COMPARE_TRUE if the entry contains the attribute  value\u2029and LDAP_COMPARE_FALSE if it does not.  Otherwise, an error code is returned that indicates the nature of the problem.  See ldap(3) for details.", "id_dupl": 307, "position": [435840, 436340], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ldap_compare_ext() routine is used to perform an LDAP compare operation asynchronously.  It takes the same parameters as ldap_compare_ext_s(), but provides the message id of\u2029the request it initiated in the integer pointed to msgidp.  The result of the compare can be obtained by a subsequent call to ldap_result(3).", "id_dupl": 306, "position": [433709, 434028], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The  ldap_compare_ext_s()  routine  is used to perform an LDAP compare operation synchronously.  It takes dn, the DN of the entry upon which to perform the compare, and attr and\u2029value, the attribute description and value to compare to those found in the entry.  It returns a code, which will be LDAP_COMPARE_TRUE if the entry contains the attribute  value\u2029and LDAP_COMPARE_FALSE if it does not.  Otherwise, an error code is returned that indicates the nature of the problem.  See ldap(3) for details.", "id_dupl": 305, "position": [433207, 433707], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "23", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043c\u0435\u0442\u043e\u0434\u043e\u0432 \u043f\u0430\u043a\u0435\u0442\u0430 LBER_DECODE", "group_ids": [{"name2": "The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.", "id_dupl": 988, "position": [320889, 321008]}, {"name2": "The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.", "id_dupl": 987, "position": [204465, 204584]}, {"name2": "The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.", "id_dupl": 361, "position": [321010, 321130], "check": 1, "intersection": 121, "FP_dupl": 26058, "FN_dupl": 0, "F": 0.00920152091254753, "Prec_Dupl": 0.0046220252874441346, "Recall_Dupl": 1.0}, {"name2": "The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.", "id_dupl": 360, "position": [294834, 294954], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.", "id_dupl": 359, "position": [283026, 283146], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.", "id_dupl": 358, "position": [204586, 204706], "check": 1, "intersection": 121, "FP_dupl": 47114, "FN_dupl": 0, "F": 0.005110228904468283, "Prec_Dupl": 0.0025616597861755053, "Recall_Dupl": 1.0}, {"name2": "The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.", "id_dupl": 357, "position": [192778, 192898], "check": 1, "intersection": 121, "FP_dupl": 47114, "FN_dupl": 0, "F": 0.005110228904468283, "Prec_Dupl": 0.0025616597861755053, "Recall_Dupl": 1.0}, {"name2": "The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.", "id_dupl": 356, "position": [180970, 181090], "check": 1, "intersection": 121, "FP_dupl": 47114, "FN_dupl": 0, "F": 0.005110228904468283, "Prec_Dupl": 0.0025616597861755053, "Recall_Dupl": 1.0}, {"name2": "The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.", "id_dupl": 355, "position": [169162, 169282], "check": 1, "intersection": 121, "FP_dupl": 47114, "FN_dupl": 0, "F": 0.005110228904468283, "Prec_Dupl": 0.0025616597861755053, "Recall_Dupl": 1.0}, {"name2": "The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.", "id_dupl": 354, "position": [157354, 157474], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.", "id_dupl": 353, "position": [145546, 145666], "check": 1, "intersection": 121, "FP_dupl": 47114, "FN_dupl": 0, "F": 0.005110228904468283, "Prec_Dupl": 0.0025616597861755053, "Recall_Dupl": 1.0}, {"name2": "The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.", "id_dupl": 352, "position": [133738, 133858], "check": 1, "intersection": 121, "FP_dupl": 47114, "FN_dupl": 0, "F": 0.005110228904468283, "Prec_Dupl": 0.0025616597861755053, "Recall_Dupl": 1.0}, {"name2": "The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.", "id_dupl": 351, "position": [121930, 122050], "check": 1, "intersection": 121, "FP_dupl": 47114, "FN_dupl": 0, "F": 0.005110228904468283, "Prec_Dupl": 0.0025616597861755053, "Recall_Dupl": 1.0}, {"name2": "The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.", "id_dupl": 350, "position": [110122, 110242], "check": 1, "intersection": 121, "FP_dupl": 47114, "FN_dupl": 0, "F": 0.005110228904468283, "Prec_Dupl": 0.0025616597861755053, "Recall_Dupl": 1.0}, {"name2": "The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.", "id_dupl": 349, "position": [98314, 98434], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.", "id_dupl": 348, "position": [72138, 72258], "check": 1, "intersection": 121, "FP_dupl": 26058, "FN_dupl": 0, "F": 0.00920152091254753, "Prec_Dupl": 0.0046220252874441346, "Recall_Dupl": 1.0}, {"name2": "The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.", "id_dupl": 333, "position": [294713, 294832], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.", "id_dupl": 332, "position": [282905, 283024], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.", "id_dupl": 330, "position": [192657, 192776], "check": 1, "intersection": 120, "FP_dupl": 47115, "FN_dupl": 0, "F": 0.005068102629078239, "Prec_Dupl": 0.0025404890441409972, "Recall_Dupl": 1.0}, {"name2": "The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.", "id_dupl": 329, "position": [180849, 180968], "check": 1, "intersection": 120, "FP_dupl": 47115, "FN_dupl": 0, "F": 0.005068102629078239, "Prec_Dupl": 0.0025404890441409972, "Recall_Dupl": 1.0}, {"name2": "The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.", "id_dupl": 328, "position": [169041, 169160], "check": 1, "intersection": 120, "FP_dupl": 47115, "FN_dupl": 0, "F": 0.005068102629078239, "Prec_Dupl": 0.0025404890441409972, "Recall_Dupl": 1.0}, {"name2": "The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.", "id_dupl": 327, "position": [157233, 157352], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.", "id_dupl": 326, "position": [145425, 145544], "check": 1, "intersection": 120, "FP_dupl": 47115, "FN_dupl": 0, "F": 0.005068102629078239, "Prec_Dupl": 0.0025404890441409972, "Recall_Dupl": 1.0}, {"name2": "The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.", "id_dupl": 325, "position": [133617, 133736], "check": 1, "intersection": 120, "FP_dupl": 47115, "FN_dupl": 0, "F": 0.005068102629078239, "Prec_Dupl": 0.0025404890441409972, "Recall_Dupl": 1.0}, {"name2": "The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.", "id_dupl": 324, "position": [121809, 121928], "check": 1, "intersection": 120, "FP_dupl": 47115, "FN_dupl": 0, "F": 0.005068102629078239, "Prec_Dupl": 0.0025404890441409972, "Recall_Dupl": 1.0}, {"name2": "The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.", "id_dupl": 323, "position": [110001, 110120], "check": 1, "intersection": 120, "FP_dupl": 47115, "FN_dupl": 0, "F": 0.005068102629078239, "Prec_Dupl": 0.0025404890441409972, "Recall_Dupl": 1.0}, {"name2": "The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.", "id_dupl": 322, "position": [98193, 98312], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called", "id_dupl": 321, "position": [72017, 72135], "check": 1, "intersection": 119, "FP_dupl": 26060, "FN_dupl": 0, "F": 0.009050117879686667, "Prec_Dupl": 0.004545628175254975, "Recall_Dupl": 1.0}]}, {"name": "24", "annotation": "\u041e\u0431\u0449\u0435\u0435 \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043f\u0430\u043a\u0435\u0442\u043e\u0432 LBER_ENCODE \u0438 LBER_DECODE", "group_ids": [{"name2": "These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and\u2029ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou\u2010\u2029tines return the length of the element encoded, or -1 if an error occurred.\u2029", "id_dupl": 385, "position": [324876, 325898], "check": 1, "intersection": 1023, "FP_dupl": 25156, "FN_dupl": 0, "F": 0.07521505771634437, "Prec_Dupl": 0.039077122884754956, "Recall_Dupl": 1.0}, {"name2": "These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.", "id_dupl": 384, "position": [313180, 314215], "check": 1, "intersection": 1036, "FP_dupl": 25143, "FN_dupl": 0, "F": 0.07613448465919528, "Prec_Dupl": 0.03957370411398449, "Recall_Dupl": 1.0}, {"name2": "These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and\u2029ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou\u2010\u2029tines return the length of the element encoded, or -1 if an error occurred.", "id_dupl": 383, "position": [298700, 299721], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.", "id_dupl": 382, "position": [287004, 288039], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.", "id_dupl": 381, "position": [275196, 276231], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and\u2029ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou\u2010\u2029tines return the length of the element encoded, or -1 if an error occurred.\u2029", "id_dupl": 380, "position": [266755, 267777], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and\u2029ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou\u2010\u2029tines return the length of the element encoded, or -1 if an error occurred.", "id_dupl": 379, "position": [258426, 259447], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and\u2029ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou\u2010\u2029tines return the length of the element encoded, or -1 if an error occurred.", "id_dupl": 378, "position": [250097, 251118], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and\u2029ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou\u2010\u2029tines return the length of the element encoded, or -1 if an error occurred.", "id_dupl": 377, "position": [241768, 242789], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and\u2029ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou\u2010\u2029tines return the length of the element encoded, or -1 if an error occurred.", "id_dupl": 376, "position": [233439, 234460], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and\u2029ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou\u2010\u2029tines return the length of the element encoded, or -1 if an error occurred.", "id_dupl": 375, "position": [225110, 226131], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and\u2029ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou\u2010\u2029tines return the length of the element encoded, or -1 if an error occurred.", "id_dupl": 374, "position": [216781, 217802], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and\u2029ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou\u2010\u2029tines return the length of the element encoded, or -1 if an error occurred.", "id_dupl": 373, "position": [208452, 209473], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.", "id_dupl": 372, "position": [196756, 197344], "check": 1, "intersection": 589, "FP_dupl": 46646, "FN_dupl": 0, "F": 0.024631983941117427, "Prec_Dupl": 0.012469567058325394, "Recall_Dupl": 1.0}, {"name2": "These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.", "id_dupl": 371, "position": [184948, 185983], "check": 1, "intersection": 1036, "FP_dupl": 46199, "FN_dupl": 0, "F": 0.04292432309254004, "Prec_Dupl": 0.02193288874775061, "Recall_Dupl": 1.0}, {"name2": "These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.", "id_dupl": 370, "position": [173140, 174175], "check": 1, "intersection": 1036, "FP_dupl": 46199, "FN_dupl": 0, "F": 0.04292432309254004, "Prec_Dupl": 0.02193288874775061, "Recall_Dupl": 1.0}, {"name2": "These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.", "id_dupl": 369, "position": [161332, 162367], "check": 1, "intersection": 1036, "FP_dupl": 46199, "FN_dupl": 0, "F": 0.04292432309254004, "Prec_Dupl": 0.02193288874775061, "Recall_Dupl": 1.0}, {"name2": "These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.", "id_dupl": 368, "position": [149524, 150559], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.", "id_dupl": 367, "position": [137716, 138751], "check": 1, "intersection": 1036, "FP_dupl": 46199, "FN_dupl": 0, "F": 0.04292432309254004, "Prec_Dupl": 0.02193288874775061, "Recall_Dupl": 1.0}, {"name2": "These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.", "id_dupl": 366, "position": [125908, 126943], "check": 1, "intersection": 1036, "FP_dupl": 46199, "FN_dupl": 0, "F": 0.04292432309254004, "Prec_Dupl": 0.02193288874775061, "Recall_Dupl": 1.0}, {"name2": "These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.", "id_dupl": 365, "position": [114100, 115135], "check": 1, "intersection": 1036, "FP_dupl": 46199, "FN_dupl": 0, "F": 0.04292432309254004, "Prec_Dupl": 0.02193288874775061, "Recall_Dupl": 1.0}, {"name2": "These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.", "id_dupl": 364, "position": [102292, 103327], "check": 1, "intersection": 1036, "FP_dupl": 46199, "FN_dupl": 0, "F": 0.04292432309254004, "Prec_Dupl": 0.02193288874775061, "Recall_Dupl": 1.0}, {"name2": "These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.", "id_dupl": 363, "position": [90484, 91519], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and\u2029ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou\u2010\u2029tines return the length of the element encoded, or -1 if an error occurred.", "id_dupl": 362, "position": [76004, 77025], "check": 1, "intersection": 1022, "FP_dupl": 25157, "FN_dupl": 0, "F": 0.07514429616558214, "Prec_Dupl": 0.03903892432866038, "Recall_Dupl": 1.0}]}, {"name": "25", "annotation": "\u0420\u0430\u0437\u0434\u0435\u043b NOTES \u043f\u0430\u043a\u0435\u0442\u043e\u0432 LBER_ENCODE \u0438 LBER_DECODE", "group_ids": [{"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.", "id_dupl": 411, "position": [331173, 331273], "check": 1, "intersection": 101, "FP_dupl": 26078, "FN_dupl": 0, "F": 0.0076864535768645355, "Prec_Dupl": 0.0038580541655525422, "Recall_Dupl": 1.0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.", "id_dupl": 410, "position": [322721, 322944], "check": 1, "intersection": 224, "FP_dupl": 25955, "FN_dupl": 0, "F": 0.01696776881414991, "Prec_Dupl": 0.008556476565185836, "Recall_Dupl": 1.0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.", "id_dupl": 409, "position": [304997, 305097], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.", "id_dupl": 408, "position": [296545, 296768], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.", "id_dupl": 407, "position": [284737, 284960], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.", "id_dupl": 406, "position": [273052, 273152], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.", "id_dupl": 405, "position": [264723, 264823], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.", "id_dupl": 404, "position": [256394, 256494], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.", "id_dupl": 403, "position": [248065, 248165], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.", "id_dupl": 402, "position": [239736, 239836], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.", "id_dupl": 401, "position": [231407, 231507], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.", "id_dupl": 400, "position": [223078, 223178], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.", "id_dupl": 399, "position": [214749, 214849], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.", "id_dupl": 398, "position": [206297, 206520], "check": 1, "intersection": 224, "FP_dupl": 47011, "FN_dupl": 0, "F": 0.009439726922185466, "Prec_Dupl": 0.004742246215729861, "Recall_Dupl": 1.0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.", "id_dupl": 397, "position": [194489, 194712], "check": 1, "intersection": 224, "FP_dupl": 47011, "FN_dupl": 0, "F": 0.009439726922185466, "Prec_Dupl": 0.004742246215729861, "Recall_Dupl": 1.0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.", "id_dupl": 396, "position": [182681, 182904], "check": 1, "intersection": 224, "FP_dupl": 47011, "FN_dupl": 0, "F": 0.009439726922185466, "Prec_Dupl": 0.004742246215729861, "Recall_Dupl": 1.0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.", "id_dupl": 395, "position": [170873, 171096], "check": 1, "intersection": 224, "FP_dupl": 47011, "FN_dupl": 0, "F": 0.009439726922185466, "Prec_Dupl": 0.004742246215729861, "Recall_Dupl": 1.0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.\u2029", "id_dupl": 394, "position": [159065, 159289], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.", "id_dupl": 393, "position": [147257, 147480], "check": 1, "intersection": 224, "FP_dupl": 47011, "FN_dupl": 0, "F": 0.009439726922185466, "Prec_Dupl": 0.004742246215729861, "Recall_Dupl": 1.0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.", "id_dupl": 392, "position": [135449, 135672], "check": 1, "intersection": 224, "FP_dupl": 47011, "FN_dupl": 0, "F": 0.009439726922185466, "Prec_Dupl": 0.004742246215729861, "Recall_Dupl": 1.0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.", "id_dupl": 391, "position": [123641, 123864], "check": 1, "intersection": 224, "FP_dupl": 47011, "FN_dupl": 0, "F": 0.009439726922185466, "Prec_Dupl": 0.004742246215729861, "Recall_Dupl": 1.0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.", "id_dupl": 390, "position": [111833, 112056], "check": 1, "intersection": 224, "FP_dupl": 47011, "FN_dupl": 0, "F": 0.009439726922185466, "Prec_Dupl": 0.004742246215729861, "Recall_Dupl": 1.0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.", "id_dupl": 389, "position": [100025, 100248], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.", "id_dupl": 388, "position": [82301, 82401], "check": 1, "intersection": 101, "FP_dupl": 26078, "FN_dupl": 0, "F": 0.0076864535768645355, "Prec_Dupl": 0.0038580541655525422, "Recall_Dupl": 1.0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.", "id_dupl": 387, "position": [73849, 74072], "check": 1, "intersection": 224, "FP_dupl": 25955, "FN_dupl": 0, "F": 0.01696776881414991, "Prec_Dupl": 0.008556476565185836, "Recall_Dupl": 1.0}, {"name2": "The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.", "id_dupl": 386, "position": [7813, 7913], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "26", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043f\u0440\u043e\u0446\u0435\u0434\u0443\u0440 \u043f\u0430\u043a\u0435\u0442\u0430 LDAP_GET_OPTION", "group_ids": [{"name2": "Determines whether the library should implicitly chase referrals or not.  invalue must be const int *; its value should either be LDAP_OPT_OFF or  LDAP_OPT_ON.   outvalue\u2029must be int *.", "id_dupl": 413, "position": [867000, 867185], "check": 1, "intersection": 186, "FP_dupl": 17502, "FN_dupl": 0, "F": 0.02081235313863713, "Prec_Dupl": 0.01051560379918589, "Recall_Dupl": 1.0}, {"name2": "Determines whether the library should implicitly chase referrals or not.  invalue must be const int *; its value should either be LDAP_OPT_OFF or  LDAP_OPT_ON.   outvalue\u2029must be int *.", "id_dupl": 412, "position": [594825, 595010], "check": 1, "intersection": 186, "FP_dupl": 17502, "FN_dupl": 0, "F": 0.02081235313863713, "Prec_Dupl": 0.01051560379918589, "Recall_Dupl": 1.0}]}, {"name": "27", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043c\u0435\u0442\u043e\u0434\u043e\u0432 \u043f\u0430\u043a\u0435\u0442\u043e\u0432 LDAP_ADD, LDAP_MODIFY, LDAP_SEARCH", "group_ids": [{"name2": "ldap_modify_ext_s() returns a code indicating success or, in the case of failure, indicating the nature of the failure.  See ldap_error(3) for details", "id_dupl": 424, "position": [697782, 697932], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "ldap_modify_ext_s() returns a code indicating success or, in the case of failure, indicating the nature of the failure.  See ldap_error(3) for details", "id_dupl": 423, "position": [684498, 684648], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "ldap_modify_ext_s() returns a code indicating success or, in the case of failure, indicating the nature of the failure.  See ldap_error(3) for details", "id_dupl": 422, "position": [680226, 680376], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "ldap_modify_ext_s() returns a code indicating success or, in the case of failure, indicating the nature of the failure.  See ldap_error(3) for details\u2029", "id_dupl": 421, "position": [675954, 676105], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "ldap_modify_ext_s() returns a code indicating success or, in the case of failure, indicating the nature of the failure.  See ldap_error(3) for details", "id_dupl": 420, "position": [671682, 671832], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "ldap_add_ext_s() returns an code indicating success or, in the case of\u2029failure, indicating the nature of failure of the operation.  See ldap_error(3) for more details.", "id_dupl": 419, "position": [382645, 382812], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "ldap_add_ext_s() returns an code indicating success or, in the case of\u2029failure, indicating the nature of failure of the operation.  See ldap_error(3) for more details.", "id_dupl": 418, "position": [380084, 380251], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "ldap_add_ext_s() returns an code indicating success or, in the case of\u2029failure, indicating the nature of failure of the operation.  See ldap_error(3) for more details.", "id_dupl": 417, "position": [377523, 377690], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "dap_add_ext_s() returns an code indicating success or, in the case of\u2029failure, indicating the nature of failure of the operation.  See ldap_error(3) for more details.", "id_dupl": 416, "position": [374963, 375129], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "\u2029ldap_abandon_ext() returns a code indicating success or, in the case of failure, the nature of the failure.  See ldap_error(3) for details.", "id_dupl": 415, "position": [372670, 372810], "check": 1, "intersection": 141, "FP_dupl": 2130, "FN_dupl": 0, "F": 0.11691542288557213, "Prec_Dupl": 0.062087186261558784, "Recall_Dupl": 1.0}, {"name2": "ldap_abandon_ext() returns a code indicating success or, in the case of failure, the nature of the failure.  See ldap_error(3) for details.", "id_dupl": 414, "position": [370400, 370539], "check": 1, "intersection": 140, "FP_dupl": 2131, "FN_dupl": 0, "F": 0.11613438407299875, "Prec_Dupl": 0.06164685160722149, "Recall_Dupl": 1.0}]}, {"name": "28", "annotation": "\u041f\u0443\u043d\u043a\u0442 NAME \u043f\u0430\u043a\u0435\u0442\u043e\u0432 LDAP_PARSE_SORT-CONTROL, LDAP_PARSE_VLV_CONTROL", "group_ids": [{"name2": "ldap_parse_vlv_control - Decode the information returned from a search operation that used a VLV (virtual list view) control", "id_dupl": 426, "position": [770379, 770503], "check": 1, "intersection": 8, "FP_dupl": 88, "FN_dupl": 117, "F": 0.07239819004524888, "Prec_Dupl": 0.08333333333333333, "Recall_Dupl": 0.064}, {"name2": "dap_parse_sort_control - Decode the information returned from a search operation that used a server-side sort control", "id_dupl": 425, "position": [768657, 768774], "check": 1, "intersection": 8, "FP_dupl": 88, "FN_dupl": 110, "F": 0.07476635514018692, "Prec_Dupl": 0.08333333333333333, "Recall_Dupl": 0.06779661016949153}]}, {"name": "29", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 a \u0438 A \u043c\u0435\u0442\u043e\u0434\u0430 ber_scanf()  \u0432 LBER_DECODER", "group_ids": [{"name2": "Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().", "id_dupl": 982, "position": [151416, 151643], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().", "id_dupl": 981, "position": [116224, 116551], "check": 1, "intersection": 328, "FP_dupl": 46907, "FN_dupl": 0, "F": 0.013792233458780985, "Prec_Dupl": 0.0069440033873187255, "Recall_Dupl": 1.0}, {"name2": "Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().", "id_dupl": 980, "position": [66432, 66759], "check": 1, "intersection": 328, "FP_dupl": 25851, "FN_dupl": 0, "F": 0.024748179726110084, "Prec_Dupl": 0.012529126399022117, "Recall_Dupl": 1.0}, {"name2": "Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().", "id_dupl": 983, "position": [175032, 175259], "check": 1, "intersection": 228, "FP_dupl": 47007, "FN_dupl": 0, "F": 0.009607483724164086, "Prec_Dupl": 0.004826929183867895, "Recall_Dupl": 1.0}, {"name2": "Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().", "id_dupl": 455, "position": [315304, 315631], "check": 1, "intersection": 328, "FP_dupl": 25851, "FN_dupl": 0, "F": 0.024748179726110084, "Prec_Dupl": 0.012529126399022117, "Recall_Dupl": 1.0}, {"name2": "Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().", "id_dupl": 454, "position": [315072, 315299], "check": 1, "intersection": 228, "FP_dupl": 25951, "FN_dupl": 0, "F": 0.017268148596962928, "Prec_Dupl": 0.008709270789564155, "Recall_Dupl": 1.0}, {"name2": "Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().", "id_dupl": 452, "position": [289128, 289455], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().", "id_dupl": 451, "position": [288896, 289123], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().", "id_dupl": 450, "position": [277320, 277647], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().", "id_dupl": 449, "position": [277088, 277315], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().", "id_dupl": 448, "position": [198880, 199207], "check": 1, "intersection": 328, "FP_dupl": 46907, "FN_dupl": 0, "F": 0.013792233458780985, "Prec_Dupl": 0.0069440033873187255, "Recall_Dupl": 1.0}, {"name2": "Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().", "id_dupl": 447, "position": [198648, 198875], "check": 1, "intersection": 228, "FP_dupl": 47007, "FN_dupl": 0, "F": 0.009607483724164086, "Prec_Dupl": 0.004826929183867895, "Recall_Dupl": 1.0}, {"name2": "Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().", "id_dupl": 446, "position": [187072, 187399], "check": 1, "intersection": 328, "FP_dupl": 46907, "FN_dupl": 0, "F": 0.013792233458780985, "Prec_Dupl": 0.0069440033873187255, "Recall_Dupl": 1.0}, {"name2": "Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().", "id_dupl": 445, "position": [186840, 187067], "check": 1, "intersection": 228, "FP_dupl": 47007, "FN_dupl": 0, "F": 0.009607483724164086, "Prec_Dupl": 0.004826929183867895, "Recall_Dupl": 1.0}, {"name2": "Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().", "id_dupl": 444, "position": [175264, 175591], "check": 1, "intersection": 328, "FP_dupl": 46907, "FN_dupl": 0, "F": 0.013792233458780985, "Prec_Dupl": 0.0069440033873187255, "Recall_Dupl": 1.0}, {"name2": "Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().", "id_dupl": 442, "position": [163456, 163783], "check": 1, "intersection": 328, "FP_dupl": 46907, "FN_dupl": 0, "F": 0.013792233458780985, "Prec_Dupl": 0.0069440033873187255, "Recall_Dupl": 1.0}, {"name2": "Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().", "id_dupl": 441, "position": [163224, 163451], "check": 1, "intersection": 228, "FP_dupl": 47007, "FN_dupl": 0, "F": 0.009607483724164086, "Prec_Dupl": 0.004826929183867895, "Recall_Dupl": 1.0}, {"name2": "Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().", "id_dupl": 440, "position": [151648, 151975], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().", "id_dupl": 438, "position": [139840, 140167], "check": 1, "intersection": 328, "FP_dupl": 46907, "FN_dupl": 0, "F": 0.013792233458780985, "Prec_Dupl": 0.0069440033873187255, "Recall_Dupl": 1.0}, {"name2": "Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().", "id_dupl": 437, "position": [139608, 139835], "check": 1, "intersection": 228, "FP_dupl": 47007, "FN_dupl": 0, "F": 0.009607483724164086, "Prec_Dupl": 0.004826929183867895, "Recall_Dupl": 1.0}, {"name2": "Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().", "id_dupl": 436, "position": [128032, 128359], "check": 1, "intersection": 328, "FP_dupl": 46907, "FN_dupl": 0, "F": 0.013792233458780985, "Prec_Dupl": 0.0069440033873187255, "Recall_Dupl": 1.0}, {"name2": "Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().", "id_dupl": 435, "position": [127800, 128027], "check": 1, "intersection": 228, "FP_dupl": 47007, "FN_dupl": 0, "F": 0.009607483724164086, "Prec_Dupl": 0.004826929183867895, "Recall_Dupl": 1.0}, {"name2": "Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().", "id_dupl": 433, "position": [115992, 116219], "check": 1, "intersection": 228, "FP_dupl": 47007, "FN_dupl": 0, "F": 0.009607483724164086, "Prec_Dupl": 0.004826929183867895, "Recall_Dupl": 1.0}, {"name2": "Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string us", "id_dupl": 432, "position": [104416, 104725], "check": 1, "intersection": 310, "FP_dupl": 46925, "FN_dupl": 0, "F": 0.013040277631717322, "Prec_Dupl": 0.006562930030697576, "Recall_Dupl": 1.0}, {"name2": "Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().", "id_dupl": 431, "position": [104184, 104411], "check": 1, "intersection": 228, "FP_dupl": 47007, "FN_dupl": 0, "F": 0.009607483724164086, "Prec_Dupl": 0.004826929183867895, "Recall_Dupl": 1.0}, {"name2": "Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().", "id_dupl": 430, "position": [92608, 92935], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().", "id_dupl": 429, "position": [92376, 92603], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().", "id_dupl": 427, "position": [66200, 66427], "check": 1, "intersection": 228, "FP_dupl": 25951, "FN_dupl": 0, "F": 0.017268148596962928, "Prec_Dupl": 0.008709270789564155, "Recall_Dupl": 1.0}]}, {"name": "30", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 o \u0438 O \u043c\u0435\u0442\u043e\u0434\u0430 ber_scanf()  \u0432 LBER_DECODER", "group_ids": [{"name2": "Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().", "id_dupl": 951, "position": [316142, 316352], "check": 1, "intersection": 211, "FP_dupl": 25968, "FN_dupl": 0, "F": 0.01599090564607806, "Prec_Dupl": 0.0080598953359563, "Recall_Dupl": 1.0}, {"name2": "Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().", "id_dupl": 950, "position": [315904, 316137], "check": 1, "intersection": 234, "FP_dupl": 25945, "FN_dupl": 0, "F": 0.017718547684852155, "Prec_Dupl": 0.008938462126131632, "Recall_Dupl": 1.0}, {"name2": "Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().", "id_dupl": 949, "position": [289966, 290176], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().", "id_dupl": 948, "position": [289728, 289961], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().", "id_dupl": 947, "position": [278158, 278368], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().", "id_dupl": 946, "position": [277920, 278153], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().", "id_dupl": 945, "position": [199718, 199928], "check": 1, "intersection": 211, "FP_dupl": 47024, "FN_dupl": 0, "F": 0.008894321966024533, "Prec_Dupl": 0.004467026569281253, "Recall_Dupl": 1.0}, {"name2": "Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().", "id_dupl": 944, "position": [199480, 199713], "check": 1, "intersection": 234, "FP_dupl": 47001, "FN_dupl": 0, "F": 0.009859065916703531, "Prec_Dupl": 0.004953953636074944, "Recall_Dupl": 1.0}, {"name2": "Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().", "id_dupl": 475, "position": [187910, 188120], "check": 1, "intersection": 211, "FP_dupl": 47024, "FN_dupl": 0, "F": 0.008894321966024533, "Prec_Dupl": 0.004467026569281253, "Recall_Dupl": 1.0}, {"name2": " Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().", "id_dupl": 474, "position": [187671, 187905], "check": 1, "intersection": 235, "FP_dupl": 47000, "FN_dupl": 0, "F": 0.0099009900990099, "Prec_Dupl": 0.004975124378109453, "Recall_Dupl": 1.0}, {"name2": "Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().", "id_dupl": 473, "position": [176102, 176312], "check": 1, "intersection": 211, "FP_dupl": 47024, "FN_dupl": 0, "F": 0.008894321966024533, "Prec_Dupl": 0.004467026569281253, "Recall_Dupl": 1.0}, {"name2": " Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().", "id_dupl": 472, "position": [175863, 176097], "check": 1, "intersection": 235, "FP_dupl": 47000, "FN_dupl": 0, "F": 0.0099009900990099, "Prec_Dupl": 0.004975124378109453, "Recall_Dupl": 1.0}, {"name2": "Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().", "id_dupl": 471, "position": [164294, 164504], "check": 1, "intersection": 211, "FP_dupl": 47024, "FN_dupl": 0, "F": 0.008894321966024533, "Prec_Dupl": 0.004467026569281253, "Recall_Dupl": 1.0}, {"name2": "Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().", "id_dupl": 470, "position": [164056, 164289], "check": 1, "intersection": 234, "FP_dupl": 47001, "FN_dupl": 0, "F": 0.009859065916703531, "Prec_Dupl": 0.004953953636074944, "Recall_Dupl": 1.0}, {"name2": "Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().", "id_dupl": 469, "position": [152486, 152696], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().", "id_dupl": 468, "position": [152248, 152481], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": " Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().", "id_dupl": 467, "position": [140677, 140888], "check": 1, "intersection": 212, "FP_dupl": 47023, "FN_dupl": 0, "F": 0.00893628680422366, "Prec_Dupl": 0.0044881973113157616, "Recall_Dupl": 1.0}, {"name2": " Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().", "id_dupl": 466, "position": [140439, 140673], "check": 1, "intersection": 235, "FP_dupl": 47000, "FN_dupl": 0, "F": 0.0099009900990099, "Prec_Dupl": 0.004975124378109453, "Recall_Dupl": 1.0}, {"name2": "Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().", "id_dupl": 465, "position": [128870, 129080], "check": 1, "intersection": 211, "FP_dupl": 47024, "FN_dupl": 0, "F": 0.008894321966024533, "Prec_Dupl": 0.004467026569281253, "Recall_Dupl": 1.0}, {"name2": "Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().", "id_dupl": 464, "position": [128632, 128865], "check": 1, "intersection": 234, "FP_dupl": 47001, "FN_dupl": 0, "F": 0.009859065916703531, "Prec_Dupl": 0.004953953636074944, "Recall_Dupl": 1.0}, {"name2": "Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().", "id_dupl": 463, "position": [117062, 117272], "check": 1, "intersection": 211, "FP_dupl": 47024, "FN_dupl": 0, "F": 0.008894321966024533, "Prec_Dupl": 0.004467026569281253, "Recall_Dupl": 1.0}, {"name2": "Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().", "id_dupl": 462, "position": [116824, 117057], "check": 1, "intersection": 234, "FP_dupl": 47001, "FN_dupl": 0, "F": 0.009859065916703531, "Prec_Dupl": 0.004953953636074944, "Recall_Dupl": 1.0}, {"name2": " Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().", "id_dupl": 461, "position": [105253, 105464], "check": 1, "intersection": 212, "FP_dupl": 47023, "FN_dupl": 0, "F": 0.00893628680422366, "Prec_Dupl": 0.0044881973113157616, "Recall_Dupl": 1.0}, {"name2": "Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().", "id_dupl": 460, "position": [105016, 105249], "check": 1, "intersection": 234, "FP_dupl": 47001, "FN_dupl": 0, "F": 0.009859065916703531, "Prec_Dupl": 0.004953953636074944, "Recall_Dupl": 1.0}, {"name2": "Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().", "id_dupl": 459, "position": [93446, 93656], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().", "id_dupl": 458, "position": [93208, 93441], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().", "id_dupl": 457, "position": [67270, 67480], "check": 1, "intersection": 211, "FP_dupl": 25968, "FN_dupl": 0, "F": 0.01599090564607806, "Prec_Dupl": 0.0080598953359563, "Recall_Dupl": 1.0}, {"name2": "Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().", "id_dupl": 456, "position": [67032, 67265], "check": 1, "intersection": 234, "FP_dupl": 25945, "FN_dupl": 0, "F": 0.017718547684852155, "Prec_Dupl": 0.008938462126131632, "Recall_Dupl": 1.0}]}, {"name": "31", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 l, T \u0438 t \u043c\u0435\u0442\u043e\u0434\u0430  ber_scanf()  \u0432 LBER_DECODER", "group_ids": [{"name2": "Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 525, "position": [319004, 319082], "check": 1, "intersection": 79, "FP_dupl": 26100, "FN_dupl": 0, "F": 0.006017213801508111, "Prec_Dupl": 0.0030176859314717903, "Recall_Dupl": 1.0}, {"name2": "Tag of the next element.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 524, "position": [318929, 318999], "check": 1, "intersection": 71, "FP_dupl": 26108, "FN_dupl": 0, "F": 0.00540952380952381, "Prec_Dupl": 0.0027120974827151536, "Recall_Dupl": 1.0}, {"name2": "Length of the next element.  A pointer to a ber_len_t should be supplied.", "id_dupl": 523, "position": [318851, 318924], "check": 1, "intersection": 74, "FP_dupl": 26105, "FN_dupl": 0, "F": 0.0056374509579857545, "Prec_Dupl": 0.002826693150998892, "Recall_Dupl": 1.0}, {"name2": "Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 522, "position": [292828, 292906], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Tag of the next element.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 521, "position": [292753, 292823], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Length of the next element.  A pointer to a ber_len_t should be supplied.\u2029", "id_dupl": 520, "position": [292675, 292749], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": " Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 519, "position": [281019, 281098], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Tag of the next element.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 518, "position": [280945, 281015], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Length of the next element.  A pointer to a ber_len_t should be supplied.", "id_dupl": 517, "position": [280867, 280940], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 516, "position": [202580, 202658], "check": 1, "intersection": 79, "FP_dupl": 47156, "FN_dupl": 0, "F": 0.0033393921460878385, "Prec_Dupl": 0.0016724886207261564, "Recall_Dupl": 1.0}, {"name2": "Tag of the next element.  A pointer to a ber_tag_t should be supplied", "id_dupl": 515, "position": [202505, 202574], "check": 1, "intersection": 70, "FP_dupl": 47165, "FN_dupl": 0, "F": 0.0029595180213508082, "Prec_Dupl": 0.0014819519424155816, "Recall_Dupl": 1.0}, {"name2": "Length of the next element.  A pointer to a ber_len_t should be supplied.", "id_dupl": 514, "position": [202427, 202500], "check": 1, "intersection": 74, "FP_dupl": 47161, "FN_dupl": 0, "F": 0.0031283688093174658, "Prec_Dupl": 0.0015666349105536148, "Recall_Dupl": 1.0}, {"name2": "Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 513, "position": [190772, 190850], "check": 1, "intersection": 79, "FP_dupl": 47156, "FN_dupl": 0, "F": 0.0033393921460878385, "Prec_Dupl": 0.0016724886207261564, "Recall_Dupl": 1.0}, {"name2": "Tag of the next element.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 512, "position": [190697, 190767], "check": 1, "intersection": 71, "FP_dupl": 47164, "FN_dupl": 0, "F": 0.0030017333953409712, "Prec_Dupl": 0.0015031226844500899, "Recall_Dupl": 1.0}, {"name2": "Length of the next element.  A pointer to a ber_len_t should be supplied.", "id_dupl": 511, "position": [190619, 190692], "check": 1, "intersection": 74, "FP_dupl": 47161, "FN_dupl": 0, "F": 0.0031283688093174658, "Prec_Dupl": 0.0015666349105536148, "Recall_Dupl": 1.0}, {"name2": " Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 510, "position": [178963, 179042], "check": 1, "intersection": 80, "FP_dupl": 47155, "FN_dupl": 0, "F": 0.00338159146148156, "Prec_Dupl": 0.0016936593627606647, "Recall_Dupl": 1.0}, {"name2": "Tag of the next element.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 509, "position": [178889, 178959], "check": 1, "intersection": 71, "FP_dupl": 47164, "FN_dupl": 0, "F": 0.0030017333953409712, "Prec_Dupl": 0.0015031226844500899, "Recall_Dupl": 1.0}, {"name2": " Length of the next element.  A pointer to a ber_len_t should be supplied.", "id_dupl": 508, "position": [178810, 178884], "check": 1, "intersection": 75, "FP_dupl": 47160, "FN_dupl": 0, "F": 0.003170577045022194, "Prec_Dupl": 0.0015878056525881232, "Recall_Dupl": 1.0}, {"name2": "Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 507, "position": [167156, 167234], "check": 1, "intersection": 79, "FP_dupl": 47156, "FN_dupl": 0, "F": 0.0033393921460878385, "Prec_Dupl": 0.0016724886207261564, "Recall_Dupl": 1.0}, {"name2": " Tag of the next element.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 506, "position": [167080, 167151], "check": 1, "intersection": 72, "FP_dupl": 47163, "FN_dupl": 0, "F": 0.0030439469845900185, "Prec_Dupl": 0.0015242934264845982, "Recall_Dupl": 1.0}, {"name2": " Length of the next element.  A pointer to a ber_len_t should be supplied.", "id_dupl": 505, "position": [167002, 167076], "check": 1, "intersection": 75, "FP_dupl": 47160, "FN_dupl": 0, "F": 0.003170577045022194, "Prec_Dupl": 0.0015878056525881232, "Recall_Dupl": 1.0}, {"name2": " Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 504, "position": [155347, 155426], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Tag of the next element.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 503, "position": [155273, 155343], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Length of the next element.  A pointer to a ber_len_t should be supplied.", "id_dupl": 502, "position": [155195, 155268], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 501, "position": [143540, 143618], "check": 1, "intersection": 79, "FP_dupl": 47156, "FN_dupl": 0, "F": 0.0033393921460878385, "Prec_Dupl": 0.0016724886207261564, "Recall_Dupl": 1.0}, {"name2": "Tag of the next element.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 500, "position": [143465, 143535], "check": 1, "intersection": 71, "FP_dupl": 47164, "FN_dupl": 0, "F": 0.0030017333953409712, "Prec_Dupl": 0.0015031226844500899, "Recall_Dupl": 1.0}, {"name2": " Length of the next element.  A pointer to a ber_len_t should be supplied.", "id_dupl": 499, "position": [143386, 143460], "check": 1, "intersection": 75, "FP_dupl": 47160, "FN_dupl": 0, "F": 0.003170577045022194, "Prec_Dupl": 0.0015878056525881232, "Recall_Dupl": 1.0}, {"name2": "Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 498, "position": [131732, 131810], "check": 1, "intersection": 79, "FP_dupl": 47156, "FN_dupl": 0, "F": 0.0033393921460878385, "Prec_Dupl": 0.0016724886207261564, "Recall_Dupl": 1.0}, {"name2": "Tag of the next element.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 497, "position": [131657, 131727], "check": 1, "intersection": 71, "FP_dupl": 47164, "FN_dupl": 0, "F": 0.0030017333953409712, "Prec_Dupl": 0.0015031226844500899, "Recall_Dupl": 1.0}, {"name2": " Length of the next element.  A pointer to a ber_len_t should be supplied.", "id_dupl": 496, "position": [131578, 131652], "check": 1, "intersection": 75, "FP_dupl": 47160, "FN_dupl": 0, "F": 0.003170577045022194, "Prec_Dupl": 0.0015878056525881232, "Recall_Dupl": 1.0}, {"name2": "Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 495, "position": [119924, 120002], "check": 1, "intersection": 79, "FP_dupl": 47156, "FN_dupl": 0, "F": 0.0033393921460878385, "Prec_Dupl": 0.0016724886207261564, "Recall_Dupl": 1.0}, {"name2": "Tag of the next element.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 494, "position": [119849, 119919], "check": 1, "intersection": 71, "FP_dupl": 47164, "FN_dupl": 0, "F": 0.0030017333953409712, "Prec_Dupl": 0.0015031226844500899, "Recall_Dupl": 1.0}, {"name2": "Length of the next element.  A pointer to a ber_len_t should be supplied.", "id_dupl": 493, "position": [119771, 119844], "check": 1, "intersection": 74, "FP_dupl": 47161, "FN_dupl": 0, "F": 0.0031283688093174658, "Prec_Dupl": 0.0015666349105536148, "Recall_Dupl": 1.0}, {"name2": "Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 492, "position": [108116, 108194], "check": 1, "intersection": 79, "FP_dupl": 47156, "FN_dupl": 0, "F": 0.0033393921460878385, "Prec_Dupl": 0.0016724886207261564, "Recall_Dupl": 1.0}, {"name2": "Tag of the next element.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 491, "position": [108041, 108111], "check": 1, "intersection": 71, "FP_dupl": 47164, "FN_dupl": 0, "F": 0.0030017333953409712, "Prec_Dupl": 0.0015031226844500899, "Recall_Dupl": 1.0}, {"name2": "Length of the next element.  A pointer to a ber_len_t should be supplied.", "id_dupl": 490, "position": [107963, 108036], "check": 1, "intersection": 74, "FP_dupl": 47161, "FN_dupl": 0, "F": 0.0031283688093174658, "Prec_Dupl": 0.0015666349105536148, "Recall_Dupl": 1.0}, {"name2": "Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 489, "position": [96308, 96386], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": " Tag of the next element.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 488, "position": [96232, 96303], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Length of the next element.  A pointer to a ber_len_t should be supplied.", "id_dupl": 487, "position": [96155, 96228], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 486, "position": [70132, 70210], "check": 1, "intersection": 79, "FP_dupl": 26100, "FN_dupl": 0, "F": 0.006017213801508111, "Prec_Dupl": 0.0030176859314717903, "Recall_Dupl": 1.0}, {"name2": "Tag of the next element.  A pointer to a ber_tag_t should be supplied.", "id_dupl": 485, "position": [70057, 70127], "check": 1, "intersection": 71, "FP_dupl": 26108, "FN_dupl": 0, "F": 0.00540952380952381, "Prec_Dupl": 0.0027120974827151536, "Recall_Dupl": 1.0}, {"name2": " Length of the next element.  A pointer to a ber_len_t should be supplied.", "id_dupl": 484, "position": [69978, 70052], "check": 1, "intersection": 75, "FP_dupl": 26104, "FN_dupl": 0, "F": 0.005713415098651634, "Prec_Dupl": 0.002864891707093472, "Recall_Dupl": 1.0}]}, {"name": "32", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430 n \u043c\u0435\u0442\u043e\u0434\u043e\u0432 ber_printf() \u0432 LBER_ENCODER \u0438 ber_scanf()  \u0432 LBER_DECODER", "group_ids": [{"name2": "Null.  No parameter is required.  A null element is output.", "id_dupl": 952, "position": [4532, 4591], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Null.  No parameter is required.  A null element is output.", "id_dupl": 550, "position": [327892, 327951], "check": 1, "intersection": 60, "FP_dupl": 26119, "FN_dupl": 0, "F": 0.004573345020770609, "Prec_Dupl": 0.0022919133656747774, "Recall_Dupl": 1.0}, {"name2": "Null.  No parameter is required.  The element is simply skipped if it is recognized.", "id_dupl": 549, "position": [316945, 317029], "check": 1, "intersection": 85, "FP_dupl": 26094, "FN_dupl": 0, "F": 0.006472738349070972, "Prec_Dupl": 0.0032468772680392683, "Recall_Dupl": 1.0}, {"name2": " Null.  No parameter is required.  A null element is output.", "id_dupl": 548, "position": [301715, 301775], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Null.  No parameter is required.  The element is simply skipped if it is recognized.", "id_dupl": 547, "position": [290769, 290853], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Null.  No parameter is required.  The element is simply skipped if it is recognized.", "id_dupl": 546, "position": [278961, 279045], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Null.  No parameter is required.  A null element is output.", "id_dupl": 545, "position": [269771, 269830], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Null.  No parameter is required.  A null element is output.", "id_dupl": 544, "position": [261442, 261501], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Null.  No parameter is required.  A null element is output.", "id_dupl": 543, "position": [253113, 253172], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Null.  No parameter is required.  A null element is output.", "id_dupl": 542, "position": [244784, 244843], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Null.  No parameter is required.  A null element is output.", "id_dupl": 541, "position": [236455, 236514], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Null.  No parameter is required.  A null element is output.", "id_dupl": 540, "position": [228126, 228185], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Null.  No parameter is required.  A null element is output.", "id_dupl": 539, "position": [219797, 219856], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Null.  No parameter is required.  A null element is output.", "id_dupl": 538, "position": [211468, 211527], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Null.  No parameter is required.  The element is simply skipped if it is recognized.", "id_dupl": 537, "position": [200521, 200605], "check": 1, "intersection": 85, "FP_dupl": 47150, "FN_dupl": 0, "F": 0.0035925612848689776, "Prec_Dupl": 0.0017995130729332063, "Recall_Dupl": 1.0}, {"name2": "Null.  No parameter is required.  The element is simply skipped if it is recognized.", "id_dupl": 536, "position": [188713, 188797], "check": 1, "intersection": 85, "FP_dupl": 47150, "FN_dupl": 0, "F": 0.0035925612848689776, "Prec_Dupl": 0.0017995130729332063, "Recall_Dupl": 1.0}, {"name2": " Null.  No parameter is required.  The element is simply skipped if it is recognized.", "id_dupl": 535, "position": [176904, 176989], "check": 1, "intersection": 86, "FP_dupl": 47149, "FN_dupl": 0, "F": 0.0036347498996217326, "Prec_Dupl": 0.0018206838149677146, "Recall_Dupl": 1.0}, {"name2": "Null.  No parameter is required.  The element is simply skipped if it is recognized.", "id_dupl": 534, "position": [165097, 165181], "check": 1, "intersection": 85, "FP_dupl": 47150, "FN_dupl": 0, "F": 0.0035925612848689776, "Prec_Dupl": 0.0017995130729332063, "Recall_Dupl": 1.0}, {"name2": "Null.  No parameter is required.  The element is simply skipped if it is recognized.", "id_dupl": 533, "position": [153289, 153373], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Null.  No parameter is required.  The element is simply skipped if it is recognized.", "id_dupl": 532, "position": [141481, 141565], "check": 1, "intersection": 85, "FP_dupl": 47150, "FN_dupl": 0, "F": 0.0035925612848689776, "Prec_Dupl": 0.0017995130729332063, "Recall_Dupl": 1.0}, {"name2": "Null.  No parameter is required.  The element is simply skipped if it is recognized.", "id_dupl": 531, "position": [129673, 129757], "check": 1, "intersection": 85, "FP_dupl": 47150, "FN_dupl": 0, "F": 0.0035925612848689776, "Prec_Dupl": 0.0017995130729332063, "Recall_Dupl": 1.0}, {"name2": "Null.  No parameter is required.  The element is simply skipped if it is recognized.", "id_dupl": 530, "position": [117865, 117949], "check": 1, "intersection": 85, "FP_dupl": 47150, "FN_dupl": 0, "F": 0.0035925612848689776, "Prec_Dupl": 0.0017995130729332063, "Recall_Dupl": 1.0}, {"name2": "Null.  No parameter is required.  The element is simply skipped if it is recognized.", "id_dupl": 529, "position": [106057, 106141], "check": 1, "intersection": 85, "FP_dupl": 47150, "FN_dupl": 0, "F": 0.0035925612848689776, "Prec_Dupl": 0.0017995130729332063, "Recall_Dupl": 1.0}, {"name2": " Null.  No parameter is required.  The element is simply skipped if it is recognized.", "id_dupl": 528, "position": [94248, 94333], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Null.  No parameter is required.  A null element is output.", "id_dupl": 527, "position": [79020, 79079], "check": 1, "intersection": 60, "FP_dupl": 26119, "FN_dupl": 0, "F": 0.004573345020770609, "Prec_Dupl": 0.0022919133656747774, "Recall_Dupl": 1.0}, {"name2": "Null.  No parameter is required.  The element is simply skipped if it is recognized.", "id_dupl": 526, "position": [68073, 68157], "check": 1, "intersection": 85, "FP_dupl": 26094, "FN_dupl": 0, "F": 0.006472738349070972, "Prec_Dupl": 0.0032468772680392683, "Recall_Dupl": 1.0}]}, {"name": "33", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 o \u0438 O \u043c\u0435\u0442\u043e\u0434\u0430 ber_printf() \u0432 LBER_ENCODER", "group_ids": [{"name2": "Octet string.  A struct berval * is supplied.  An octet string element is output.", "id_dupl": 972, "position": [219987, 220068], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.", "id_dupl": 971, "position": [219861, 219982], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A struct berval * is supplied.  An octet string element is output.", "id_dupl": 970, "position": [328082, 328163], "check": 1, "intersection": 82, "FP_dupl": 26097, "FN_dupl": 0, "F": 0.006245002094360459, "Prec_Dupl": 0.0031322815997555293, "Recall_Dupl": 1.0}, {"name2": "Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.", "id_dupl": 969, "position": [327956, 328077], "check": 1, "intersection": 122, "FP_dupl": 26057, "FN_dupl": 0, "F": 0.009277213794152315, "Prec_Dupl": 0.004660223843538714, "Recall_Dupl": 1.0}, {"name2": "Octet string.  A struct berval * is supplied.  An octet string element is output.", "id_dupl": 968, "position": [301906, 301987], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.", "id_dupl": 967, "position": [301780, 301901], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A struct berval * is supplied.  An octet string element is output.", "id_dupl": 966, "position": [269961, 270042], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.", "id_dupl": 965, "position": [269835, 269956], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A struct berval * is supplied.  An octet string element is output.", "id_dupl": 964, "position": [261632, 261713], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.", "id_dupl": 963, "position": [261506, 261627], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A struct berval * is supplied.  An octet string element is output.", "id_dupl": 962, "position": [253303, 253384], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.", "id_dupl": 961, "position": [253177, 253298], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A struct berval * is supplied.  An octet string element is output.", "id_dupl": 960, "position": [244974, 245055], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.", "id_dupl": 959, "position": [244848, 244969], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A struct berval * is supplied.  An octet string element is output.", "id_dupl": 958, "position": [236645, 236726], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.", "id_dupl": 957, "position": [236519, 236640], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A struct berval * is supplied.  An octet string element is output.", "id_dupl": 956, "position": [228316, 228397], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.", "id_dupl": 955, "position": [228190, 228311], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A struct berval * is supplied.  An octet string element is output.", "id_dupl": 954, "position": [211658, 211739], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.", "id_dupl": 953, "position": [211532, 211653], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A struct berval * is supplied.  An octet string element is output.", "id_dupl": 952, "position": [79210, 79291], "check": 1, "intersection": 82, "FP_dupl": 26097, "FN_dupl": 0, "F": 0.006245002094360459, "Prec_Dupl": 0.0031322815997555293, "Recall_Dupl": 1.0}, {"name2": "Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.", "id_dupl": 951, "position": [79084, 79205], "check": 1, "intersection": 122, "FP_dupl": 26057, "FN_dupl": 0, "F": 0.009277213794152315, "Prec_Dupl": 0.004660223843538714, "Recall_Dupl": 1.0}, {"name2": "Octet string.  A struct berval * is supplied.  An octet string element is output.", "id_dupl": 554, "position": [4722, 4803], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.", "id_dupl": 552, "position": [4596, 4717], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "34", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043c\u0435\u0442\u043e\u0434\u043e\u0432 \u043f\u0430\u043a\u0435\u0442\u0430 LBER_DECODE", "group_ids": [{"name2": "The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().", "id_dupl": 604, "position": [320130, 320390], "check": 1, "intersection": 261, "FP_dupl": 25918, "FN_dupl": 0, "F": 0.019742813918305596, "Prec_Dupl": 0.009969823140685282, "Recall_Dupl": 1.0}, {"name2": "The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().", "id_dupl": 603, "position": [319960, 320128], "check": 1, "intersection": 169, "FP_dupl": 26010, "FN_dupl": 0, "F": 0.012828298163048429, "Prec_Dupl": 0.006455555979983957, "Recall_Dupl": 1.0}, {"name2": "The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().", "id_dupl": 602, "position": [293954, 294214], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().", "id_dupl": 601, "position": [293784, 293952], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().", "id_dupl": 600, "position": [282146, 282406], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().", "id_dupl": 599, "position": [281976, 282144], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().", "id_dupl": 598, "position": [203706, 203966], "check": 1, "intersection": 261, "FP_dupl": 46974, "FN_dupl": 0, "F": 0.010990399191510862, "Prec_Dupl": 0.0055255636710066685, "Recall_Dupl": 1.0}, {"name2": "The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().", "id_dupl": 597, "position": [203536, 203704], "check": 1, "intersection": 169, "FP_dupl": 47066, "FN_dupl": 0, "F": 0.007130199983123787, "Prec_Dupl": 0.003577855403831904, "Recall_Dupl": 1.0}, {"name2": "The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().", "id_dupl": 596, "position": [191898, 192158], "check": 1, "intersection": 261, "FP_dupl": 46974, "FN_dupl": 0, "F": 0.010990399191510862, "Prec_Dupl": 0.0055255636710066685, "Recall_Dupl": 1.0}, {"name2": "The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().", "id_dupl": 595, "position": [191728, 191896], "check": 1, "intersection": 169, "FP_dupl": 47066, "FN_dupl": 0, "F": 0.007130199983123787, "Prec_Dupl": 0.003577855403831904, "Recall_Dupl": 1.0}, {"name2": "The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().", "id_dupl": 594, "position": [180090, 180350], "check": 1, "intersection": 261, "FP_dupl": 46974, "FN_dupl": 0, "F": 0.010990399191510862, "Prec_Dupl": 0.0055255636710066685, "Recall_Dupl": 1.0}, {"name2": "The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().", "id_dupl": 593, "position": [179920, 180088], "check": 1, "intersection": 169, "FP_dupl": 47066, "FN_dupl": 0, "F": 0.007130199983123787, "Prec_Dupl": 0.003577855403831904, "Recall_Dupl": 1.0}, {"name2": "The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().", "id_dupl": 592, "position": [168282, 168542], "check": 1, "intersection": 261, "FP_dupl": 46974, "FN_dupl": 0, "F": 0.010990399191510862, "Prec_Dupl": 0.0055255636710066685, "Recall_Dupl": 1.0}, {"name2": "The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().", "id_dupl": 591, "position": [168112, 168280], "check": 1, "intersection": 169, "FP_dupl": 47066, "FN_dupl": 0, "F": 0.007130199983123787, "Prec_Dupl": 0.003577855403831904, "Recall_Dupl": 1.0}, {"name2": "The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().", "id_dupl": 590, "position": [156474, 156734], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().", "id_dupl": 589, "position": [156304, 156472], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().", "id_dupl": 588, "position": [144666, 144926], "check": 1, "intersection": 261, "FP_dupl": 46974, "FN_dupl": 0, "F": 0.010990399191510862, "Prec_Dupl": 0.0055255636710066685, "Recall_Dupl": 1.0}, {"name2": "The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().", "id_dupl": 587, "position": [144496, 144664], "check": 1, "intersection": 169, "FP_dupl": 47066, "FN_dupl": 0, "F": 0.007130199983123787, "Prec_Dupl": 0.003577855403831904, "Recall_Dupl": 1.0}, {"name2": "The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().", "id_dupl": 586, "position": [132858, 133118], "check": 1, "intersection": 261, "FP_dupl": 46974, "FN_dupl": 0, "F": 0.010990399191510862, "Prec_Dupl": 0.0055255636710066685, "Recall_Dupl": 1.0}, {"name2": "The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().", "id_dupl": 585, "position": [132688, 132856], "check": 1, "intersection": 169, "FP_dupl": 47066, "FN_dupl": 0, "F": 0.007130199983123787, "Prec_Dupl": 0.003577855403831904, "Recall_Dupl": 1.0}, {"name2": "The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().", "id_dupl": 584, "position": [121050, 121310], "check": 1, "intersection": 261, "FP_dupl": 46974, "FN_dupl": 0, "F": 0.010990399191510862, "Prec_Dupl": 0.0055255636710066685, "Recall_Dupl": 1.0}, {"name2": "The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().", "id_dupl": 583, "position": [120880, 121048], "check": 1, "intersection": 169, "FP_dupl": 47066, "FN_dupl": 0, "F": 0.007130199983123787, "Prec_Dupl": 0.003577855403831904, "Recall_Dupl": 1.0}, {"name2": "The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().", "id_dupl": 582, "position": [109242, 109502], "check": 1, "intersection": 261, "FP_dupl": 46974, "FN_dupl": 0, "F": 0.010990399191510862, "Prec_Dupl": 0.0055255636710066685, "Recall_Dupl": 1.0}, {"name2": "The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().", "id_dupl": 581, "position": [109072, 109240], "check": 1, "intersection": 169, "FP_dupl": 47066, "FN_dupl": 0, "F": 0.007130199983123787, "Prec_Dupl": 0.003577855403831904, "Recall_Dupl": 1.0}, {"name2": "The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().", "id_dupl": 580, "position": [97434, 97694], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().", "id_dupl": 579, "position": [97264, 97432], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().", "id_dupl": 578, "position": [71258, 71518], "check": 1, "intersection": 261, "FP_dupl": 25918, "FN_dupl": 0, "F": 0.019742813918305596, "Prec_Dupl": 0.009969823140685282, "Recall_Dupl": 1.0}, {"name2": "The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().", "id_dupl": 577, "position": [71088, 71256], "check": 1, "intersection": 169, "FP_dupl": 26010, "FN_dupl": 0, "F": 0.012828298163048429, "Prec_Dupl": 0.006455555979983957, "Recall_Dupl": 1.0}]}, {"name": "35", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 v \u0438 V \u043c\u0435\u0442\u043e\u0434\u0430 ber_printf() \u0432 LBER_ENCODER", "group_ids": [{"name2": "Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet\u2029strings.", "id_dupl": 974, "position": [5212, 5388], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.", "id_dupl": 973, "position": [5045, 5207], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet\u2029strings.", "id_dupl": 626, "position": [328572, 328748], "check": 1, "intersection": 177, "FP_dupl": 26002, "FN_dupl": 0, "F": 0.013431476703596904, "Prec_Dupl": 0.0067611444287405936, "Recall_Dupl": 1.0}, {"name2": "Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.", "id_dupl": 625, "position": [328405, 328567], "check": 1, "intersection": 163, "FP_dupl": 26016, "FN_dupl": 0, "F": 0.01237567382886645, "Prec_Dupl": 0.006226364643416479, "Recall_Dupl": 1.0}, {"name2": "Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet\u2029strings.", "id_dupl": 624, "position": [302396, 302572], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.", "id_dupl": 623, "position": [302229, 302391], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet\u2029strings.", "id_dupl": 622, "position": [270451, 270627], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.", "id_dupl": 621, "position": [270284, 270446], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet\u2029strings.\u2029", "id_dupl": 620, "position": [262122, 262299], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.", "id_dupl": 619, "position": [261955, 262117], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet\u2029strings.", "id_dupl": 618, "position": [253793, 253969], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.", "id_dupl": 617, "position": [253626, 253788], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet\u2029strings.", "id_dupl": 616, "position": [245464, 245640], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.", "id_dupl": 615, "position": [245297, 245459], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet\u2029strings.", "id_dupl": 614, "position": [237135, 237311], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.", "id_dupl": 613, "position": [236968, 237130], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet\u2029strings.", "id_dupl": 612, "position": [228806, 228982], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.", "id_dupl": 611, "position": [228639, 228801], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet\u2029strings.", "id_dupl": 610, "position": [220477, 220653], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.", "id_dupl": 609, "position": [220310, 220472], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet\u2029strings.", "id_dupl": 608, "position": [212148, 212324], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.", "id_dupl": 607, "position": [211981, 212143], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet\u2029strings.", "id_dupl": 606, "position": [79700, 79876], "check": 1, "intersection": 177, "FP_dupl": 26002, "FN_dupl": 0, "F": 0.013431476703596904, "Prec_Dupl": 0.0067611444287405936, "Recall_Dupl": 1.0}, {"name2": "Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.", "id_dupl": 605, "position": [79533, 79695], "check": 1, "intersection": 163, "FP_dupl": 26016, "FN_dupl": 0, "F": 0.01237567382886645, "Prec_Dupl": 0.006226364643416479, "Recall_Dupl": 1.0}]}, {"name": "36", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043a\u043b\u044e\u0447\u0435\u0432\u044b\u0445 \u0441\u043b\u043e\u0432 \u0434\u043b\u044f \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430 <when> \u043c\u0435\u0442\u043e\u0434\u0430 DEREF \u043f\u0430\u043a\u0435\u0442\u0430 LDAP.CONF", "group_ids": [{"name2": "Aliases are dereferenced both in searching and in locating the base object of the search.", "id_dupl": 631, "position": [1068061, 1068150], "check": 1, "intersection": 43, "FP_dupl": 1, "FN_dupl": 47, "F": 0.6417910447761194, "Prec_Dupl": 0.9772727272727273, "Recall_Dupl": 0.4777777777777778}, {"name2": "Aliases are only dereferenced when locating the base object of the search.", "id_dupl": 630, "position": [1067978, 1068052], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Aliases are dereferenced in subordinates of the base object, but not in locating the base object of the search.", "id_dupl": 629, "position": [1067857, 1067968], "check": 1, "intersection": 43, "FP_dupl": 1, "FN_dupl": 69, "F": 0.5512820512820513, "Prec_Dupl": 0.9772727272727273, "Recall_Dupl": 0.38392857142857145}]}, {"name": "37", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432-\u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u043c\u0435\u0442\u043e\u0434\u0430 ber_scanf(), \u044f\u0432\u043b\u044f\u044e\u0449\u0438\u0445\u0441\u044f \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c\u044e ocet \u0441\u0442\u0440\u043e\u043a, \u0438\u0437 \u043f\u0430\u043a\u0435\u0442\u0430 LBER_DECODE", "group_ids": [{"name2": " Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().", "id_dupl": 687, "position": [318099, 318846], "check": 1, "intersection": 748, "FP_dupl": 25431, "FN_dupl": 0, "F": 0.055557618746982576, "Prec_Dupl": 0.02857251995874556, "Recall_Dupl": 1.0}, {"name2": "Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().", "id_dupl": 686, "position": [317698, 318095], "check": 1, "intersection": 398, "FP_dupl": 25781, "FN_dupl": 0, "F": 0.029950709259886365, "Prec_Dupl": 0.01520302532564269, "Recall_Dupl": 1.0}, {"name2": " Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().", "id_dupl": 685, "position": [317341, 317693], "check": 1, "intersection": 353, "FP_dupl": 25826, "FN_dupl": 0, "F": 0.02660937735564601, "Prec_Dupl": 0.013484090301386607, "Recall_Dupl": 1.0}, {"name2": " Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().", "id_dupl": 684, "position": [317033, 317337], "check": 1, "intersection": 305, "FP_dupl": 25874, "FN_dupl": 0, "F": 0.023032774505361727, "Prec_Dupl": 0.011650559608846785, "Recall_Dupl": 1.0}, {"name2": "Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().", "id_dupl": 683, "position": [291924, 292670], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().", "id_dupl": 682, "position": [291522, 291919], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": " Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().", "id_dupl": 681, "position": [291165, 291517], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().", "id_dupl": 680, "position": [290858, 291161], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().", "id_dupl": 679, "position": [280116, 280862], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": " Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().", "id_dupl": 678, "position": [279713, 280111], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().", "id_dupl": 677, "position": [279358, 279709], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": " Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().", "id_dupl": 676, "position": [279049, 279353], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": " Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().", "id_dupl": 675, "position": [201675, 202422], "check": 1, "intersection": 748, "FP_dupl": 46487, "FN_dupl": 0, "F": 0.031177708771856702, "Prec_Dupl": 0.015835715041812217, "Recall_Dupl": 1.0}, {"name2": " Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().", "id_dupl": 674, "position": [201273, 201671], "check": 1, "intersection": 399, "FP_dupl": 46836, "FN_dupl": 0, "F": 0.016752739639753118, "Prec_Dupl": 0.008447126071768816, "Recall_Dupl": 1.0}, {"name2": "Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().", "id_dupl": 673, "position": [200918, 201269], "check": 1, "intersection": 352, "FP_dupl": 46883, "FN_dupl": 0, "F": 0.014793956332611847, "Prec_Dupl": 0.007452101196146925, "Recall_Dupl": 1.0}, {"name2": "Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().", "id_dupl": 672, "position": [200610, 200913], "check": 1, "intersection": 304, "FP_dupl": 46931, "FN_dupl": 0, "F": 0.012789499148067901, "Prec_Dupl": 0.006435905578490526, "Recall_Dupl": 1.0}, {"name2": "Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().", "id_dupl": 671, "position": [189868, 190614], "check": 1, "intersection": 747, "FP_dupl": 46488, "FN_dupl": 0, "F": 0.031136676253595095, "Prec_Dupl": 0.015814544299777706, "Recall_Dupl": 1.0}, {"name2": "Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().", "id_dupl": 670, "position": [189466, 189863], "check": 1, "intersection": 398, "FP_dupl": 46837, "FN_dupl": 0, "F": 0.016711103646631534, "Prec_Dupl": 0.008425955329734306, "Recall_Dupl": 1.0}, {"name2": "Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().", "id_dupl": 669, "position": [189110, 189461], "check": 1, "intersection": 352, "FP_dupl": 46883, "FN_dupl": 0, "F": 0.014793956332611847, "Prec_Dupl": 0.007452101196146925, "Recall_Dupl": 1.0}, {"name2": " Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().", "id_dupl": 668, "position": [188801, 189105], "check": 1, "intersection": 305, "FP_dupl": 46930, "FN_dupl": 0, "F": 0.012831299957930165, "Prec_Dupl": 0.006457076320525034, "Recall_Dupl": 1.0}, {"name2": " Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().", "id_dupl": 667, "position": [178059, 178806], "check": 1, "intersection": 748, "FP_dupl": 46487, "FN_dupl": 0, "F": 0.031177708771856702, "Prec_Dupl": 0.015835715041812217, "Recall_Dupl": 1.0}, {"name2": " Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().", "id_dupl": 666, "position": [177657, 178055], "check": 1, "intersection": 399, "FP_dupl": 46836, "FN_dupl": 0, "F": 0.016752739639753118, "Prec_Dupl": 0.008447126071768816, "Recall_Dupl": 1.0}, {"name2": "Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().", "id_dupl": 665, "position": [177302, 177653], "check": 1, "intersection": 352, "FP_dupl": 46883, "FN_dupl": 0, "F": 0.014793956332611847, "Prec_Dupl": 0.007452101196146925, "Recall_Dupl": 1.0}, {"name2": "Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().", "id_dupl": 664, "position": [176994, 177297], "check": 1, "intersection": 304, "FP_dupl": 46931, "FN_dupl": 0, "F": 0.012789499148067901, "Prec_Dupl": 0.006435905578490526, "Recall_Dupl": 1.0}, {"name2": "Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().\u2029\u2029l  Length of the next element.  A pointer to a ber_len_t should be supplied.", "id_dupl": 663, "position": [166252, 167076], "check": 1, "intersection": 825, "FP_dupl": 46410, "FN_dupl": 0, "F": 0.03433208489388265, "Prec_Dupl": 0.017465862178469356, "Recall_Dupl": 1.0}, {"name2": "Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().", "id_dupl": 662, "position": [165850, 166247], "check": 1, "intersection": 398, "FP_dupl": 46837, "FN_dupl": 0, "F": 0.016711103646631534, "Prec_Dupl": 0.008425955329734306, "Recall_Dupl": 1.0}, {"name2": "Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().", "id_dupl": 661, "position": [165494, 165845], "check": 1, "intersection": 352, "FP_dupl": 46883, "FN_dupl": 0, "F": 0.014793956332611847, "Prec_Dupl": 0.007452101196146925, "Recall_Dupl": 1.0}, {"name2": "Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().", "id_dupl": 660, "position": [165186, 165489], "check": 1, "intersection": 304, "FP_dupl": 46931, "FN_dupl": 0, "F": 0.012789499148067901, "Prec_Dupl": 0.006435905578490526, "Recall_Dupl": 1.0}, {"name2": "Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().", "id_dupl": 659, "position": [154444, 155190], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().", "id_dupl": 658, "position": [154042, 154439], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().", "id_dupl": 657, "position": [153686, 154037], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": " Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().", "id_dupl": 656, "position": [153377, 153681], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().", "id_dupl": 655, "position": [142636, 143382], "check": 1, "intersection": 747, "FP_dupl": 46488, "FN_dupl": 0, "F": 0.031136676253595095, "Prec_Dupl": 0.015814544299777706, "Recall_Dupl": 1.0}, {"name2": " Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().", "id_dupl": 654, "position": [142233, 142631], "check": 1, "intersection": 399, "FP_dupl": 46836, "FN_dupl": 0, "F": 0.016752739639753118, "Prec_Dupl": 0.008447126071768816, "Recall_Dupl": 1.0}, {"name2": "Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().", "id_dupl": 653, "position": [141878, 142229], "check": 1, "intersection": 352, "FP_dupl": 46883, "FN_dupl": 0, "F": 0.014793956332611847, "Prec_Dupl": 0.007452101196146925, "Recall_Dupl": 1.0}, {"name2": "Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().", "id_dupl": 652, "position": [141570, 141873], "check": 1, "intersection": 304, "FP_dupl": 46931, "FN_dupl": 0, "F": 0.012789499148067901, "Prec_Dupl": 0.006435905578490526, "Recall_Dupl": 1.0}, {"name2": "Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().", "id_dupl": 651, "position": [130828, 131574], "check": 1, "intersection": 747, "FP_dupl": 46488, "FN_dupl": 0, "F": 0.031136676253595095, "Prec_Dupl": 0.015814544299777706, "Recall_Dupl": 1.0}, {"name2": "Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().", "id_dupl": 650, "position": [130426, 130823], "check": 1, "intersection": 398, "FP_dupl": 46837, "FN_dupl": 0, "F": 0.016711103646631534, "Prec_Dupl": 0.008425955329734306, "Recall_Dupl": 1.0}, {"name2": "Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().", "id_dupl": 649, "position": [130070, 130421], "check": 1, "intersection": 352, "FP_dupl": 46883, "FN_dupl": 0, "F": 0.014793956332611847, "Prec_Dupl": 0.007452101196146925, "Recall_Dupl": 1.0}, {"name2": "Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().", "id_dupl": 648, "position": [129762, 130065], "check": 1, "intersection": 304, "FP_dupl": 46931, "FN_dupl": 0, "F": 0.012789499148067901, "Prec_Dupl": 0.006435905578490526, "Recall_Dupl": 1.0}, {"name2": "Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().\u2029", "id_dupl": 647, "position": [119020, 119767], "check": 1, "intersection": 748, "FP_dupl": 46487, "FN_dupl": 0, "F": 0.031177708771856702, "Prec_Dupl": 0.015835715041812217, "Recall_Dupl": 1.0}, {"name2": "Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().", "id_dupl": 646, "position": [118618, 119015], "check": 1, "intersection": 398, "FP_dupl": 46837, "FN_dupl": 0, "F": 0.016711103646631534, "Prec_Dupl": 0.008425955329734306, "Recall_Dupl": 1.0}, {"name2": "Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().", "id_dupl": 645, "position": [118262, 118613], "check": 1, "intersection": 352, "FP_dupl": 46883, "FN_dupl": 0, "F": 0.014793956332611847, "Prec_Dupl": 0.007452101196146925, "Recall_Dupl": 1.0}, {"name2": "Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().", "id_dupl": 644, "position": [117954, 118257], "check": 1, "intersection": 304, "FP_dupl": 46931, "FN_dupl": 0, "F": 0.012789499148067901, "Prec_Dupl": 0.006435905578490526, "Recall_Dupl": 1.0}, {"name2": "Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().", "id_dupl": 643, "position": [107212, 107958], "check": 1, "intersection": 747, "FP_dupl": 46488, "FN_dupl": 0, "F": 0.031136676253595095, "Prec_Dupl": 0.015814544299777706, "Recall_Dupl": 1.0}, {"name2": "Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().", "id_dupl": 642, "position": [106810, 107207], "check": 1, "intersection": 398, "FP_dupl": 46837, "FN_dupl": 0, "F": 0.016711103646631534, "Prec_Dupl": 0.008425955329734306, "Recall_Dupl": 1.0}, {"name2": "Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().", "id_dupl": 641, "position": [106454, 106805], "check": 1, "intersection": 352, "FP_dupl": 46883, "FN_dupl": 0, "F": 0.014793956332611847, "Prec_Dupl": 0.007452101196146925, "Recall_Dupl": 1.0}, {"name2": "Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().", "id_dupl": 640, "position": [106146, 106449], "check": 1, "intersection": 304, "FP_dupl": 46931, "FN_dupl": 0, "F": 0.012789499148067901, "Prec_Dupl": 0.006435905578490526, "Recall_Dupl": 1.0}, {"name2": "Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().", "id_dupl": 639, "position": [95404, 96150], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().", "id_dupl": 638, "position": [95002, 95399], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": " Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().", "id_dupl": 637, "position": [94645, 94997], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": " Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().", "id_dupl": 636, "position": [94337, 94641], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().", "id_dupl": 635, "position": [69228, 69974], "check": 1, "intersection": 747, "FP_dupl": 25432, "FN_dupl": 0, "F": 0.055485404441803464, "Prec_Dupl": 0.02853432140265098, "Recall_Dupl": 1.0}, {"name2": "Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().", "id_dupl": 634, "position": [68826, 69223], "check": 1, "intersection": 398, "FP_dupl": 25781, "FN_dupl": 0, "F": 0.029950709259886365, "Prec_Dupl": 0.01520302532564269, "Recall_Dupl": 1.0}, {"name2": "Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().", "id_dupl": 633, "position": [68470, 68821], "check": 1, "intersection": 352, "FP_dupl": 25827, "FN_dupl": 0, "F": 0.02653499679620067, "Prec_Dupl": 0.013445891745292027, "Recall_Dupl": 1.0}, {"name2": "Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().", "id_dupl": 632, "position": [68162, 68465], "check": 1, "intersection": 304, "FP_dupl": 25875, "FN_dupl": 0, "F": 0.022958124079598234, "Prec_Dupl": 0.011612361052752205, "Recall_Dupl": 1.0}]}, {"name": "38", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u0442\u0438\u043f\u043e\u0432 \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u043e\u0432 \u043f\u0430\u043a\u0435\u0442\u0430 LDAP_SCHEMA", "group_ids": [{"name2": "the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.", "id_dupl": 741, "position": [1001789, 1001990], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.", "id_dupl": 740, "position": [993009, 993210], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.", "id_dupl": 739, "position": [984229, 984430], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.", "id_dupl": 738, "position": [964690, 964891], "check": 1, "intersection": 202, "FP_dupl": 27680, "FN_dupl": 0, "F": 0.01438541518302236, "Prec_Dupl": 0.00724481744494656, "Recall_Dupl": 1.0}, {"name2": "the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.\u2029", "id_dupl": 737, "position": [955910, 956112], "check": 1, "intersection": 203, "FP_dupl": 27679, "FN_dupl": 0, "F": 0.01445611536407335, "Prec_Dupl": 0.007280682877842335, "Recall_Dupl": 1.0}, {"name2": "the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.", "id_dupl": 736, "position": [947130, 947331], "check": 1, "intersection": 202, "FP_dupl": 27680, "FN_dupl": 0, "F": 0.01438541518302236, "Prec_Dupl": 0.00724481744494656, "Recall_Dupl": 1.0}, {"name2": "the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.", "id_dupl": 735, "position": [931883, 932084], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.", "id_dupl": 734, "position": [832537, 832738], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.", "id_dupl": 733, "position": [823757, 823958], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.", "id_dupl": 732, "position": [746214, 746415], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.", "id_dupl": 731, "position": [737434, 737635], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.", "id_dupl": 730, "position": [728654, 728855], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.", "id_dupl": 729, "position": [657414, 657615], "check": 1, "intersection": 202, "FP_dupl": 27680, "FN_dupl": 0, "F": 0.01438541518302236, "Prec_Dupl": 0.00724481744494656, "Recall_Dupl": 1.0}, {"name2": "the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.", "id_dupl": 728, "position": [648634, 648835], "check": 1, "intersection": 202, "FP_dupl": 27680, "FN_dupl": 0, "F": 0.01438541518302236, "Prec_Dupl": 0.00724481744494656, "Recall_Dupl": 1.0}, {"name2": "the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry", "id_dupl": 727, "position": [639854, 640054], "check": 1, "intersection": 201, "FP_dupl": 27681, "FN_dupl": 0, "F": 0.014314709966883879, "Prec_Dupl": 0.007208952012050785, "Recall_Dupl": 1.0}, {"name2": "the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.", "id_dupl": 726, "position": [408044, 408245], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.", "id_dupl": 725, "position": [399264, 399465], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.", "id_dupl": 724, "position": [390484, 390685], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.", "id_dupl": 723, "position": [1001640, 1001761], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.", "id_dupl": 722, "position": [1001428, 1001604], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.", "id_dupl": 721, "position": [992860, 992981], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.", "id_dupl": 720, "position": [992648, 992824], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.", "id_dupl": 719, "position": [984080, 984201], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.", "id_dupl": 718, "position": [983868, 984044], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.\u2029", "id_dupl": 717, "position": [964541, 964663], "check": 1, "intersection": 123, "FP_dupl": 27759, "FN_dupl": 0, "F": 0.008784145688269952, "Prec_Dupl": 0.0044114482461803314, "Recall_Dupl": 1.0}, {"name2": "the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.", "id_dupl": 716, "position": [964329, 964505], "check": 1, "intersection": 177, "FP_dupl": 27705, "FN_dupl": 0, "F": 0.012616272853629852, "Prec_Dupl": 0.006348181622552184, "Recall_Dupl": 1.0}, {"name2": "the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.", "id_dupl": 715, "position": [955761, 955882], "check": 1, "intersection": 122, "FP_dupl": 27760, "FN_dupl": 0, "F": 0.008713040994143694, "Prec_Dupl": 0.004375582813284556, "Recall_Dupl": 1.0}, {"name2": "the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.", "id_dupl": 714, "position": [955549, 955725], "check": 1, "intersection": 177, "FP_dupl": 27705, "FN_dupl": 0, "F": 0.012616272853629852, "Prec_Dupl": 0.006348181622552184, "Recall_Dupl": 1.0}, {"name2": "the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.", "id_dupl": 713, "position": [946981, 947102], "check": 1, "intersection": 122, "FP_dupl": 27760, "FN_dupl": 0, "F": 0.008713040994143694, "Prec_Dupl": 0.004375582813284556, "Recall_Dupl": 1.0}, {"name2": "the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.", "id_dupl": 712, "position": [946769, 946945], "check": 1, "intersection": 177, "FP_dupl": 27705, "FN_dupl": 0, "F": 0.012616272853629852, "Prec_Dupl": 0.006348181622552184, "Recall_Dupl": 1.0}, {"name2": "the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.", "id_dupl": 711, "position": [931734, 931855], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.", "id_dupl": 710, "position": [931522, 931698], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.", "id_dupl": 709, "position": [832388, 832509], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.", "id_dupl": 708, "position": [832176, 832352], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC", "id_dupl": 707, "position": [823608, 823728], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.", "id_dupl": 706, "position": [823396, 823572], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.", "id_dupl": 705, "position": [746065, 746186], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.", "id_dupl": 704, "position": [745853, 746029], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.", "id_dupl": 703, "position": [737285, 737406], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.", "id_dupl": 702, "position": [737073, 737249], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.", "id_dupl": 701, "position": [728505, 728626], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.", "id_dupl": 700, "position": [728293, 728469], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.", "id_dupl": 699, "position": [657265, 657386], "check": 1, "intersection": 122, "FP_dupl": 27760, "FN_dupl": 0, "F": 0.008713040994143694, "Prec_Dupl": 0.004375582813284556, "Recall_Dupl": 1.0}, {"name2": "the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.", "id_dupl": 698, "position": [657053, 657229], "check": 1, "intersection": 177, "FP_dupl": 27705, "FN_dupl": 0, "F": 0.012616272853629852, "Prec_Dupl": 0.006348181622552184, "Recall_Dupl": 1.0}, {"name2": "the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.\u2029", "id_dupl": 697, "position": [648485, 648607], "check": 1, "intersection": 123, "FP_dupl": 27759, "FN_dupl": 0, "F": 0.008784145688269952, "Prec_Dupl": 0.0044114482461803314, "Recall_Dupl": 1.0}, {"name2": "the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.", "id_dupl": 696, "position": [648273, 648449], "check": 1, "intersection": 177, "FP_dupl": 27705, "FN_dupl": 0, "F": 0.012616272853629852, "Prec_Dupl": 0.006348181622552184, "Recall_Dupl": 1.0}, {"name2": "the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.", "id_dupl": 695, "position": [639705, 639826], "check": 1, "intersection": 122, "FP_dupl": 27760, "FN_dupl": 0, "F": 0.008713040994143694, "Prec_Dupl": 0.004375582813284556, "Recall_Dupl": 1.0}, {"name2": "the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.", "id_dupl": 694, "position": [639493, 639669], "check": 1, "intersection": 177, "FP_dupl": 27705, "FN_dupl": 0, "F": 0.012616272853629852, "Prec_Dupl": 0.006348181622552184, "Recall_Dupl": 1.0}, {"name2": "the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.", "id_dupl": 693, "position": [407895, 408016], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.", "id_dupl": 692, "position": [407683, 407859], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC", "id_dupl": 691, "position": [399115, 399235], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.", "id_dupl": 690, "position": [398903, 399079], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.", "id_dupl": 689, "position": [390335, 390456], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.", "id_dupl": 688, "position": [390123, 390299], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "39", "annotation": "\u0420\u0430\u0437\u0434\u0435\u0441\u043b DESCRIPTION \u043f\u0430\u043a\u0435\u0442\u043e\u0432 \u043f\u043e\u0434\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c LDAP_FIRST_ENTRY,  LDAP_FIRST_MESSAGE, LDAP_FIRST_REFERENCE", "group_ids": [{"name2": "These routines are used to step through the continuation references in a result chain received from ldap_result(3) or the synchronous LDAP search operation routines.\u2029\u2029The  ldap_first_reference()  routine  is  used  to  retrieve  the  first  reference  message  in  a  result  chain.  It takes the result as returned by a call to ldap_result(3),\u2029ldap_search_s(3) or ldap_search_st(3) and returns a pointer to the first reference message in the result chain.\u2029\u2029This pointer should be supplied on a subsequent call to ldap_next_reference() to get the next reference message, the result of which should be  supplied  to  the  next  call  to\u2029ldap_next_reference(),  etc.   ldap_next_reference()  will  return  NULL when there are no more reference messages.  The reference messages returned from these calls are used by\u2029ldap_parse_reference(3) to extract referrals and controls.\u2029\u2029A count of the number of reference messages in the search result can be obtained by calling ldap_count_references().  It can also be used to count the number of  reference  mes\u2010\u2029sages remaining in a result chain.", "id_dupl": 982, "position": [720526, 721612], "check": 1, "intersection": 1087, "FP_dupl": 8453, "FN_dupl": 0, "F": 0.20457325679872024, "Prec_Dupl": 0.11394129979035639, "Recall_Dupl": 1.0}, {"name2": "These routines are used to step through the continuation references in a result chain received from ldap_result(3) or the synchronous LDAP search operation routines.\u2029\u2029The  ldap_first_reference()  routine  is  used  to  retrieve  the  first  reference  message  in  a  result  chain.  It takes the result as returned by a call to ldap_result(3),\u2029ldap_search_s(3) or ldap_search_st(3) and returns a pointer to the first reference message in the result chain.\u2029\u2029This pointer should be supplied on a subsequent call to ldap_next_reference() to get the next reference message, the result of which should be  supplied  to  the  next  call  to\u2029ldap_next_reference(),  etc.   ldap_next_reference()  will  return  NULL when there are no more reference messages.  The reference messages returned from these calls are used by\u2029ldap_parse_reference(3) to extract referrals and controls.\u2029\u2029A count of the number of reference messages in the search result can be obtained by calling ldap_count_references().  It can also be used to count the number of  reference  mes\u2010\u2029sages remaining in a result chain.", "id_dupl": 981, "position": [576847, 577933], "check": 1, "intersection": 1087, "FP_dupl": 8453, "FN_dupl": 0, "F": 0.20457325679872024, "Prec_Dupl": 0.11394129979035639, "Recall_Dupl": 1.0}, {"name2": "These routines are used to step through the continuation references in a result chain received from ldap_result(3) or the synchronous LDAP search operation routines.\u2029\u2029The  ldap_first_reference()  routine  is  used  to  retrieve  the  first  reference  message  in  a  result  chain.  It takes the result as returned by a call to ldap_result(3),\u2029ldap_search_s(3) or ldap_search_st(3) and returns a pointer to the first reference message in the result chain.\u2029\u2029This pointer should be supplied on a subsequent call to ldap_next_reference() to get the next reference message, the result of which should be  supplied  to  the  next  call  to\u2029ldap_next_reference(),  etc.   ldap_next_reference()  will  return  NULL when there are no more reference messages.  The reference messages returned from these calls are used by\u2029ldap_parse_reference(3) to extract referrals and controls.\u2029\u2029A count of the number of reference messages in the search result can be obtained by calling ldap_count_references().  It can also be used to count the number of  reference  mes\u2010\u2029sages remaining in a result chain.", "id_dupl": 980, "position": [469086, 470172], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "These  routines  are  used  to step through the messages in a result chain received from ldap_result(3).  For search operations, the result chain can contain referral, entry and\u2029result messages. The ldap_msgtype(3) function can be used to distinguish between the different message types.\u2029\u2029The ldap_first_message() routine is used to retrieve the first message in a result chain.  It takes the result as returned by  a  call  to  ldap_result(3),  ldap_search_s(3)  or\u2029ldap_search_st(3) and returns a pointer to the first message in the result chain.\u2029\u2029This  pointer  should  be supplied on a subsequent call to ldap_next_message() to get the next message, the result of which should be supplied to the next call to ldap_next_mes\u2010\u2029sage(), etc.  ldap_next_message() will return NULL when there are no more messages.\u2029\u2029These functions are useful when using routines like ldap_parse_result(3) that only operate on the first result in the chain.\u2029\u2029A count of the number of messages in the result chain can be obtained by calling ldap_count_messages().  It can also be used to count the number of remaining messages in a chain\u2029if  called  with  a  message,  entry  or  reference  returned  by  ldap_first_message() , ldap_next_message() , ldap_first_entry(3), ldap_next_entry(3), ldap_first_reference(3),\u2029ldap_next_reference(3).", "id_dupl": 979, "position": [717931, 719249], "check": 1, "intersection": 1319, "FP_dupl": 8221, "FN_dupl": 0, "F": 0.24293213003038955, "Prec_Dupl": 0.13825995807127883, "Recall_Dupl": 1.0}, {"name2": "These  routines  are  used  to step through the messages in a result chain received from ldap_result(3).  For search operations, the result chain can contain referral, entry and\u2029result messages. The ldap_msgtype(3) function can be used to distinguish between the different message types.\u2029\u2029The ldap_first_message() routine is used to retrieve the first message in a result chain.  It takes the result as returned by  a  call  to  ldap_result(3),  ldap_search_s(3)  or\u2029ldap_search_st(3) and returns a pointer to the first message in the result chain.\u2029\u2029This  pointer  should  be supplied on a subsequent call to ldap_next_message() to get the next message, the result of which should be supplied to the next call to ldap_next_mes\u2010\u2029sage(), etc.  ldap_next_message() will return NULL when there are no more messages.\u2029\u2029These functions are useful when using routines like ldap_parse_result(3) that only operate on the first result in the chain.\u2029\u2029A count of the number of messages in the result chain can be obtained by calling ldap_count_messages().  It can also be used to count the number of remaining messages in a chain\u2029if  called  with  a  message,  entry  or  reference  returned  by  ldap_first_message() , ldap_next_message() , ldap_first_entry(3), ldap_next_entry(3), ldap_first_reference(3),\u2029ldap_next_reference(3).", "id_dupl": 978, "position": [574252, 575570], "check": 1, "intersection": 1319, "FP_dupl": 8221, "FN_dupl": 0, "F": 0.24293213003038955, "Prec_Dupl": 0.13825995807127883, "Recall_Dupl": 1.0}, {"name2": "These  routines  are  used  to step through the messages in a result chain received from ldap_result(3).  For search operations, the result chain can contain referral, entry and\u2029result messages. The ldap_msgtype(3) function can be used to distinguish between the different message types.\u2029\u2029The ldap_first_message() routine is used to retrieve the first message in a result chain.  It takes the result as returned by  a  call  to  ldap_result(3),  ldap_search_s(3)  or\u2029ldap_search_st(3) and returns a pointer to the first message in the result chain.\u2029\u2029This  pointer  should  be supplied on a subsequent call to ldap_next_message() to get the next message, the result of which should be supplied to the next call to ldap_next_mes\u2010\u2029sage(), etc.  ldap_next_message() will return NULL when there are no more messages.\u2029\u2029These functions are useful when using routines like ldap_parse_result(3) that only operate on the first result in the chain.\u2029\u2029A count of the number of messages in the result chain can be obtained by calling ldap_count_messages().  It can also be used to count the number of remaining messages in a chain\u2029if  called  with  a  message,  entry  or  reference  returned  by  ldap_first_message() , ldap_next_message() , ldap_first_entry(3), ldap_next_entry(3), ldap_first_reference(3),\u2029ldap_next_reference(3).", "id_dupl": 977, "position": [466491, 467809], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "These routines are used to parse results received from ldap_result(3) or the synchronous LDAP search operation routines ldap_search_s(3) and ldap_search_st(3).\u2029\u2029The ldap_first_entry() routine is used to retrieve the first entry in a chain of search results.  It takes the result as returned by a call to ldap_result(3) or ldap_search_s(3)\u2029or ldap_search_st(3) and returns a pointer to the first entry in the result.\u2029\u2029This pointer should be supplied on a subsequent call to ldap_next_entry() to get the next entry, the result of which should be supplied to the next  call  to  ldap_next_entry(),\u2029etc.   ldap_next_entry()  will  return NULL when there are no more entries.  The entries returned from these calls are used in calls to the routines described in ldap_get_dn(3),\u2029ldap_first_attribute(3), ldap_get_values(3), etc.\u2029\u2029A count of the number of entries in the search result can be obtained by calling ldap_count_entries().", "id_dupl": 976, "position": [715598, 716524], "check": 1, "intersection": 927, "FP_dupl": 8613, "FN_dupl": 0, "F": 0.177128116938951, "Prec_Dupl": 0.09716981132075472, "Recall_Dupl": 1.0}, {"name2": "These routines are used to parse results received from ldap_result(3) or the synchronous LDAP search operation routines ldap_search_s(3) and ldap_search_st(3).\u2029\u2029The ldap_first_entry() routine is used to retrieve the first entry in a chain of search results.  It takes the result as returned by a call to ldap_result(3) or ldap_search_s(3)\u2029or ldap_search_st(3) and returns a pointer to the first entry in the result.\u2029\u2029This pointer should be supplied on a subsequent call to ldap_next_entry() to get the next entry, the result of which should be supplied to the next  call  to  ldap_next_entry(),\u2029etc.   ldap_next_entry()  will  return NULL when there are no more entries.  The entries returned from these calls are used in calls to the routines described in ldap_get_dn(3),\u2029ldap_first_attribute(3), ldap_get_values(3), etc.\u2029\u2029A count of the number of entries in the search result can be obtained by calling ldap_count_entries().", "id_dupl": 975, "position": [571919, 572845], "check": 1, "intersection": 927, "FP_dupl": 8613, "FN_dupl": 0, "F": 0.177128116938951, "Prec_Dupl": 0.09716981132075472, "Recall_Dupl": 1.0}, {"name2": "These routines are used to parse results received from ldap_result(3) or the synchronous LDAP search operation routines ldap_search_s(3) and ldap_search_st(3).\u2029\u2029The ldap_first_entry() routine is used to retrieve the first entry in a chain of search results.  It takes the result as returned by a call to ldap_result(3) or ldap_search_s(3)\u2029or ldap_search_st(3) and returns a pointer to the first entry in the result.\u2029\u2029This pointer should be supplied on a subsequent call to ldap_next_entry() to get the next entry, the result of which should be supplied to the next  call  to  ldap_next_entry(),\u2029etc.   ldap_next_entry()  will  return NULL when there are no more entries.  The entries returned from these calls are used in calls to the routines described in ldap_get_dn(3),\u2029ldap_first_attribute(3), ldap_get_values(3), etc.\u2029\u2029A count of the number of entries in the search result can be obtained by calling ldap_count_entries().", "id_dupl": 744, "position": [464158, 465084], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "40", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u0440\u0430\u0437\u0434\u0435\u043b\u0430 DEPRECATED  \u0438 DEPRECATED INTERFACES \u043f\u0430\u043a\u0435\u0442\u043e\u0432 LDAP_ERROR, LDAP_ABANDON, LDAP_ADD, LDAP_COMPARE, LDAP_MODIFY, LDAP_SEARCH, \u0430 \u0442\u0430\u043a\u0436\u0435 \u0440\u0430\u0437\u0434\u0435\u043b DESCRIPTION  \u0443\u0441\u0442\u0430\u0440\u0435\u0432\u0448\u0435\u0433\u043e \u043f\u0430\u043a\u0435\u0442\u0430 LDAP_SORT", "group_ids": [{"name2": "Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.", "id_dupl": 766, "position": [350221, 350666], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.", "id_dupl": 765, "position": [794377, 794822], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.", "id_dupl": 764, "position": [778120, 778565], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ldap_modify() and ldap_modify_s() routines are deprecated in favor of the ldap_modify_ext() and ldap_modify_ext_s() routines, respectively.\u2029\u2029Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.", "id_dupl": 763, "position": [698370, 698960], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ldap_modify() and ldap_modify_s() routines are deprecated in favor of the ldap_modify_ext() and ldap_modify_ext_s() routines, respectively.\u2029\u2029Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.", "id_dupl": 762, "position": [685086, 685676], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The ldap_modify() and ldap_modify_s() routines are deprecated in favor of the ldap_modify_ext() and ldap_modify_ext_s() routines, respectively.\u2029\u2029Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.", "id_dupl": 761, "position": [680814, 681404], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.", "id_dupl": 758, "position": [550442, 550887], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.", "id_dupl": 757, "position": [544030, 544475], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.", "id_dupl": 756, "position": [537618, 538063], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The routines ldap_compare() and ldap_compare_s() are deprecated in favor of ldap_compare_ext() and ldap_compare_ext_s(), respectively.\u2029\u2029Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029", "id_dupl": 755, "position": [442046, 442628], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The routines ldap_compare() and ldap_compare_s() are deprecated in favor of ldap_compare_ext() and ldap_compare_ext_s(), respectively.\u2029\u2029Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.", "id_dupl": 754, "position": [439413, 439994], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The routines ldap_compare() and ldap_compare_s() are deprecated in favor of ldap_compare_ext() and ldap_compare_ext_s(), respectively.\u2029\u2029Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.", "id_dupl": 753, "position": [436780, 437361], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "The routines ldap_compare() and ldap_compare_s() are deprecated in favor of ldap_compare_ext() and ldap_compare_ext_s(), respectively.\u2029\u2029Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.", "id_dupl": 752, "position": [434147, 434728], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.", "id_dupl": 751, "position": [350221, 350666], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "41", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u043c\u0435\u0442\u043e\u0434\u0430 \u0432 LBER_ENCODER \u0438 LBER_DECODER", "group_ids": [{"name2": " End set.  No parameter is required and no action is taken.", "id_dupl": 820, "position": [319386, 319445], "check": 1, "intersection": 60, "FP_dupl": 26119, "FN_dupl": 0, "F": 0.004573345020770609, "Prec_Dupl": 0.0022919133656747774, "Recall_Dupl": 1.0}, {"name2": "Begin set.  No parameter is required.  The initial set tag and length are skipped.", "id_dupl": 819, "position": [319300, 319382], "check": 1, "intersection": 83, "FP_dupl": 26096, "FN_dupl": 0, "F": 0.006320919960399056, "Prec_Dupl": 0.0031704801558501087, "Recall_Dupl": 1.0}, {"name2": "End sequence.  No parameter is required and no action is taken.", "id_dupl": 818, "position": [319232, 319295], "check": 1, "intersection": 64, "FP_dupl": 26115, "FN_dupl": 0, "F": 0.004877491140494608, "Prec_Dupl": 0.002444707590053096, "Recall_Dupl": 1.0}, {"name2": "Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.", "id_dupl": 817, "position": [319135, 319227], "check": 1, "intersection": 93, "FP_dupl": 26086, "FN_dupl": 0, "F": 0.007079780755176615, "Prec_Dupl": 0.003552465716795905, "Recall_Dupl": 1.0}, {"name2": "End set.  No parameter is required and no action is taken.", "id_dupl": 816, "position": [293211, 293269], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Begin set.  No parameter is required.  The initial set tag and length are skipped.", "id_dupl": 815, "position": [293124, 293206], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "End sequence.  No parameter is required and no action is taken.", "id_dupl": 814, "position": [293056, 293119], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.", "id_dupl": 813, "position": [292959, 293051], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "End set.  No parameter is required and no action is taken.", "id_dupl": 812, "position": [281403, 281461], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Begin set.  No parameter is required.  The initial set tag and length are skipped.", "id_dupl": 811, "position": [281316, 281398], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "End sequence.  No parameter is required and no action is taken.", "id_dupl": 810, "position": [281248, 281311], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.", "id_dupl": 809, "position": [281151, 281243], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "End set.  No parameter is required and no action is taken.", "id_dupl": 808, "position": [202963, 203021], "check": 1, "intersection": 59, "FP_dupl": 47176, "FN_dupl": 0, "F": 0.0024950310821668714, "Prec_Dupl": 0.0012490737800359903, "Recall_Dupl": 1.0}, {"name2": "Begin set.  No parameter is required.  The initial set tag and length are skipped.", "id_dupl": 807, "position": [202876, 202958], "check": 1, "intersection": 83, "FP_dupl": 47152, "FN_dupl": 0, "F": 0.003508178705777928, "Prec_Dupl": 0.0017571715888641897, "Recall_Dupl": 1.0}, {"name2": "End sequence.  No parameter is required and no action is taken.", "id_dupl": 806, "position": [202808, 202871], "check": 1, "intersection": 64, "FP_dupl": 47171, "FN_dupl": 0, "F": 0.0027061882915072203, "Prec_Dupl": 0.0013549274902085319, "Recall_Dupl": 1.0}, {"name2": "Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.", "id_dupl": 805, "position": [202711, 202803], "check": 1, "intersection": 93, "FP_dupl": 47142, "FN_dupl": 0, "F": 0.00393002028397566, "Prec_Dupl": 0.001968879009209273, "Recall_Dupl": 1.0}, {"name2": "End set.  No parameter is required and no action is taken.", "id_dupl": 804, "position": [191155, 191213], "check": 1, "intersection": 59, "FP_dupl": 47176, "FN_dupl": 0, "F": 0.0024950310821668714, "Prec_Dupl": 0.0012490737800359903, "Recall_Dupl": 1.0}, {"name2": "Begin set.  No parameter is required.  The initial set tag and length are skipped.", "id_dupl": 803, "position": [191068, 191150], "check": 1, "intersection": 83, "FP_dupl": 47152, "FN_dupl": 0, "F": 0.003508178705777928, "Prec_Dupl": 0.0017571715888641897, "Recall_Dupl": 1.0}, {"name2": "End sequence.  No parameter is required and no action is taken.", "id_dupl": 802, "position": [191000, 191063], "check": 1, "intersection": 64, "FP_dupl": 47171, "FN_dupl": 0, "F": 0.0027061882915072203, "Prec_Dupl": 0.0013549274902085319, "Recall_Dupl": 1.0}, {"name2": "Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.", "id_dupl": 801, "position": [190903, 190995], "check": 1, "intersection": 93, "FP_dupl": 47142, "FN_dupl": 0, "F": 0.00393002028397566, "Prec_Dupl": 0.001968879009209273, "Recall_Dupl": 1.0}, {"name2": "End set.  No parameter is required and no action is taken.", "id_dupl": 800, "position": [179347, 179405], "check": 1, "intersection": 59, "FP_dupl": 47176, "FN_dupl": 0, "F": 0.0024950310821668714, "Prec_Dupl": 0.0012490737800359903, "Recall_Dupl": 1.0}, {"name2": "Begin set.  No parameter is required.  The initial set tag and length are skipped.", "id_dupl": 799, "position": [179260, 179342], "check": 1, "intersection": 83, "FP_dupl": 47152, "FN_dupl": 0, "F": 0.003508178705777928, "Prec_Dupl": 0.0017571715888641897, "Recall_Dupl": 1.0}, {"name2": "End sequence.  No parameter is required and no action is taken.", "id_dupl": 798, "position": [179192, 179255], "check": 1, "intersection": 64, "FP_dupl": 47171, "FN_dupl": 0, "F": 0.0027061882915072203, "Prec_Dupl": 0.0013549274902085319, "Recall_Dupl": 1.0}, {"name2": "Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.", "id_dupl": 797, "position": [179095, 179187], "check": 1, "intersection": 93, "FP_dupl": 47142, "FN_dupl": 0, "F": 0.00393002028397566, "Prec_Dupl": 0.001968879009209273, "Recall_Dupl": 1.0}, {"name2": " End set.  No parameter is required and no action is taken.\u2029", "id_dupl": 796, "position": [167538, 167598], "check": 1, "intersection": 61, "FP_dupl": 47174, "FN_dupl": 0, "F": 0.0025794993234100135, "Prec_Dupl": 0.001291415264105007, "Recall_Dupl": 1.0}, {"name2": " Begin set.  No parameter is required.  The initial set tag and length are skipped.", "id_dupl": 795, "position": [167451, 167534], "check": 1, "intersection": 84, "FP_dupl": 47151, "FN_dupl": 0, "F": 0.0035503708869587267, "Prec_Dupl": 0.001778342330898698, "Recall_Dupl": 1.0}, {"name2": " End sequence.  No parameter is required and no action is taken.", "id_dupl": 794, "position": [167383, 167447], "check": 1, "intersection": 65, "FP_dupl": 47170, "FN_dupl": 0, "F": 0.0027484143763213532, "Prec_Dupl": 0.0013760982322430402, "Recall_Dupl": 1.0}, {"name2": "Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped", "id_dupl": 793, "position": [167287, 167378], "check": 1, "intersection": 92, "FP_dupl": 47143, "FN_dupl": 0, "F": 0.003887844148160669, "Prec_Dupl": 0.0019477082671747646, "Recall_Dupl": 1.0}, {"name2": "End set.  No parameter is required and no action is taken.", "id_dupl": 792, "position": [155731, 155789], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Begin set.  No parameter is required.  The initial set tag and length are skipped.", "id_dupl": 791, "position": [155644, 155726], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "End sequence.  No parameter is required and no action is taken.", "id_dupl": 790, "position": [155576, 155639], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.", "id_dupl": 789, "position": [155479, 155571], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": " End set.  No parameter is required and no action is taken.", "id_dupl": 788, "position": [143922, 143981], "check": 1, "intersection": 60, "FP_dupl": 47175, "FN_dupl": 0, "F": 0.002537266095781795, "Prec_Dupl": 0.0012702445220704986, "Recall_Dupl": 1.0}, {"name2": "Begin set.  No parameter is required.  The initial set tag and length are skipped.", "id_dupl": 787, "position": [143836, 143918], "check": 1, "intersection": 83, "FP_dupl": 47152, "FN_dupl": 0, "F": 0.003508178705777928, "Prec_Dupl": 0.0017571715888641897, "Recall_Dupl": 1.0}, {"name2": "End sequence.  No parameter is required and no action is taken.", "id_dupl": 786, "position": [143768, 143831], "check": 1, "intersection": 64, "FP_dupl": 47171, "FN_dupl": 0, "F": 0.0027061882915072203, "Prec_Dupl": 0.0013549274902085319, "Recall_Dupl": 1.0}, {"name2": "Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.", "id_dupl": 785, "position": [143671, 143763], "check": 1, "intersection": 93, "FP_dupl": 47142, "FN_dupl": 0, "F": 0.00393002028397566, "Prec_Dupl": 0.001968879009209273, "Recall_Dupl": 1.0}, {"name2": "End set.  No parameter is required and no action is taken.", "id_dupl": 784, "position": [132115, 132173], "check": 1, "intersection": 59, "FP_dupl": 47176, "FN_dupl": 0, "F": 0.0024950310821668714, "Prec_Dupl": 0.0012490737800359903, "Recall_Dupl": 1.0}, {"name2": "Begin set.  No parameter is required.  The initial set tag and length are skipped.", "id_dupl": 783, "position": [132028, 132110], "check": 1, "intersection": 83, "FP_dupl": 47152, "FN_dupl": 0, "F": 0.003508178705777928, "Prec_Dupl": 0.0017571715888641897, "Recall_Dupl": 1.0}, {"name2": " End sequence.  No parameter is required and no action is taken.", "id_dupl": 782, "position": [131959, 132023], "check": 1, "intersection": 65, "FP_dupl": 47170, "FN_dupl": 0, "F": 0.0027484143763213532, "Prec_Dupl": 0.0013760982322430402, "Recall_Dupl": 1.0}, {"name2": "Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.", "id_dupl": 781, "position": [131863, 131955], "check": 1, "intersection": 93, "FP_dupl": 47142, "FN_dupl": 0, "F": 0.00393002028397566, "Prec_Dupl": 0.001968879009209273, "Recall_Dupl": 1.0}, {"name2": "End set.  No parameter is required and no action is taken.", "id_dupl": 780, "position": [120307, 120365], "check": 1, "intersection": 59, "FP_dupl": 47176, "FN_dupl": 0, "F": 0.0024950310821668714, "Prec_Dupl": 0.0012490737800359903, "Recall_Dupl": 1.0}, {"name2": " Begin set.  No parameter is required.  The initial set tag and length are skipped.", "id_dupl": 779, "position": [120219, 120302], "check": 1, "intersection": 84, "FP_dupl": 47151, "FN_dupl": 0, "F": 0.0035503708869587267, "Prec_Dupl": 0.001778342330898698, "Recall_Dupl": 1.0}, {"name2": "End sequence.  No parameter is required and no action is taken.", "id_dupl": 778, "position": [120152, 120215], "check": 1, "intersection": 64, "FP_dupl": 47171, "FN_dupl": 0, "F": 0.0027061882915072203, "Prec_Dupl": 0.0013549274902085319, "Recall_Dupl": 1.0}, {"name2": "Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.", "id_dupl": 777, "position": [120055, 120147], "check": 1, "intersection": 93, "FP_dupl": 47142, "FN_dupl": 0, "F": 0.00393002028397566, "Prec_Dupl": 0.001968879009209273, "Recall_Dupl": 1.0}, {"name2": "Begin set.  No parameter is required.  The initial set tag and length are skipped.", "id_dupl": 776, "position": [108412, 108494], "check": 1, "intersection": 83, "FP_dupl": 47152, "FN_dupl": 0, "F": 0.003508178705777928, "Prec_Dupl": 0.0017571715888641897, "Recall_Dupl": 1.0}, {"name2": " End set.  No parameter is required and no action is taken.", "id_dupl": 775, "position": [108498, 108557], "check": 1, "intersection": 60, "FP_dupl": 47175, "FN_dupl": 0, "F": 0.002537266095781795, "Prec_Dupl": 0.0012702445220704986, "Recall_Dupl": 1.0}, {"name2": "End sequence.  No parameter is required and no action is taken.", "id_dupl": 774, "position": [108344, 108407], "check": 1, "intersection": 64, "FP_dupl": 47171, "FN_dupl": 0, "F": 0.0027061882915072203, "Prec_Dupl": 0.0013549274902085319, "Recall_Dupl": 1.0}, {"name2": " Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.", "id_dupl": 773, "position": [108246, 108339], "check": 1, "intersection": 94, "FP_dupl": 47141, "FN_dupl": 0, "F": 0.003972194637537239, "Prec_Dupl": 0.001990049751243781, "Recall_Dupl": 1.0}, {"name2": "End set.  No parameter is required and no action is taken.", "id_dupl": 772, "position": [96691, 96749], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "Begin set.  No parameter is required.  The initial set tag and length are skipped.", "id_dupl": 771, "position": [96604, 96686], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "End sequence.  No parameter is required and no action is taken.", "id_dupl": 770, "position": [96536, 96599], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": " Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped", "id_dupl": 769, "position": [96438, 96530], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "End set.  No parameter is required and no action is taken.", "id_dupl": 768, "position": [70515, 70573], "check": 1, "intersection": 59, "FP_dupl": 26120, "FN_dupl": 0, "F": 0.004497294001067155, "Prec_Dupl": 0.002253714809580198, "Recall_Dupl": 1.0}, {"name2": "Begin set.  No parameter is required.  The initial set tag and length are skipped.", "id_dupl": 767, "position": [70428, 70510], "check": 1, "intersection": 83, "FP_dupl": 26096, "FN_dupl": 0, "F": 0.006320919960399056, "Prec_Dupl": 0.0031704801558501087, "Recall_Dupl": 1.0}]}, {"name": "42", "annotation": "LBER_ENCODE", "group_ids": [{"name2": "NAME\u2029ber_alloc_t,  ber_flush,  ber_flush2,  ber_printf,  ber_put_int,  ber_put_enum, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean, ber_put_bitstring, ber_start_seq,\u2029ber_start_set, ber_put_seq, ber_put_set - OpenLDAP LBER simplified Basic Encoding Rules library routines for encoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029BerElement *ber_alloc_t(int options);\u2029\u2029int ber_flush(Sockbuf *sb, BerElement *ber, int freeit);\u2029\u2029int ber_flush2(Sockbuf *sb, BerElement *ber, int freeit);\u2029\u2029int ber_printf(BerElement *ber, const char *fmt, ...);\u2029\u2029int ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);\u2029\u2029int ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);\u2029\u2029int ber_put_ostring(BerElement *ber, const char *str, ber_len_t len, ber_tag_t tag);\u2029\u2029int ber_put_string(BerElement *ber, const char *str, ber_tag_t tag);\u2029\u2029int ber_put_null(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_put_boolean(BerElement *ber, ber_int_t bool, ber_tag_t tag);\u2029\u2029int ber_put_bitstring(BerElement *ber, const char *str, ber_len_t blen, ber_tag_t tag);\u2029\u2029int ber_start_seq(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_start_set(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_put_seq(BerElement *ber);\u2029\u2029int ber_put_set(BerElement *ber);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and\u2029ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou\u2010\u2029tines return the length of the element encoded, or -1 if an error occurred.\u2029\u2029The ber_alloc_t() routine is used to allocate a new BER element.  It should be called with an argument of LBER_USE_DER.\u2029\u2029The ber_flush2() routine is used to actually write the element to a socket (or file) descriptor, once it has been fully encoded (using ber_printf() and friends).  See lber-sock\u2010\u2029buf(3) for more details on the Sockbuf implementation of the sb parameter.  If the freeit parameter is non-zero, the supplied ber will be freed.   If  LBER_FLUSH_FREE_ON_SUCCESS\u2029is used, the ber is only freed when successfully flushed, otherwise it is left intact; if LBER_FLUSH_FREE_ON_ERROR is used, the ber is only freed when an error occurs, otherwise\u2029it is left intact; if LBER_FLUSH_FREE_ALWAYS is used, the ber is freed anyway.  This function differs from the original ber_flush(3) function, whose behavior corresponds to that\u2029indicated  for LBER_FLUSH_FREE_ON_SUCCESS.  Note that in the future, the behavior of ber_flush(3) with freeit non-zero might change into that of ber_flush2(3) with freeit set to\u2029LBER_FLUSH_FREE_ALWAYS.\u2029\u2029The ber_printf() routine is used to encode a BER element in much the same way that sprintf(3) works.  One important difference, though, is that some state  information  is  kept\u2029with  the ber parameter so that multiple calls can be made to ber_printf() to append things to the end of the BER element.  Ber_printf() writes to ber, a pointer to a BerElement\u2029such as returned by ber_alloc_t().  It interprets and formats its arguments according to the format string fmt.  The format string can contain the following characters:\u2029\u2029b  Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.\u2029\u2029e  Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.\u2029\u2029i  Integer.  An ber_int_t parameter should be supplied.  An integer element is output.\u2029\u2029B  Bitstring.  A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.  A bitstring element is output.\u2029\u2029n  Null.  No parameter is required.  A null element is output.\u2029\u2029o  Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.\u2029\u2029O  Octet string.  A struct berval * is supplied.  An octet string element is output.\u2029\u2029s  Octet string.  A null-terminated string is supplied.  An octet string element is output, not including the trailing NULL octet.\u2029\u2029t  Tag.  A ber_tag_t specifying the tag to give the next element is provided.  This works across calls.\u2029\u2029v  Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.\u2029\u2029V  Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet\u2029strings.\u2029\u2029W  Several  octet  strings.  An array of struct berval's is supplied.  The array is terminated by a struct berval with a NULL bv_val.  Note that a construct like '{W}' is\u2029required to get an actual SEQUENCE OF octet strings.\u2029\u2029{  Begin sequence.  No parameter is required.\u2029\u2029}  End sequence.  No parameter is required.\u2029\u2029[  Begin set.  No parameter is required.\u2029\u2029]  End set.  No parameter is required.\u2029\u2029The ber_put_int() routine writes the integer element num to the BER element ber.\u2029\u2029The ber_put_enum() routine writes the enumeration element num to the BER element ber.\u2029\u2029The ber_put_boolean() routine writes the boolean value given by bool to the BER element.\u2029\u2029The ber_put_bitstring() routine writes blen bits starting at str as a bitstring value to the given BER element.  Note that blen is the length in bits of the bitstring.\u2029\u2029The ber_put_ostring() routine writes len bytes starting at str to the BER element as an octet string.\u2029\u2029The ber_put_string() routine writes the null-terminated string (minus the terminating ' ') to the BER element as an octet string.\u2029\u2029The ber_put_null() routine writes a NULL element to the BER element.\u2029\u2029The ber_start_seq() routine is used to start a sequence in the BER element.  The ber_start_set() routine works similarly.  The end of the sequence or set is marked by the  near\u2010\u2029est matching call to ber_put_seq() or ber_put_set(), respectively.\u2029\u2029EXAMPLES\u2029Assuming the following variable declarations, and that the variables have been assigned appropriately, an lber encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029can be achieved like so:\u2029\u2029int rc;\u2029ber_int_t    scope, ali, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029BerElement *ber;\u2029\u2029/* ... fill in values ... */\u2029\u2029ber = ber_alloc_t( LBER_USE_DER );\u2029\u2029if ( ber == NULL ) {\u2029/* error */\u2029}\u2029\u2029rc = ber_printf( ber, \"{siiiib{v}}\", dn, scope, ali,\u2029size, time, attrsonly, attrs );\u2029\u2029if( rc == -1 ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ERRORS\u2029If an error occurs during encoding, generally these routines return -1.\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.\u2029\u2029SEE ALSO\u2029lber-decode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 833, "position": [323596, 331552], "check": 1, "intersection": 7957, "FP_dupl": 18222, "FN_dupl": 0, "F": 0.46619404734005154, "Prec_Dupl": 0.30394591084457007, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ber_alloc_t,  ber_flush,  ber_flush2,  ber_printf,  ber_put_int,  ber_put_enum, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean, ber_put_bitstring, ber_start_seq,\u2029ber_start_set, ber_put_seq, ber_put_set - OpenLDAP LBER simplified Basic Encoding Rules library routines for encoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029BerElement *ber_alloc_t(int options);\u2029\u2029int ber_flush(Sockbuf *sb, BerElement *ber, int freeit);\u2029\u2029int ber_flush2(Sockbuf *sb, BerElement *ber, int freeit);\u2029\u2029int ber_printf(BerElement *ber, const char *fmt, ...);\u2029\u2029int ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);\u2029\u2029int ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);\u2029\u2029int ber_put_ostring(BerElement *ber, const char *str, ber_len_t len, ber_tag_t tag);\u2029\u2029int ber_put_string(BerElement *ber, const char *str, ber_tag_t tag);\u2029\u2029int ber_put_null(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_put_boolean(BerElement *ber, ber_int_t bool, ber_tag_t tag);\u2029\u2029int ber_put_bitstring(BerElement *ber, const char *str, ber_len_t blen, ber_tag_t tag);\u2029\u2029int ber_start_seq(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_start_set(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_put_seq(BerElement *ber);\u2029\u2029int ber_put_set(BerElement *ber);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and\u2029ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou\u2010\u2029tines return the length of the element encoded, or -1 if an error occurred.\u2029\u2029The ber_alloc_t() routine is used to allocate a new BER element.  It should be called with an argument of LBER_USE_DER.\u2029\u2029The ber_flush2() routine is used to actually write the element to a socket (or file) descriptor, once it has been fully encoded (using ber_printf() and friends).  See lber-sock\u2010\u2029buf(3) for more details on the Sockbuf implementation of the sb parameter.  If the freeit parameter is non-zero, the supplied ber will be freed.   If  LBER_FLUSH_FREE_ON_SUCCESS\u2029is used, the ber is only freed when successfully flushed, otherwise it is left intact; if LBER_FLUSH_FREE_ON_ERROR is used, the ber is only freed when an error occurs, otherwise\u2029it is left intact; if LBER_FLUSH_FREE_ALWAYS is used, the ber is freed anyway.  This function differs from the original ber_flush(3) function, whose behavior corresponds to that\u2029indicated  for LBER_FLUSH_FREE_ON_SUCCESS.  Note that in the future, the behavior of ber_flush(3) with freeit non-zero might change into that of ber_flush2(3) with freeit set to\u2029LBER_FLUSH_FREE_ALWAYS.\u2029\u2029The ber_printf() routine is used to encode a BER element in much the same way that sprintf(3) works.  One important difference, though, is that some state  information  is  kept\u2029with  the ber parameter so that multiple calls can be made to ber_printf() to append things to the end of the BER element.  Ber_printf() writes to ber, a pointer to a BerElement\u2029such as returned by ber_alloc_t().  It interprets and formats its arguments according to the format string fmt.  The format string can contain the following characters:\u2029\u2029b  Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.\u2029\u2029e  Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.\u2029\u2029i  Integer.  An ber_int_t parameter should be supplied.  An integer element is output.\u2029\u2029B  Bitstring.  A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.  A bitstring element is output.\u2029\u2029n  Null.  No parameter is required.  A null element is output.\u2029\u2029o  Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.\u2029\u2029O  Octet string.  A struct berval * is supplied.  An octet string element is output.\u2029\u2029s  Octet string.  A null-terminated string is supplied.  An octet string element is output, not including the trailing NULL octet.\u2029\u2029t  Tag.  A ber_tag_t specifying the tag to give the next element is provided.  This works across calls.\u2029\u2029v  Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.\u2029\u2029V  Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet\u2029strings.\u2029\u2029W  Several  octet  strings.  An array of struct berval's is supplied.  The array is terminated by a struct berval with a NULL bv_val.  Note that a construct like '{W}' is\u2029required to get an actual SEQUENCE OF octet strings.\u2029\u2029{  Begin sequence.  No parameter is required.\u2029\u2029}  End sequence.  No parameter is required.\u2029\u2029[  Begin set.  No parameter is required.\u2029\u2029]  End set.  No parameter is required.\u2029\u2029The ber_put_int() routine writes the integer element num to the BER element ber.\u2029\u2029The ber_put_enum() routine writes the enumeration element num to the BER element ber.\u2029\u2029The ber_put_boolean() routine writes the boolean value given by bool to the BER element.\u2029\u2029The ber_put_bitstring() routine writes blen bits starting at str as a bitstring value to the given BER element.  Note that blen is the length in bits of the bitstring.\u2029\u2029The ber_put_ostring() routine writes len bytes starting at str to the BER element as an octet string.\u2029\u2029The ber_put_string() routine writes the null-terminated string (minus the terminating ' ') to the BER element as an octet string.\u2029\u2029The ber_put_null() routine writes a NULL element to the BER element.\u2029\u2029The ber_start_seq() routine is used to start a sequence in the BER element.  The ber_start_set() routine works similarly.  The end of the sequence or set is marked by the  near\u2010\u2029est matching call to ber_put_seq() or ber_put_set(), respectively.\u2029\u2029EXAMPLES\u2029Assuming the following variable declarations, and that the variables have been assigned appropriately, an lber encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029can be achieved like so:\u2029\u2029int rc;\u2029ber_int_t    scope, ali, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029BerElement *ber;\u2029\u2029/* ... fill in values ... */\u2029\u2029ber = ber_alloc_t( LBER_USE_DER );\u2029\u2029if ( ber == NULL ) {\u2029/* error */\u2029}\u2029\u2029rc = ber_printf( ber, \"{siiiib{v}}\", dn, scope, ali,\u2029size, time, attrsonly, attrs );\u2029\u2029if( rc == -1 ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ERRORS\u2029If an error occurs during encoding, generally these routines return -1.\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.\u2029\u2029SEE ALSO\u2029lber-decode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 832, "position": [297420, 305376], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ber_alloc_t,  ber_flush,  ber_flush2,  ber_printf,  ber_put_int,  ber_put_enum, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean, ber_put_bitstring, ber_start_seq,\u2029ber_start_set, ber_put_seq, ber_put_set - OpenLDAP LBER simplified Basic Encoding Rules library routines for encoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029BerElement *ber_alloc_t(int options);\u2029\u2029int ber_flush(Sockbuf *sb, BerElement *ber, int freeit);\u2029\u2029int ber_flush2(Sockbuf *sb, BerElement *ber, int freeit);\u2029\u2029int ber_printf(BerElement *ber, const char *fmt, ...);\u2029\u2029int ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);\u2029\u2029int ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);\u2029\u2029int ber_put_ostring(BerElement *ber, const char *str, ber_len_t len, ber_tag_t tag);\u2029\u2029int ber_put_string(BerElement *ber, const char *str, ber_tag_t tag);\u2029\u2029int ber_put_null(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_put_boolean(BerElement *ber, ber_int_t bool, ber_tag_t tag);\u2029\u2029int ber_put_bitstring(BerElement *ber, const char *str, ber_len_t blen, ber_tag_t tag);\u2029\u2029int ber_start_seq(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_start_set(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_put_seq(BerElement *ber);\u2029\u2029int ber_put_set(BerElement *ber);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and\u2029ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou\u2010\u2029tines return the length of the element encoded, or -1 if an error occurred.\u2029\u2029The ber_alloc_t() routine is used to allocate a new BER element.  It should be called with an argument of LBER_USE_DER.\u2029\u2029The ber_flush2() routine is used to actually write the element to a socket (or file) descriptor, once it has been fully encoded (using ber_printf() and friends).  See lber-sock\u2010\u2029buf(3) for more details on the Sockbuf implementation of the sb parameter.  If the freeit parameter is non-zero, the supplied ber will be freed.   If  LBER_FLUSH_FREE_ON_SUCCESS\u2029is used, the ber is only freed when successfully flushed, otherwise it is left intact; if LBER_FLUSH_FREE_ON_ERROR is used, the ber is only freed when an error occurs, otherwise\u2029it is left intact; if LBER_FLUSH_FREE_ALWAYS is used, the ber is freed anyway.  This function differs from the original ber_flush(3) function, whose behavior corresponds to that\u2029indicated  for LBER_FLUSH_FREE_ON_SUCCESS.  Note that in the future, the behavior of ber_flush(3) with freeit non-zero might change into that of ber_flush2(3) with freeit set to\u2029LBER_FLUSH_FREE_ALWAYS.\u2029\u2029The ber_printf() routine is used to encode a BER element in much the same way that sprintf(3) works.  One important difference, though, is that some state  information  is  kept\u2029with  the ber parameter so that multiple calls can be made to ber_printf() to append things to the end of the BER element.  Ber_printf() writes to ber, a pointer to a BerElement\u2029such as returned by ber_alloc_t().  It interprets and formats its arguments according to the format string fmt.  The format string can contain the following characters:\u2029\u2029b  Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.\u2029\u2029e  Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.\u2029\u2029i  Integer.  An ber_int_t parameter should be supplied.  An integer element is output.\u2029\u2029B  Bitstring.  A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.  A bitstring element is output.\u2029\u2029n  Null.  No parameter is required.  A null element is output.\u2029\u2029o  Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.\u2029\u2029O  Octet string.  A struct berval * is supplied.  An octet string element is output.\u2029\u2029s  Octet string.  A null-terminated string is supplied.  An octet string element is output, not including the trailing NULL octet.\u2029\u2029t  Tag.  A ber_tag_t specifying the tag to give the next element is provided.  This works across calls.\u2029\u2029v  Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.\u2029\u2029V  Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet\u2029strings.\u2029\u2029W  Several  octet  strings.  An array of struct berval's is supplied.  The array is terminated by a struct berval with a NULL bv_val.  Note that a construct like '{W}' is\u2029required to get an actual SEQUENCE OF octet strings.\u2029\u2029{  Begin sequence.  No parameter is required.\u2029\u2029}  End sequence.  No parameter is required.\u2029\u2029[  Begin set.  No parameter is required.\u2029\u2029]  End set.  No parameter is required.\u2029\u2029The ber_put_int() routine writes the integer element num to the BER element ber.\u2029\u2029The ber_put_enum() routine writes the enumeration element num to the BER element ber.\u2029\u2029The ber_put_boolean() routine writes the boolean value given by bool to the BER element.\u2029\u2029The ber_put_bitstring() routine writes blen bits starting at str as a bitstring value to the given BER element.  Note that blen is the length in bits of the bitstring.\u2029\u2029The ber_put_ostring() routine writes len bytes starting at str to the BER element as an octet string.\u2029\u2029The ber_put_string() routine writes the null-terminated string (minus the terminating ' ') to the BER element as an octet string.\u2029\u2029The ber_put_null() routine writes a NULL element to the BER element.\u2029\u2029The ber_start_seq() routine is used to start a sequence in the BER element.  The ber_start_set() routine works similarly.  The end of the sequence or set is marked by the  near\u2010\u2029est matching call to ber_put_seq() or ber_put_set(), respectively.\u2029\u2029EXAMPLES\u2029Assuming the following variable declarations, and that the variables have been assigned appropriately, an lber encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029can be achieved like so:\u2029\u2029int rc;\u2029ber_int_t    scope, ali, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029BerElement *ber;\u2029\u2029/* ... fill in values ... */\u2029\u2029ber = ber_alloc_t( LBER_USE_DER );\u2029\u2029if ( ber == NULL ) {\u2029/* error */\u2029}\u2029\u2029rc = ber_printf( ber, \"{siiiib{v}}\", dn, scope, ali,\u2029size, time, attrsonly, attrs );\u2029\u2029if( rc == -1 ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ERRORS\u2029If an error occurs during encoding, generally these routines return -1.\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.\u2029\u2029SEE ALSO\u2029lber-decode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 831, "position": [265475, 273431], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ber_alloc_t,  ber_flush,  ber_flush2,  ber_printf,  ber_put_int,  ber_put_enum, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean, ber_put_bitstring, ber_start_seq,\u2029ber_start_set, ber_put_seq, ber_put_set - OpenLDAP LBER simplified Basic Encoding Rules library routines for encoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029BerElement *ber_alloc_t(int options);\u2029\u2029int ber_flush(Sockbuf *sb, BerElement *ber, int freeit);\u2029\u2029int ber_flush2(Sockbuf *sb, BerElement *ber, int freeit);\u2029\u2029int ber_printf(BerElement *ber, const char *fmt, ...);\u2029\u2029int ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);\u2029\u2029int ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);\u2029\u2029int ber_put_ostring(BerElement *ber, const char *str, ber_len_t len, ber_tag_t tag);\u2029\u2029int ber_put_string(BerElement *ber, const char *str, ber_tag_t tag);\u2029\u2029int ber_put_null(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_put_boolean(BerElement *ber, ber_int_t bool, ber_tag_t tag);\u2029\u2029int ber_put_bitstring(BerElement *ber, const char *str, ber_len_t blen, ber_tag_t tag);\u2029\u2029int ber_start_seq(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_start_set(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_put_seq(BerElement *ber);\u2029\u2029int ber_put_set(BerElement *ber);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and\u2029ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou\u2010\u2029tines return the length of the element encoded, or -1 if an error occurred.\u2029\u2029The ber_alloc_t() routine is used to allocate a new BER element.  It should be called with an argument of LBER_USE_DER.\u2029\u2029The ber_flush2() routine is used to actually write the element to a socket (or file) descriptor, once it has been fully encoded (using ber_printf() and friends).  See lber-sock\u2010\u2029buf(3) for more details on the Sockbuf implementation of the sb parameter.  If the freeit parameter is non-zero, the supplied ber will be freed.   If  LBER_FLUSH_FREE_ON_SUCCESS\u2029is used, the ber is only freed when successfully flushed, otherwise it is left intact; if LBER_FLUSH_FREE_ON_ERROR is used, the ber is only freed when an error occurs, otherwise\u2029it is left intact; if LBER_FLUSH_FREE_ALWAYS is used, the ber is freed anyway.  This function differs from the original ber_flush(3) function, whose behavior corresponds to that\u2029indicated  for LBER_FLUSH_FREE_ON_SUCCESS.  Note that in the future, the behavior of ber_flush(3) with freeit non-zero might change into that of ber_flush2(3) with freeit set to\u2029LBER_FLUSH_FREE_ALWAYS.\u2029\u2029The ber_printf() routine is used to encode a BER element in much the same way that sprintf(3) works.  One important difference, though, is that some state  information  is  kept\u2029with  the ber parameter so that multiple calls can be made to ber_printf() to append things to the end of the BER element.  Ber_printf() writes to ber, a pointer to a BerElement\u2029such as returned by ber_alloc_t().  It interprets and formats its arguments according to the format string fmt.  The format string can contain the following characters:\u2029\u2029b  Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.\u2029\u2029e  Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.\u2029\u2029i  Integer.  An ber_int_t parameter should be supplied.  An integer element is output.\u2029\u2029B  Bitstring.  A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.  A bitstring element is output.\u2029\u2029n  Null.  No parameter is required.  A null element is output.\u2029\u2029o  Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.\u2029\u2029O  Octet string.  A struct berval * is supplied.  An octet string element is output.\u2029\u2029s  Octet string.  A null-terminated string is supplied.  An octet string element is output, not including the trailing NULL octet.\u2029\u2029t  Tag.  A ber_tag_t specifying the tag to give the next element is provided.  This works across calls.\u2029\u2029v  Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.\u2029\u2029V  Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet\u2029strings.\u2029\u2029W  Several  octet  strings.  An array of struct berval's is supplied.  The array is terminated by a struct berval with a NULL bv_val.  Note that a construct like '{W}' is\u2029required to get an actual SEQUENCE OF octet strings.\u2029\u2029{  Begin sequence.  No parameter is required.\u2029\u2029}  End sequence.  No parameter is required.\u2029\u2029[  Begin set.  No parameter is required.\u2029\u2029]  End set.  No parameter is required.\u2029\u2029The ber_put_int() routine writes the integer element num to the BER element ber.\u2029\u2029The ber_put_enum() routine writes the enumeration element num to the BER element ber.\u2029\u2029The ber_put_boolean() routine writes the boolean value given by bool to the BER element.\u2029\u2029The ber_put_bitstring() routine writes blen bits starting at str as a bitstring value to the given BER element.  Note that blen is the length in bits of the bitstring.\u2029\u2029The ber_put_ostring() routine writes len bytes starting at str to the BER element as an octet string.\u2029\u2029The ber_put_string() routine writes the null-terminated string (minus the terminating ' ') to the BER element as an octet string.\u2029\u2029The ber_put_null() routine writes a NULL element to the BER element.\u2029\u2029The ber_start_seq() routine is used to start a sequence in the BER element.  The ber_start_set() routine works similarly.  The end of the sequence or set is marked by the  near\u2010\u2029est matching call to ber_put_seq() or ber_put_set(), respectively.\u2029\u2029EXAMPLES\u2029Assuming the following variable declarations, and that the variables have been assigned appropriately, an lber encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029can be achieved like so:\u2029\u2029int rc;\u2029ber_int_t    scope, ali, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029BerElement *ber;\u2029\u2029/* ... fill in values ... */\u2029\u2029ber = ber_alloc_t( LBER_USE_DER );\u2029\u2029if ( ber == NULL ) {\u2029/* error */\u2029}\u2029\u2029rc = ber_printf( ber, \"{siiiib{v}}\", dn, scope, ali,\u2029size, time, attrsonly, attrs );\u2029\u2029if( rc == -1 ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ERRORS\u2029If an error occurs during encoding, generally these routines return -1.\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.\u2029\u2029SEE ALSO\u2029lber-decode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 830, "position": [257146, 265102], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ber_alloc_t,  ber_flush,  ber_flush2,  ber_printf,  ber_put_int,  ber_put_enum, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean, ber_put_bitstring, ber_start_seq,\u2029ber_start_set, ber_put_seq, ber_put_set - OpenLDAP LBER simplified Basic Encoding Rules library routines for encoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029BerElement *ber_alloc_t(int options);\u2029\u2029int ber_flush(Sockbuf *sb, BerElement *ber, int freeit);\u2029\u2029int ber_flush2(Sockbuf *sb, BerElement *ber, int freeit);\u2029\u2029int ber_printf(BerElement *ber, const char *fmt, ...);\u2029\u2029int ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);\u2029\u2029int ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);\u2029\u2029int ber_put_ostring(BerElement *ber, const char *str, ber_len_t len, ber_tag_t tag);\u2029\u2029int ber_put_string(BerElement *ber, const char *str, ber_tag_t tag);\u2029\u2029int ber_put_null(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_put_boolean(BerElement *ber, ber_int_t bool, ber_tag_t tag);\u2029\u2029int ber_put_bitstring(BerElement *ber, const char *str, ber_len_t blen, ber_tag_t tag);\u2029\u2029int ber_start_seq(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_start_set(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_put_seq(BerElement *ber);\u2029\u2029int ber_put_set(BerElement *ber);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and\u2029ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou\u2010\u2029tines return the length of the element encoded, or -1 if an error occurred.\u2029\u2029The ber_alloc_t() routine is used to allocate a new BER element.  It should be called with an argument of LBER_USE_DER.\u2029\u2029The ber_flush2() routine is used to actually write the element to a socket (or file) descriptor, once it has been fully encoded (using ber_printf() and friends).  See lber-sock\u2010\u2029buf(3) for more details on the Sockbuf implementation of the sb parameter.  If the freeit parameter is non-zero, the supplied ber will be freed.   If  LBER_FLUSH_FREE_ON_SUCCESS\u2029is used, the ber is only freed when successfully flushed, otherwise it is left intact; if LBER_FLUSH_FREE_ON_ERROR is used, the ber is only freed when an error occurs, otherwise\u2029it is left intact; if LBER_FLUSH_FREE_ALWAYS is used, the ber is freed anyway.  This function differs from the original ber_flush(3) function, whose behavior corresponds to that\u2029indicated  for LBER_FLUSH_FREE_ON_SUCCESS.  Note that in the future, the behavior of ber_flush(3) with freeit non-zero might change into that of ber_flush2(3) with freeit set to\u2029LBER_FLUSH_FREE_ALWAYS.\u2029\u2029The ber_printf() routine is used to encode a BER element in much the same way that sprintf(3) works.  One important difference, though, is that some state  information  is  kept\u2029with  the ber parameter so that multiple calls can be made to ber_printf() to append things to the end of the BER element.  Ber_printf() writes to ber, a pointer to a BerElement\u2029such as returned by ber_alloc_t().  It interprets and formats its arguments according to the format string fmt.  The format string can contain the following characters:\u2029\u2029b  Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.\u2029\u2029e  Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.\u2029\u2029i  Integer.  An ber_int_t parameter should be supplied.  An integer element is output.\u2029\u2029B  Bitstring.  A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.  A bitstring element is output.\u2029\u2029n  Null.  No parameter is required.  A null element is output.\u2029\u2029o  Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.\u2029\u2029O  Octet string.  A struct berval * is supplied.  An octet string element is output.\u2029\u2029s  Octet string.  A null-terminated string is supplied.  An octet string element is output, not including the trailing NULL octet.\u2029\u2029t  Tag.  A ber_tag_t specifying the tag to give the next element is provided.  This works across calls.\u2029\u2029v  Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.\u2029\u2029V  Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet\u2029strings.\u2029\u2029W  Several  octet  strings.  An array of struct berval's is supplied.  The array is terminated by a struct berval with a NULL bv_val.  Note that a construct like '{W}' is\u2029required to get an actual SEQUENCE OF octet strings.\u2029\u2029{  Begin sequence.  No parameter is required.\u2029\u2029}  End sequence.  No parameter is required.\u2029\u2029[  Begin set.  No parameter is required.\u2029\u2029]  End set.  No parameter is required.\u2029\u2029The ber_put_int() routine writes the integer element num to the BER element ber.\u2029\u2029The ber_put_enum() routine writes the enumeration element num to the BER element ber.\u2029\u2029The ber_put_boolean() routine writes the boolean value given by bool to the BER element.\u2029\u2029The ber_put_bitstring() routine writes blen bits starting at str as a bitstring value to the given BER element.  Note that blen is the length in bits of the bitstring.\u2029\u2029The ber_put_ostring() routine writes len bytes starting at str to the BER element as an octet string.\u2029\u2029The ber_put_string() routine writes the null-terminated string (minus the terminating ' ') to the BER element as an octet string.\u2029\u2029The ber_put_null() routine writes a NULL element to the BER element.\u2029\u2029The ber_start_seq() routine is used to start a sequence in the BER element.  The ber_start_set() routine works similarly.  The end of the sequence or set is marked by the  near\u2010\u2029est matching call to ber_put_seq() or ber_put_set(), respectively.\u2029\u2029EXAMPLES\u2029Assuming the following variable declarations, and that the variables have been assigned appropriately, an lber encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029can be achieved like so:\u2029\u2029int rc;\u2029ber_int_t    scope, ali, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029BerElement *ber;\u2029\u2029/* ... fill in values ... */\u2029\u2029ber = ber_alloc_t( LBER_USE_DER );\u2029\u2029if ( ber == NULL ) {\u2029/* error */\u2029}\u2029\u2029rc = ber_printf( ber, \"{siiiib{v}}\", dn, scope, ali,\u2029size, time, attrsonly, attrs );\u2029\u2029if( rc == -1 ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ERRORS\u2029If an error occurs during encoding, generally these routines return -1.\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.\u2029\u2029SEE ALSO\u2029lber-decode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 829, "position": [248817, 256773], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ber_alloc_t,  ber_flush,  ber_flush2,  ber_printf,  ber_put_int,  ber_put_enum, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean, ber_put_bitstring, ber_start_seq,\u2029ber_start_set, ber_put_seq, ber_put_set - OpenLDAP LBER simplified Basic Encoding Rules library routines for encoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029BerElement *ber_alloc_t(int options);\u2029\u2029int ber_flush(Sockbuf *sb, BerElement *ber, int freeit);\u2029\u2029int ber_flush2(Sockbuf *sb, BerElement *ber, int freeit);\u2029\u2029int ber_printf(BerElement *ber, const char *fmt, ...);\u2029\u2029int ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);\u2029\u2029int ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);\u2029\u2029int ber_put_ostring(BerElement *ber, const char *str, ber_len_t len, ber_tag_t tag);\u2029\u2029int ber_put_string(BerElement *ber, const char *str, ber_tag_t tag);\u2029\u2029int ber_put_null(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_put_boolean(BerElement *ber, ber_int_t bool, ber_tag_t tag);\u2029\u2029int ber_put_bitstring(BerElement *ber, const char *str, ber_len_t blen, ber_tag_t tag);\u2029\u2029int ber_start_seq(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_start_set(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_put_seq(BerElement *ber);\u2029\u2029int ber_put_set(BerElement *ber);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and\u2029ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou\u2010\u2029tines return the length of the element encoded, or -1 if an error occurred.\u2029\u2029The ber_alloc_t() routine is used to allocate a new BER element.  It should be called with an argument of LBER_USE_DER.\u2029\u2029The ber_flush2() routine is used to actually write the element to a socket (or file) descriptor, once it has been fully encoded (using ber_printf() and friends).  See lber-sock\u2010\u2029buf(3) for more details on the Sockbuf implementation of the sb parameter.  If the freeit parameter is non-zero, the supplied ber will be freed.   If  LBER_FLUSH_FREE_ON_SUCCESS\u2029is used, the ber is only freed when successfully flushed, otherwise it is left intact; if LBER_FLUSH_FREE_ON_ERROR is used, the ber is only freed when an error occurs, otherwise\u2029it is left intact; if LBER_FLUSH_FREE_ALWAYS is used, the ber is freed anyway.  This function differs from the original ber_flush(3) function, whose behavior corresponds to that\u2029indicated  for LBER_FLUSH_FREE_ON_SUCCESS.  Note that in the future, the behavior of ber_flush(3) with freeit non-zero might change into that of ber_flush2(3) with freeit set to\u2029LBER_FLUSH_FREE_ALWAYS.\u2029\u2029The ber_printf() routine is used to encode a BER element in much the same way that sprintf(3) works.  One important difference, though, is that some state  information  is  kept\u2029with  the ber parameter so that multiple calls can be made to ber_printf() to append things to the end of the BER element.  Ber_printf() writes to ber, a pointer to a BerElement\u2029such as returned by ber_alloc_t().  It interprets and formats its arguments according to the format string fmt.  The format string can contain the following characters:\u2029\u2029b  Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.\u2029\u2029e  Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.\u2029\u2029i  Integer.  An ber_int_t parameter should be supplied.  An integer element is output.\u2029\u2029B  Bitstring.  A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.  A bitstring element is output.\u2029\u2029n  Null.  No parameter is required.  A null element is output.\u2029\u2029o  Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.\u2029\u2029O  Octet string.  A struct berval * is supplied.  An octet string element is output.\u2029\u2029s  Octet string.  A null-terminated string is supplied.  An octet string element is output, not including the trailing NULL octet.\u2029\u2029t  Tag.  A ber_tag_t specifying the tag to give the next element is provided.  This works across calls.\u2029\u2029v  Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.\u2029\u2029V  Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet\u2029strings.\u2029\u2029W  Several  octet  strings.  An array of struct berval's is supplied.  The array is terminated by a struct berval with a NULL bv_val.  Note that a construct like '{W}' is\u2029required to get an actual SEQUENCE OF octet strings.\u2029\u2029{  Begin sequence.  No parameter is required.\u2029\u2029}  End sequence.  No parameter is required.\u2029\u2029[  Begin set.  No parameter is required.\u2029\u2029]  End set.  No parameter is required.\u2029\u2029The ber_put_int() routine writes the integer element num to the BER element ber.\u2029\u2029The ber_put_enum() routine writes the enumeration element num to the BER element ber.\u2029\u2029The ber_put_boolean() routine writes the boolean value given by bool to the BER element.\u2029\u2029The ber_put_bitstring() routine writes blen bits starting at str as a bitstring value to the given BER element.  Note that blen is the length in bits of the bitstring.\u2029\u2029The ber_put_ostring() routine writes len bytes starting at str to the BER element as an octet string.\u2029\u2029The ber_put_string() routine writes the null-terminated string (minus the terminating ' ') to the BER element as an octet string.\u2029\u2029The ber_put_null() routine writes a NULL element to the BER element.\u2029\u2029The ber_start_seq() routine is used to start a sequence in the BER element.  The ber_start_set() routine works similarly.  The end of the sequence or set is marked by the  near\u2010\u2029est matching call to ber_put_seq() or ber_put_set(), respectively.\u2029\u2029EXAMPLES\u2029Assuming the following variable declarations, and that the variables have been assigned appropriately, an lber encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029can be achieved like so:\u2029\u2029int rc;\u2029ber_int_t    scope, ali, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029BerElement *ber;\u2029\u2029/* ... fill in values ... */\u2029\u2029ber = ber_alloc_t( LBER_USE_DER );\u2029\u2029if ( ber == NULL ) {\u2029/* error */\u2029}\u2029\u2029rc = ber_printf( ber, \"{siiiib{v}}\", dn, scope, ali,\u2029size, time, attrsonly, attrs );\u2029\u2029if( rc == -1 ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ERRORS\u2029If an error occurs during encoding, generally these routines return -1.\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.\u2029\u2029SEE ALSO\u2029lber-decode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 828, "position": [240488, 248444], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ber_alloc_t,  ber_flush,  ber_flush2,  ber_printf,  ber_put_int,  ber_put_enum, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean, ber_put_bitstring, ber_start_seq,\u2029ber_start_set, ber_put_seq, ber_put_set - OpenLDAP LBER simplified Basic Encoding Rules library routines for encoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029BerElement *ber_alloc_t(int options);\u2029\u2029int ber_flush(Sockbuf *sb, BerElement *ber, int freeit);\u2029\u2029int ber_flush2(Sockbuf *sb, BerElement *ber, int freeit);\u2029\u2029int ber_printf(BerElement *ber, const char *fmt, ...);\u2029\u2029int ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);\u2029\u2029int ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);\u2029\u2029int ber_put_ostring(BerElement *ber, const char *str, ber_len_t len, ber_tag_t tag);\u2029\u2029int ber_put_string(BerElement *ber, const char *str, ber_tag_t tag);\u2029\u2029int ber_put_null(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_put_boolean(BerElement *ber, ber_int_t bool, ber_tag_t tag);\u2029\u2029int ber_put_bitstring(BerElement *ber, const char *str, ber_len_t blen, ber_tag_t tag);\u2029\u2029int ber_start_seq(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_start_set(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_put_seq(BerElement *ber);\u2029\u2029int ber_put_set(BerElement *ber);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and\u2029ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou\u2010\u2029tines return the length of the element encoded, or -1 if an error occurred.\u2029\u2029The ber_alloc_t() routine is used to allocate a new BER element.  It should be called with an argument of LBER_USE_DER.\u2029\u2029The ber_flush2() routine is used to actually write the element to a socket (or file) descriptor, once it has been fully encoded (using ber_printf() and friends).  See lber-sock\u2010\u2029buf(3) for more details on the Sockbuf implementation of the sb parameter.  If the freeit parameter is non-zero, the supplied ber will be freed.   If  LBER_FLUSH_FREE_ON_SUCCESS\u2029is used, the ber is only freed when successfully flushed, otherwise it is left intact; if LBER_FLUSH_FREE_ON_ERROR is used, the ber is only freed when an error occurs, otherwise\u2029it is left intact; if LBER_FLUSH_FREE_ALWAYS is used, the ber is freed anyway.  This function differs from the original ber_flush(3) function, whose behavior corresponds to that\u2029indicated  for LBER_FLUSH_FREE_ON_SUCCESS.  Note that in the future, the behavior of ber_flush(3) with freeit non-zero might change into that of ber_flush2(3) with freeit set to\u2029LBER_FLUSH_FREE_ALWAYS.\u2029\u2029The ber_printf() routine is used to encode a BER element in much the same way that sprintf(3) works.  One important difference, though, is that some state  information  is  kept\u2029with  the ber parameter so that multiple calls can be made to ber_printf() to append things to the end of the BER element.  Ber_printf() writes to ber, a pointer to a BerElement\u2029such as returned by ber_alloc_t().  It interprets and formats its arguments according to the format string fmt.  The format string can contain the following characters:\u2029\u2029b  Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.\u2029\u2029e  Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.\u2029\u2029i  Integer.  An ber_int_t parameter should be supplied.  An integer element is output.\u2029\u2029B  Bitstring.  A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.  A bitstring element is output.\u2029\u2029n  Null.  No parameter is required.  A null element is output.\u2029\u2029o  Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.\u2029\u2029O  Octet string.  A struct berval * is supplied.  An octet string element is output.\u2029\u2029s  Octet string.  A null-terminated string is supplied.  An octet string element is output, not including the trailing NULL octet.\u2029\u2029t  Tag.  A ber_tag_t specifying the tag to give the next element is provided.  This works across calls.\u2029\u2029v  Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.\u2029\u2029V  Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet\u2029strings.\u2029\u2029W  Several  octet  strings.  An array of struct berval's is supplied.  The array is terminated by a struct berval with a NULL bv_val.  Note that a construct like '{W}' is\u2029required to get an actual SEQUENCE OF octet strings.\u2029\u2029{  Begin sequence.  No parameter is required.\u2029\u2029}  End sequence.  No parameter is required.\u2029\u2029[  Begin set.  No parameter is required.\u2029\u2029]  End set.  No parameter is required.\u2029\u2029The ber_put_int() routine writes the integer element num to the BER element ber.\u2029\u2029The ber_put_enum() routine writes the enumeration element num to the BER element ber.\u2029\u2029The ber_put_boolean() routine writes the boolean value given by bool to the BER element.\u2029\u2029The ber_put_bitstring() routine writes blen bits starting at str as a bitstring value to the given BER element.  Note that blen is the length in bits of the bitstring.\u2029\u2029The ber_put_ostring() routine writes len bytes starting at str to the BER element as an octet string.\u2029\u2029The ber_put_string() routine writes the null-terminated string (minus the terminating ' ') to the BER element as an octet string.\u2029\u2029The ber_put_null() routine writes a NULL element to the BER element.\u2029\u2029The ber_start_seq() routine is used to start a sequence in the BER element.  The ber_start_set() routine works similarly.  The end of the sequence or set is marked by the  near\u2010\u2029est matching call to ber_put_seq() or ber_put_set(), respectively.\u2029\u2029EXAMPLES\u2029Assuming the following variable declarations, and that the variables have been assigned appropriately, an lber encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029can be achieved like so:\u2029\u2029int rc;\u2029ber_int_t    scope, ali, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029BerElement *ber;\u2029\u2029/* ... fill in values ... */\u2029\u2029ber = ber_alloc_t( LBER_USE_DER );\u2029\u2029if ( ber == NULL ) {\u2029/* error */\u2029}\u2029\u2029rc = ber_printf( ber, \"{siiiib{v}}\", dn, scope, ali,\u2029size, time, attrsonly, attrs );\u2029\u2029if( rc == -1 ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ERRORS\u2029If an error occurs during encoding, generally these routines return -1.\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.\u2029\u2029SEE ALSO\u2029lber-decode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 827, "position": [232159, 240115], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ber_alloc_t,  ber_flush,  ber_flush2,  ber_printf,  ber_put_int,  ber_put_enum, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean, ber_put_bitstring, ber_start_seq,\u2029ber_start_set, ber_put_seq, ber_put_set - OpenLDAP LBER simplified Basic Encoding Rules library routines for encoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029BerElement *ber_alloc_t(int options);\u2029\u2029int ber_flush(Sockbuf *sb, BerElement *ber, int freeit);\u2029\u2029int ber_flush2(Sockbuf *sb, BerElement *ber, int freeit);\u2029\u2029int ber_printf(BerElement *ber, const char *fmt, ...);\u2029\u2029int ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);\u2029\u2029int ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);\u2029\u2029int ber_put_ostring(BerElement *ber, const char *str, ber_len_t len, ber_tag_t tag);\u2029\u2029int ber_put_string(BerElement *ber, const char *str, ber_tag_t tag);\u2029\u2029int ber_put_null(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_put_boolean(BerElement *ber, ber_int_t bool, ber_tag_t tag);\u2029\u2029int ber_put_bitstring(BerElement *ber, const char *str, ber_len_t blen, ber_tag_t tag);\u2029\u2029int ber_start_seq(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_start_set(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_put_seq(BerElement *ber);\u2029\u2029int ber_put_set(BerElement *ber);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and\u2029ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou\u2010\u2029tines return the length of the element encoded, or -1 if an error occurred.\u2029\u2029The ber_alloc_t() routine is used to allocate a new BER element.  It should be called with an argument of LBER_USE_DER.\u2029\u2029The ber_flush2() routine is used to actually write the element to a socket (or file) descriptor, once it has been fully encoded (using ber_printf() and friends).  See lber-sock\u2010\u2029buf(3) for more details on the Sockbuf implementation of the sb parameter.  If the freeit parameter is non-zero, the supplied ber will be freed.   If  LBER_FLUSH_FREE_ON_SUCCESS\u2029is used, the ber is only freed when successfully flushed, otherwise it is left intact; if LBER_FLUSH_FREE_ON_ERROR is used, the ber is only freed when an error occurs, otherwise\u2029it is left intact; if LBER_FLUSH_FREE_ALWAYS is used, the ber is freed anyway.  This function differs from the original ber_flush(3) function, whose behavior corresponds to that\u2029indicated  for LBER_FLUSH_FREE_ON_SUCCESS.  Note that in the future, the behavior of ber_flush(3) with freeit non-zero might change into that of ber_flush2(3) with freeit set to\u2029LBER_FLUSH_FREE_ALWAYS.\u2029\u2029The ber_printf() routine is used to encode a BER element in much the same way that sprintf(3) works.  One important difference, though, is that some state  information  is  kept\u2029with  the ber parameter so that multiple calls can be made to ber_printf() to append things to the end of the BER element.  Ber_printf() writes to ber, a pointer to a BerElement\u2029such as returned by ber_alloc_t().  It interprets and formats its arguments according to the format string fmt.  The format string can contain the following characters:\u2029\u2029b  Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.\u2029\u2029e  Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.\u2029\u2029i  Integer.  An ber_int_t parameter should be supplied.  An integer element is output.\u2029\u2029B  Bitstring.  A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.  A bitstring element is output.\u2029\u2029n  Null.  No parameter is required.  A null element is output.\u2029\u2029o  Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.\u2029\u2029O  Octet string.  A struct berval * is supplied.  An octet string element is output.\u2029\u2029s  Octet string.  A null-terminated string is supplied.  An octet string element is output, not including the trailing NULL octet.\u2029\u2029t  Tag.  A ber_tag_t specifying the tag to give the next element is provided.  This works across calls.\u2029\u2029v  Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.\u2029\u2029V  Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet\u2029strings.\u2029\u2029W  Several  octet  strings.  An array of struct berval's is supplied.  The array is terminated by a struct berval with a NULL bv_val.  Note that a construct like '{W}' is\u2029required to get an actual SEQUENCE OF octet strings.\u2029\u2029{  Begin sequence.  No parameter is required.\u2029\u2029}  End sequence.  No parameter is required.\u2029\u2029[  Begin set.  No parameter is required.\u2029\u2029]  End set.  No parameter is required.\u2029\u2029The ber_put_int() routine writes the integer element num to the BER element ber.\u2029\u2029The ber_put_enum() routine writes the enumeration element num to the BER element ber.\u2029\u2029The ber_put_boolean() routine writes the boolean value given by bool to the BER element.\u2029\u2029The ber_put_bitstring() routine writes blen bits starting at str as a bitstring value to the given BER element.  Note that blen is the length in bits of the bitstring.\u2029\u2029The ber_put_ostring() routine writes len bytes starting at str to the BER element as an octet string.\u2029\u2029The ber_put_string() routine writes the null-terminated string (minus the terminating ' ') to the BER element as an octet string.\u2029\u2029The ber_put_null() routine writes a NULL element to the BER element.\u2029\u2029The ber_start_seq() routine is used to start a sequence in the BER element.  The ber_start_set() routine works similarly.  The end of the sequence or set is marked by the  near\u2010\u2029est matching call to ber_put_seq() or ber_put_set(), respectively.\u2029\u2029EXAMPLES\u2029Assuming the following variable declarations, and that the variables have been assigned appropriately, an lber encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029can be achieved like so:\u2029\u2029int rc;\u2029ber_int_t    scope, ali, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029BerElement *ber;\u2029\u2029/* ... fill in values ... */\u2029\u2029ber = ber_alloc_t( LBER_USE_DER );\u2029\u2029if ( ber == NULL ) {\u2029/* error */\u2029}\u2029\u2029rc = ber_printf( ber, \"{siiiib{v}}\", dn, scope, ali,\u2029size, time, attrsonly, attrs );\u2029\u2029if( rc == -1 ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ERRORS\u2029If an error occurs during encoding, generally these routines return -1.\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.\u2029\u2029SEE ALSO\u2029lber-decode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 826, "position": [223830, 231786], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ber_alloc_t,  ber_flush,  ber_flush2,  ber_printf,  ber_put_int,  ber_put_enum, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean, ber_put_bitstring, ber_start_seq,\u2029ber_start_set, ber_put_seq, ber_put_set - OpenLDAP LBER simplified Basic Encoding Rules library routines for encoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029BerElement *ber_alloc_t(int options);\u2029\u2029int ber_flush(Sockbuf *sb, BerElement *ber, int freeit);\u2029\u2029int ber_flush2(Sockbuf *sb, BerElement *ber, int freeit);\u2029\u2029int ber_printf(BerElement *ber, const char *fmt, ...);\u2029\u2029int ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);\u2029\u2029int ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);\u2029\u2029int ber_put_ostring(BerElement *ber, const char *str, ber_len_t len, ber_tag_t tag);\u2029\u2029int ber_put_string(BerElement *ber, const char *str, ber_tag_t tag);\u2029\u2029int ber_put_null(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_put_boolean(BerElement *ber, ber_int_t bool, ber_tag_t tag);\u2029\u2029int ber_put_bitstring(BerElement *ber, const char *str, ber_len_t blen, ber_tag_t tag);\u2029\u2029int ber_start_seq(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_start_set(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_put_seq(BerElement *ber);\u2029\u2029int ber_put_set(BerElement *ber);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and\u2029ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou\u2010\u2029tines return the length of the element encoded, or -1 if an error occurred.\u2029\u2029The ber_alloc_t() routine is used to allocate a new BER element.  It should be called with an argument of LBER_USE_DER.\u2029\u2029The ber_flush2() routine is used to actually write the element to a socket (or file) descriptor, once it has been fully encoded (using ber_printf() and friends).  See lber-sock\u2010\u2029buf(3) for more details on the Sockbuf implementation of the sb parameter.  If the freeit parameter is non-zero, the supplied ber will be freed.   If  LBER_FLUSH_FREE_ON_SUCCESS\u2029is used, the ber is only freed when successfully flushed, otherwise it is left intact; if LBER_FLUSH_FREE_ON_ERROR is used, the ber is only freed when an error occurs, otherwise\u2029it is left intact; if LBER_FLUSH_FREE_ALWAYS is used, the ber is freed anyway.  This function differs from the original ber_flush(3) function, whose behavior corresponds to that\u2029indicated  for LBER_FLUSH_FREE_ON_SUCCESS.  Note that in the future, the behavior of ber_flush(3) with freeit non-zero might change into that of ber_flush2(3) with freeit set to\u2029LBER_FLUSH_FREE_ALWAYS.\u2029\u2029The ber_printf() routine is used to encode a BER element in much the same way that sprintf(3) works.  One important difference, though, is that some state  information  is  kept\u2029with  the ber parameter so that multiple calls can be made to ber_printf() to append things to the end of the BER element.  Ber_printf() writes to ber, a pointer to a BerElement\u2029such as returned by ber_alloc_t().  It interprets and formats its arguments according to the format string fmt.  The format string can contain the following characters:\u2029\u2029b  Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.\u2029\u2029e  Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.\u2029\u2029i  Integer.  An ber_int_t parameter should be supplied.  An integer element is output.\u2029\u2029B  Bitstring.  A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.  A bitstring element is output.\u2029\u2029n  Null.  No parameter is required.  A null element is output.\u2029\u2029o  Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.\u2029\u2029O  Octet string.  A struct berval * is supplied.  An octet string element is output.\u2029\u2029s  Octet string.  A null-terminated string is supplied.  An octet string element is output, not including the trailing NULL octet.\u2029\u2029t  Tag.  A ber_tag_t specifying the tag to give the next element is provided.  This works across calls.\u2029\u2029v  Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.\u2029\u2029V  Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet\u2029strings.\u2029\u2029W  Several  octet  strings.  An array of struct berval's is supplied.  The array is terminated by a struct berval with a NULL bv_val.  Note that a construct like '{W}' is\u2029required to get an actual SEQUENCE OF octet strings.\u2029\u2029{  Begin sequence.  No parameter is required.\u2029\u2029}  End sequence.  No parameter is required.\u2029\u2029[  Begin set.  No parameter is required.\u2029\u2029]  End set.  No parameter is required.\u2029\u2029The ber_put_int() routine writes the integer element num to the BER element ber.\u2029\u2029The ber_put_enum() routine writes the enumeration element num to the BER element ber.\u2029\u2029The ber_put_boolean() routine writes the boolean value given by bool to the BER element.\u2029\u2029The ber_put_bitstring() routine writes blen bits starting at str as a bitstring value to the given BER element.  Note that blen is the length in bits of the bitstring.\u2029\u2029The ber_put_ostring() routine writes len bytes starting at str to the BER element as an octet string.\u2029\u2029The ber_put_string() routine writes the null-terminated string (minus the terminating ' ') to the BER element as an octet string.\u2029\u2029The ber_put_null() routine writes a NULL element to the BER element.\u2029\u2029The ber_start_seq() routine is used to start a sequence in the BER element.  The ber_start_set() routine works similarly.  The end of the sequence or set is marked by the  near\u2010\u2029est matching call to ber_put_seq() or ber_put_set(), respectively.\u2029\u2029EXAMPLES\u2029Assuming the following variable declarations, and that the variables have been assigned appropriately, an lber encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029can be achieved like so:\u2029\u2029int rc;\u2029ber_int_t    scope, ali, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029BerElement *ber;\u2029\u2029/* ... fill in values ... */\u2029\u2029ber = ber_alloc_t( LBER_USE_DER );\u2029\u2029if ( ber == NULL ) {\u2029/* error */\u2029}\u2029\u2029rc = ber_printf( ber, \"{siiiib{v}}\", dn, scope, ali,\u2029size, time, attrsonly, attrs );\u2029\u2029if( rc == -1 ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ERRORS\u2029If an error occurs during encoding, generally these routines return -1.\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.\u2029\u2029SEE ALSO\u2029lber-decode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 825, "position": [215501, 223457], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ber_alloc_t,  ber_flush,  ber_flush2,  ber_printf,  ber_put_int,  ber_put_enum, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean, ber_put_bitstring, ber_start_seq,\u2029ber_start_set, ber_put_seq, ber_put_set - OpenLDAP LBER simplified Basic Encoding Rules library routines for encoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029BerElement *ber_alloc_t(int options);\u2029\u2029int ber_flush(Sockbuf *sb, BerElement *ber, int freeit);\u2029\u2029int ber_flush2(Sockbuf *sb, BerElement *ber, int freeit);\u2029\u2029int ber_printf(BerElement *ber, const char *fmt, ...);\u2029\u2029int ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);\u2029\u2029int ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);\u2029\u2029int ber_put_ostring(BerElement *ber, const char *str, ber_len_t len, ber_tag_t tag);\u2029\u2029int ber_put_string(BerElement *ber, const char *str, ber_tag_t tag);\u2029\u2029int ber_put_null(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_put_boolean(BerElement *ber, ber_int_t bool, ber_tag_t tag);\u2029\u2029int ber_put_bitstring(BerElement *ber, const char *str, ber_len_t blen, ber_tag_t tag);\u2029\u2029int ber_start_seq(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_start_set(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_put_seq(BerElement *ber);\u2029\u2029int ber_put_set(BerElement *ber);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and\u2029ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou\u2010\u2029tines return the length of the element encoded, or -1 if an error occurred.\u2029\u2029The ber_alloc_t() routine is used to allocate a new BER element.  It should be called with an argument of LBER_USE_DER.\u2029\u2029The ber_flush2() routine is used to actually write the element to a socket (or file) descriptor, once it has been fully encoded (using ber_printf() and friends).  See lber-sock\u2010\u2029buf(3) for more details on the Sockbuf implementation of the sb parameter.  If the freeit parameter is non-zero, the supplied ber will be freed.   If  LBER_FLUSH_FREE_ON_SUCCESS\u2029is used, the ber is only freed when successfully flushed, otherwise it is left intact; if LBER_FLUSH_FREE_ON_ERROR is used, the ber is only freed when an error occurs, otherwise\u2029it is left intact; if LBER_FLUSH_FREE_ALWAYS is used, the ber is freed anyway.  This function differs from the original ber_flush(3) function, whose behavior corresponds to that\u2029indicated  for LBER_FLUSH_FREE_ON_SUCCESS.  Note that in the future, the behavior of ber_flush(3) with freeit non-zero might change into that of ber_flush2(3) with freeit set to\u2029LBER_FLUSH_FREE_ALWAYS.\u2029\u2029The ber_printf() routine is used to encode a BER element in much the same way that sprintf(3) works.  One important difference, though, is that some state  information  is  kept\u2029with  the ber parameter so that multiple calls can be made to ber_printf() to append things to the end of the BER element.  Ber_printf() writes to ber, a pointer to a BerElement\u2029such as returned by ber_alloc_t().  It interprets and formats its arguments according to the format string fmt.  The format string can contain the following characters:\u2029\u2029b  Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.\u2029\u2029e  Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.\u2029\u2029i  Integer.  An ber_int_t parameter should be supplied.  An integer element is output.\u2029\u2029B  Bitstring.  A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.  A bitstring element is output.\u2029\u2029n  Null.  No parameter is required.  A null element is output.\u2029\u2029o  Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.\u2029\u2029O  Octet string.  A struct berval * is supplied.  An octet string element is output.\u2029\u2029s  Octet string.  A null-terminated string is supplied.  An octet string element is output, not including the trailing NULL octet.\u2029\u2029t  Tag.  A ber_tag_t specifying the tag to give the next element is provided.  This works across calls.\u2029\u2029v  Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.\u2029\u2029V  Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet\u2029strings.\u2029\u2029W  Several  octet  strings.  An array of struct berval's is supplied.  The array is terminated by a struct berval with a NULL bv_val.  Note that a construct like '{W}' is\u2029required to get an actual SEQUENCE OF octet strings.\u2029\u2029{  Begin sequence.  No parameter is required.\u2029\u2029}  End sequence.  No parameter is required.\u2029\u2029[  Begin set.  No parameter is required.\u2029\u2029]  End set.  No parameter is required.\u2029\u2029The ber_put_int() routine writes the integer element num to the BER element ber.\u2029\u2029The ber_put_enum() routine writes the enumeration element num to the BER element ber.\u2029\u2029The ber_put_boolean() routine writes the boolean value given by bool to the BER element.\u2029\u2029The ber_put_bitstring() routine writes blen bits starting at str as a bitstring value to the given BER element.  Note that blen is the length in bits of the bitstring.\u2029\u2029The ber_put_ostring() routine writes len bytes starting at str to the BER element as an octet string.\u2029\u2029The ber_put_string() routine writes the null-terminated string (minus the terminating ' ') to the BER element as an octet string.\u2029\u2029The ber_put_null() routine writes a NULL element to the BER element.\u2029\u2029The ber_start_seq() routine is used to start a sequence in the BER element.  The ber_start_set() routine works similarly.  The end of the sequence or set is marked by the  near\u2010\u2029est matching call to ber_put_seq() or ber_put_set(), respectively.\u2029\u2029EXAMPLES\u2029Assuming the following variable declarations, and that the variables have been assigned appropriately, an lber encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029can be achieved like so:\u2029\u2029int rc;\u2029ber_int_t    scope, ali, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029BerElement *ber;\u2029\u2029/* ... fill in values ... */\u2029\u2029ber = ber_alloc_t( LBER_USE_DER );\u2029\u2029if ( ber == NULL ) {\u2029/* error */\u2029}\u2029\u2029rc = ber_printf( ber, \"{siiiib{v}}\", dn, scope, ali,\u2029size, time, attrsonly, attrs );\u2029\u2029if( rc == -1 ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ERRORS\u2029If an error occurs during encoding, generally these routines return -1.\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.\u2029\u2029SEE ALSO\u2029lber-decode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 824, "position": [207172, 215128], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ber_alloc_t,  ber_flush,  ber_flush2,  ber_printf,  ber_put_int,  ber_put_enum, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean, ber_put_bitstring, ber_start_seq,\u2029ber_start_set, ber_put_seq, ber_put_set - OpenLDAP LBER simplified Basic Encoding Rules library routines for encoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029BerElement *ber_alloc_t(int options);\u2029\u2029int ber_flush(Sockbuf *sb, BerElement *ber, int freeit);\u2029\u2029int ber_flush2(Sockbuf *sb, BerElement *ber, int freeit);\u2029\u2029int ber_printf(BerElement *ber, const char *fmt, ...);\u2029\u2029int ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);\u2029\u2029int ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);\u2029\u2029int ber_put_ostring(BerElement *ber, const char *str, ber_len_t len, ber_tag_t tag);\u2029\u2029int ber_put_string(BerElement *ber, const char *str, ber_tag_t tag);\u2029\u2029int ber_put_null(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_put_boolean(BerElement *ber, ber_int_t bool, ber_tag_t tag);\u2029\u2029int ber_put_bitstring(BerElement *ber, const char *str, ber_len_t blen, ber_tag_t tag);\u2029\u2029int ber_start_seq(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_start_set(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_put_seq(BerElement *ber);\u2029\u2029int ber_put_set(BerElement *ber);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and\u2029ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou\u2010\u2029tines return the length of the element encoded, or -1 if an error occurred.\u2029\u2029The ber_alloc_t() routine is used to allocate a new BER element.  It should be called with an argument of LBER_USE_DER.\u2029\u2029The ber_flush2() routine is used to actually write the element to a socket (or file) descriptor, once it has been fully encoded (using ber_printf() and friends).  See lber-sock\u2010\u2029buf(3) for more details on the Sockbuf implementation of the sb parameter.  If the freeit parameter is non-zero, the supplied ber will be freed.   If  LBER_FLUSH_FREE_ON_SUCCESS\u2029is used, the ber is only freed when successfully flushed, otherwise it is left intact; if LBER_FLUSH_FREE_ON_ERROR is used, the ber is only freed when an error occurs, otherwise\u2029it is left intact; if LBER_FLUSH_FREE_ALWAYS is used, the ber is freed anyway.  This function differs from the original ber_flush(3) function, whose behavior corresponds to that\u2029indicated  for LBER_FLUSH_FREE_ON_SUCCESS.  Note that in the future, the behavior of ber_flush(3) with freeit non-zero might change into that of ber_flush2(3) with freeit set to\u2029LBER_FLUSH_FREE_ALWAYS.\u2029\u2029The ber_printf() routine is used to encode a BER element in much the same way that sprintf(3) works.  One important difference, though, is that some state  information  is  kept\u2029with  the ber parameter so that multiple calls can be made to ber_printf() to append things to the end of the BER element.  Ber_printf() writes to ber, a pointer to a BerElement\u2029such as returned by ber_alloc_t().  It interprets and formats its arguments according to the format string fmt.  The format string can contain the following characters:\u2029\u2029b  Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.\u2029\u2029e  Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.\u2029\u2029i  Integer.  An ber_int_t parameter should be supplied.  An integer element is output.\u2029\u2029B  Bitstring.  A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.  A bitstring element is output.\u2029\u2029n  Null.  No parameter is required.  A null element is output.\u2029\u2029o  Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.\u2029\u2029O  Octet string.  A struct berval * is supplied.  An octet string element is output.\u2029\u2029s  Octet string.  A null-terminated string is supplied.  An octet string element is output, not including the trailing NULL octet.\u2029\u2029t  Tag.  A ber_tag_t specifying the tag to give the next element is provided.  This works across calls.\u2029\u2029v  Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.\u2029\u2029V  Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet\u2029strings.\u2029\u2029W  Several  octet  strings.  An array of struct berval's is supplied.  The array is terminated by a struct berval with a NULL bv_val.  Note that a construct like '{W}' is\u2029required to get an actual SEQUENCE OF octet strings.\u2029\u2029{  Begin sequence.  No parameter is required.\u2029\u2029}  End sequence.  No parameter is required.\u2029\u2029[  Begin set.  No parameter is required.\u2029\u2029]  End set.  No parameter is required.\u2029\u2029The ber_put_int() routine writes the integer element num to the BER element ber.\u2029\u2029The ber_put_enum() routine writes the enumeration element num to the BER element ber.\u2029\u2029The ber_put_boolean() routine writes the boolean value given by bool to the BER element.\u2029\u2029The ber_put_bitstring() routine writes blen bits starting at str as a bitstring value to the given BER element.  Note that blen is the length in bits of the bitstring.\u2029\u2029The ber_put_ostring() routine writes len bytes starting at str to the BER element as an octet string.\u2029\u2029The ber_put_string() routine writes the null-terminated string (minus the terminating ' ') to the BER element as an octet string.\u2029\u2029The ber_put_null() routine writes a NULL element to the BER element.\u2029\u2029The ber_start_seq() routine is used to start a sequence in the BER element.  The ber_start_set() routine works similarly.  The end of the sequence or set is marked by the  near\u2010\u2029est matching call to ber_put_seq() or ber_put_set(), respectively.\u2029\u2029EXAMPLES\u2029Assuming the following variable declarations, and that the variables have been assigned appropriately, an lber encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029can be achieved like so:\u2029\u2029int rc;\u2029ber_int_t    scope, ali, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029BerElement *ber;\u2029\u2029/* ... fill in values ... */\u2029\u2029ber = ber_alloc_t( LBER_USE_DER );\u2029\u2029if ( ber == NULL ) {\u2029/* error */\u2029}\u2029\u2029rc = ber_printf( ber, \"{siiiib{v}}\", dn, scope, ali,\u2029size, time, attrsonly, attrs );\u2029\u2029if( rc == -1 ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ERRORS\u2029If an error occurs during encoding, generally these routines return -1.\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.\u2029\u2029SEE ALSO\u2029lber-decode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 823, "position": [74724, 82680], "check": 1, "intersection": 7957, "FP_dupl": 18222, "FN_dupl": 0, "F": 0.46619404734005154, "Prec_Dupl": 0.30394591084457007, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ber_alloc_t,  ber_flush,  ber_flush2,  ber_printf,  ber_put_int,  ber_put_enum, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean, ber_put_bitstring, ber_start_seq,\u2029ber_start_set, ber_put_seq, ber_put_set - OpenLDAP LBER simplified Basic Encoding Rules library routines for encoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029BerElement *ber_alloc_t(int options);\u2029\u2029int ber_flush(Sockbuf *sb, BerElement *ber, int freeit);\u2029\u2029int ber_flush2(Sockbuf *sb, BerElement *ber, int freeit);\u2029\u2029int ber_printf(BerElement *ber, const char *fmt, ...);\u2029\u2029int ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);\u2029\u2029int ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);\u2029\u2029int ber_put_ostring(BerElement *ber, const char *str, ber_len_t len, ber_tag_t tag);\u2029\u2029int ber_put_string(BerElement *ber, const char *str, ber_tag_t tag);\u2029\u2029int ber_put_null(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_put_boolean(BerElement *ber, ber_int_t bool, ber_tag_t tag);\u2029\u2029int ber_put_bitstring(BerElement *ber, const char *str, ber_len_t blen, ber_tag_t tag);\u2029\u2029int ber_start_seq(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_start_set(BerElement *ber, ber_tag_t tag);\u2029\u2029int ber_put_seq(BerElement *ber);\u2029\u2029int ber_put_set(BerElement *ber);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and\u2029ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou\u2010\u2029tines return the length of the element encoded, or -1 if an error occurred.\u2029\u2029The ber_alloc_t() routine is used to allocate a new BER element.  It should be called with an argument of LBER_USE_DER.\u2029\u2029The ber_flush2() routine is used to actually write the element to a socket (or file) descriptor, once it has been fully encoded (using ber_printf() and friends).  See lber-sock\u2010\u2029buf(3) for more details on the Sockbuf implementation of the sb parameter.  If the freeit parameter is non-zero, the supplied ber will be freed.   If  LBER_FLUSH_FREE_ON_SUCCESS\u2029is used, the ber is only freed when successfully flushed, otherwise it is left intact; if LBER_FLUSH_FREE_ON_ERROR is used, the ber is only freed when an error occurs, otherwise\u2029it is left intact; if LBER_FLUSH_FREE_ALWAYS is used, the ber is freed anyway.  This function differs from the original ber_flush(3) function, whose behavior corresponds to that\u2029indicated  for LBER_FLUSH_FREE_ON_SUCCESS.  Note that in the future, the behavior of ber_flush(3) with freeit non-zero might change into that of ber_flush2(3) with freeit set to\u2029LBER_FLUSH_FREE_ALWAYS.\u2029\u2029The ber_printf() routine is used to encode a BER element in much the same way that sprintf(3) works.  One important difference, though, is that some state  information  is  kept\u2029with  the ber parameter so that multiple calls can be made to ber_printf() to append things to the end of the BER element.  Ber_printf() writes to ber, a pointer to a BerElement\u2029such as returned by ber_alloc_t().  It interprets and formats its arguments according to the format string fmt.  The format string can contain the following characters:\u2029\u2029b  Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.\u2029\u2029e  Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.\u2029\u2029i  Integer.  An ber_int_t parameter should be supplied.  An integer element is output.\u2029\u2029B  Bitstring.  A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.  A bitstring element is output.\u2029\u2029n  Null.  No parameter is required.  A null element is output.\u2029\u2029o  Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.\u2029\u2029O  Octet string.  A struct berval * is supplied.  An octet string element is output.\u2029\u2029s  Octet string.  A null-terminated string is supplied.  An octet string element is output, not including the trailing NULL octet.\u2029\u2029t  Tag.  A ber_tag_t specifying the tag to give the next element is provided.  This works across calls.\u2029\u2029v  Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.\u2029\u2029V  Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet\u2029strings.\u2029\u2029W  Several  octet  strings.  An array of struct berval's is supplied.  The array is terminated by a struct berval with a NULL bv_val.  Note that a construct like '{W}' is\u2029required to get an actual SEQUENCE OF octet strings.\u2029\u2029{  Begin sequence.  No parameter is required.\u2029\u2029}  End sequence.  No parameter is required.\u2029\u2029[  Begin set.  No parameter is required.\u2029\u2029]  End set.  No parameter is required.\u2029\u2029The ber_put_int() routine writes the integer element num to the BER element ber.\u2029\u2029The ber_put_enum() routine writes the enumeration element num to the BER element ber.\u2029\u2029The ber_put_boolean() routine writes the boolean value given by bool to the BER element.\u2029\u2029The ber_put_bitstring() routine writes blen bits starting at str as a bitstring value to the given BER element.  Note that blen is the length in bits of the bitstring.\u2029\u2029The ber_put_ostring() routine writes len bytes starting at str to the BER element as an octet string.\u2029\u2029The ber_put_string() routine writes the null-terminated string (minus the terminating ' ') to the BER element as an octet string.\u2029\u2029The ber_put_null() routine writes a NULL element to the BER element.\u2029\u2029The ber_start_seq() routine is used to start a sequence in the BER element.  The ber_start_set() routine works similarly.  The end of the sequence or set is marked by the  near\u2010\u2029est matching call to ber_put_seq() or ber_put_set(), respectively.\u2029\u2029EXAMPLES\u2029Assuming the following variable declarations, and that the variables have been assigned appropriately, an lber encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029can be achieved like so:\u2029\u2029int rc;\u2029ber_int_t    scope, ali, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029BerElement *ber;\u2029\u2029/* ... fill in values ... */\u2029\u2029ber = ber_alloc_t( LBER_USE_DER );\u2029\u2029if ( ber == NULL ) {\u2029/* error */\u2029}\u2029\u2029rc = ber_printf( ber, \"{siiiib{v}}\", dn, scope, ali,\u2029size, time, attrsonly, attrs );\u2029\u2029if( rc == -1 ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ERRORS\u2029If an error occurs during encoding, generally these routines return -1.\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.\u2029\u2029SEE ALSO\u2029lber-decode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 822, "position": [236, 8192], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "44", "annotation": "LBER_TYPES", "group_ids": [{"name2": "NAME\u2029ber_int_t,  ber_uint_t,  ber_len_t,  ber_slen_t,  ber_tag_t,  struct  berval, BerValue, BerVarray, BerElement, ber_bvfree, ber_bvecfree, ber_bvecadd, ber_bvarray_free, ber_bvar\u2010\u2029ray_add, ber_bvdup, ber_dupbv, ber_bvstr, ber_bvstrdup, ber_str2bv, ber_alloc_t, ber_init, ber_init2, ber_free - OpenLDAP LBER types and allocation functions\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029typedef impl_tag_t ber_tag_t;\u2029typedef impl_int_t ber_int_t;\u2029typedef impl_uint_t ber_uint_t;\u2029typedef impl_len_t ber_len_t;\u2029typedef impl_slen_t ber_slen_t;\u2029\u2029typedef struct berval {\u2029ber_len_t bv_len;\u2029char *bv_val;\u2029} BerValue, *BerVarray;\u2029\u2029typedef struct berelement BerElement;\u2029\u2029void ber_bvfree(struct berval *bv);\u2029\u2029void ber_bvecfree(struct berval **bvec);\u2029\u2029void ber_bvecadd(struct berval ***bvec, struct berval *bv);\u2029\u2029void ber_bvarray_free(struct berval *bvarray);\u2029\u2029void ber_bvarray_add(BerVarray *bvarray, BerValue *bv);\u2029\u2029struct berval *ber_bvdup(const struct berval *bv);\u2029\u2029struct berval *ber_dupbv(const struct berval *dst, struct berval *src);\u2029\u2029struct berval *ber_bvstr(const char *str);\u2029\u2029struct berval *ber_bvstrdup(const char *str);\u2029\u2029struct berval *ber_str2bv(const char *str, ber_len_t len, int dup, struct berval *bv);\u2029\u2029BerElement *ber_alloc_t(int options);\u2029\u2029BerElement *ber_init(struct berval *bv);\u2029\u2029void ber_init2(BerElement *ber, struct berval *bv, int options);\u2029\u2029void ber_free(BerElement *ber, int freebuf);\u2029\u2029DESCRIPTION\u2029The following are the basic types and structures defined for use with the Lightweight BER library.\u2029\u2029ber_int_t is a signed integer of at least 32 bits.  It is commonly equivalent to int.  ber_uint_t is the unsigned variant of ber_int_t.\u2029\u2029ber_len_t is an unsigned integer of at least 32 bits used to represent a length.  It is commonly equivalent to a size_t.  ber_slen_t is the signed variant to ber_len_t.\u2029\u2029ber_tag_t is an unsigned integer of at least 32 bits used to represent a BER tag.  It is commonly equivalent to a unsigned long.\u2029\u2029The actual definitions of the integral impl_TYPE_t types are platform specific.\u2029\u2029BerValue, commonly used as struct berval, is used to hold an arbitrary sequence of octets.  bv_val points to bv_len octets.  bv_val is  not  necessarily  terminated  by  a  NULL\u2029(zero) octet.  ber_bvfree() frees a BerValue, pointed to by bv, returned from this API.  If bv is NULL, the routine does nothing.\u2029\u2029ber_bvecfree() frees an array of BerValues (and the array), pointed to by bvec, returned from this API.  If bvec is NULL, the routine does nothing.  ber_bvecadd() appends the bv\u2029pointer to the bvec array.  Space for the array is allocated as needed.  The end of the array is marked by a NULL pointer.\u2029\u2029ber_bvarray_free() frees an array of BerValues (and the array), pointed to by bvarray, returned from this API.  If bvarray is NULL, the routine does nothing.   ber_bvarray_add()\u2029appends the contents of the BerValue pointed to by bv to the bvarray array.  Space for the new element is allocated as needed.  The end of the array is marked by a BerValue with\u2029a NULL bv_val field.\u2029\u2029ber_bvdup() returns a copy of a BerValue.  The routine returns NULL upon error (e.g. out of memory).  The caller should use ber_bvfree() to deallocate  the  resulting  BerValue.\u2029ber_dupbv()  copies  a  BerValue from src to dst.  If dst is NULL a new BerValue will be allocated to hold the copy.  The routine returns NULL upon error, otherwise it returns a\u2029pointer to the copy.  If dst is NULL the caller should use ber_bvfree() to deallocate  the  resulting  BerValue,  otherwise  ber_memfree()  should  be  used  to  deallocate  the\u2029dst-&amp;gt;bv_val.   (The  ber_bvdup()  function  is internally implemented as ber_dupbv(NULL, bv).  ber_bvdup() is provided only for compatibility with an expired draft of the LDAP C\u2029API; ber_dupbv() is the preferred interface.)\u2029\u2029ber_bvstr() returns a BerValue containing the string pointed to by str.  ber_bvstrdup() returns a BerValue containing a copy of the  string  pointed  to  by  str.   ber_str2bv()\u2029returns  a  BerValue  containing the string pointed to by str, whose length may be optionally specified in len.  If dup is non-zero, the BerValue will contain a copy of str.  If\u2029len is zero, the number of bytes to copy will be determined by strlen(3), otherwise len bytes will be copied.  If bv is  non-NULL,  the  result  will  be  stored  in  the  given\u2029BerValue, otherwise a new BerValue will be allocated to store the result.  NOTE: Both ber_bvstr() and ber_bvstrdup() are implemented as macros using ber_str2bv() in this version\u2029of the library.\u2029\u2029BerElement is an opaque structure used to maintain state information used in encoding and  decoding.   ber_alloc_t()  is  used  to  create  an  empty  BerElement  structure.  If\u2029LBER_USE_DER is specified for the options parameter then data lengths for data written to the BerElement will be encoded in the minimal number of octets required, otherwise they\u2029will always be written as four byte values.  ber_init() creates a BerElement structure that is initialized with a copy of the data in its bv parameter.  ber_init2()  initializes\u2029an  existing  BerElement ber using the data in the bv parameter. The data is referenced directly, not copied. The options parameter is the same as for ber_alloc_t().  ber_free()\u2029frees a BerElement pointed to by ber.  If ber is NULL, the routine does nothing.  If freebuf is zero, the internal buffer is not freed.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-decode(3), lber-memory(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 845, "position": [338813, 344479], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ber_int_t,  ber_uint_t,  ber_len_t,  ber_slen_t,  ber_tag_t,  struct  berval, BerValue, BerVarray, BerElement, ber_bvfree, ber_bvecfree, ber_bvecadd, ber_bvarray_free, ber_bvar\u2010\u2029ray_add, ber_bvdup, ber_dupbv, ber_bvstr, ber_bvstrdup, ber_str2bv, ber_alloc_t, ber_init, ber_init2, ber_free - OpenLDAP LBER types and allocation functions\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029typedef impl_tag_t ber_tag_t;\u2029typedef impl_int_t ber_int_t;\u2029typedef impl_uint_t ber_uint_t;\u2029typedef impl_len_t ber_len_t;\u2029typedef impl_slen_t ber_slen_t;\u2029\u2029typedef struct berval {\u2029ber_len_t bv_len;\u2029char *bv_val;\u2029} BerValue, *BerVarray;\u2029\u2029typedef struct berelement BerElement;\u2029\u2029void ber_bvfree(struct berval *bv);\u2029\u2029void ber_bvecfree(struct berval **bvec);\u2029\u2029void ber_bvecadd(struct berval ***bvec, struct berval *bv);\u2029\u2029void ber_bvarray_free(struct berval *bvarray);\u2029\u2029void ber_bvarray_add(BerVarray *bvarray, BerValue *bv);\u2029\u2029struct berval *ber_bvdup(const struct berval *bv);\u2029\u2029struct berval *ber_dupbv(const struct berval *dst, struct berval *src);\u2029\u2029struct berval *ber_bvstr(const char *str);\u2029\u2029struct berval *ber_bvstrdup(const char *str);\u2029\u2029struct berval *ber_str2bv(const char *str, ber_len_t len, int dup, struct berval *bv);\u2029\u2029BerElement *ber_alloc_t(int options);\u2029\u2029BerElement *ber_init(struct berval *bv);\u2029\u2029void ber_init2(BerElement *ber, struct berval *bv, int options);\u2029\u2029void ber_free(BerElement *ber, int freebuf);\u2029\u2029DESCRIPTION\u2029The following are the basic types and structures defined for use with the Lightweight BER library.\u2029\u2029ber_int_t is a signed integer of at least 32 bits.  It is commonly equivalent to int.  ber_uint_t is the unsigned variant of ber_int_t.\u2029\u2029ber_len_t is an unsigned integer of at least 32 bits used to represent a length.  It is commonly equivalent to a size_t.  ber_slen_t is the signed variant to ber_len_t.\u2029\u2029ber_tag_t is an unsigned integer of at least 32 bits used to represent a BER tag.  It is commonly equivalent to a unsigned long.\u2029\u2029The actual definitions of the integral impl_TYPE_t types are platform specific.\u2029\u2029BerValue, commonly used as struct berval, is used to hold an arbitrary sequence of octets.  bv_val points to bv_len octets.  bv_val is  not  necessarily  terminated  by  a  NULL\u2029(zero) octet.  ber_bvfree() frees a BerValue, pointed to by bv, returned from this API.  If bv is NULL, the routine does nothing.\u2029\u2029ber_bvecfree() frees an array of BerValues (and the array), pointed to by bvec, returned from this API.  If bvec is NULL, the routine does nothing.  ber_bvecadd() appends the bv\u2029pointer to the bvec array.  Space for the array is allocated as needed.  The end of the array is marked by a NULL pointer.\u2029\u2029ber_bvarray_free() frees an array of BerValues (and the array), pointed to by bvarray, returned from this API.  If bvarray is NULL, the routine does nothing.   ber_bvarray_add()\u2029appends the contents of the BerValue pointed to by bv to the bvarray array.  Space for the new element is allocated as needed.  The end of the array is marked by a BerValue with\u2029a NULL bv_val field.\u2029\u2029ber_bvdup() returns a copy of a BerValue.  The routine returns NULL upon error (e.g. out of memory).  The caller should use ber_bvfree() to deallocate  the  resulting  BerValue.\u2029ber_dupbv()  copies  a  BerValue from src to dst.  If dst is NULL a new BerValue will be allocated to hold the copy.  The routine returns NULL upon error, otherwise it returns a\u2029pointer to the copy.  If dst is NULL the caller should use ber_bvfree() to deallocate  the  resulting  BerValue,  otherwise  ber_memfree()  should  be  used  to  deallocate  the\u2029dst-&amp;gt;bv_val.   (The  ber_bvdup()  function  is internally implemented as ber_dupbv(NULL, bv).  ber_bvdup() is provided only for compatibility with an expired draft of the LDAP C\u2029API; ber_dupbv() is the preferred interface.)\u2029\u2029ber_bvstr() returns a BerValue containing the string pointed to by str.  ber_bvstrdup() returns a BerValue containing a copy of the  string  pointed  to  by  str.   ber_str2bv()\u2029returns  a  BerValue  containing the string pointed to by str, whose length may be optionally specified in len.  If dup is non-zero, the BerValue will contain a copy of str.  If\u2029len is zero, the number of bytes to copy will be determined by strlen(3), otherwise len bytes will be copied.  If bv is  non-NULL,  the  result  will  be  stored  in  the  given\u2029BerValue, otherwise a new BerValue will be allocated to store the result.  NOTE: Both ber_bvstr() and ber_bvstrdup() are implemented as macros using ber_str2bv() in this version\u2029of the library.\u2029\u2029BerElement is an opaque structure used to maintain state information used in encoding and  decoding.   ber_alloc_t()  is  used  to  create  an  empty  BerElement  structure.  If\u2029LBER_USE_DER is specified for the options parameter then data lengths for data written to the BerElement will be encoded in the minimal number of octets required, otherwise they\u2029will always be written as four byte values.  ber_init() creates a BerElement structure that is initialized with a copy of the data in its bv parameter.  ber_init2()  initializes\u2029an  existing  BerElement ber using the data in the bv parameter. The data is referenced directly, not copied. The options parameter is the same as for ber_alloc_t().  ber_free()\u2029frees a BerElement pointed to by ber.  If ber is NULL, the routine does nothing.  If freebuf is zero, the internal buffer is not freed.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-decode(3), lber-memory(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 844, "position": [305749, 311415], "check": 1, "intersection": 5667, "FP_dupl": 20512, "FN_dupl": 0, "F": 0.3559002700496137, "Prec_Dupl": 0.21647121738798272, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ber_int_t,  ber_uint_t,  ber_len_t,  ber_slen_t,  ber_tag_t,  struct  berval, BerValue, BerVarray, BerElement, ber_bvfree, ber_bvecfree, ber_bvecadd, ber_bvarray_free, ber_bvar\u2010\u2029ray_add, ber_bvdup, ber_dupbv, ber_bvstr, ber_bvstrdup, ber_str2bv, ber_alloc_t, ber_init, ber_init2, ber_free - OpenLDAP LBER types and allocation functions\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029typedef impl_tag_t ber_tag_t;\u2029typedef impl_int_t ber_int_t;\u2029typedef impl_uint_t ber_uint_t;\u2029typedef impl_len_t ber_len_t;\u2029typedef impl_slen_t ber_slen_t;\u2029\u2029typedef struct berval {\u2029ber_len_t bv_len;\u2029char *bv_val;\u2029} BerValue, *BerVarray;\u2029\u2029typedef struct berelement BerElement;\u2029\u2029void ber_bvfree(struct berval *bv);\u2029\u2029void ber_bvecfree(struct berval **bvec);\u2029\u2029void ber_bvecadd(struct berval ***bvec, struct berval *bv);\u2029\u2029void ber_bvarray_free(struct berval *bvarray);\u2029\u2029void ber_bvarray_add(BerVarray *bvarray, BerValue *bv);\u2029\u2029struct berval *ber_bvdup(const struct berval *bv);\u2029\u2029struct berval *ber_dupbv(const struct berval *dst, struct berval *src);\u2029\u2029struct berval *ber_bvstr(const char *str);\u2029\u2029struct berval *ber_bvstrdup(const char *str);\u2029\u2029struct berval *ber_str2bv(const char *str, ber_len_t len, int dup, struct berval *bv);\u2029\u2029BerElement *ber_alloc_t(int options);\u2029\u2029BerElement *ber_init(struct berval *bv);\u2029\u2029void ber_init2(BerElement *ber, struct berval *bv, int options);\u2029\u2029void ber_free(BerElement *ber, int freebuf);\u2029\u2029DESCRIPTION\u2029The following are the basic types and structures defined for use with the Lightweight BER library.\u2029\u2029ber_int_t is a signed integer of at least 32 bits.  It is commonly equivalent to int.  ber_uint_t is the unsigned variant of ber_int_t.\u2029\u2029ber_len_t is an unsigned integer of at least 32 bits used to represent a length.  It is commonly equivalent to a size_t.  ber_slen_t is the signed variant to ber_len_t.\u2029\u2029ber_tag_t is an unsigned integer of at least 32 bits used to represent a BER tag.  It is commonly equivalent to a unsigned long.\u2029\u2029The actual definitions of the integral impl_TYPE_t types are platform specific.\u2029\u2029BerValue, commonly used as struct berval, is used to hold an arbitrary sequence of octets.  bv_val points to bv_len octets.  bv_val is  not  necessarily  terminated  by  a  NULL\u2029(zero) octet.  ber_bvfree() frees a BerValue, pointed to by bv, returned from this API.  If bv is NULL, the routine does nothing.\u2029\u2029ber_bvecfree() frees an array of BerValues (and the array), pointed to by bvec, returned from this API.  If bvec is NULL, the routine does nothing.  ber_bvecadd() appends the bv\u2029pointer to the bvec array.  Space for the array is allocated as needed.  The end of the array is marked by a NULL pointer.\u2029\u2029ber_bvarray_free() frees an array of BerValues (and the array), pointed to by bvarray, returned from this API.  If bvarray is NULL, the routine does nothing.   ber_bvarray_add()\u2029appends the contents of the BerValue pointed to by bv to the bvarray array.  Space for the new element is allocated as needed.  The end of the array is marked by a BerValue with\u2029a NULL bv_val field.\u2029\u2029ber_bvdup() returns a copy of a BerValue.  The routine returns NULL upon error (e.g. out of memory).  The caller should use ber_bvfree() to deallocate  the  resulting  BerValue.\u2029ber_dupbv()  copies  a  BerValue from src to dst.  If dst is NULL a new BerValue will be allocated to hold the copy.  The routine returns NULL upon error, otherwise it returns a\u2029pointer to the copy.  If dst is NULL the caller should use ber_bvfree() to deallocate  the  resulting  BerValue,  otherwise  ber_memfree()  should  be  used  to  deallocate  the\u2029dst-&amp;gt;bv_val.   (The  ber_bvdup()  function  is internally implemented as ber_dupbv(NULL, bv).  ber_bvdup() is provided only for compatibility with an expired draft of the LDAP C\u2029API; ber_dupbv() is the preferred interface.)\u2029\u2029ber_bvstr() returns a BerValue containing the string pointed to by str.  ber_bvstrdup() returns a BerValue containing a copy of the  string  pointed  to  by  str.   ber_str2bv()\u2029returns  a  BerValue  containing the string pointed to by str, whose length may be optionally specified in len.  If dup is non-zero, the BerValue will contain a copy of str.  If\u2029len is zero, the number of bytes to copy will be determined by strlen(3), otherwise len bytes will be copied.  If bv is  non-NULL,  the  result  will  be  stored  in  the  given\u2029BerValue, otherwise a new BerValue will be allocated to store the result.  NOTE: Both ber_bvstr() and ber_bvstrdup() are implemented as macros using ber_str2bv() in this version\u2029of the library.\u2029\u2029BerElement is an opaque structure used to maintain state information used in encoding and  decoding.   ber_alloc_t()  is  used  to  create  an  empty  BerElement  structure.  If\u2029LBER_USE_DER is specified for the options parameter then data lengths for data written to the BerElement will be encoded in the minimal number of octets required, otherwise they\u2029will always be written as four byte values.  ber_init() creates a BerElement structure that is initialized with a copy of the data in its bv parameter.  ber_init2()  initializes\u2029an  existing  BerElement ber using the data in the bv parameter. The data is referenced directly, not copied. The options parameter is the same as for ber_alloc_t().  ber_free()\u2029frees a BerElement pointed to by ber.  If ber is NULL, the routine does nothing.  If freebuf is zero, the internal buffer is not freed.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-decode(3), lber-memory(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 843, "position": [83053, 88719], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ber_int_t,  ber_uint_t,  ber_len_t,  ber_slen_t,  ber_tag_t,  struct  berval, BerValue, BerVarray, BerElement, ber_bvfree, ber_bvecfree, ber_bvecadd, ber_bvarray_free, ber_bvar\u2010\u2029ray_add, ber_bvdup, ber_dupbv, ber_bvstr, ber_bvstrdup, ber_str2bv, ber_alloc_t, ber_init, ber_init2, ber_free - OpenLDAP LBER types and allocation functions\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029typedef impl_tag_t ber_tag_t;\u2029typedef impl_int_t ber_int_t;\u2029typedef impl_uint_t ber_uint_t;\u2029typedef impl_len_t ber_len_t;\u2029typedef impl_slen_t ber_slen_t;\u2029\u2029typedef struct berval {\u2029ber_len_t bv_len;\u2029char *bv_val;\u2029} BerValue, *BerVarray;\u2029\u2029typedef struct berelement BerElement;\u2029\u2029void ber_bvfree(struct berval *bv);\u2029\u2029void ber_bvecfree(struct berval **bvec);\u2029\u2029void ber_bvecadd(struct berval ***bvec, struct berval *bv);\u2029\u2029void ber_bvarray_free(struct berval *bvarray);\u2029\u2029void ber_bvarray_add(BerVarray *bvarray, BerValue *bv);\u2029\u2029struct berval *ber_bvdup(const struct berval *bv);\u2029\u2029struct berval *ber_dupbv(const struct berval *dst, struct berval *src);\u2029\u2029struct berval *ber_bvstr(const char *str);\u2029\u2029struct berval *ber_bvstrdup(const char *str);\u2029\u2029struct berval *ber_str2bv(const char *str, ber_len_t len, int dup, struct berval *bv);\u2029\u2029BerElement *ber_alloc_t(int options);\u2029\u2029BerElement *ber_init(struct berval *bv);\u2029\u2029void ber_init2(BerElement *ber, struct berval *bv, int options);\u2029\u2029void ber_free(BerElement *ber, int freebuf);\u2029\u2029DESCRIPTION\u2029The following are the basic types and structures defined for use with the Lightweight BER library.\u2029\u2029ber_int_t is a signed integer of at least 32 bits.  It is commonly equivalent to int.  ber_uint_t is the unsigned variant of ber_int_t.\u2029\u2029ber_len_t is an unsigned integer of at least 32 bits used to represent a length.  It is commonly equivalent to a size_t.  ber_slen_t is the signed variant to ber_len_t.\u2029\u2029ber_tag_t is an unsigned integer of at least 32 bits used to represent a BER tag.  It is commonly equivalent to a unsigned long.\u2029\u2029The actual definitions of the integral impl_TYPE_t types are platform specific.\u2029\u2029BerValue, commonly used as struct berval, is used to hold an arbitrary sequence of octets.  bv_val points to bv_len octets.  bv_val is  not  necessarily  terminated  by  a  NULL\u2029(zero) octet.  ber_bvfree() frees a BerValue, pointed to by bv, returned from this API.  If bv is NULL, the routine does nothing.\u2029\u2029ber_bvecfree() frees an array of BerValues (and the array), pointed to by bvec, returned from this API.  If bvec is NULL, the routine does nothing.  ber_bvecadd() appends the bv\u2029pointer to the bvec array.  Space for the array is allocated as needed.  The end of the array is marked by a NULL pointer.\u2029\u2029ber_bvarray_free() frees an array of BerValues (and the array), pointed to by bvarray, returned from this API.  If bvarray is NULL, the routine does nothing.   ber_bvarray_add()\u2029appends the contents of the BerValue pointed to by bv to the bvarray array.  Space for the new element is allocated as needed.  The end of the array is marked by a BerValue with\u2029a NULL bv_val field.\u2029\u2029ber_bvdup() returns a copy of a BerValue.  The routine returns NULL upon error (e.g. out of memory).  The caller should use ber_bvfree() to deallocate  the  resulting  BerValue.\u2029ber_dupbv()  copies  a  BerValue from src to dst.  If dst is NULL a new BerValue will be allocated to hold the copy.  The routine returns NULL upon error, otherwise it returns a\u2029pointer to the copy.  If dst is NULL the caller should use ber_bvfree() to deallocate  the  resulting  BerValue,  otherwise  ber_memfree()  should  be  used  to  deallocate  the\u2029dst-&amp;gt;bv_val.   (The  ber_bvdup()  function  is internally implemented as ber_dupbv(NULL, bv).  ber_bvdup() is provided only for compatibility with an expired draft of the LDAP C\u2029API; ber_dupbv() is the preferred interface.)\u2029\u2029ber_bvstr() returns a BerValue containing the string pointed to by str.  ber_bvstrdup() returns a BerValue containing a copy of the  string  pointed  to  by  str.   ber_str2bv()\u2029returns  a  BerValue  containing the string pointed to by str, whose length may be optionally specified in len.  If dup is non-zero, the BerValue will contain a copy of str.  If\u2029len is zero, the number of bytes to copy will be determined by strlen(3), otherwise len bytes will be copied.  If bv is  non-NULL,  the  result  will  be  stored  in  the  given\u2029BerValue, otherwise a new BerValue will be allocated to store the result.  NOTE: Both ber_bvstr() and ber_bvstrdup() are implemented as macros using ber_str2bv() in this version\u2029of the library.\u2029\u2029BerElement is an opaque structure used to maintain state information used in encoding and  decoding.   ber_alloc_t()  is  used  to  create  an  empty  BerElement  structure.  If\u2029LBER_USE_DER is specified for the options parameter then data lengths for data written to the BerElement will be encoded in the minimal number of octets required, otherwise they\u2029will always be written as four byte values.  ber_init() creates a BerElement structure that is initialized with a copy of the data in its bv parameter.  ber_init2()  initializes\u2029an  existing  BerElement ber using the data in the bv parameter. The data is referenced directly, not copied. The options parameter is the same as for ber_alloc_t().  ber_free()\u2029frees a BerElement pointed to by ber.  If ber is NULL, the routine does nothing.  If freebuf is zero, the internal buffer is not freed.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-decode(3), lber-memory(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 842, "position": [56877, 62543], "check": 1, "intersection": 5667, "FP_dupl": 20512, "FN_dupl": 0, "F": 0.3559002700496137, "Prec_Dupl": 0.21647121738798272, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ber_int_t,  ber_uint_t,  ber_len_t,  ber_slen_t,  ber_tag_t,  struct  berval, BerValue, BerVarray, BerElement, ber_bvfree, ber_bvecfree, ber_bvecadd, ber_bvarray_free, ber_bvar\u2010\u2029ray_add, ber_bvdup, ber_dupbv, ber_bvstr, ber_bvstrdup, ber_str2bv, ber_alloc_t, ber_init, ber_init2, ber_free - OpenLDAP LBER types and allocation functions\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029typedef impl_tag_t ber_tag_t;\u2029typedef impl_int_t ber_int_t;\u2029typedef impl_uint_t ber_uint_t;\u2029typedef impl_len_t ber_len_t;\u2029typedef impl_slen_t ber_slen_t;\u2029\u2029typedef struct berval {\u2029ber_len_t bv_len;\u2029char *bv_val;\u2029} BerValue, *BerVarray;\u2029\u2029typedef struct berelement BerElement;\u2029\u2029void ber_bvfree(struct berval *bv);\u2029\u2029void ber_bvecfree(struct berval **bvec);\u2029\u2029void ber_bvecadd(struct berval ***bvec, struct berval *bv);\u2029\u2029void ber_bvarray_free(struct berval *bvarray);\u2029\u2029void ber_bvarray_add(BerVarray *bvarray, BerValue *bv);\u2029\u2029struct berval *ber_bvdup(const struct berval *bv);\u2029\u2029struct berval *ber_dupbv(const struct berval *dst, struct berval *src);\u2029\u2029struct berval *ber_bvstr(const char *str);\u2029\u2029struct berval *ber_bvstrdup(const char *str);\u2029\u2029struct berval *ber_str2bv(const char *str, ber_len_t len, int dup, struct berval *bv);\u2029\u2029BerElement *ber_alloc_t(int options);\u2029\u2029BerElement *ber_init(struct berval *bv);\u2029\u2029void ber_init2(BerElement *ber, struct berval *bv, int options);\u2029\u2029void ber_free(BerElement *ber, int freebuf);\u2029\u2029DESCRIPTION\u2029The following are the basic types and structures defined for use with the Lightweight BER library.\u2029\u2029ber_int_t is a signed integer of at least 32 bits.  It is commonly equivalent to int.  ber_uint_t is the unsigned variant of ber_int_t.\u2029\u2029ber_len_t is an unsigned integer of at least 32 bits used to represent a length.  It is commonly equivalent to a size_t.  ber_slen_t is the signed variant to ber_len_t.\u2029\u2029ber_tag_t is an unsigned integer of at least 32 bits used to represent a BER tag.  It is commonly equivalent to a unsigned long.\u2029\u2029The actual definitions of the integral impl_TYPE_t types are platform specific.\u2029\u2029BerValue, commonly used as struct berval, is used to hold an arbitrary sequence of octets.  bv_val points to bv_len octets.  bv_val is  not  necessarily  terminated  by  a  NULL\u2029(zero) octet.  ber_bvfree() frees a BerValue, pointed to by bv, returned from this API.  If bv is NULL, the routine does nothing.\u2029\u2029ber_bvecfree() frees an array of BerValues (and the array), pointed to by bvec, returned from this API.  If bvec is NULL, the routine does nothing.  ber_bvecadd() appends the bv\u2029pointer to the bvec array.  Space for the array is allocated as needed.  The end of the array is marked by a NULL pointer.\u2029\u2029ber_bvarray_free() frees an array of BerValues (and the array), pointed to by bvarray, returned from this API.  If bvarray is NULL, the routine does nothing.   ber_bvarray_add()\u2029appends the contents of the BerValue pointed to by bv to the bvarray array.  Space for the new element is allocated as needed.  The end of the array is marked by a BerValue with\u2029a NULL bv_val field.\u2029\u2029ber_bvdup() returns a copy of a BerValue.  The routine returns NULL upon error (e.g. out of memory).  The caller should use ber_bvfree() to deallocate  the  resulting  BerValue.\u2029ber_dupbv()  copies  a  BerValue from src to dst.  If dst is NULL a new BerValue will be allocated to hold the copy.  The routine returns NULL upon error, otherwise it returns a\u2029pointer to the copy.  If dst is NULL the caller should use ber_bvfree() to deallocate  the  resulting  BerValue,  otherwise  ber_memfree()  should  be  used  to  deallocate  the\u2029dst-&amp;gt;bv_val.   (The  ber_bvdup()  function  is internally implemented as ber_dupbv(NULL, bv).  ber_bvdup() is provided only for compatibility with an expired draft of the LDAP C\u2029API; ber_dupbv() is the preferred interface.)\u2029\u2029ber_bvstr() returns a BerValue containing the string pointed to by str.  ber_bvstrdup() returns a BerValue containing a copy of the  string  pointed  to  by  str.   ber_str2bv()\u2029returns  a  BerValue  containing the string pointed to by str, whose length may be optionally specified in len.  If dup is non-zero, the BerValue will contain a copy of str.  If\u2029len is zero, the number of bytes to copy will be determined by strlen(3), otherwise len bytes will be copied.  If bv is  non-NULL,  the  result  will  be  stored  in  the  given\u2029BerValue, otherwise a new BerValue will be allocated to store the result.  NOTE: Both ber_bvstr() and ber_bvstrdup() are implemented as macros using ber_str2bv() in this version\u2029of the library.\u2029\u2029BerElement is an opaque structure used to maintain state information used in encoding and  decoding.   ber_alloc_t()  is  used  to  create  an  empty  BerElement  structure.  If\u2029LBER_USE_DER is specified for the options parameter then data lengths for data written to the BerElement will be encoded in the minimal number of octets required, otherwise they\u2029will always be written as four byte values.  ber_init() creates a BerElement structure that is initialized with a copy of the data in its bv parameter.  ber_init2()  initializes\u2029an  existing  BerElement ber using the data in the bv parameter. The data is referenced directly, not copied. The options parameter is the same as for ber_alloc_t().  ber_free()\u2029frees a BerElement pointed to by ber.  If ber is NULL, the routine does nothing.  If freebuf is zero, the internal buffer is not freed.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-decode(3), lber-memory(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 841, "position": [50838, 56504], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ber_int_t,  ber_uint_t,  ber_len_t,  ber_slen_t,  ber_tag_t,  struct  berval, BerValue, BerVarray, BerElement, ber_bvfree, ber_bvecfree, ber_bvecadd, ber_bvarray_free, ber_bvar\u2010\u2029ray_add, ber_bvdup, ber_dupbv, ber_bvstr, ber_bvstrdup, ber_str2bv, ber_alloc_t, ber_init, ber_init2, ber_free - OpenLDAP LBER types and allocation functions\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029typedef impl_tag_t ber_tag_t;\u2029typedef impl_int_t ber_int_t;\u2029typedef impl_uint_t ber_uint_t;\u2029typedef impl_len_t ber_len_t;\u2029typedef impl_slen_t ber_slen_t;\u2029\u2029typedef struct berval {\u2029ber_len_t bv_len;\u2029char *bv_val;\u2029} BerValue, *BerVarray;\u2029\u2029typedef struct berelement BerElement;\u2029\u2029void ber_bvfree(struct berval *bv);\u2029\u2029void ber_bvecfree(struct berval **bvec);\u2029\u2029void ber_bvecadd(struct berval ***bvec, struct berval *bv);\u2029\u2029void ber_bvarray_free(struct berval *bvarray);\u2029\u2029void ber_bvarray_add(BerVarray *bvarray, BerValue *bv);\u2029\u2029struct berval *ber_bvdup(const struct berval *bv);\u2029\u2029struct berval *ber_dupbv(const struct berval *dst, struct berval *src);\u2029\u2029struct berval *ber_bvstr(const char *str);\u2029\u2029struct berval *ber_bvstrdup(const char *str);\u2029\u2029struct berval *ber_str2bv(const char *str, ber_len_t len, int dup, struct berval *bv);\u2029\u2029BerElement *ber_alloc_t(int options);\u2029\u2029BerElement *ber_init(struct berval *bv);\u2029\u2029void ber_init2(BerElement *ber, struct berval *bv, int options);\u2029\u2029void ber_free(BerElement *ber, int freebuf);\u2029\u2029DESCRIPTION\u2029The following are the basic types and structures defined for use with the Lightweight BER library.\u2029\u2029ber_int_t is a signed integer of at least 32 bits.  It is commonly equivalent to int.  ber_uint_t is the unsigned variant of ber_int_t.\u2029\u2029ber_len_t is an unsigned integer of at least 32 bits used to represent a length.  It is commonly equivalent to a size_t.  ber_slen_t is the signed variant to ber_len_t.\u2029\u2029ber_tag_t is an unsigned integer of at least 32 bits used to represent a BER tag.  It is commonly equivalent to a unsigned long.\u2029\u2029The actual definitions of the integral impl_TYPE_t types are platform specific.\u2029\u2029BerValue, commonly used as struct berval, is used to hold an arbitrary sequence of octets.  bv_val points to bv_len octets.  bv_val is  not  necessarily  terminated  by  a  NULL\u2029(zero) octet.  ber_bvfree() frees a BerValue, pointed to by bv, returned from this API.  If bv is NULL, the routine does nothing.\u2029\u2029ber_bvecfree() frees an array of BerValues (and the array), pointed to by bvec, returned from this API.  If bvec is NULL, the routine does nothing.  ber_bvecadd() appends the bv\u2029pointer to the bvec array.  Space for the array is allocated as needed.  The end of the array is marked by a NULL pointer.\u2029\u2029ber_bvarray_free() frees an array of BerValues (and the array), pointed to by bvarray, returned from this API.  If bvarray is NULL, the routine does nothing.   ber_bvarray_add()\u2029appends the contents of the BerValue pointed to by bv to the bvarray array.  Space for the new element is allocated as needed.  The end of the array is marked by a BerValue with\u2029a NULL bv_val field.\u2029\u2029ber_bvdup() returns a copy of a BerValue.  The routine returns NULL upon error (e.g. out of memory).  The caller should use ber_bvfree() to deallocate  the  resulting  BerValue.\u2029ber_dupbv()  copies  a  BerValue from src to dst.  If dst is NULL a new BerValue will be allocated to hold the copy.  The routine returns NULL upon error, otherwise it returns a\u2029pointer to the copy.  If dst is NULL the caller should use ber_bvfree() to deallocate  the  resulting  BerValue,  otherwise  ber_memfree()  should  be  used  to  deallocate  the\u2029dst-&amp;gt;bv_val.   (The  ber_bvdup()  function  is internally implemented as ber_dupbv(NULL, bv).  ber_bvdup() is provided only for compatibility with an expired draft of the LDAP C\u2029API; ber_dupbv() is the preferred interface.)\u2029\u2029ber_bvstr() returns a BerValue containing the string pointed to by str.  ber_bvstrdup() returns a BerValue containing a copy of the  string  pointed  to  by  str.   ber_str2bv()\u2029returns  a  BerValue  containing the string pointed to by str, whose length may be optionally specified in len.  If dup is non-zero, the BerValue will contain a copy of str.  If\u2029len is zero, the number of bytes to copy will be determined by strlen(3), otherwise len bytes will be copied.  If bv is  non-NULL,  the  result  will  be  stored  in  the  given\u2029BerValue, otherwise a new BerValue will be allocated to store the result.  NOTE: Both ber_bvstr() and ber_bvstrdup() are implemented as macros using ber_str2bv() in this version\u2029of the library.\u2029\u2029BerElement is an opaque structure used to maintain state information used in encoding and  decoding.   ber_alloc_t()  is  used  to  create  an  empty  BerElement  structure.  If\u2029LBER_USE_DER is specified for the options parameter then data lengths for data written to the BerElement will be encoded in the minimal number of octets required, otherwise they\u2029will always be written as four byte values.  ber_init() creates a BerElement structure that is initialized with a copy of the data in its bv parameter.  ber_init2()  initializes\u2029an  existing  BerElement ber using the data in the bv parameter. The data is referenced directly, not copied. The options parameter is the same as for ber_alloc_t().  ber_free()\u2029frees a BerElement pointed to by ber.  If ber is NULL, the routine does nothing.  If freebuf is zero, the internal buffer is not freed.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-decode(3), lber-memory(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 840, "position": [44799, 50465], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ber_int_t,  ber_uint_t,  ber_len_t,  ber_slen_t,  ber_tag_t,  struct  berval, BerValue, BerVarray, BerElement, ber_bvfree, ber_bvecfree, ber_bvecadd, ber_bvarray_free, ber_bvar\u2010\u2029ray_add, ber_bvdup, ber_dupbv, ber_bvstr, ber_bvstrdup, ber_str2bv, ber_alloc_t, ber_init, ber_init2, ber_free - OpenLDAP LBER types and allocation functions\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029typedef impl_tag_t ber_tag_t;\u2029typedef impl_int_t ber_int_t;\u2029typedef impl_uint_t ber_uint_t;\u2029typedef impl_len_t ber_len_t;\u2029typedef impl_slen_t ber_slen_t;\u2029\u2029typedef struct berval {\u2029ber_len_t bv_len;\u2029char *bv_val;\u2029} BerValue, *BerVarray;\u2029\u2029typedef struct berelement BerElement;\u2029\u2029void ber_bvfree(struct berval *bv);\u2029\u2029void ber_bvecfree(struct berval **bvec);\u2029\u2029void ber_bvecadd(struct berval ***bvec, struct berval *bv);\u2029\u2029void ber_bvarray_free(struct berval *bvarray);\u2029\u2029void ber_bvarray_add(BerVarray *bvarray, BerValue *bv);\u2029\u2029struct berval *ber_bvdup(const struct berval *bv);\u2029\u2029struct berval *ber_dupbv(const struct berval *dst, struct berval *src);\u2029\u2029struct berval *ber_bvstr(const char *str);\u2029\u2029struct berval *ber_bvstrdup(const char *str);\u2029\u2029struct berval *ber_str2bv(const char *str, ber_len_t len, int dup, struct berval *bv);\u2029\u2029BerElement *ber_alloc_t(int options);\u2029\u2029BerElement *ber_init(struct berval *bv);\u2029\u2029void ber_init2(BerElement *ber, struct berval *bv, int options);\u2029\u2029void ber_free(BerElement *ber, int freebuf);\u2029\u2029DESCRIPTION\u2029The following are the basic types and structures defined for use with the Lightweight BER library.\u2029\u2029ber_int_t is a signed integer of at least 32 bits.  It is commonly equivalent to int.  ber_uint_t is the unsigned variant of ber_int_t.\u2029\u2029ber_len_t is an unsigned integer of at least 32 bits used to represent a length.  It is commonly equivalent to a size_t.  ber_slen_t is the signed variant to ber_len_t.\u2029\u2029ber_tag_t is an unsigned integer of at least 32 bits used to represent a BER tag.  It is commonly equivalent to a unsigned long.\u2029\u2029The actual definitions of the integral impl_TYPE_t types are platform specific.\u2029\u2029BerValue, commonly used as struct berval, is used to hold an arbitrary sequence of octets.  bv_val points to bv_len octets.  bv_val is  not  necessarily  terminated  by  a  NULL\u2029(zero) octet.  ber_bvfree() frees a BerValue, pointed to by bv, returned from this API.  If bv is NULL, the routine does nothing.\u2029\u2029ber_bvecfree() frees an array of BerValues (and the array), pointed to by bvec, returned from this API.  If bvec is NULL, the routine does nothing.  ber_bvecadd() appends the bv\u2029pointer to the bvec array.  Space for the array is allocated as needed.  The end of the array is marked by a NULL pointer.\u2029\u2029ber_bvarray_free() frees an array of BerValues (and the array), pointed to by bvarray, returned from this API.  If bvarray is NULL, the routine does nothing.   ber_bvarray_add()\u2029appends the contents of the BerValue pointed to by bv to the bvarray array.  Space for the new element is allocated as needed.  The end of the array is marked by a BerValue with\u2029a NULL bv_val field.\u2029\u2029ber_bvdup() returns a copy of a BerValue.  The routine returns NULL upon error (e.g. out of memory).  The caller should use ber_bvfree() to deallocate  the  resulting  BerValue.\u2029ber_dupbv()  copies  a  BerValue from src to dst.  If dst is NULL a new BerValue will be allocated to hold the copy.  The routine returns NULL upon error, otherwise it returns a\u2029pointer to the copy.  If dst is NULL the caller should use ber_bvfree() to deallocate  the  resulting  BerValue,  otherwise  ber_memfree()  should  be  used  to  deallocate  the\u2029dst-&amp;gt;bv_val.   (The  ber_bvdup()  function  is internally implemented as ber_dupbv(NULL, bv).  ber_bvdup() is provided only for compatibility with an expired draft of the LDAP C\u2029API; ber_dupbv() is the preferred interface.)\u2029\u2029ber_bvstr() returns a BerValue containing the string pointed to by str.  ber_bvstrdup() returns a BerValue containing a copy of the  string  pointed  to  by  str.   ber_str2bv()\u2029returns  a  BerValue  containing the string pointed to by str, whose length may be optionally specified in len.  If dup is non-zero, the BerValue will contain a copy of str.  If\u2029len is zero, the number of bytes to copy will be determined by strlen(3), otherwise len bytes will be copied.  If bv is  non-NULL,  the  result  will  be  stored  in  the  given\u2029BerValue, otherwise a new BerValue will be allocated to store the result.  NOTE: Both ber_bvstr() and ber_bvstrdup() are implemented as macros using ber_str2bv() in this version\u2029of the library.\u2029\u2029BerElement is an opaque structure used to maintain state information used in encoding and  decoding.   ber_alloc_t()  is  used  to  create  an  empty  BerElement  structure.  If\u2029LBER_USE_DER is specified for the options parameter then data lengths for data written to the BerElement will be encoded in the minimal number of octets required, otherwise they\u2029will always be written as four byte values.  ber_init() creates a BerElement structure that is initialized with a copy of the data in its bv parameter.  ber_init2()  initializes\u2029an  existing  BerElement ber using the data in the bv parameter. The data is referenced directly, not copied. The options parameter is the same as for ber_alloc_t().  ber_free()\u2029frees a BerElement pointed to by ber.  If ber is NULL, the routine does nothing.  If freebuf is zero, the internal buffer is not freed.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-decode(3), lber-memory(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 839, "position": [38760, 44426], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ber_int_t,  ber_uint_t,  ber_len_t,  ber_slen_t,  ber_tag_t,  struct  berval, BerValue, BerVarray, BerElement, ber_bvfree, ber_bvecfree, ber_bvecadd, ber_bvarray_free, ber_bvar\u2010\u2029ray_add, ber_bvdup, ber_dupbv, ber_bvstr, ber_bvstrdup, ber_str2bv, ber_alloc_t, ber_init, ber_init2, ber_free - OpenLDAP LBER types and allocation functions\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029typedef impl_tag_t ber_tag_t;\u2029typedef impl_int_t ber_int_t;\u2029typedef impl_uint_t ber_uint_t;\u2029typedef impl_len_t ber_len_t;\u2029typedef impl_slen_t ber_slen_t;\u2029\u2029typedef struct berval {\u2029ber_len_t bv_len;\u2029char *bv_val;\u2029} BerValue, *BerVarray;\u2029\u2029typedef struct berelement BerElement;\u2029\u2029void ber_bvfree(struct berval *bv);\u2029\u2029void ber_bvecfree(struct berval **bvec);\u2029\u2029void ber_bvecadd(struct berval ***bvec, struct berval *bv);\u2029\u2029void ber_bvarray_free(struct berval *bvarray);\u2029\u2029void ber_bvarray_add(BerVarray *bvarray, BerValue *bv);\u2029\u2029struct berval *ber_bvdup(const struct berval *bv);\u2029\u2029struct berval *ber_dupbv(const struct berval *dst, struct berval *src);\u2029\u2029struct berval *ber_bvstr(const char *str);\u2029\u2029struct berval *ber_bvstrdup(const char *str);\u2029\u2029struct berval *ber_str2bv(const char *str, ber_len_t len, int dup, struct berval *bv);\u2029\u2029BerElement *ber_alloc_t(int options);\u2029\u2029BerElement *ber_init(struct berval *bv);\u2029\u2029void ber_init2(BerElement *ber, struct berval *bv, int options);\u2029\u2029void ber_free(BerElement *ber, int freebuf);\u2029\u2029DESCRIPTION\u2029The following are the basic types and structures defined for use with the Lightweight BER library.\u2029\u2029ber_int_t is a signed integer of at least 32 bits.  It is commonly equivalent to int.  ber_uint_t is the unsigned variant of ber_int_t.\u2029\u2029ber_len_t is an unsigned integer of at least 32 bits used to represent a length.  It is commonly equivalent to a size_t.  ber_slen_t is the signed variant to ber_len_t.\u2029\u2029ber_tag_t is an unsigned integer of at least 32 bits used to represent a BER tag.  It is commonly equivalent to a unsigned long.\u2029\u2029The actual definitions of the integral impl_TYPE_t types are platform specific.\u2029\u2029BerValue, commonly used as struct berval, is used to hold an arbitrary sequence of octets.  bv_val points to bv_len octets.  bv_val is  not  necessarily  terminated  by  a  NULL\u2029(zero) octet.  ber_bvfree() frees a BerValue, pointed to by bv, returned from this API.  If bv is NULL, the routine does nothing.\u2029\u2029ber_bvecfree() frees an array of BerValues (and the array), pointed to by bvec, returned from this API.  If bvec is NULL, the routine does nothing.  ber_bvecadd() appends the bv\u2029pointer to the bvec array.  Space for the array is allocated as needed.  The end of the array is marked by a NULL pointer.\u2029\u2029ber_bvarray_free() frees an array of BerValues (and the array), pointed to by bvarray, returned from this API.  If bvarray is NULL, the routine does nothing.   ber_bvarray_add()\u2029appends the contents of the BerValue pointed to by bv to the bvarray array.  Space for the new element is allocated as needed.  The end of the array is marked by a BerValue with\u2029a NULL bv_val field.\u2029\u2029ber_bvdup() returns a copy of a BerValue.  The routine returns NULL upon error (e.g. out of memory).  The caller should use ber_bvfree() to deallocate  the  resulting  BerValue.\u2029ber_dupbv()  copies  a  BerValue from src to dst.  If dst is NULL a new BerValue will be allocated to hold the copy.  The routine returns NULL upon error, otherwise it returns a\u2029pointer to the copy.  If dst is NULL the caller should use ber_bvfree() to deallocate  the  resulting  BerValue,  otherwise  ber_memfree()  should  be  used  to  deallocate  the\u2029dst-&amp;gt;bv_val.   (The  ber_bvdup()  function  is internally implemented as ber_dupbv(NULL, bv).  ber_bvdup() is provided only for compatibility with an expired draft of the LDAP C\u2029API; ber_dupbv() is the preferred interface.)\u2029\u2029ber_bvstr() returns a BerValue containing the string pointed to by str.  ber_bvstrdup() returns a BerValue containing a copy of the  string  pointed  to  by  str.   ber_str2bv()\u2029returns  a  BerValue  containing the string pointed to by str, whose length may be optionally specified in len.  If dup is non-zero, the BerValue will contain a copy of str.  If\u2029len is zero, the number of bytes to copy will be determined by strlen(3), otherwise len bytes will be copied.  If bv is  non-NULL,  the  result  will  be  stored  in  the  given\u2029BerValue, otherwise a new BerValue will be allocated to store the result.  NOTE: Both ber_bvstr() and ber_bvstrdup() are implemented as macros using ber_str2bv() in this version\u2029of the library.\u2029\u2029BerElement is an opaque structure used to maintain state information used in encoding and  decoding.   ber_alloc_t()  is  used  to  create  an  empty  BerElement  structure.  If\u2029LBER_USE_DER is specified for the options parameter then data lengths for data written to the BerElement will be encoded in the minimal number of octets required, otherwise they\u2029will always be written as four byte values.  ber_init() creates a BerElement structure that is initialized with a copy of the data in its bv parameter.  ber_init2()  initializes\u2029an  existing  BerElement ber using the data in the bv parameter. The data is referenced directly, not copied. The options parameter is the same as for ber_alloc_t().  ber_free()\u2029frees a BerElement pointed to by ber.  If ber is NULL, the routine does nothing.  If freebuf is zero, the internal buffer is not freed.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-decode(3), lber-memory(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 838, "position": [32721, 38387], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ber_int_t,  ber_uint_t,  ber_len_t,  ber_slen_t,  ber_tag_t,  struct  berval, BerValue, BerVarray, BerElement, ber_bvfree, ber_bvecfree, ber_bvecadd, ber_bvarray_free, ber_bvar\u2010\u2029ray_add, ber_bvdup, ber_dupbv, ber_bvstr, ber_bvstrdup, ber_str2bv, ber_alloc_t, ber_init, ber_init2, ber_free - OpenLDAP LBER types and allocation functions\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029typedef impl_tag_t ber_tag_t;\u2029typedef impl_int_t ber_int_t;\u2029typedef impl_uint_t ber_uint_t;\u2029typedef impl_len_t ber_len_t;\u2029typedef impl_slen_t ber_slen_t;\u2029\u2029typedef struct berval {\u2029ber_len_t bv_len;\u2029char *bv_val;\u2029} BerValue, *BerVarray;\u2029\u2029typedef struct berelement BerElement;\u2029\u2029void ber_bvfree(struct berval *bv);\u2029\u2029void ber_bvecfree(struct berval **bvec);\u2029\u2029void ber_bvecadd(struct berval ***bvec, struct berval *bv);\u2029\u2029void ber_bvarray_free(struct berval *bvarray);\u2029\u2029void ber_bvarray_add(BerVarray *bvarray, BerValue *bv);\u2029\u2029struct berval *ber_bvdup(const struct berval *bv);\u2029\u2029struct berval *ber_dupbv(const struct berval *dst, struct berval *src);\u2029\u2029struct berval *ber_bvstr(const char *str);\u2029\u2029struct berval *ber_bvstrdup(const char *str);\u2029\u2029struct berval *ber_str2bv(const char *str, ber_len_t len, int dup, struct berval *bv);\u2029\u2029BerElement *ber_alloc_t(int options);\u2029\u2029BerElement *ber_init(struct berval *bv);\u2029\u2029void ber_init2(BerElement *ber, struct berval *bv, int options);\u2029\u2029void ber_free(BerElement *ber, int freebuf);\u2029\u2029DESCRIPTION\u2029The following are the basic types and structures defined for use with the Lightweight BER library.\u2029\u2029ber_int_t is a signed integer of at least 32 bits.  It is commonly equivalent to int.  ber_uint_t is the unsigned variant of ber_int_t.\u2029\u2029ber_len_t is an unsigned integer of at least 32 bits used to represent a length.  It is commonly equivalent to a size_t.  ber_slen_t is the signed variant to ber_len_t.\u2029\u2029ber_tag_t is an unsigned integer of at least 32 bits used to represent a BER tag.  It is commonly equivalent to a unsigned long.\u2029\u2029The actual definitions of the integral impl_TYPE_t types are platform specific.\u2029\u2029BerValue, commonly used as struct berval, is used to hold an arbitrary sequence of octets.  bv_val points to bv_len octets.  bv_val is  not  necessarily  terminated  by  a  NULL\u2029(zero) octet.  ber_bvfree() frees a BerValue, pointed to by bv, returned from this API.  If bv is NULL, the routine does nothing.\u2029\u2029ber_bvecfree() frees an array of BerValues (and the array), pointed to by bvec, returned from this API.  If bvec is NULL, the routine does nothing.  ber_bvecadd() appends the bv\u2029pointer to the bvec array.  Space for the array is allocated as needed.  The end of the array is marked by a NULL pointer.\u2029\u2029ber_bvarray_free() frees an array of BerValues (and the array), pointed to by bvarray, returned from this API.  If bvarray is NULL, the routine does nothing.   ber_bvarray_add()\u2029appends the contents of the BerValue pointed to by bv to the bvarray array.  Space for the new element is allocated as needed.  The end of the array is marked by a BerValue with\u2029a NULL bv_val field.\u2029\u2029ber_bvdup() returns a copy of a BerValue.  The routine returns NULL upon error (e.g. out of memory).  The caller should use ber_bvfree() to deallocate  the  resulting  BerValue.\u2029ber_dupbv()  copies  a  BerValue from src to dst.  If dst is NULL a new BerValue will be allocated to hold the copy.  The routine returns NULL upon error, otherwise it returns a\u2029pointer to the copy.  If dst is NULL the caller should use ber_bvfree() to deallocate  the  resulting  BerValue,  otherwise  ber_memfree()  should  be  used  to  deallocate  the\u2029dst-&amp;gt;bv_val.   (The  ber_bvdup()  function  is internally implemented as ber_dupbv(NULL, bv).  ber_bvdup() is provided only for compatibility with an expired draft of the LDAP C\u2029API; ber_dupbv() is the preferred interface.)\u2029\u2029ber_bvstr() returns a BerValue containing the string pointed to by str.  ber_bvstrdup() returns a BerValue containing a copy of the  string  pointed  to  by  str.   ber_str2bv()\u2029returns  a  BerValue  containing the string pointed to by str, whose length may be optionally specified in len.  If dup is non-zero, the BerValue will contain a copy of str.  If\u2029len is zero, the number of bytes to copy will be determined by strlen(3), otherwise len bytes will be copied.  If bv is  non-NULL,  the  result  will  be  stored  in  the  given\u2029BerValue, otherwise a new BerValue will be allocated to store the result.  NOTE: Both ber_bvstr() and ber_bvstrdup() are implemented as macros using ber_str2bv() in this version\u2029of the library.\u2029\u2029BerElement is an opaque structure used to maintain state information used in encoding and  decoding.   ber_alloc_t()  is  used  to  create  an  empty  BerElement  structure.  If\u2029LBER_USE_DER is specified for the options parameter then data lengths for data written to the BerElement will be encoded in the minimal number of octets required, otherwise they\u2029will always be written as four byte values.  ber_init() creates a BerElement structure that is initialized with a copy of the data in its bv parameter.  ber_init2()  initializes\u2029an  existing  BerElement ber using the data in the bv parameter. The data is referenced directly, not copied. The options parameter is the same as for ber_alloc_t().  ber_free()\u2029frees a BerElement pointed to by ber.  If ber is NULL, the routine does nothing.  If freebuf is zero, the internal buffer is not freed.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-decode(3), lber-memory(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 837, "position": [26682, 32348], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ber_int_t,  ber_uint_t,  ber_len_t,  ber_slen_t,  ber_tag_t,  struct  berval, BerValue, BerVarray, BerElement, ber_bvfree, ber_bvecfree, ber_bvecadd, ber_bvarray_free, ber_bvar\u2010\u2029ray_add, ber_bvdup, ber_dupbv, ber_bvstr, ber_bvstrdup, ber_str2bv, ber_alloc_t, ber_init, ber_init2, ber_free - OpenLDAP LBER types and allocation functions\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029typedef impl_tag_t ber_tag_t;\u2029typedef impl_int_t ber_int_t;\u2029typedef impl_uint_t ber_uint_t;\u2029typedef impl_len_t ber_len_t;\u2029typedef impl_slen_t ber_slen_t;\u2029\u2029typedef struct berval {\u2029ber_len_t bv_len;\u2029char *bv_val;\u2029} BerValue, *BerVarray;\u2029\u2029typedef struct berelement BerElement;\u2029\u2029void ber_bvfree(struct berval *bv);\u2029\u2029void ber_bvecfree(struct berval **bvec);\u2029\u2029void ber_bvecadd(struct berval ***bvec, struct berval *bv);\u2029\u2029void ber_bvarray_free(struct berval *bvarray);\u2029\u2029void ber_bvarray_add(BerVarray *bvarray, BerValue *bv);\u2029\u2029struct berval *ber_bvdup(const struct berval *bv);\u2029\u2029struct berval *ber_dupbv(const struct berval *dst, struct berval *src);\u2029\u2029struct berval *ber_bvstr(const char *str);\u2029\u2029struct berval *ber_bvstrdup(const char *str);\u2029\u2029struct berval *ber_str2bv(const char *str, ber_len_t len, int dup, struct berval *bv);\u2029\u2029BerElement *ber_alloc_t(int options);\u2029\u2029BerElement *ber_init(struct berval *bv);\u2029\u2029void ber_init2(BerElement *ber, struct berval *bv, int options);\u2029\u2029void ber_free(BerElement *ber, int freebuf);\u2029\u2029DESCRIPTION\u2029The following are the basic types and structures defined for use with the Lightweight BER library.\u2029\u2029ber_int_t is a signed integer of at least 32 bits.  It is commonly equivalent to int.  ber_uint_t is the unsigned variant of ber_int_t.\u2029\u2029ber_len_t is an unsigned integer of at least 32 bits used to represent a length.  It is commonly equivalent to a size_t.  ber_slen_t is the signed variant to ber_len_t.\u2029\u2029ber_tag_t is an unsigned integer of at least 32 bits used to represent a BER tag.  It is commonly equivalent to a unsigned long.\u2029\u2029The actual definitions of the integral impl_TYPE_t types are platform specific.\u2029\u2029BerValue, commonly used as struct berval, is used to hold an arbitrary sequence of octets.  bv_val points to bv_len octets.  bv_val is  not  necessarily  terminated  by  a  NULL\u2029(zero) octet.  ber_bvfree() frees a BerValue, pointed to by bv, returned from this API.  If bv is NULL, the routine does nothing.\u2029\u2029ber_bvecfree() frees an array of BerValues (and the array), pointed to by bvec, returned from this API.  If bvec is NULL, the routine does nothing.  ber_bvecadd() appends the bv\u2029pointer to the bvec array.  Space for the array is allocated as needed.  The end of the array is marked by a NULL pointer.\u2029\u2029ber_bvarray_free() frees an array of BerValues (and the array), pointed to by bvarray, returned from this API.  If bvarray is NULL, the routine does nothing.   ber_bvarray_add()\u2029appends the contents of the BerValue pointed to by bv to the bvarray array.  Space for the new element is allocated as needed.  The end of the array is marked by a BerValue with\u2029a NULL bv_val field.\u2029\u2029ber_bvdup() returns a copy of a BerValue.  The routine returns NULL upon error (e.g. out of memory).  The caller should use ber_bvfree() to deallocate  the  resulting  BerValue.\u2029ber_dupbv()  copies  a  BerValue from src to dst.  If dst is NULL a new BerValue will be allocated to hold the copy.  The routine returns NULL upon error, otherwise it returns a\u2029pointer to the copy.  If dst is NULL the caller should use ber_bvfree() to deallocate  the  resulting  BerValue,  otherwise  ber_memfree()  should  be  used  to  deallocate  the\u2029dst-&amp;gt;bv_val.   (The  ber_bvdup()  function  is internally implemented as ber_dupbv(NULL, bv).  ber_bvdup() is provided only for compatibility with an expired draft of the LDAP C\u2029API; ber_dupbv() is the preferred interface.)\u2029\u2029ber_bvstr() returns a BerValue containing the string pointed to by str.  ber_bvstrdup() returns a BerValue containing a copy of the  string  pointed  to  by  str.   ber_str2bv()\u2029returns  a  BerValue  containing the string pointed to by str, whose length may be optionally specified in len.  If dup is non-zero, the BerValue will contain a copy of str.  If\u2029len is zero, the number of bytes to copy will be determined by strlen(3), otherwise len bytes will be copied.  If bv is  non-NULL,  the  result  will  be  stored  in  the  given\u2029BerValue, otherwise a new BerValue will be allocated to store the result.  NOTE: Both ber_bvstr() and ber_bvstrdup() are implemented as macros using ber_str2bv() in this version\u2029of the library.\u2029\u2029BerElement is an opaque structure used to maintain state information used in encoding and  decoding.   ber_alloc_t()  is  used  to  create  an  empty  BerElement  structure.  If\u2029LBER_USE_DER is specified for the options parameter then data lengths for data written to the BerElement will be encoded in the minimal number of octets required, otherwise they\u2029will always be written as four byte values.  ber_init() creates a BerElement structure that is initialized with a copy of the data in its bv parameter.  ber_init2()  initializes\u2029an  existing  BerElement ber using the data in the bv parameter. The data is referenced directly, not copied. The options parameter is the same as for ber_alloc_t().  ber_free()\u2029frees a BerElement pointed to by ber.  If ber is NULL, the routine does nothing.  If freebuf is zero, the internal buffer is not freed.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-decode(3), lber-memory(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 836, "position": [20643, 26309], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ber_int_t,  ber_uint_t,  ber_len_t,  ber_slen_t,  ber_tag_t,  struct  berval, BerValue, BerVarray, BerElement, ber_bvfree, ber_bvecfree, ber_bvecadd, ber_bvarray_free, ber_bvar\u2010\u2029ray_add, ber_bvdup, ber_dupbv, ber_bvstr, ber_bvstrdup, ber_str2bv, ber_alloc_t, ber_init, ber_init2, ber_free - OpenLDAP LBER types and allocation functions\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029typedef impl_tag_t ber_tag_t;\u2029typedef impl_int_t ber_int_t;\u2029typedef impl_uint_t ber_uint_t;\u2029typedef impl_len_t ber_len_t;\u2029typedef impl_slen_t ber_slen_t;\u2029\u2029typedef struct berval {\u2029ber_len_t bv_len;\u2029char *bv_val;\u2029} BerValue, *BerVarray;\u2029\u2029typedef struct berelement BerElement;\u2029\u2029void ber_bvfree(struct berval *bv);\u2029\u2029void ber_bvecfree(struct berval **bvec);\u2029\u2029void ber_bvecadd(struct berval ***bvec, struct berval *bv);\u2029\u2029void ber_bvarray_free(struct berval *bvarray);\u2029\u2029void ber_bvarray_add(BerVarray *bvarray, BerValue *bv);\u2029\u2029struct berval *ber_bvdup(const struct berval *bv);\u2029\u2029struct berval *ber_dupbv(const struct berval *dst, struct berval *src);\u2029\u2029struct berval *ber_bvstr(const char *str);\u2029\u2029struct berval *ber_bvstrdup(const char *str);\u2029\u2029struct berval *ber_str2bv(const char *str, ber_len_t len, int dup, struct berval *bv);\u2029\u2029BerElement *ber_alloc_t(int options);\u2029\u2029BerElement *ber_init(struct berval *bv);\u2029\u2029void ber_init2(BerElement *ber, struct berval *bv, int options);\u2029\u2029void ber_free(BerElement *ber, int freebuf);\u2029\u2029DESCRIPTION\u2029The following are the basic types and structures defined for use with the Lightweight BER library.\u2029\u2029ber_int_t is a signed integer of at least 32 bits.  It is commonly equivalent to int.  ber_uint_t is the unsigned variant of ber_int_t.\u2029\u2029ber_len_t is an unsigned integer of at least 32 bits used to represent a length.  It is commonly equivalent to a size_t.  ber_slen_t is the signed variant to ber_len_t.\u2029\u2029ber_tag_t is an unsigned integer of at least 32 bits used to represent a BER tag.  It is commonly equivalent to a unsigned long.\u2029\u2029The actual definitions of the integral impl_TYPE_t types are platform specific.\u2029\u2029BerValue, commonly used as struct berval, is used to hold an arbitrary sequence of octets.  bv_val points to bv_len octets.  bv_val is  not  necessarily  terminated  by  a  NULL\u2029(zero) octet.  ber_bvfree() frees a BerValue, pointed to by bv, returned from this API.  If bv is NULL, the routine does nothing.\u2029\u2029ber_bvecfree() frees an array of BerValues (and the array), pointed to by bvec, returned from this API.  If bvec is NULL, the routine does nothing.  ber_bvecadd() appends the bv\u2029pointer to the bvec array.  Space for the array is allocated as needed.  The end of the array is marked by a NULL pointer.\u2029\u2029ber_bvarray_free() frees an array of BerValues (and the array), pointed to by bvarray, returned from this API.  If bvarray is NULL, the routine does nothing.   ber_bvarray_add()\u2029appends the contents of the BerValue pointed to by bv to the bvarray array.  Space for the new element is allocated as needed.  The end of the array is marked by a BerValue with\u2029a NULL bv_val field.\u2029\u2029ber_bvdup() returns a copy of a BerValue.  The routine returns NULL upon error (e.g. out of memory).  The caller should use ber_bvfree() to deallocate  the  resulting  BerValue.\u2029ber_dupbv()  copies  a  BerValue from src to dst.  If dst is NULL a new BerValue will be allocated to hold the copy.  The routine returns NULL upon error, otherwise it returns a\u2029pointer to the copy.  If dst is NULL the caller should use ber_bvfree() to deallocate  the  resulting  BerValue,  otherwise  ber_memfree()  should  be  used  to  deallocate  the\u2029dst-&amp;gt;bv_val.   (The  ber_bvdup()  function  is internally implemented as ber_dupbv(NULL, bv).  ber_bvdup() is provided only for compatibility with an expired draft of the LDAP C\u2029API; ber_dupbv() is the preferred interface.)\u2029\u2029ber_bvstr() returns a BerValue containing the string pointed to by str.  ber_bvstrdup() returns a BerValue containing a copy of the  string  pointed  to  by  str.   ber_str2bv()\u2029returns  a  BerValue  containing the string pointed to by str, whose length may be optionally specified in len.  If dup is non-zero, the BerValue will contain a copy of str.  If\u2029len is zero, the number of bytes to copy will be determined by strlen(3), otherwise len bytes will be copied.  If bv is  non-NULL,  the  result  will  be  stored  in  the  given\u2029BerValue, otherwise a new BerValue will be allocated to store the result.  NOTE: Both ber_bvstr() and ber_bvstrdup() are implemented as macros using ber_str2bv() in this version\u2029of the library.\u2029\u2029BerElement is an opaque structure used to maintain state information used in encoding and  decoding.   ber_alloc_t()  is  used  to  create  an  empty  BerElement  structure.  If\u2029LBER_USE_DER is specified for the options parameter then data lengths for data written to the BerElement will be encoded in the minimal number of octets required, otherwise they\u2029will always be written as four byte values.  ber_init() creates a BerElement structure that is initialized with a copy of the data in its bv parameter.  ber_init2()  initializes\u2029an  existing  BerElement ber using the data in the bv parameter. The data is referenced directly, not copied. The options parameter is the same as for ber_alloc_t().  ber_free()\u2029frees a BerElement pointed to by ber.  If ber is NULL, the routine does nothing.  If freebuf is zero, the internal buffer is not freed.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-decode(3), lber-memory(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 835, "position": [14604, 20270], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ber_int_t,  ber_uint_t,  ber_len_t,  ber_slen_t,  ber_tag_t,  struct  berval, BerValue, BerVarray, BerElement, ber_bvfree, ber_bvecfree, ber_bvecadd, ber_bvarray_free, ber_bvar\u2010\u2029ray_add, ber_bvdup, ber_dupbv, ber_bvstr, ber_bvstrdup, ber_str2bv, ber_alloc_t, ber_init, ber_init2, ber_free - OpenLDAP LBER types and allocation functions\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029typedef impl_tag_t ber_tag_t;\u2029typedef impl_int_t ber_int_t;\u2029typedef impl_uint_t ber_uint_t;\u2029typedef impl_len_t ber_len_t;\u2029typedef impl_slen_t ber_slen_t;\u2029\u2029typedef struct berval {\u2029ber_len_t bv_len;\u2029char *bv_val;\u2029} BerValue, *BerVarray;\u2029\u2029typedef struct berelement BerElement;\u2029\u2029void ber_bvfree(struct berval *bv);\u2029\u2029void ber_bvecfree(struct berval **bvec);\u2029\u2029void ber_bvecadd(struct berval ***bvec, struct berval *bv);\u2029\u2029void ber_bvarray_free(struct berval *bvarray);\u2029\u2029void ber_bvarray_add(BerVarray *bvarray, BerValue *bv);\u2029\u2029struct berval *ber_bvdup(const struct berval *bv);\u2029\u2029struct berval *ber_dupbv(const struct berval *dst, struct berval *src);\u2029\u2029struct berval *ber_bvstr(const char *str);\u2029\u2029struct berval *ber_bvstrdup(const char *str);\u2029\u2029struct berval *ber_str2bv(const char *str, ber_len_t len, int dup, struct berval *bv);\u2029\u2029BerElement *ber_alloc_t(int options);\u2029\u2029BerElement *ber_init(struct berval *bv);\u2029\u2029void ber_init2(BerElement *ber, struct berval *bv, int options);\u2029\u2029void ber_free(BerElement *ber, int freebuf);\u2029\u2029DESCRIPTION\u2029The following are the basic types and structures defined for use with the Lightweight BER library.\u2029\u2029ber_int_t is a signed integer of at least 32 bits.  It is commonly equivalent to int.  ber_uint_t is the unsigned variant of ber_int_t.\u2029\u2029ber_len_t is an unsigned integer of at least 32 bits used to represent a length.  It is commonly equivalent to a size_t.  ber_slen_t is the signed variant to ber_len_t.\u2029\u2029ber_tag_t is an unsigned integer of at least 32 bits used to represent a BER tag.  It is commonly equivalent to a unsigned long.\u2029\u2029The actual definitions of the integral impl_TYPE_t types are platform specific.\u2029\u2029BerValue, commonly used as struct berval, is used to hold an arbitrary sequence of octets.  bv_val points to bv_len octets.  bv_val is  not  necessarily  terminated  by  a  NULL\u2029(zero) octet.  ber_bvfree() frees a BerValue, pointed to by bv, returned from this API.  If bv is NULL, the routine does nothing.\u2029\u2029ber_bvecfree() frees an array of BerValues (and the array), pointed to by bvec, returned from this API.  If bvec is NULL, the routine does nothing.  ber_bvecadd() appends the bv\u2029pointer to the bvec array.  Space for the array is allocated as needed.  The end of the array is marked by a NULL pointer.\u2029\u2029ber_bvarray_free() frees an array of BerValues (and the array), pointed to by bvarray, returned from this API.  If bvarray is NULL, the routine does nothing.   ber_bvarray_add()\u2029appends the contents of the BerValue pointed to by bv to the bvarray array.  Space for the new element is allocated as needed.  The end of the array is marked by a BerValue with\u2029a NULL bv_val field.\u2029\u2029ber_bvdup() returns a copy of a BerValue.  The routine returns NULL upon error (e.g. out of memory).  The caller should use ber_bvfree() to deallocate  the  resulting  BerValue.\u2029ber_dupbv()  copies  a  BerValue from src to dst.  If dst is NULL a new BerValue will be allocated to hold the copy.  The routine returns NULL upon error, otherwise it returns a\u2029pointer to the copy.  If dst is NULL the caller should use ber_bvfree() to deallocate  the  resulting  BerValue,  otherwise  ber_memfree()  should  be  used  to  deallocate  the\u2029dst-&amp;gt;bv_val.   (The  ber_bvdup()  function  is internally implemented as ber_dupbv(NULL, bv).  ber_bvdup() is provided only for compatibility with an expired draft of the LDAP C\u2029API; ber_dupbv() is the preferred interface.)\u2029\u2029ber_bvstr() returns a BerValue containing the string pointed to by str.  ber_bvstrdup() returns a BerValue containing a copy of the  string  pointed  to  by  str.   ber_str2bv()\u2029returns  a  BerValue  containing the string pointed to by str, whose length may be optionally specified in len.  If dup is non-zero, the BerValue will contain a copy of str.  If\u2029len is zero, the number of bytes to copy will be determined by strlen(3), otherwise len bytes will be copied.  If bv is  non-NULL,  the  result  will  be  stored  in  the  given\u2029BerValue, otherwise a new BerValue will be allocated to store the result.  NOTE: Both ber_bvstr() and ber_bvstrdup() are implemented as macros using ber_str2bv() in this version\u2029of the library.\u2029\u2029BerElement is an opaque structure used to maintain state information used in encoding and  decoding.   ber_alloc_t()  is  used  to  create  an  empty  BerElement  structure.  If\u2029LBER_USE_DER is specified for the options parameter then data lengths for data written to the BerElement will be encoded in the minimal number of octets required, otherwise they\u2029will always be written as four byte values.  ber_init() creates a BerElement structure that is initialized with a copy of the data in its bv parameter.  ber_init2()  initializes\u2029an  existing  BerElement ber using the data in the bv parameter. The data is referenced directly, not copied. The options parameter is the same as for ber_alloc_t().  ber_free()\u2029frees a BerElement pointed to by ber.  If ber is NULL, the routine does nothing.  If freebuf is zero, the internal buffer is not freed.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-decode(3), lber-memory(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 835, "position": [8565, 14231], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "44", "annotation": "LBER_DECODE", "group_ids": [{"name2": "NAME\u2029ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool\u2010\u2029ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);\u2029\u2029ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);\u2029\u2029ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);\u2029\u2029ber_tag_t ber_get_stringa(BerElement *ber, char **buf);\u2029\u2029ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);\u2029\u2029ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);\u2029\u2029ber_tag_t ber_get_null(BerElement *ber);\u2029\u2029ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);\u2029\u2029ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);\u2029\u2029ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);\u2029\u2029ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.\u2029\u2029The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the\u2029entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb\u2029parameter.\u2029\u2029The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by\u2029ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica\u2010\u2029tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.\u2029\u2029a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().\u2029\u2029A  Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().\u2029\u2029s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet\u2029string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.\u2029\u2029O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().\u2029\u2029o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().\u2029\u2029m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle\u2010\u2029ment, and must not be freed by the caller.\u2029\u2029b  Boolean.  A pointer to a ber_int_t should be supplied.\u2029\u2029e  Enumeration.  A pointer to a ber_int_t should be supplied.\u2029\u2029i  Integer.  A pointer to a ber_int_t should be supplied.\u2029\u2029B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the\u2029bitstring returned.\u2029\u2029n  Null.  No parameter is required.  The element is simply skipped if it is recognized.\u2029\u2029v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().\u2029\u2029V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().\u2029\u2029W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().\u2029\u2029M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().\u2029\u2029l  Length of the next element.  A pointer to a ber_len_t should be supplied.\u2029\u2029t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.\u2029\u2029T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.\u2029\u2029x  Skip element.  The next element is skipped.\u2029\u2029{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.\u2029\u2029}  End sequence.  No parameter is required and no action is taken.\u2029\u2029[  Begin set.  No parameter is required.  The initial set tag and length are skipped.\u2029\u2029]  End set.  No parameter is required and no action is taken.\u2029\u2029The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)\u2029on failure.\u2029\u2029The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain\u2029the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.\u2029\u2029The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().\u2029\u2029The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory\u2029assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be\u2029returned using ber_memfree().\u2029\u2029The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.\u2029\u2029The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will\u2029point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should\u2029be passed to subsequent calls to ber_next_element(), which returns similar information.\u2029\u2029EXAMPLES\u2029Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029The element can be decoded using ber_scanf() as follows.\u2029\u2029ber_int_t    scope, deref, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029ber_tag_t tag;\u2029\u2029tag = ber_scanf( ber, \"{aeeiib{v}}\",\u2029&amp;dn, &amp;scope, &amp;deref,\u2029&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );\u2029\u2029if( tag == LBER_ERROR ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ber_memfree( dn );\u2029ber_memvfree( attrs );\u2029\u2029ERRORS\u2029If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 859, "position": [311788, 323223], "check": 1, "intersection": 11436, "FP_dupl": 14743, "FN_dupl": 0, "F": 0.6080552970889274, "Prec_Dupl": 0.43683868749761257, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool\u2010\u2029ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);\u2029\u2029ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);\u2029\u2029ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);\u2029\u2029ber_tag_t ber_get_stringa(BerElement *ber, char **buf);\u2029\u2029ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);\u2029\u2029ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);\u2029\u2029ber_tag_t ber_get_null(BerElement *ber);\u2029\u2029ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);\u2029\u2029ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);\u2029\u2029ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);\u2029\u2029ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.\u2029\u2029The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the\u2029entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb\u2029parameter.\u2029\u2029The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by\u2029ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica\u2010\u2029tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.\u2029\u2029a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().\u2029\u2029A  Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().\u2029\u2029s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet\u2029string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.\u2029\u2029O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().\u2029\u2029o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().\u2029\u2029m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle\u2010\u2029ment, and must not be freed by the caller.\u2029\u2029b  Boolean.  A pointer to a ber_int_t should be supplied.\u2029\u2029e  Enumeration.  A pointer to a ber_int_t should be supplied.\u2029\u2029i  Integer.  A pointer to a ber_int_t should be supplied.\u2029\u2029B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the\u2029bitstring returned.\u2029\u2029n  Null.  No parameter is required.  The element is simply skipped if it is recognized.\u2029\u2029v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().\u2029\u2029V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().\u2029\u2029W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().\u2029\u2029M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().\u2029\u2029l  Length of the next element.  A pointer to a ber_len_t should be supplied.\u2029\u2029t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.\u2029\u2029T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.\u2029\u2029x  Skip element.  The next element is skipped.\u2029\u2029{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.\u2029\u2029}  End sequence.  No parameter is required and no action is taken.\u2029\u2029[  Begin set.  No parameter is required.  The initial set tag and length are skipped.\u2029\u2029]  End set.  No parameter is required and no action is taken.\u2029\u2029The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)\u2029on failure.\u2029\u2029The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain\u2029the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.\u2029\u2029The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().\u2029\u2029The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory\u2029assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be\u2029returned using ber_memfree().\u2029\u2029The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.\u2029\u2029The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will\u2029point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should\u2029be passed to subsequent calls to ber_next_element(), which returns similar information.\u2029\u2029EXAMPLES\u2029Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029The element can be decoded using ber_scanf() as follows.\u2029\u2029ber_int_t    scope, deref, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029ber_tag_t tag;\u2029\u2029tag = ber_scanf( ber, \"{aeeiib{v}}\",\u2029&amp;dn, &amp;scope, &amp;deref,\u2029&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );\u2029\u2029if( tag == LBER_ERROR ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ber_memfree( dn );\u2029ber_memvfree( attrs );\u2029\u2029ERRORS\u2029If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 858, "position": [285612, 297047], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool\u2010\u2029ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);\u2029\u2029ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);\u2029\u2029ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);\u2029\u2029ber_tag_t ber_get_stringa(BerElement *ber, char **buf);\u2029\u2029ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);\u2029\u2029ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);\u2029\u2029ber_tag_t ber_get_null(BerElement *ber);\u2029\u2029ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);\u2029\u2029ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);\u2029\u2029ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);\u2029\u2029ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.\u2029\u2029The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the\u2029entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb\u2029parameter.\u2029\u2029The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by\u2029ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica\u2010\u2029tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.\u2029\u2029a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().\u2029\u2029A  Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().\u2029\u2029s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet\u2029string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.\u2029\u2029O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().\u2029\u2029o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().\u2029\u2029m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle\u2010\u2029ment, and must not be freed by the caller.\u2029\u2029b  Boolean.  A pointer to a ber_int_t should be supplied.\u2029\u2029e  Enumeration.  A pointer to a ber_int_t should be supplied.\u2029\u2029i  Integer.  A pointer to a ber_int_t should be supplied.\u2029\u2029B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the\u2029bitstring returned.\u2029\u2029n  Null.  No parameter is required.  The element is simply skipped if it is recognized.\u2029\u2029v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().\u2029\u2029V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().\u2029\u2029W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().\u2029\u2029M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().\u2029\u2029l  Length of the next element.  A pointer to a ber_len_t should be supplied.\u2029\u2029t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.\u2029\u2029T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.\u2029\u2029x  Skip element.  The next element is skipped.\u2029\u2029{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.\u2029\u2029}  End sequence.  No parameter is required and no action is taken.\u2029\u2029[  Begin set.  No parameter is required.  The initial set tag and length are skipped.\u2029\u2029]  End set.  No parameter is required and no action is taken.\u2029\u2029The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)\u2029on failure.\u2029\u2029The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain\u2029the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.\u2029\u2029The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().\u2029\u2029The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory\u2029assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be\u2029returned using ber_memfree().\u2029\u2029The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.\u2029\u2029The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will\u2029point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should\u2029be passed to subsequent calls to ber_next_element(), which returns similar information.\u2029\u2029EXAMPLES\u2029Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029The element can be decoded using ber_scanf() as follows.\u2029\u2029ber_int_t    scope, deref, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029ber_tag_t tag;\u2029\u2029tag = ber_scanf( ber, \"{aeeiib{v}}\",\u2029&amp;dn, &amp;scope, &amp;deref,\u2029&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );\u2029\u2029if( tag == LBER_ERROR ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ber_memfree( dn );\u2029ber_memvfree( attrs );\u2029\u2029ERRORS\u2029If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 857, "position": [273804, 285239], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool\u2010\u2029ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);\u2029\u2029ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);\u2029\u2029ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);\u2029\u2029ber_tag_t ber_get_stringa(BerElement *ber, char **buf);\u2029\u2029ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);\u2029\u2029ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);\u2029\u2029ber_tag_t ber_get_null(BerElement *ber);\u2029\u2029ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);\u2029\u2029ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);\u2029\u2029ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);\u2029\u2029ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.\u2029\u2029The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the\u2029entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb\u2029parameter.\u2029\u2029The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by\u2029ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica\u2010\u2029tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.\u2029\u2029a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().\u2029\u2029A  Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().\u2029\u2029s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet\u2029string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.\u2029\u2029O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().\u2029\u2029o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().\u2029\u2029m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle\u2010\u2029ment, and must not be freed by the caller.\u2029\u2029b  Boolean.  A pointer to a ber_int_t should be supplied.\u2029\u2029e  Enumeration.  A pointer to a ber_int_t should be supplied.\u2029\u2029i  Integer.  A pointer to a ber_int_t should be supplied.\u2029\u2029B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the\u2029bitstring returned.\u2029\u2029n  Null.  No parameter is required.  The element is simply skipped if it is recognized.\u2029\u2029v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().\u2029\u2029V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().\u2029\u2029W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().\u2029\u2029M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().\u2029\u2029l  Length of the next element.  A pointer to a ber_len_t should be supplied.\u2029\u2029t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.\u2029\u2029T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.\u2029\u2029x  Skip element.  The next element is skipped.\u2029\u2029{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.\u2029\u2029}  End sequence.  No parameter is required and no action is taken.\u2029\u2029[  Begin set.  No parameter is required.  The initial set tag and length are skipped.\u2029\u2029]  End set.  No parameter is required and no action is taken.\u2029\u2029The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)\u2029on failure.\u2029\u2029The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain\u2029the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.\u2029\u2029The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().\u2029\u2029The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory\u2029assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be\u2029returned using ber_memfree().\u2029\u2029The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.\u2029\u2029The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will\u2029point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should\u2029be passed to subsequent calls to ber_next_element(), which returns similar information.\u2029\u2029EXAMPLES\u2029Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029The element can be decoded using ber_scanf() as follows.\u2029\u2029ber_int_t    scope, deref, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029ber_tag_t tag;\u2029\u2029tag = ber_scanf( ber, \"{aeeiib{v}}\",\u2029&amp;dn, &amp;scope, &amp;deref,\u2029&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );\u2029\u2029if( tag == LBER_ERROR ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ber_memfree( dn );\u2029ber_memvfree( attrs );\u2029\u2029ERRORS\u2029If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 856, "position": [195364, 206799], "check": 1, "intersection": 11436, "FP_dupl": 35799, "FN_dupl": 0, "F": 0.38983484174464383, "Prec_Dupl": 0.24210860590663702, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool\u2010\u2029ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);\u2029\u2029ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);\u2029\u2029ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);\u2029\u2029ber_tag_t ber_get_stringa(BerElement *ber, char **buf);\u2029\u2029ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);\u2029\u2029ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);\u2029\u2029ber_tag_t ber_get_null(BerElement *ber);\u2029\u2029ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);\u2029\u2029ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);\u2029\u2029ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);\u2029\u2029ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.\u2029\u2029The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the\u2029entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb\u2029parameter.\u2029\u2029The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by\u2029ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica\u2010\u2029tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.\u2029\u2029a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().\u2029\u2029A  Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().\u2029\u2029s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet\u2029string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.\u2029\u2029O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().\u2029\u2029o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().\u2029\u2029m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle\u2010\u2029ment, and must not be freed by the caller.\u2029\u2029b  Boolean.  A pointer to a ber_int_t should be supplied.\u2029\u2029e  Enumeration.  A pointer to a ber_int_t should be supplied.\u2029\u2029i  Integer.  A pointer to a ber_int_t should be supplied.\u2029\u2029B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the\u2029bitstring returned.\u2029\u2029n  Null.  No parameter is required.  The element is simply skipped if it is recognized.\u2029\u2029v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().\u2029\u2029V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().\u2029\u2029W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().\u2029\u2029M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().\u2029\u2029l  Length of the next element.  A pointer to a ber_len_t should be supplied.\u2029\u2029t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.\u2029\u2029T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.\u2029\u2029x  Skip element.  The next element is skipped.\u2029\u2029{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.\u2029\u2029}  End sequence.  No parameter is required and no action is taken.\u2029\u2029[  Begin set.  No parameter is required.  The initial set tag and length are skipped.\u2029\u2029]  End set.  No parameter is required and no action is taken.\u2029\u2029The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)\u2029on failure.\u2029\u2029The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain\u2029the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.\u2029\u2029The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().\u2029\u2029The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory\u2029assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be\u2029returned using ber_memfree().\u2029\u2029The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.\u2029\u2029The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will\u2029point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should\u2029be passed to subsequent calls to ber_next_element(), which returns similar information.\u2029\u2029EXAMPLES\u2029Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029The element can be decoded using ber_scanf() as follows.\u2029\u2029ber_int_t    scope, deref, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029ber_tag_t tag;\u2029\u2029tag = ber_scanf( ber, \"{aeeiib{v}}\",\u2029&amp;dn, &amp;scope, &amp;deref,\u2029&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );\u2029\u2029if( tag == LBER_ERROR ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ber_memfree( dn );\u2029ber_memvfree( attrs );\u2029\u2029ERRORS\u2029If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 855, "position": [183556, 194991], "check": 1, "intersection": 11436, "FP_dupl": 35799, "FN_dupl": 0, "F": 0.38983484174464383, "Prec_Dupl": 0.24210860590663702, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool\u2010\u2029ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);\u2029\u2029ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);\u2029\u2029ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);\u2029\u2029ber_tag_t ber_get_stringa(BerElement *ber, char **buf);\u2029\u2029ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);\u2029\u2029ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);\u2029\u2029ber_tag_t ber_get_null(BerElement *ber);\u2029\u2029ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);\u2029\u2029ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);\u2029\u2029ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);\u2029\u2029ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.\u2029\u2029The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the\u2029entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb\u2029parameter.\u2029\u2029The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by\u2029ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica\u2010\u2029tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.\u2029\u2029a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().\u2029\u2029A  Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().\u2029\u2029s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet\u2029string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.\u2029\u2029O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().\u2029\u2029o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().\u2029\u2029m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle\u2010\u2029ment, and must not be freed by the caller.\u2029\u2029b  Boolean.  A pointer to a ber_int_t should be supplied.\u2029\u2029e  Enumeration.  A pointer to a ber_int_t should be supplied.\u2029\u2029i  Integer.  A pointer to a ber_int_t should be supplied.\u2029\u2029B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the\u2029bitstring returned.\u2029\u2029n  Null.  No parameter is required.  The element is simply skipped if it is recognized.\u2029\u2029v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().\u2029\u2029V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().\u2029\u2029W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().\u2029\u2029M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().\u2029\u2029l  Length of the next element.  A pointer to a ber_len_t should be supplied.\u2029\u2029t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.\u2029\u2029T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.\u2029\u2029x  Skip element.  The next element is skipped.\u2029\u2029{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.\u2029\u2029}  End sequence.  No parameter is required and no action is taken.\u2029\u2029[  Begin set.  No parameter is required.  The initial set tag and length are skipped.\u2029\u2029]  End set.  No parameter is required and no action is taken.\u2029\u2029The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)\u2029on failure.\u2029\u2029The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain\u2029the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.\u2029\u2029The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().\u2029\u2029The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory\u2029assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be\u2029returned using ber_memfree().\u2029\u2029The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.\u2029\u2029The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will\u2029point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should\u2029be passed to subsequent calls to ber_next_element(), which returns similar information.\u2029\u2029EXAMPLES\u2029Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029The element can be decoded using ber_scanf() as follows.\u2029\u2029ber_int_t    scope, deref, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029ber_tag_t tag;\u2029\u2029tag = ber_scanf( ber, \"{aeeiib{v}}\",\u2029&amp;dn, &amp;scope, &amp;deref,\u2029&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );\u2029\u2029if( tag == LBER_ERROR ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ber_memfree( dn );\u2029ber_memvfree( attrs );\u2029\u2029ERRORS\u2029If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 854, "position": [171748, 183183], "check": 1, "intersection": 11436, "FP_dupl": 35799, "FN_dupl": 0, "F": 0.38983484174464383, "Prec_Dupl": 0.24210860590663702, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool\u2010\u2029ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);\u2029\u2029ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);\u2029\u2029ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);\u2029\u2029ber_tag_t ber_get_stringa(BerElement *ber, char **buf);\u2029\u2029ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);\u2029\u2029ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);\u2029\u2029ber_tag_t ber_get_null(BerElement *ber);\u2029\u2029ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);\u2029\u2029ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);\u2029\u2029ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);\u2029\u2029ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.\u2029\u2029The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the\u2029entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb\u2029parameter.\u2029\u2029The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by\u2029ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica\u2010\u2029tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.\u2029\u2029a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().\u2029\u2029A  Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().\u2029\u2029s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet\u2029string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.\u2029\u2029O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().\u2029\u2029o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().\u2029\u2029m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle\u2010\u2029ment, and must not be freed by the caller.\u2029\u2029b  Boolean.  A pointer to a ber_int_t should be supplied.\u2029\u2029e  Enumeration.  A pointer to a ber_int_t should be supplied.\u2029\u2029i  Integer.  A pointer to a ber_int_t should be supplied.\u2029\u2029B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the\u2029bitstring returned.\u2029\u2029n  Null.  No parameter is required.  The element is simply skipped if it is recognized.\u2029\u2029v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().\u2029\u2029V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().\u2029\u2029W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().\u2029\u2029M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().\u2029\u2029l  Length of the next element.  A pointer to a ber_len_t should be supplied.\u2029\u2029t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.\u2029\u2029T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.\u2029\u2029x  Skip element.  The next element is skipped.\u2029\u2029{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.\u2029\u2029}  End sequence.  No parameter is required and no action is taken.\u2029\u2029[  Begin set.  No parameter is required.  The initial set tag and length are skipped.\u2029\u2029]  End set.  No parameter is required and no action is taken.\u2029\u2029The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)\u2029on failure.\u2029\u2029The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain\u2029the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.\u2029\u2029The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().\u2029\u2029The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory\u2029assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be\u2029returned using ber_memfree().\u2029\u2029The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.\u2029\u2029The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will\u2029point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should\u2029be passed to subsequent calls to ber_next_element(), which returns similar information.\u2029\u2029EXAMPLES\u2029Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029The element can be decoded using ber_scanf() as follows.\u2029\u2029ber_int_t    scope, deref, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029ber_tag_t tag;\u2029\u2029tag = ber_scanf( ber, \"{aeeiib{v}}\",\u2029&amp;dn, &amp;scope, &amp;deref,\u2029&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );\u2029\u2029if( tag == LBER_ERROR ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ber_memfree( dn );\u2029ber_memvfree( attrs );\u2029\u2029ERRORS\u2029If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 853, "position": [159940, 171375], "check": 1, "intersection": 11436, "FP_dupl": 35799, "FN_dupl": 0, "F": 0.38983484174464383, "Prec_Dupl": 0.24210860590663702, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool\u2010\u2029ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);\u2029\u2029ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);\u2029\u2029ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);\u2029\u2029ber_tag_t ber_get_stringa(BerElement *ber, char **buf);\u2029\u2029ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);\u2029\u2029ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);\u2029\u2029ber_tag_t ber_get_null(BerElement *ber);\u2029\u2029ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);\u2029\u2029ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);\u2029\u2029ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);\u2029\u2029ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.\u2029\u2029The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the\u2029entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb\u2029parameter.\u2029\u2029The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by\u2029ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica\u2010\u2029tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.\u2029\u2029a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().\u2029\u2029A  Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().\u2029\u2029s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet\u2029string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.\u2029\u2029O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().\u2029\u2029o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().\u2029\u2029m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle\u2010\u2029ment, and must not be freed by the caller.\u2029\u2029b  Boolean.  A pointer to a ber_int_t should be supplied.\u2029\u2029e  Enumeration.  A pointer to a ber_int_t should be supplied.\u2029\u2029i  Integer.  A pointer to a ber_int_t should be supplied.\u2029\u2029B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the\u2029bitstring returned.\u2029\u2029n  Null.  No parameter is required.  The element is simply skipped if it is recognized.\u2029\u2029v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().\u2029\u2029V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().\u2029\u2029W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().\u2029\u2029M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().\u2029\u2029l  Length of the next element.  A pointer to a ber_len_t should be supplied.\u2029\u2029t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.\u2029\u2029T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.\u2029\u2029x  Skip element.  The next element is skipped.\u2029\u2029{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.\u2029\u2029}  End sequence.  No parameter is required and no action is taken.\u2029\u2029[  Begin set.  No parameter is required.  The initial set tag and length are skipped.\u2029\u2029]  End set.  No parameter is required and no action is taken.\u2029\u2029The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)\u2029on failure.\u2029\u2029The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain\u2029the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.\u2029\u2029The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().\u2029\u2029The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory\u2029assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be\u2029returned using ber_memfree().\u2029\u2029The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.\u2029\u2029The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will\u2029point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should\u2029be passed to subsequent calls to ber_next_element(), which returns similar information.\u2029\u2029EXAMPLES\u2029Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029The element can be decoded using ber_scanf() as follows.\u2029\u2029ber_int_t    scope, deref, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029ber_tag_t tag;\u2029\u2029tag = ber_scanf( ber, \"{aeeiib{v}}\",\u2029&amp;dn, &amp;scope, &amp;deref,\u2029&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );\u2029\u2029if( tag == LBER_ERROR ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ber_memfree( dn );\u2029ber_memvfree( attrs );\u2029\u2029ERRORS\u2029If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 852, "position": [148132, 159567], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool\u2010\u2029ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);\u2029\u2029ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);\u2029\u2029ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);\u2029\u2029ber_tag_t ber_get_stringa(BerElement *ber, char **buf);\u2029\u2029ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);\u2029\u2029ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);\u2029\u2029ber_tag_t ber_get_null(BerElement *ber);\u2029\u2029ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);\u2029\u2029ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);\u2029\u2029ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);\u2029\u2029ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.\u2029\u2029The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the\u2029entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb\u2029parameter.\u2029\u2029The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by\u2029ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica\u2010\u2029tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.\u2029\u2029a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().\u2029\u2029A  Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().\u2029\u2029s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet\u2029string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.\u2029\u2029O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().\u2029\u2029o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().\u2029\u2029m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle\u2010\u2029ment, and must not be freed by the caller.\u2029\u2029b  Boolean.  A pointer to a ber_int_t should be supplied.\u2029\u2029e  Enumeration.  A pointer to a ber_int_t should be supplied.\u2029\u2029i  Integer.  A pointer to a ber_int_t should be supplied.\u2029\u2029B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the\u2029bitstring returned.\u2029\u2029n  Null.  No parameter is required.  The element is simply skipped if it is recognized.\u2029\u2029v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().\u2029\u2029V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().\u2029\u2029W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().\u2029\u2029M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().\u2029\u2029l  Length of the next element.  A pointer to a ber_len_t should be supplied.\u2029\u2029t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.\u2029\u2029T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.\u2029\u2029x  Skip element.  The next element is skipped.\u2029\u2029{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.\u2029\u2029}  End sequence.  No parameter is required and no action is taken.\u2029\u2029[  Begin set.  No parameter is required.  The initial set tag and length are skipped.\u2029\u2029]  End set.  No parameter is required and no action is taken.\u2029\u2029The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)\u2029on failure.\u2029\u2029The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain\u2029the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.\u2029\u2029The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().\u2029\u2029The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory\u2029assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be\u2029returned using ber_memfree().\u2029\u2029The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.\u2029\u2029The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will\u2029point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should\u2029be passed to subsequent calls to ber_next_element(), which returns similar information.\u2029\u2029EXAMPLES\u2029Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029The element can be decoded using ber_scanf() as follows.\u2029\u2029ber_int_t    scope, deref, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029ber_tag_t tag;\u2029\u2029tag = ber_scanf( ber, \"{aeeiib{v}}\",\u2029&amp;dn, &amp;scope, &amp;deref,\u2029&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );\u2029\u2029if( tag == LBER_ERROR ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ber_memfree( dn );\u2029ber_memvfree( attrs );\u2029\u2029ERRORS\u2029If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 851, "position": [136324, 147759], "check": 1, "intersection": 11436, "FP_dupl": 35799, "FN_dupl": 0, "F": 0.38983484174464383, "Prec_Dupl": 0.24210860590663702, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool\u2010\u2029ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);\u2029\u2029ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);\u2029\u2029ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);\u2029\u2029ber_tag_t ber_get_stringa(BerElement *ber, char **buf);\u2029\u2029ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);\u2029\u2029ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);\u2029\u2029ber_tag_t ber_get_null(BerElement *ber);\u2029\u2029ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);\u2029\u2029ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);\u2029\u2029ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);\u2029\u2029ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.\u2029\u2029The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the\u2029entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb\u2029parameter.\u2029\u2029The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by\u2029ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica\u2010\u2029tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.\u2029\u2029a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().\u2029\u2029A  Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().\u2029\u2029s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet\u2029string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.\u2029\u2029O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().\u2029\u2029o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().\u2029\u2029m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle\u2010\u2029ment, and must not be freed by the caller.\u2029\u2029b  Boolean.  A pointer to a ber_int_t should be supplied.\u2029\u2029e  Enumeration.  A pointer to a ber_int_t should be supplied.\u2029\u2029i  Integer.  A pointer to a ber_int_t should be supplied.\u2029\u2029B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the\u2029bitstring returned.\u2029\u2029n  Null.  No parameter is required.  The element is simply skipped if it is recognized.\u2029\u2029v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().\u2029\u2029V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().\u2029\u2029W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().\u2029\u2029M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().\u2029\u2029l  Length of the next element.  A pointer to a ber_len_t should be supplied.\u2029\u2029t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.\u2029\u2029T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.\u2029\u2029x  Skip element.  The next element is skipped.\u2029\u2029{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.\u2029\u2029}  End sequence.  No parameter is required and no action is taken.\u2029\u2029[  Begin set.  No parameter is required.  The initial set tag and length are skipped.\u2029\u2029]  End set.  No parameter is required and no action is taken.\u2029\u2029The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)\u2029on failure.\u2029\u2029The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain\u2029the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.\u2029\u2029The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().\u2029\u2029The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory\u2029assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be\u2029returned using ber_memfree().\u2029\u2029The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.\u2029\u2029The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will\u2029point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should\u2029be passed to subsequent calls to ber_next_element(), which returns similar information.\u2029\u2029EXAMPLES\u2029Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029The element can be decoded using ber_scanf() as follows.\u2029\u2029ber_int_t    scope, deref, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029ber_tag_t tag;\u2029\u2029tag = ber_scanf( ber, \"{aeeiib{v}}\",\u2029&amp;dn, &amp;scope, &amp;deref,\u2029&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );\u2029\u2029if( tag == LBER_ERROR ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ber_memfree( dn );\u2029ber_memvfree( attrs );\u2029\u2029ERRORS\u2029If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 850, "position": [124516, 135951], "check": 1, "intersection": 11436, "FP_dupl": 35799, "FN_dupl": 0, "F": 0.38983484174464383, "Prec_Dupl": 0.24210860590663702, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool\u2010\u2029ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);\u2029\u2029ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);\u2029\u2029ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);\u2029\u2029ber_tag_t ber_get_stringa(BerElement *ber, char **buf);\u2029\u2029ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);\u2029\u2029ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);\u2029\u2029ber_tag_t ber_get_null(BerElement *ber);\u2029\u2029ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);\u2029\u2029ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);\u2029\u2029ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);\u2029\u2029ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.\u2029\u2029The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the\u2029entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb\u2029parameter.\u2029\u2029The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by\u2029ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica\u2010\u2029tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.\u2029\u2029a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().\u2029\u2029A  Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().\u2029\u2029s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet\u2029string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.\u2029\u2029O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().\u2029\u2029o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().\u2029\u2029m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle\u2010\u2029ment, and must not be freed by the caller.\u2029\u2029b  Boolean.  A pointer to a ber_int_t should be supplied.\u2029\u2029e  Enumeration.  A pointer to a ber_int_t should be supplied.\u2029\u2029i  Integer.  A pointer to a ber_int_t should be supplied.\u2029\u2029B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the\u2029bitstring returned.\u2029\u2029n  Null.  No parameter is required.  The element is simply skipped if it is recognized.\u2029\u2029v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().\u2029\u2029V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().\u2029\u2029W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().\u2029\u2029M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().\u2029\u2029l  Length of the next element.  A pointer to a ber_len_t should be supplied.\u2029\u2029t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.\u2029\u2029T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.\u2029\u2029x  Skip element.  The next element is skipped.\u2029\u2029{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.\u2029\u2029}  End sequence.  No parameter is required and no action is taken.\u2029\u2029[  Begin set.  No parameter is required.  The initial set tag and length are skipped.\u2029\u2029]  End set.  No parameter is required and no action is taken.\u2029\u2029The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)\u2029on failure.\u2029\u2029The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain\u2029the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.\u2029\u2029The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().\u2029\u2029The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory\u2029assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be\u2029returned using ber_memfree().\u2029\u2029The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.\u2029\u2029The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will\u2029point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should\u2029be passed to subsequent calls to ber_next_element(), which returns similar information.\u2029\u2029EXAMPLES\u2029Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029The element can be decoded using ber_scanf() as follows.\u2029\u2029ber_int_t    scope, deref, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029ber_tag_t tag;\u2029\u2029tag = ber_scanf( ber, \"{aeeiib{v}}\",\u2029&amp;dn, &amp;scope, &amp;deref,\u2029&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );\u2029\u2029if( tag == LBER_ERROR ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ber_memfree( dn );\u2029ber_memvfree( attrs );\u2029\u2029ERRORS\u2029If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 849, "position": [112708, 124143], "check": 1, "intersection": 11436, "FP_dupl": 35799, "FN_dupl": 0, "F": 0.38983484174464383, "Prec_Dupl": 0.24210860590663702, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool\u2010\u2029ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);\u2029\u2029ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);\u2029\u2029ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);\u2029\u2029ber_tag_t ber_get_stringa(BerElement *ber, char **buf);\u2029\u2029ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);\u2029\u2029ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);\u2029\u2029ber_tag_t ber_get_null(BerElement *ber);\u2029\u2029ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);\u2029\u2029ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);\u2029\u2029ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);\u2029\u2029ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.\u2029\u2029The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the\u2029entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb\u2029parameter.\u2029\u2029The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by\u2029ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica\u2010\u2029tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.\u2029\u2029a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().\u2029\u2029A  Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().\u2029\u2029s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet\u2029string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.\u2029\u2029O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().\u2029\u2029o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().\u2029\u2029m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle\u2010\u2029ment, and must not be freed by the caller.\u2029\u2029b  Boolean.  A pointer to a ber_int_t should be supplied.\u2029\u2029e  Enumeration.  A pointer to a ber_int_t should be supplied.\u2029\u2029i  Integer.  A pointer to a ber_int_t should be supplied.\u2029\u2029B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the\u2029bitstring returned.\u2029\u2029n  Null.  No parameter is required.  The element is simply skipped if it is recognized.\u2029\u2029v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().\u2029\u2029V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().\u2029\u2029W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().\u2029\u2029M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().\u2029\u2029l  Length of the next element.  A pointer to a ber_len_t should be supplied.\u2029\u2029t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.\u2029\u2029T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.\u2029\u2029x  Skip element.  The next element is skipped.\u2029\u2029{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.\u2029\u2029}  End sequence.  No parameter is required and no action is taken.\u2029\u2029[  Begin set.  No parameter is required.  The initial set tag and length are skipped.\u2029\u2029]  End set.  No parameter is required and no action is taken.\u2029\u2029The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)\u2029on failure.\u2029\u2029The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain\u2029the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.\u2029\u2029The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().\u2029\u2029The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory\u2029assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be\u2029returned using ber_memfree().\u2029\u2029The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.\u2029\u2029The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will\u2029point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should\u2029be passed to subsequent calls to ber_next_element(), which returns similar information.\u2029\u2029EXAMPLES\u2029Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029The element can be decoded using ber_scanf() as follows.\u2029\u2029ber_int_t    scope, deref, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029ber_tag_t tag;\u2029\u2029tag = ber_scanf( ber, \"{aeeiib{v}}\",\u2029&amp;dn, &amp;scope, &amp;deref,\u2029&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );\u2029\u2029if( tag == LBER_ERROR ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ber_memfree( dn );\u2029ber_memvfree( attrs );\u2029\u2029ERRORS\u2029If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 848, "position": [100900, 112335], "check": 1, "intersection": 11436, "FP_dupl": 35799, "FN_dupl": 0, "F": 0.38983484174464383, "Prec_Dupl": 0.24210860590663702, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool\u2010\u2029ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);\u2029\u2029ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);\u2029\u2029ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);\u2029\u2029ber_tag_t ber_get_stringa(BerElement *ber, char **buf);\u2029\u2029ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);\u2029\u2029ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);\u2029\u2029ber_tag_t ber_get_null(BerElement *ber);\u2029\u2029ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);\u2029\u2029ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);\u2029\u2029ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);\u2029\u2029ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.\u2029\u2029The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the\u2029entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb\u2029parameter.\u2029\u2029The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by\u2029ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica\u2010\u2029tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.\u2029\u2029a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().\u2029\u2029A  Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().\u2029\u2029s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet\u2029string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.\u2029\u2029O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().\u2029\u2029o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().\u2029\u2029m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle\u2010\u2029ment, and must not be freed by the caller.\u2029\u2029b  Boolean.  A pointer to a ber_int_t should be supplied.\u2029\u2029e  Enumeration.  A pointer to a ber_int_t should be supplied.\u2029\u2029i  Integer.  A pointer to a ber_int_t should be supplied.\u2029\u2029B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the\u2029bitstring returned.\u2029\u2029n  Null.  No parameter is required.  The element is simply skipped if it is recognized.\u2029\u2029v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().\u2029\u2029V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().\u2029\u2029W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().\u2029\u2029M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().\u2029\u2029l  Length of the next element.  A pointer to a ber_len_t should be supplied.\u2029\u2029t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.\u2029\u2029T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.\u2029\u2029x  Skip element.  The next element is skipped.\u2029\u2029{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.\u2029\u2029}  End sequence.  No parameter is required and no action is taken.\u2029\u2029[  Begin set.  No parameter is required.  The initial set tag and length are skipped.\u2029\u2029]  End set.  No parameter is required and no action is taken.\u2029\u2029The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)\u2029on failure.\u2029\u2029The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain\u2029the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.\u2029\u2029The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().\u2029\u2029The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory\u2029assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be\u2029returned using ber_memfree().\u2029\u2029The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.\u2029\u2029The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will\u2029point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should\u2029be passed to subsequent calls to ber_next_element(), which returns similar information.\u2029\u2029EXAMPLES\u2029Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029The element can be decoded using ber_scanf() as follows.\u2029\u2029ber_int_t    scope, deref, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029ber_tag_t tag;\u2029\u2029tag = ber_scanf( ber, \"{aeeiib{v}}\",\u2029&amp;dn, &amp;scope, &amp;deref,\u2029&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );\u2029\u2029if( tag == LBER_ERROR ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ber_memfree( dn );\u2029ber_memvfree( attrs );\u2029\u2029ERRORS\u2029If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 847, "position": [89092, 100527], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool\u2010\u2029ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding\u2029\u2029LIBRARY\u2029OpenLDAP LBER (liblber, -llber)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;lber.h&amp;gt;\u2029\u2029ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);\u2029\u2029ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);\u2029\u2029ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);\u2029\u2029ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);\u2029\u2029ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);\u2029\u2029ber_tag_t ber_get_stringa(BerElement *ber, char **buf);\u2029\u2029ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);\u2029\u2029ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);\u2029\u2029ber_tag_t ber_get_null(BerElement *ber);\u2029\u2029ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);\u2029\u2029ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);\u2029\u2029ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);\u2029\u2029ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);\u2029\u2029DESCRIPTION\u2029These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined\u2029for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive\u2029form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for\u2029information about types, allocators, and deallocators.\u2029\u2029Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,\u2029ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,\u2029these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.\u2029\u2029The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the\u2029entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb\u2029parameter.\u2029\u2029The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by\u2029ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica\u2010\u2029tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.\u2029\u2029a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The\u2029caller should free the returned string using ber_memfree().\u2029\u2029A  Octet string.  A variant of \"a\".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in\u2029the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().\u2029\u2029s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet\u2029string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.\u2029\u2029O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.\u2029The caller should free the returned structure using ber_bvfree().\u2029\u2029o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the\u2029returned octet string using ber_memfree().\u2029\u2029m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle\u2010\u2029ment, and must not be freed by the caller.\u2029\u2029b  Boolean.  A pointer to a ber_int_t should be supplied.\u2029\u2029e  Enumeration.  A pointer to a ber_int_t should be supplied.\u2029\u2029i  Integer.  A pointer to a ber_int_t should be supplied.\u2029\u2029B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the\u2029bitstring returned.\u2029\u2029n  Null.  No parameter is required.  The element is simply skipped if it is recognized.\u2029\u2029v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet\u2029strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().\u2029\u2029V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct\u2029berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using\u2029ber_bvecfree().\u2029\u2029W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the\u2029octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller\u2029should free the returned structures using ber_bvarray_free().\u2029\u2029M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)\u2029and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting\u2029at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter\u2010\u2029minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)\u2029on return.  The caller should free the returned array using ber_memfree().\u2029\u2029l  Length of the next element.  A pointer to a ber_len_t should be supplied.\u2029\u2029t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.\u2029\u2029T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.\u2029\u2029x  Skip element.  The next element is skipped.\u2029\u2029{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.\u2029\u2029}  End sequence.  No parameter is required and no action is taken.\u2029\u2029[  Begin set.  No parameter is required.  The initial set tag and length are skipped.\u2029\u2029]  End set.  No parameter is required and no action is taken.\u2029\u2029The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)\u2029on failure.\u2029\u2029The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain\u2029the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.\u2029\u2029The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in\u2029this parameter.  The caller should free the returned structure using ber_bvfree().\u2029\u2029The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory\u2029assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be\u2029returned using ber_memfree().\u2029\u2029The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.\u2029\u2029The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.\u2029\u2029The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will\u2029point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().\u2029\u2029The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should\u2029be passed to subsequent calls to ber_next_element(), which returns similar information.\u2029\u2029EXAMPLES\u2029Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:\u2029\u2029AlmostASearchRequest := SEQUENCE {\u2029baseObject      DistinguishedName,\u2029scope           ENUMERATED {\u2029baseObject    (0),\u2029singleLevel   (1),\u2029wholeSubtree  (2)\u2029},\u2029derefAliases    ENUMERATED {\u2029neverDerefaliases   (0),\u2029derefInSearching    (1),\u2029derefFindingBaseObj (2),\u2029alwaysDerefAliases  (3)\u2029},\u2029sizelimit       INTEGER (0 .. 65535),\u2029timelimit       INTEGER (0 .. 65535),\u2029attrsOnly       BOOLEAN,\u2029attributes      SEQUENCE OF AttributeType\u2029}\u2029\u2029The element can be decoded using ber_scanf() as follows.\u2029\u2029ber_int_t    scope, deref, size, time, attrsonly;\u2029char   *dn, **attrs;\u2029ber_tag_t tag;\u2029\u2029tag = ber_scanf( ber, \"{aeeiib{v}}\",\u2029&amp;dn, &amp;scope, &amp;deref,\u2029&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );\u2029\u2029if( tag == LBER_ERROR ) {\u2029/* error */\u2029} else {\u2029/* success */\u2029}\u2029\u2029ber_memfree( dn );\u2029ber_memvfree( attrs );\u2029\u2029ERRORS\u2029If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).\u2029\u2029NOTES\u2029The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using\u2029supplied deallocation routines.\u2029\u2029SEE ALSO\u2029lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 846, "position": [62916, 74351], "check": 1, "intersection": 11436, "FP_dupl": 14743, "FN_dupl": 0, "F": 0.6080552970889274, "Prec_Dupl": 0.43683868749761257, "Recall_Dupl": 1.0}]}, {"name": "45", "annotation": "LDAP_ABANDON", "group_ids": [{"name2": "NAME\u2029ldap_abandon_ext - Abandon an LDAP operation in progress\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_abandon_ext(\u2029LDAP *ld,\u2029Bint msgid,\u2029LDAPControl **sctrls,\u2029LDAPControl **cctrls );\u2029\u2029DESCRIPTION\u2029The  ldap_abandon_ext() routine is used to send a LDAP Abandon request for an operation in progress.  The msgid passed should be the message id of an outstanding LDAP operation,\u2029such as returned by ldap_search_ext(3).\u2029\u2029ldap_abandon_ext() checks to see if the result of the operation has already come in.  If it has, it deletes it from the queue of pending messages.  If  not,  it  sends  an  LDAP\u2029abandon request to the LDAP server.\u2029\u2029The caller can expect that the result of an abandoned operation will not be returned from a future call to ldap_result(3).\u2029\u2029ldap_abandon_ext() allows server and client controls to be passed in via the sctrls and cctrls parameters, respectively.\u2029\u2029ldap_abandon_ext() returns a code indicating success or, in the case of failure, the nature of the failure.  See ldap_error(3) for details.\u2029\u2029DEPRECATED INTERFACES\u2029The ldap_abandon() routine is deprecated in favor of the ldap_abandon_ext() routine.\u2029\u2029Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed\u2029to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_result(3), ldap_search_ext(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 862, "position": [371742, 373640], "check": 1, "intersection": 1899, "FP_dupl": 372, "FN_dupl": 0, "F": 0.9107913669064749, "Prec_Dupl": 0.8361955085865258, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_abandon_ext - Abandon an LDAP operation in progress\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_abandon_ext(\u2029LDAP *ld,\u2029Bint msgid,\u2029LDAPControl **sctrls,\u2029LDAPControl **cctrls );\u2029\u2029DESCRIPTION\u2029The  ldap_abandon_ext() routine is used to send a LDAP Abandon request for an operation in progress.  The msgid passed should be the message id of an outstanding LDAP operation,\u2029such as returned by ldap_search_ext(3).\u2029\u2029ldap_abandon_ext() checks to see if the result of the operation has already come in.  If it has, it deletes it from the queue of pending messages.  If  not,  it  sends  an  LDAP\u2029abandon request to the LDAP server.\u2029\u2029The caller can expect that the result of an abandoned operation will not be returned from a future call to ldap_result(3).\u2029\u2029ldap_abandon_ext() allows server and client controls to be passed in via the sctrls and cctrls parameters, respectively.\u2029\u2029ldap_abandon_ext() returns a code indicating success or, in the case of failure, the nature of the failure.  See ldap_error(3) for details.\u2029\u2029DEPRECATED INTERFACES\u2029The ldap_abandon() routine is deprecated in favor of the ldap_abandon_ext() routine.\u2029\u2029Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed\u2029to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_result(3), ldap_search_ext(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 861, "position": [369471, 371369], "check": 1, "intersection": 1899, "FP_dupl": 372, "FN_dupl": 0, "F": 0.9107913669064749, "Prec_Dupl": 0.8361955085865258, "Recall_Dupl": 1.0}]}, {"name": "46", "annotation": "LDAP_ADD", "group_ids": [{"name2": "NAME\u2029ldap_add_ext, ldap_add_ext_s - Perform an LDAP add operation\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_add_ext(\u2029LDAP *ld,\u2029const char *dn,\u2029LDAPMod **attrs,\u2029LDAPControl **sctrls,\u2029LDAPControl **cctrls,\u2029int *msgidp );\u2029\u2029int ldap_add_ext_s(\u2029LDAP *ld,\u2029const char *dn,\u2029LDAPMod **attrs,\u2029LDAPControl *sctrls,\u2029LDAPControl *cctrls );\u2029\u2029DESCRIPTION\u2029The  ldap_add_ext_s()  routine  is used to perform an LDAP add operation.  It takes dn, the DN of the entry to add, and attrs, a null-terminated array of the entry's attributes.\u2029The LDAPMod structure is used to represent attributes, with the mod_type and mod_values fields being used as described under ldap_modify_ext(3), and the ldap_op field being used\u2029only if you need to specify the LDAP_MOD_BVALUES option. Otherwise, it should be set to zero.\u2029\u2029Note  that  all  entries  except that specified by the last component in the given DN must already exist.  ldap_add_ext_s() returns an code indicating success or, in the case of\u2029failure, indicating the nature of failure of the operation.  See ldap_error(3) for more details.\u2029\u2029The ldap_add_ext() routine works just like ldap_add_ext_s(), but it is asynchronous.  It returns the message id of the request it initiated.  The result of this operation can be\u2029obtained by calling ldap_result(3).\u2029\u2029DEPRECATED INTERFACES\u2029The ldap_add() and ldap_add_s() routines are deprecated in favor of the ldap_add_ext() and ldap_add_ext_s() routines, respectively.\u2029\u2029Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed\u2029to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_modify(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 866, "position": [381696, 383884], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_add_ext, ldap_add_ext_s - Perform an LDAP add operation\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_add_ext(\u2029LDAP *ld,\u2029const char *dn,\u2029LDAPMod **attrs,\u2029LDAPControl **sctrls,\u2029LDAPControl **cctrls,\u2029int *msgidp );\u2029\u2029int ldap_add_ext_s(\u2029LDAP *ld,\u2029const char *dn,\u2029LDAPMod **attrs,\u2029LDAPControl *sctrls,\u2029LDAPControl *cctrls );\u2029\u2029DESCRIPTION\u2029The  ldap_add_ext_s()  routine  is used to perform an LDAP add operation.  It takes dn, the DN of the entry to add, and attrs, a null-terminated array of the entry's attributes.\u2029The LDAPMod structure is used to represent attributes, with the mod_type and mod_values fields being used as described under ldap_modify_ext(3), and the ldap_op field being used\u2029only if you need to specify the LDAP_MOD_BVALUES option. Otherwise, it should be set to zero.\u2029\u2029Note  that  all  entries  except that specified by the last component in the given DN must already exist.  ldap_add_ext_s() returns an code indicating success or, in the case of\u2029failure, indicating the nature of failure of the operation.  See ldap_error(3) for more details.\u2029\u2029The ldap_add_ext() routine works just like ldap_add_ext_s(), but it is asynchronous.  It returns the message id of the request it initiated.  The result of this operation can be\u2029obtained by calling ldap_result(3).\u2029\u2029DEPRECATED INTERFACES\u2029The ldap_add() and ldap_add_s() routines are deprecated in favor of the ldap_add_ext() and ldap_add_ext_s() routines, respectively.\u2029\u2029Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed\u2029to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_modify(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 865, "position": [379135, 381323], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_add_ext, ldap_add_ext_s - Perform an LDAP add operation\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_add_ext(\u2029LDAP *ld,\u2029const char *dn,\u2029LDAPMod **attrs,\u2029LDAPControl **sctrls,\u2029LDAPControl **cctrls,\u2029int *msgidp );\u2029\u2029int ldap_add_ext_s(\u2029LDAP *ld,\u2029const char *dn,\u2029LDAPMod **attrs,\u2029LDAPControl *sctrls,\u2029LDAPControl *cctrls );\u2029\u2029DESCRIPTION\u2029The  ldap_add_ext_s()  routine  is used to perform an LDAP add operation.  It takes dn, the DN of the entry to add, and attrs, a null-terminated array of the entry's attributes.\u2029The LDAPMod structure is used to represent attributes, with the mod_type and mod_values fields being used as described under ldap_modify_ext(3), and the ldap_op field being used\u2029only if you need to specify the LDAP_MOD_BVALUES option. Otherwise, it should be set to zero.\u2029\u2029Note  that  all  entries  except that specified by the last component in the given DN must already exist.  ldap_add_ext_s() returns an code indicating success or, in the case of\u2029failure, indicating the nature of failure of the operation.  See ldap_error(3) for more details.\u2029\u2029The ldap_add_ext() routine works just like ldap_add_ext_s(), but it is asynchronous.  It returns the message id of the request it initiated.  The result of this operation can be\u2029obtained by calling ldap_result(3).\u2029\u2029DEPRECATED INTERFACES\u2029The ldap_add() and ldap_add_s() routines are deprecated in favor of the ldap_add_ext() and ldap_add_ext_s() routines, respectively.\u2029\u2029Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed\u2029to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_modify(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 864, "position": [376574, 378762], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_add_ext, ldap_add_ext_s - Perform an LDAP add operation\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_add_ext(\u2029LDAP *ld,\u2029const char *dn,\u2029LDAPMod **attrs,\u2029LDAPControl **sctrls,\u2029LDAPControl **cctrls,\u2029int *msgidp );\u2029\u2029int ldap_add_ext_s(\u2029LDAP *ld,\u2029const char *dn,\u2029LDAPMod **attrs,\u2029LDAPControl *sctrls,\u2029LDAPControl *cctrls );\u2029\u2029DESCRIPTION\u2029The  ldap_add_ext_s()  routine  is used to perform an LDAP add operation.  It takes dn, the DN of the entry to add, and attrs, a null-terminated array of the entry's attributes.\u2029The LDAPMod structure is used to represent attributes, with the mod_type and mod_values fields being used as described under ldap_modify_ext(3), and the ldap_op field being used\u2029only if you need to specify the LDAP_MOD_BVALUES option. Otherwise, it should be set to zero.\u2029\u2029Note  that  all  entries  except that specified by the last component in the given DN must already exist.  ldap_add_ext_s() returns an code indicating success or, in the case of\u2029failure, indicating the nature of failure of the operation.  See ldap_error(3) for more details.\u2029\u2029The ldap_add_ext() routine works just like ldap_add_ext_s(), but it is asynchronous.  It returns the message id of the request it initiated.  The result of this operation can be\u2029obtained by calling ldap_result(3).\u2029\u2029DEPRECATED INTERFACES\u2029The ldap_add() and ldap_add_s() routines are deprecated in favor of the ldap_add_ext() and ldap_add_ext_s() routines, respectively.\u2029\u2029Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed\u2029to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_modify(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 863, "position": [374013, 376201], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "47", "annotation": "LDAP_SCHEMA", "group_ids": [{"name2": "NAME\u2029ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,\u2029ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object\u2010\u2029class_free, ldap_scherr2str - Schema definition handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029#include &amp;lt;ldap_schema.h&amp;gt;\u2029\u2029LDAPSyntax * ldap_str2syntax(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_syntax2str(syn)\u2029const LDAPSyntax * syn;\u2029\u2029const char * ldap_syntax2name(syn)\u2029LDAPSyntax * syn;\u2029\u2029ldap_syntax_free(syn)\u2029LDAPSyntax * syn;\u2029\u2029LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_matchingrule2str(mr);\u2029const LDAPMatchingRule * mr;\u2029\u2029const char * ldap_matchingrule2name(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029ldap_matchingrule_free(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_attributetype2str(at)\u2029const LDAPAttributeType * at;\u2029\u2029const char * ldap_attributetype2name(at)\u2029LDAPAttributeType * at;\u2029\u2029ldap_attributetype_free(at)\u2029LDAPAttributeType * at;\u2029\u2029LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_objectclass2str(oc)\u2029const LDAPObjectClass * oc;\u2029\u2029const char * ldap_objectclass2name(oc)\u2029LDAPObjectClass * oc;\u2029\u2029ldap_objectclass_free(oc)\u2029LDAPObjectClass * oc;\u2029\u2029char * ldap_scherr2str(code)\u2029int code;\u2029\u2029DESCRIPTION\u2029These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:\u2029syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.\u2029\u2029ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate\u2029kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,\u2029the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter\u2010\u2029minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a\u2029bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:\u2029\u2029LDAP_SCHEMA_ALLOW_NONE\u2029strict parsing according to RFC 4512.\u2029\u2029LDAP_SCHEMA_ALLOW_NO_OID\u2029permit definitions that do not contain an initial OID.\u2029\u2029LDAP_SCHEMA_ALLOW_QUOTED\u2029permit quotes around some items that should not have them.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR\u2029permit a descr instead of a numeric OID in places where the syntax expect the latter.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR_PREFIX\u2029permit that the initial numeric OID contains a prefix in descr format.\u2029\u2029LDAP_SCHEMA_ALLOW_ALL\u2029be very liberal, include all options.\u2029\u2029The structures returned are as follows:\u2029\u2029typedef struct ldap_schema_extension_item {\u2029char *lsei_name;        /* Extension name */\u2029char **lsei_values;     /* Extension values */\u2029} LDAPSchemaExtensionItem;\u2029\u2029typedef struct ldap_syntax {\u2029char *syn_oid;          /* OID */\u2029char **syn_names;       /* Names */\u2029char *syn_desc;         /* Description */\u2029LDAPSchemaExtensionItem **syn_extensions; /* Extension */\u2029} LDAPSyntax;\u2029\u2029typedef struct ldap_matchingrule {\u2029char *mr_oid;           /* OID */\u2029char **mr_names;        /* Names */\u2029char *mr_desc;          /* Description */\u2029int  mr_obsolete;       /* Is obsolete? */\u2029char *mr_syntax_oid;    /* Syntax of asserted values */\u2029LDAPSchemaExtensionItem **mr_extensions; /* Extensions */\u2029} LDAPMatchingRule;\u2029\u2029typedef struct ldap_attributetype {\u2029char *at_oid;           /* OID */\u2029char **at_names;        /* Names */\u2029char *at_desc;          /* Description */\u2029int  at_obsolete;       /* Is obsolete? */\u2029char *at_sup_oid;       /* OID of superior type */\u2029char *at_equality_oid;  /* OID of equality matching rule */\u2029char *at_ordering_oid;  /* OID of ordering matching rule */\u2029char *at_substr_oid;    /* OID of substrings matching rule */\u2029char *at_syntax_oid;    /* OID of syntax of values */\u2029int  at_syntax_len;     /* Suggested minimum maximum length */\u2029int  at_single_value;   /* Is single-valued?  */\u2029int  at_collective;     /* Is collective? */\u2029int  at_no_user_mod;    /* Are changes forbidden through LDAP? */\u2029int  at_usage;          /* Usage, see below */\u2029LDAPSchemaExtensionItem **at_extensions; /* Extensions */\u2029} LDAPAttributeType;\u2029\u2029typedef struct ldap_objectclass {\u2029char *oc_oid;           /* OID */\u2029char **oc_names;        /* Names */\u2029char *oc_desc;          /* Description */\u2029int  oc_obsolete;       /* Is obsolete? */\u2029char **oc_sup_oids;     /* OIDs of superior classes */\u2029int  oc_kind;           /* Kind, see below */\u2029char **oc_at_oids_must; /* OIDs of required attribute types */\u2029char **oc_at_oids_may;  /* OIDs of optional attribute types */\u2029LDAPSchemaExtensionItem **oc_extensions; /* Extensions */\u2029} LDAPObjectClass;\u2029\u2029Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:\u2029\u2029LDAP_SCHEMA_NO\u2029The answer to the question is no.\u2029\u2029LDAP_SCHEMA_YES\u2029The answer to the question is yes.\u2029\u2029For attribute types, the following usages are possible:\u2029\u2029LDAP_SCHEMA_USER_APPLICATIONS\u2029the attribute type is non-operational.\u2029\u2029LDAP_SCHEMA_DIRECTORY_OPERATION\u2029the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.\u2029\u2029LDAP_SCHEMA_DISTRIBUTED_OPERATION\u2029the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.\u2029\u2029LDAP_SCHEMA_DSA_OPERATION\u2029the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.\u2029\u2029Object classes can be of three kinds:\u2029\u2029LDAP_SCHEMA_ABSTRACT\u2029the object class is abstract, i.e. there cannot be entries of this class alone.\u2029\u2029LDAP_SCHEMA_STRUCTURAL\u2029the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned\u2029cannot be changed: none of those present can be removed and none other can be added.\u2029\u2029LDAP_SCHEMA_AUXILIARY\u2029the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added\u2029or removed at the same time as needed by the set of object classes resulting from the operation.\u2029\u2029Routines ldap_xxx2name() return a canonical name for the definition.\u2029\u2029Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that\u2029must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.\u2029\u2029ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The\u2029argument code comes from one of the parsing routines and can adopt the following values:\u2029\u2029LDAP_SCHERR_OUTOFMEM\u2029Out of memory.\u2029\u2029LDAP_SCHERR_UNEXPTOKEN\u2029Unexpected token.\u2029\u2029LDAP_SCHERR_NOLEFTPAREN\u2029Missing opening parenthesis.\u2029\u2029LDAP_SCHERR_NORIGHTPAREN\u2029Missing closing parenthesis.\u2029\u2029LDAP_SCHERR_NODIGIT\u2029Expecting digit.\u2029\u2029LDAP_SCHERR_BADNAME\u2029Expecting a name.\u2029\u2029LDAP_SCHERR_BADDESC\u2029Bad description.\u2029\u2029LDAP_SCHERR_BADSUP\u2029Bad superiors.\u2029\u2029LDAP_SCHERR_DUPOPT\u2029Duplicate option.\u2029\u2029LDAP_SCHERR_EMPTY\u2029Unexpected end of data.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 983, "position": [651187, 659594], "check": 1, "intersection": 8408, "FP_dupl": 19474, "FN_dupl": 0, "F": 0.46337834114081017, "Prec_Dupl": 0.30155655978767665, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,\u2029ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object\u2010\u2029class_free, ldap_scherr2str - Schema definition handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029#include &amp;lt;ldap_schema.h&amp;gt;\u2029\u2029LDAPSyntax * ldap_str2syntax(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_syntax2str(syn)\u2029const LDAPSyntax * syn;\u2029\u2029const char * ldap_syntax2name(syn)\u2029LDAPSyntax * syn;\u2029\u2029ldap_syntax_free(syn)\u2029LDAPSyntax * syn;\u2029\u2029LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_matchingrule2str(mr);\u2029const LDAPMatchingRule * mr;\u2029\u2029const char * ldap_matchingrule2name(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029ldap_matchingrule_free(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_attributetype2str(at)\u2029const LDAPAttributeType * at;\u2029\u2029const char * ldap_attributetype2name(at)\u2029LDAPAttributeType * at;\u2029\u2029ldap_attributetype_free(at)\u2029LDAPAttributeType * at;\u2029\u2029LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_objectclass2str(oc)\u2029const LDAPObjectClass * oc;\u2029\u2029const char * ldap_objectclass2name(oc)\u2029LDAPObjectClass * oc;\u2029\u2029ldap_objectclass_free(oc)\u2029LDAPObjectClass * oc;\u2029\u2029char * ldap_scherr2str(code)\u2029int code;\u2029\u2029DESCRIPTION\u2029These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:\u2029syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.\u2029\u2029ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate\u2029kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,\u2029the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter\u2010\u2029minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a\u2029bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:\u2029\u2029LDAP_SCHEMA_ALLOW_NONE\u2029strict parsing according to RFC 4512.\u2029\u2029LDAP_SCHEMA_ALLOW_NO_OID\u2029permit definitions that do not contain an initial OID.\u2029\u2029LDAP_SCHEMA_ALLOW_QUOTED\u2029permit quotes around some items that should not have them.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR\u2029permit a descr instead of a numeric OID in places where the syntax expect the latter.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR_PREFIX\u2029permit that the initial numeric OID contains a prefix in descr format.\u2029\u2029LDAP_SCHEMA_ALLOW_ALL\u2029be very liberal, include all options.\u2029\u2029The structures returned are as follows:\u2029\u2029typedef struct ldap_schema_extension_item {\u2029char *lsei_name;        /* Extension name */\u2029char **lsei_values;     /* Extension values */\u2029} LDAPSchemaExtensionItem;\u2029\u2029typedef struct ldap_syntax {\u2029char *syn_oid;          /* OID */\u2029char **syn_names;       /* Names */\u2029char *syn_desc;         /* Description */\u2029LDAPSchemaExtensionItem **syn_extensions; /* Extension */\u2029} LDAPSyntax;\u2029\u2029typedef struct ldap_matchingrule {\u2029char *mr_oid;           /* OID */\u2029char **mr_names;        /* Names */\u2029char *mr_desc;          /* Description */\u2029int  mr_obsolete;       /* Is obsolete? */\u2029char *mr_syntax_oid;    /* Syntax of asserted values */\u2029LDAPSchemaExtensionItem **mr_extensions; /* Extensions */\u2029} LDAPMatchingRule;\u2029\u2029typedef struct ldap_attributetype {\u2029char *at_oid;           /* OID */\u2029char **at_names;        /* Names */\u2029char *at_desc;          /* Description */\u2029int  at_obsolete;       /* Is obsolete? */\u2029char *at_sup_oid;       /* OID of superior type */\u2029char *at_equality_oid;  /* OID of equality matching rule */\u2029char *at_ordering_oid;  /* OID of ordering matching rule */\u2029char *at_substr_oid;    /* OID of substrings matching rule */\u2029char *at_syntax_oid;    /* OID of syntax of values */\u2029int  at_syntax_len;     /* Suggested minimum maximum length */\u2029int  at_single_value;   /* Is single-valued?  */\u2029int  at_collective;     /* Is collective? */\u2029int  at_no_user_mod;    /* Are changes forbidden through LDAP? */\u2029int  at_usage;          /* Usage, see below */\u2029LDAPSchemaExtensionItem **at_extensions; /* Extensions */\u2029} LDAPAttributeType;\u2029\u2029typedef struct ldap_objectclass {\u2029char *oc_oid;           /* OID */\u2029char **oc_names;        /* Names */\u2029char *oc_desc;          /* Description */\u2029int  oc_obsolete;       /* Is obsolete? */\u2029char **oc_sup_oids;     /* OIDs of superior classes */\u2029int  oc_kind;           /* Kind, see below */\u2029char **oc_at_oids_must; /* OIDs of required attribute types */\u2029char **oc_at_oids_may;  /* OIDs of optional attribute types */\u2029LDAPSchemaExtensionItem **oc_extensions; /* Extensions */\u2029} LDAPObjectClass;\u2029\u2029Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:\u2029\u2029LDAP_SCHEMA_NO\u2029The answer to the question is no.\u2029\u2029LDAP_SCHEMA_YES\u2029The answer to the question is yes.\u2029\u2029For attribute types, the following usages are possible:\u2029\u2029LDAP_SCHEMA_USER_APPLICATIONS\u2029the attribute type is non-operational.\u2029\u2029LDAP_SCHEMA_DIRECTORY_OPERATION\u2029the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.\u2029\u2029LDAP_SCHEMA_DISTRIBUTED_OPERATION\u2029the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.\u2029\u2029LDAP_SCHEMA_DSA_OPERATION\u2029the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.\u2029\u2029Object classes can be of three kinds:\u2029\u2029LDAP_SCHEMA_ABSTRACT\u2029the object class is abstract, i.e. there cannot be entries of this class alone.\u2029\u2029LDAP_SCHEMA_STRUCTURAL\u2029the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned\u2029cannot be changed: none of those present can be removed and none other can be added.\u2029\u2029LDAP_SCHEMA_AUXILIARY\u2029the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added\u2029or removed at the same time as needed by the set of object classes resulting from the operation.\u2029\u2029Routines ldap_xxx2name() return a canonical name for the definition.\u2029\u2029Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that\u2029must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.\u2029\u2029ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The\u2029argument code comes from one of the parsing routines and can adopt the following values:\u2029\u2029LDAP_SCHERR_OUTOFMEM\u2029Out of memory.\u2029\u2029LDAP_SCHERR_UNEXPTOKEN\u2029Unexpected token.\u2029\u2029LDAP_SCHERR_NOLEFTPAREN\u2029Missing opening parenthesis.\u2029\u2029LDAP_SCHERR_NORIGHTPAREN\u2029Missing closing parenthesis.\u2029\u2029LDAP_SCHERR_NODIGIT\u2029Expecting digit.\u2029\u2029LDAP_SCHERR_BADNAME\u2029Expecting a name.\u2029\u2029LDAP_SCHERR_BADDESC\u2029Bad description.\u2029\u2029LDAP_SCHERR_BADSUP\u2029Bad superiors.\u2029\u2029LDAP_SCHERR_DUPOPT\u2029Duplicate option.\u2029\u2029LDAP_SCHERR_EMPTY\u2029Unexpected end of data.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 883, "position": [995562, 1003969], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,\u2029ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object\u2010\u2029class_free, ldap_scherr2str - Schema definition handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029#include &amp;lt;ldap_schema.h&amp;gt;\u2029\u2029LDAPSyntax * ldap_str2syntax(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_syntax2str(syn)\u2029const LDAPSyntax * syn;\u2029\u2029const char * ldap_syntax2name(syn)\u2029LDAPSyntax * syn;\u2029\u2029ldap_syntax_free(syn)\u2029LDAPSyntax * syn;\u2029\u2029LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_matchingrule2str(mr);\u2029const LDAPMatchingRule * mr;\u2029\u2029const char * ldap_matchingrule2name(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029ldap_matchingrule_free(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_attributetype2str(at)\u2029const LDAPAttributeType * at;\u2029\u2029const char * ldap_attributetype2name(at)\u2029LDAPAttributeType * at;\u2029\u2029ldap_attributetype_free(at)\u2029LDAPAttributeType * at;\u2029\u2029LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_objectclass2str(oc)\u2029const LDAPObjectClass * oc;\u2029\u2029const char * ldap_objectclass2name(oc)\u2029LDAPObjectClass * oc;\u2029\u2029ldap_objectclass_free(oc)\u2029LDAPObjectClass * oc;\u2029\u2029char * ldap_scherr2str(code)\u2029int code;\u2029\u2029DESCRIPTION\u2029These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:\u2029syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.\u2029\u2029ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate\u2029kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,\u2029the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter\u2010\u2029minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a\u2029bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:\u2029\u2029LDAP_SCHEMA_ALLOW_NONE\u2029strict parsing according to RFC 4512.\u2029\u2029LDAP_SCHEMA_ALLOW_NO_OID\u2029permit definitions that do not contain an initial OID.\u2029\u2029LDAP_SCHEMA_ALLOW_QUOTED\u2029permit quotes around some items that should not have them.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR\u2029permit a descr instead of a numeric OID in places where the syntax expect the latter.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR_PREFIX\u2029permit that the initial numeric OID contains a prefix in descr format.\u2029\u2029LDAP_SCHEMA_ALLOW_ALL\u2029be very liberal, include all options.\u2029\u2029The structures returned are as follows:\u2029\u2029typedef struct ldap_schema_extension_item {\u2029char *lsei_name;        /* Extension name */\u2029char **lsei_values;     /* Extension values */\u2029} LDAPSchemaExtensionItem;\u2029\u2029typedef struct ldap_syntax {\u2029char *syn_oid;          /* OID */\u2029char **syn_names;       /* Names */\u2029char *syn_desc;         /* Description */\u2029LDAPSchemaExtensionItem **syn_extensions; /* Extension */\u2029} LDAPSyntax;\u2029\u2029typedef struct ldap_matchingrule {\u2029char *mr_oid;           /* OID */\u2029char **mr_names;        /* Names */\u2029char *mr_desc;          /* Description */\u2029int  mr_obsolete;       /* Is obsolete? */\u2029char *mr_syntax_oid;    /* Syntax of asserted values */\u2029LDAPSchemaExtensionItem **mr_extensions; /* Extensions */\u2029} LDAPMatchingRule;\u2029\u2029typedef struct ldap_attributetype {\u2029char *at_oid;           /* OID */\u2029char **at_names;        /* Names */\u2029char *at_desc;          /* Description */\u2029int  at_obsolete;       /* Is obsolete? */\u2029char *at_sup_oid;       /* OID of superior type */\u2029char *at_equality_oid;  /* OID of equality matching rule */\u2029char *at_ordering_oid;  /* OID of ordering matching rule */\u2029char *at_substr_oid;    /* OID of substrings matching rule */\u2029char *at_syntax_oid;    /* OID of syntax of values */\u2029int  at_syntax_len;     /* Suggested minimum maximum length */\u2029int  at_single_value;   /* Is single-valued?  */\u2029int  at_collective;     /* Is collective? */\u2029int  at_no_user_mod;    /* Are changes forbidden through LDAP? */\u2029int  at_usage;          /* Usage, see below */\u2029LDAPSchemaExtensionItem **at_extensions; /* Extensions */\u2029} LDAPAttributeType;\u2029\u2029typedef struct ldap_objectclass {\u2029char *oc_oid;           /* OID */\u2029char **oc_names;        /* Names */\u2029char *oc_desc;          /* Description */\u2029int  oc_obsolete;       /* Is obsolete? */\u2029char **oc_sup_oids;     /* OIDs of superior classes */\u2029int  oc_kind;           /* Kind, see below */\u2029char **oc_at_oids_must; /* OIDs of required attribute types */\u2029char **oc_at_oids_may;  /* OIDs of optional attribute types */\u2029LDAPSchemaExtensionItem **oc_extensions; /* Extensions */\u2029} LDAPObjectClass;\u2029\u2029Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:\u2029\u2029LDAP_SCHEMA_NO\u2029The answer to the question is no.\u2029\u2029LDAP_SCHEMA_YES\u2029The answer to the question is yes.\u2029\u2029For attribute types, the following usages are possible:\u2029\u2029LDAP_SCHEMA_USER_APPLICATIONS\u2029the attribute type is non-operational.\u2029\u2029LDAP_SCHEMA_DIRECTORY_OPERATION\u2029the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.\u2029\u2029LDAP_SCHEMA_DISTRIBUTED_OPERATION\u2029the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.\u2029\u2029LDAP_SCHEMA_DSA_OPERATION\u2029the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.\u2029\u2029Object classes can be of three kinds:\u2029\u2029LDAP_SCHEMA_ABSTRACT\u2029the object class is abstract, i.e. there cannot be entries of this class alone.\u2029\u2029LDAP_SCHEMA_STRUCTURAL\u2029the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned\u2029cannot be changed: none of those present can be removed and none other can be added.\u2029\u2029LDAP_SCHEMA_AUXILIARY\u2029the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added\u2029or removed at the same time as needed by the set of object classes resulting from the operation.\u2029\u2029Routines ldap_xxx2name() return a canonical name for the definition.\u2029\u2029Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that\u2029must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.\u2029\u2029ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The\u2029argument code comes from one of the parsing routines and can adopt the following values:\u2029\u2029LDAP_SCHERR_OUTOFMEM\u2029Out of memory.\u2029\u2029LDAP_SCHERR_UNEXPTOKEN\u2029Unexpected token.\u2029\u2029LDAP_SCHERR_NOLEFTPAREN\u2029Missing opening parenthesis.\u2029\u2029LDAP_SCHERR_NORIGHTPAREN\u2029Missing closing parenthesis.\u2029\u2029LDAP_SCHERR_NODIGIT\u2029Expecting digit.\u2029\u2029LDAP_SCHERR_BADNAME\u2029Expecting a name.\u2029\u2029LDAP_SCHERR_BADDESC\u2029Bad description.\u2029\u2029LDAP_SCHERR_BADSUP\u2029Bad superiors.\u2029\u2029LDAP_SCHERR_DUPOPT\u2029Duplicate option.\u2029\u2029LDAP_SCHERR_EMPTY\u2029Unexpected end of data.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 882, "position": [986782, 995189], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,\u2029ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object\u2010\u2029class_free, ldap_scherr2str - Schema definition handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029#include &amp;lt;ldap_schema.h&amp;gt;\u2029\u2029LDAPSyntax * ldap_str2syntax(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_syntax2str(syn)\u2029const LDAPSyntax * syn;\u2029\u2029const char * ldap_syntax2name(syn)\u2029LDAPSyntax * syn;\u2029\u2029ldap_syntax_free(syn)\u2029LDAPSyntax * syn;\u2029\u2029LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_matchingrule2str(mr);\u2029const LDAPMatchingRule * mr;\u2029\u2029const char * ldap_matchingrule2name(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029ldap_matchingrule_free(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_attributetype2str(at)\u2029const LDAPAttributeType * at;\u2029\u2029const char * ldap_attributetype2name(at)\u2029LDAPAttributeType * at;\u2029\u2029ldap_attributetype_free(at)\u2029LDAPAttributeType * at;\u2029\u2029LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_objectclass2str(oc)\u2029const LDAPObjectClass * oc;\u2029\u2029const char * ldap_objectclass2name(oc)\u2029LDAPObjectClass * oc;\u2029\u2029ldap_objectclass_free(oc)\u2029LDAPObjectClass * oc;\u2029\u2029char * ldap_scherr2str(code)\u2029int code;\u2029\u2029DESCRIPTION\u2029These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:\u2029syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.\u2029\u2029ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate\u2029kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,\u2029the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter\u2010\u2029minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a\u2029bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:\u2029\u2029LDAP_SCHEMA_ALLOW_NONE\u2029strict parsing according to RFC 4512.\u2029\u2029LDAP_SCHEMA_ALLOW_NO_OID\u2029permit definitions that do not contain an initial OID.\u2029\u2029LDAP_SCHEMA_ALLOW_QUOTED\u2029permit quotes around some items that should not have them.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR\u2029permit a descr instead of a numeric OID in places where the syntax expect the latter.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR_PREFIX\u2029permit that the initial numeric OID contains a prefix in descr format.\u2029\u2029LDAP_SCHEMA_ALLOW_ALL\u2029be very liberal, include all options.\u2029\u2029The structures returned are as follows:\u2029\u2029typedef struct ldap_schema_extension_item {\u2029char *lsei_name;        /* Extension name */\u2029char **lsei_values;     /* Extension values */\u2029} LDAPSchemaExtensionItem;\u2029\u2029typedef struct ldap_syntax {\u2029char *syn_oid;          /* OID */\u2029char **syn_names;       /* Names */\u2029char *syn_desc;         /* Description */\u2029LDAPSchemaExtensionItem **syn_extensions; /* Extension */\u2029} LDAPSyntax;\u2029\u2029typedef struct ldap_matchingrule {\u2029char *mr_oid;           /* OID */\u2029char **mr_names;        /* Names */\u2029char *mr_desc;          /* Description */\u2029int  mr_obsolete;       /* Is obsolete? */\u2029char *mr_syntax_oid;    /* Syntax of asserted values */\u2029LDAPSchemaExtensionItem **mr_extensions; /* Extensions */\u2029} LDAPMatchingRule;\u2029\u2029typedef struct ldap_attributetype {\u2029char *at_oid;           /* OID */\u2029char **at_names;        /* Names */\u2029char *at_desc;          /* Description */\u2029int  at_obsolete;       /* Is obsolete? */\u2029char *at_sup_oid;       /* OID of superior type */\u2029char *at_equality_oid;  /* OID of equality matching rule */\u2029char *at_ordering_oid;  /* OID of ordering matching rule */\u2029char *at_substr_oid;    /* OID of substrings matching rule */\u2029char *at_syntax_oid;    /* OID of syntax of values */\u2029int  at_syntax_len;     /* Suggested minimum maximum length */\u2029int  at_single_value;   /* Is single-valued?  */\u2029int  at_collective;     /* Is collective? */\u2029int  at_no_user_mod;    /* Are changes forbidden through LDAP? */\u2029int  at_usage;          /* Usage, see below */\u2029LDAPSchemaExtensionItem **at_extensions; /* Extensions */\u2029} LDAPAttributeType;\u2029\u2029typedef struct ldap_objectclass {\u2029char *oc_oid;           /* OID */\u2029char **oc_names;        /* Names */\u2029char *oc_desc;          /* Description */\u2029int  oc_obsolete;       /* Is obsolete? */\u2029char **oc_sup_oids;     /* OIDs of superior classes */\u2029int  oc_kind;           /* Kind, see below */\u2029char **oc_at_oids_must; /* OIDs of required attribute types */\u2029char **oc_at_oids_may;  /* OIDs of optional attribute types */\u2029LDAPSchemaExtensionItem **oc_extensions; /* Extensions */\u2029} LDAPObjectClass;\u2029\u2029Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:\u2029\u2029LDAP_SCHEMA_NO\u2029The answer to the question is no.\u2029\u2029LDAP_SCHEMA_YES\u2029The answer to the question is yes.\u2029\u2029For attribute types, the following usages are possible:\u2029\u2029LDAP_SCHEMA_USER_APPLICATIONS\u2029the attribute type is non-operational.\u2029\u2029LDAP_SCHEMA_DIRECTORY_OPERATION\u2029the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.\u2029\u2029LDAP_SCHEMA_DISTRIBUTED_OPERATION\u2029the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.\u2029\u2029LDAP_SCHEMA_DSA_OPERATION\u2029the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.\u2029\u2029Object classes can be of three kinds:\u2029\u2029LDAP_SCHEMA_ABSTRACT\u2029the object class is abstract, i.e. there cannot be entries of this class alone.\u2029\u2029LDAP_SCHEMA_STRUCTURAL\u2029the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned\u2029cannot be changed: none of those present can be removed and none other can be added.\u2029\u2029LDAP_SCHEMA_AUXILIARY\u2029the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added\u2029or removed at the same time as needed by the set of object classes resulting from the operation.\u2029\u2029Routines ldap_xxx2name() return a canonical name for the definition.\u2029\u2029Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that\u2029must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.\u2029\u2029ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The\u2029argument code comes from one of the parsing routines and can adopt the following values:\u2029\u2029LDAP_SCHERR_OUTOFMEM\u2029Out of memory.\u2029\u2029LDAP_SCHERR_UNEXPTOKEN\u2029Unexpected token.\u2029\u2029LDAP_SCHERR_NOLEFTPAREN\u2029Missing opening parenthesis.\u2029\u2029LDAP_SCHERR_NORIGHTPAREN\u2029Missing closing parenthesis.\u2029\u2029LDAP_SCHERR_NODIGIT\u2029Expecting digit.\u2029\u2029LDAP_SCHERR_BADNAME\u2029Expecting a name.\u2029\u2029LDAP_SCHERR_BADDESC\u2029Bad description.\u2029\u2029LDAP_SCHERR_BADSUP\u2029Bad superiors.\u2029\u2029LDAP_SCHERR_DUPOPT\u2029Duplicate option.\u2029\u2029LDAP_SCHERR_EMPTY\u2029Unexpected end of data.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 881, "position": [978002, 986409], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,\u2029ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object\u2010\u2029class_free, ldap_scherr2str - Schema definition handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029#include &amp;lt;ldap_schema.h&amp;gt;\u2029\u2029LDAPSyntax * ldap_str2syntax(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_syntax2str(syn)\u2029const LDAPSyntax * syn;\u2029\u2029const char * ldap_syntax2name(syn)\u2029LDAPSyntax * syn;\u2029\u2029ldap_syntax_free(syn)\u2029LDAPSyntax * syn;\u2029\u2029LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_matchingrule2str(mr);\u2029const LDAPMatchingRule * mr;\u2029\u2029const char * ldap_matchingrule2name(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029ldap_matchingrule_free(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_attributetype2str(at)\u2029const LDAPAttributeType * at;\u2029\u2029const char * ldap_attributetype2name(at)\u2029LDAPAttributeType * at;\u2029\u2029ldap_attributetype_free(at)\u2029LDAPAttributeType * at;\u2029\u2029LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_objectclass2str(oc)\u2029const LDAPObjectClass * oc;\u2029\u2029const char * ldap_objectclass2name(oc)\u2029LDAPObjectClass * oc;\u2029\u2029ldap_objectclass_free(oc)\u2029LDAPObjectClass * oc;\u2029\u2029char * ldap_scherr2str(code)\u2029int code;\u2029\u2029DESCRIPTION\u2029These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:\u2029syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.\u2029\u2029ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate\u2029kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,\u2029the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter\u2010\u2029minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a\u2029bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:\u2029\u2029LDAP_SCHEMA_ALLOW_NONE\u2029strict parsing according to RFC 4512.\u2029\u2029LDAP_SCHEMA_ALLOW_NO_OID\u2029permit definitions that do not contain an initial OID.\u2029\u2029LDAP_SCHEMA_ALLOW_QUOTED\u2029permit quotes around some items that should not have them.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR\u2029permit a descr instead of a numeric OID in places where the syntax expect the latter.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR_PREFIX\u2029permit that the initial numeric OID contains a prefix in descr format.\u2029\u2029LDAP_SCHEMA_ALLOW_ALL\u2029be very liberal, include all options.\u2029\u2029The structures returned are as follows:\u2029\u2029typedef struct ldap_schema_extension_item {\u2029char *lsei_name;        /* Extension name */\u2029char **lsei_values;     /* Extension values */\u2029} LDAPSchemaExtensionItem;\u2029\u2029typedef struct ldap_syntax {\u2029char *syn_oid;          /* OID */\u2029char **syn_names;       /* Names */\u2029char *syn_desc;         /* Description */\u2029LDAPSchemaExtensionItem **syn_extensions; /* Extension */\u2029} LDAPSyntax;\u2029\u2029typedef struct ldap_matchingrule {\u2029char *mr_oid;           /* OID */\u2029char **mr_names;        /* Names */\u2029char *mr_desc;          /* Description */\u2029int  mr_obsolete;       /* Is obsolete? */\u2029char *mr_syntax_oid;    /* Syntax of asserted values */\u2029LDAPSchemaExtensionItem **mr_extensions; /* Extensions */\u2029} LDAPMatchingRule;\u2029\u2029typedef struct ldap_attributetype {\u2029char *at_oid;           /* OID */\u2029char **at_names;        /* Names */\u2029char *at_desc;          /* Description */\u2029int  at_obsolete;       /* Is obsolete? */\u2029char *at_sup_oid;       /* OID of superior type */\u2029char *at_equality_oid;  /* OID of equality matching rule */\u2029char *at_ordering_oid;  /* OID of ordering matching rule */\u2029char *at_substr_oid;    /* OID of substrings matching rule */\u2029char *at_syntax_oid;    /* OID of syntax of values */\u2029int  at_syntax_len;     /* Suggested minimum maximum length */\u2029int  at_single_value;   /* Is single-valued?  */\u2029int  at_collective;     /* Is collective? */\u2029int  at_no_user_mod;    /* Are changes forbidden through LDAP? */\u2029int  at_usage;          /* Usage, see below */\u2029LDAPSchemaExtensionItem **at_extensions; /* Extensions */\u2029} LDAPAttributeType;\u2029\u2029typedef struct ldap_objectclass {\u2029char *oc_oid;           /* OID */\u2029char **oc_names;        /* Names */\u2029char *oc_desc;          /* Description */\u2029int  oc_obsolete;       /* Is obsolete? */\u2029char **oc_sup_oids;     /* OIDs of superior classes */\u2029int  oc_kind;           /* Kind, see below */\u2029char **oc_at_oids_must; /* OIDs of required attribute types */\u2029char **oc_at_oids_may;  /* OIDs of optional attribute types */\u2029LDAPSchemaExtensionItem **oc_extensions; /* Extensions */\u2029} LDAPObjectClass;\u2029\u2029Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:\u2029\u2029LDAP_SCHEMA_NO\u2029The answer to the question is no.\u2029\u2029LDAP_SCHEMA_YES\u2029The answer to the question is yes.\u2029\u2029For attribute types, the following usages are possible:\u2029\u2029LDAP_SCHEMA_USER_APPLICATIONS\u2029the attribute type is non-operational.\u2029\u2029LDAP_SCHEMA_DIRECTORY_OPERATION\u2029the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.\u2029\u2029LDAP_SCHEMA_DISTRIBUTED_OPERATION\u2029the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.\u2029\u2029LDAP_SCHEMA_DSA_OPERATION\u2029the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.\u2029\u2029Object classes can be of three kinds:\u2029\u2029LDAP_SCHEMA_ABSTRACT\u2029the object class is abstract, i.e. there cannot be entries of this class alone.\u2029\u2029LDAP_SCHEMA_STRUCTURAL\u2029the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned\u2029cannot be changed: none of those present can be removed and none other can be added.\u2029\u2029LDAP_SCHEMA_AUXILIARY\u2029the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added\u2029or removed at the same time as needed by the set of object classes resulting from the operation.\u2029\u2029Routines ldap_xxx2name() return a canonical name for the definition.\u2029\u2029Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that\u2029must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.\u2029\u2029ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The\u2029argument code comes from one of the parsing routines and can adopt the following values:\u2029\u2029LDAP_SCHERR_OUTOFMEM\u2029Out of memory.\u2029\u2029LDAP_SCHERR_UNEXPTOKEN\u2029Unexpected token.\u2029\u2029LDAP_SCHERR_NOLEFTPAREN\u2029Missing opening parenthesis.\u2029\u2029LDAP_SCHERR_NORIGHTPAREN\u2029Missing closing parenthesis.\u2029\u2029LDAP_SCHERR_NODIGIT\u2029Expecting digit.\u2029\u2029LDAP_SCHERR_BADNAME\u2029Expecting a name.\u2029\u2029LDAP_SCHERR_BADDESC\u2029Bad description.\u2029\u2029LDAP_SCHERR_BADSUP\u2029Bad superiors.\u2029\u2029LDAP_SCHERR_DUPOPT\u2029Duplicate option.\u2029\u2029LDAP_SCHERR_EMPTY\u2029Unexpected end of data.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 880, "position": [958463, 966870], "check": 1, "intersection": 8408, "FP_dupl": 19474, "FN_dupl": 0, "F": 0.46337834114081017, "Prec_Dupl": 0.30155655978767665, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,\u2029ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object\u2010\u2029class_free, ldap_scherr2str - Schema definition handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029#include &amp;lt;ldap_schema.h&amp;gt;\u2029\u2029LDAPSyntax * ldap_str2syntax(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_syntax2str(syn)\u2029const LDAPSyntax * syn;\u2029\u2029const char * ldap_syntax2name(syn)\u2029LDAPSyntax * syn;\u2029\u2029ldap_syntax_free(syn)\u2029LDAPSyntax * syn;\u2029\u2029LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_matchingrule2str(mr);\u2029const LDAPMatchingRule * mr;\u2029\u2029const char * ldap_matchingrule2name(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029ldap_matchingrule_free(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_attributetype2str(at)\u2029const LDAPAttributeType * at;\u2029\u2029const char * ldap_attributetype2name(at)\u2029LDAPAttributeType * at;\u2029\u2029ldap_attributetype_free(at)\u2029LDAPAttributeType * at;\u2029\u2029LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_objectclass2str(oc)\u2029const LDAPObjectClass * oc;\u2029\u2029const char * ldap_objectclass2name(oc)\u2029LDAPObjectClass * oc;\u2029\u2029ldap_objectclass_free(oc)\u2029LDAPObjectClass * oc;\u2029\u2029char * ldap_scherr2str(code)\u2029int code;\u2029\u2029DESCRIPTION\u2029These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:\u2029syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.\u2029\u2029ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate\u2029kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,\u2029the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter\u2010\u2029minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a\u2029bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:\u2029\u2029LDAP_SCHEMA_ALLOW_NONE\u2029strict parsing according to RFC 4512.\u2029\u2029LDAP_SCHEMA_ALLOW_NO_OID\u2029permit definitions that do not contain an initial OID.\u2029\u2029LDAP_SCHEMA_ALLOW_QUOTED\u2029permit quotes around some items that should not have them.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR\u2029permit a descr instead of a numeric OID in places where the syntax expect the latter.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR_PREFIX\u2029permit that the initial numeric OID contains a prefix in descr format.\u2029\u2029LDAP_SCHEMA_ALLOW_ALL\u2029be very liberal, include all options.\u2029\u2029The structures returned are as follows:\u2029\u2029typedef struct ldap_schema_extension_item {\u2029char *lsei_name;        /* Extension name */\u2029char **lsei_values;     /* Extension values */\u2029} LDAPSchemaExtensionItem;\u2029\u2029typedef struct ldap_syntax {\u2029char *syn_oid;          /* OID */\u2029char **syn_names;       /* Names */\u2029char *syn_desc;         /* Description */\u2029LDAPSchemaExtensionItem **syn_extensions; /* Extension */\u2029} LDAPSyntax;\u2029\u2029typedef struct ldap_matchingrule {\u2029char *mr_oid;           /* OID */\u2029char **mr_names;        /* Names */\u2029char *mr_desc;          /* Description */\u2029int  mr_obsolete;       /* Is obsolete? */\u2029char *mr_syntax_oid;    /* Syntax of asserted values */\u2029LDAPSchemaExtensionItem **mr_extensions; /* Extensions */\u2029} LDAPMatchingRule;\u2029\u2029typedef struct ldap_attributetype {\u2029char *at_oid;           /* OID */\u2029char **at_names;        /* Names */\u2029char *at_desc;          /* Description */\u2029int  at_obsolete;       /* Is obsolete? */\u2029char *at_sup_oid;       /* OID of superior type */\u2029char *at_equality_oid;  /* OID of equality matching rule */\u2029char *at_ordering_oid;  /* OID of ordering matching rule */\u2029char *at_substr_oid;    /* OID of substrings matching rule */\u2029char *at_syntax_oid;    /* OID of syntax of values */\u2029int  at_syntax_len;     /* Suggested minimum maximum length */\u2029int  at_single_value;   /* Is single-valued?  */\u2029int  at_collective;     /* Is collective? */\u2029int  at_no_user_mod;    /* Are changes forbidden through LDAP? */\u2029int  at_usage;          /* Usage, see below */\u2029LDAPSchemaExtensionItem **at_extensions; /* Extensions */\u2029} LDAPAttributeType;\u2029\u2029typedef struct ldap_objectclass {\u2029char *oc_oid;           /* OID */\u2029char **oc_names;        /* Names */\u2029char *oc_desc;          /* Description */\u2029int  oc_obsolete;       /* Is obsolete? */\u2029char **oc_sup_oids;     /* OIDs of superior classes */\u2029int  oc_kind;           /* Kind, see below */\u2029char **oc_at_oids_must; /* OIDs of required attribute types */\u2029char **oc_at_oids_may;  /* OIDs of optional attribute types */\u2029LDAPSchemaExtensionItem **oc_extensions; /* Extensions */\u2029} LDAPObjectClass;\u2029\u2029Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:\u2029\u2029LDAP_SCHEMA_NO\u2029The answer to the question is no.\u2029\u2029LDAP_SCHEMA_YES\u2029The answer to the question is yes.\u2029\u2029For attribute types, the following usages are possible:\u2029\u2029LDAP_SCHEMA_USER_APPLICATIONS\u2029the attribute type is non-operational.\u2029\u2029LDAP_SCHEMA_DIRECTORY_OPERATION\u2029the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.\u2029\u2029LDAP_SCHEMA_DISTRIBUTED_OPERATION\u2029the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.\u2029\u2029LDAP_SCHEMA_DSA_OPERATION\u2029the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.\u2029\u2029Object classes can be of three kinds:\u2029\u2029LDAP_SCHEMA_ABSTRACT\u2029the object class is abstract, i.e. there cannot be entries of this class alone.\u2029\u2029LDAP_SCHEMA_STRUCTURAL\u2029the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned\u2029cannot be changed: none of those present can be removed and none other can be added.\u2029\u2029LDAP_SCHEMA_AUXILIARY\u2029the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added\u2029or removed at the same time as needed by the set of object classes resulting from the operation.\u2029\u2029Routines ldap_xxx2name() return a canonical name for the definition.\u2029\u2029Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that\u2029must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.\u2029\u2029ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The\u2029argument code comes from one of the parsing routines and can adopt the following values:\u2029\u2029LDAP_SCHERR_OUTOFMEM\u2029Out of memory.\u2029\u2029LDAP_SCHERR_UNEXPTOKEN\u2029Unexpected token.\u2029\u2029LDAP_SCHERR_NOLEFTPAREN\u2029Missing opening parenthesis.\u2029\u2029LDAP_SCHERR_NORIGHTPAREN\u2029Missing closing parenthesis.\u2029\u2029LDAP_SCHERR_NODIGIT\u2029Expecting digit.\u2029\u2029LDAP_SCHERR_BADNAME\u2029Expecting a name.\u2029\u2029LDAP_SCHERR_BADDESC\u2029Bad description.\u2029\u2029LDAP_SCHERR_BADSUP\u2029Bad superiors.\u2029\u2029LDAP_SCHERR_DUPOPT\u2029Duplicate option.\u2029\u2029LDAP_SCHERR_EMPTY\u2029Unexpected end of data.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 879, "position": [949683, 958090], "check": 1, "intersection": 8408, "FP_dupl": 19474, "FN_dupl": 0, "F": 0.46337834114081017, "Prec_Dupl": 0.30155655978767665, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,\u2029ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object\u2010\u2029class_free, ldap_scherr2str - Schema definition handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029#include &amp;lt;ldap_schema.h&amp;gt;\u2029\u2029LDAPSyntax * ldap_str2syntax(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_syntax2str(syn)\u2029const LDAPSyntax * syn;\u2029\u2029const char * ldap_syntax2name(syn)\u2029LDAPSyntax * syn;\u2029\u2029ldap_syntax_free(syn)\u2029LDAPSyntax * syn;\u2029\u2029LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_matchingrule2str(mr);\u2029const LDAPMatchingRule * mr;\u2029\u2029const char * ldap_matchingrule2name(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029ldap_matchingrule_free(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_attributetype2str(at)\u2029const LDAPAttributeType * at;\u2029\u2029const char * ldap_attributetype2name(at)\u2029LDAPAttributeType * at;\u2029\u2029ldap_attributetype_free(at)\u2029LDAPAttributeType * at;\u2029\u2029LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_objectclass2str(oc)\u2029const LDAPObjectClass * oc;\u2029\u2029const char * ldap_objectclass2name(oc)\u2029LDAPObjectClass * oc;\u2029\u2029ldap_objectclass_free(oc)\u2029LDAPObjectClass * oc;\u2029\u2029char * ldap_scherr2str(code)\u2029int code;\u2029\u2029DESCRIPTION\u2029These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:\u2029syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.\u2029\u2029ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate\u2029kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,\u2029the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter\u2010\u2029minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a\u2029bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:\u2029\u2029LDAP_SCHEMA_ALLOW_NONE\u2029strict parsing according to RFC 4512.\u2029\u2029LDAP_SCHEMA_ALLOW_NO_OID\u2029permit definitions that do not contain an initial OID.\u2029\u2029LDAP_SCHEMA_ALLOW_QUOTED\u2029permit quotes around some items that should not have them.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR\u2029permit a descr instead of a numeric OID in places where the syntax expect the latter.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR_PREFIX\u2029permit that the initial numeric OID contains a prefix in descr format.\u2029\u2029LDAP_SCHEMA_ALLOW_ALL\u2029be very liberal, include all options.\u2029\u2029The structures returned are as follows:\u2029\u2029typedef struct ldap_schema_extension_item {\u2029char *lsei_name;        /* Extension name */\u2029char **lsei_values;     /* Extension values */\u2029} LDAPSchemaExtensionItem;\u2029\u2029typedef struct ldap_syntax {\u2029char *syn_oid;          /* OID */\u2029char **syn_names;       /* Names */\u2029char *syn_desc;         /* Description */\u2029LDAPSchemaExtensionItem **syn_extensions; /* Extension */\u2029} LDAPSyntax;\u2029\u2029typedef struct ldap_matchingrule {\u2029char *mr_oid;           /* OID */\u2029char **mr_names;        /* Names */\u2029char *mr_desc;          /* Description */\u2029int  mr_obsolete;       /* Is obsolete? */\u2029char *mr_syntax_oid;    /* Syntax of asserted values */\u2029LDAPSchemaExtensionItem **mr_extensions; /* Extensions */\u2029} LDAPMatchingRule;\u2029\u2029typedef struct ldap_attributetype {\u2029char *at_oid;           /* OID */\u2029char **at_names;        /* Names */\u2029char *at_desc;          /* Description */\u2029int  at_obsolete;       /* Is obsolete? */\u2029char *at_sup_oid;       /* OID of superior type */\u2029char *at_equality_oid;  /* OID of equality matching rule */\u2029char *at_ordering_oid;  /* OID of ordering matching rule */\u2029char *at_substr_oid;    /* OID of substrings matching rule */\u2029char *at_syntax_oid;    /* OID of syntax of values */\u2029int  at_syntax_len;     /* Suggested minimum maximum length */\u2029int  at_single_value;   /* Is single-valued?  */\u2029int  at_collective;     /* Is collective? */\u2029int  at_no_user_mod;    /* Are changes forbidden through LDAP? */\u2029int  at_usage;          /* Usage, see below */\u2029LDAPSchemaExtensionItem **at_extensions; /* Extensions */\u2029} LDAPAttributeType;\u2029\u2029typedef struct ldap_objectclass {\u2029char *oc_oid;           /* OID */\u2029char **oc_names;        /* Names */\u2029char *oc_desc;          /* Description */\u2029int  oc_obsolete;       /* Is obsolete? */\u2029char **oc_sup_oids;     /* OIDs of superior classes */\u2029int  oc_kind;           /* Kind, see below */\u2029char **oc_at_oids_must; /* OIDs of required attribute types */\u2029char **oc_at_oids_may;  /* OIDs of optional attribute types */\u2029LDAPSchemaExtensionItem **oc_extensions; /* Extensions */\u2029} LDAPObjectClass;\u2029\u2029Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:\u2029\u2029LDAP_SCHEMA_NO\u2029The answer to the question is no.\u2029\u2029LDAP_SCHEMA_YES\u2029The answer to the question is yes.\u2029\u2029For attribute types, the following usages are possible:\u2029\u2029LDAP_SCHEMA_USER_APPLICATIONS\u2029the attribute type is non-operational.\u2029\u2029LDAP_SCHEMA_DIRECTORY_OPERATION\u2029the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.\u2029\u2029LDAP_SCHEMA_DISTRIBUTED_OPERATION\u2029the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.\u2029\u2029LDAP_SCHEMA_DSA_OPERATION\u2029the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.\u2029\u2029Object classes can be of three kinds:\u2029\u2029LDAP_SCHEMA_ABSTRACT\u2029the object class is abstract, i.e. there cannot be entries of this class alone.\u2029\u2029LDAP_SCHEMA_STRUCTURAL\u2029the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned\u2029cannot be changed: none of those present can be removed and none other can be added.\u2029\u2029LDAP_SCHEMA_AUXILIARY\u2029the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added\u2029or removed at the same time as needed by the set of object classes resulting from the operation.\u2029\u2029Routines ldap_xxx2name() return a canonical name for the definition.\u2029\u2029Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that\u2029must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.\u2029\u2029ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The\u2029argument code comes from one of the parsing routines and can adopt the following values:\u2029\u2029LDAP_SCHERR_OUTOFMEM\u2029Out of memory.\u2029\u2029LDAP_SCHERR_UNEXPTOKEN\u2029Unexpected token.\u2029\u2029LDAP_SCHERR_NOLEFTPAREN\u2029Missing opening parenthesis.\u2029\u2029LDAP_SCHERR_NORIGHTPAREN\u2029Missing closing parenthesis.\u2029\u2029LDAP_SCHERR_NODIGIT\u2029Expecting digit.\u2029\u2029LDAP_SCHERR_BADNAME\u2029Expecting a name.\u2029\u2029LDAP_SCHERR_BADDESC\u2029Bad description.\u2029\u2029LDAP_SCHERR_BADSUP\u2029Bad superiors.\u2029\u2029LDAP_SCHERR_DUPOPT\u2029Duplicate option.\u2029\u2029LDAP_SCHERR_EMPTY\u2029Unexpected end of data.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 878, "position": [940903, 949310], "check": 1, "intersection": 8408, "FP_dupl": 19474, "FN_dupl": 0, "F": 0.46337834114081017, "Prec_Dupl": 0.30155655978767665, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,\u2029ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object\u2010\u2029class_free, ldap_scherr2str - Schema definition handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029#include &amp;lt;ldap_schema.h&amp;gt;\u2029\u2029LDAPSyntax * ldap_str2syntax(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_syntax2str(syn)\u2029const LDAPSyntax * syn;\u2029\u2029const char * ldap_syntax2name(syn)\u2029LDAPSyntax * syn;\u2029\u2029ldap_syntax_free(syn)\u2029LDAPSyntax * syn;\u2029\u2029LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_matchingrule2str(mr);\u2029const LDAPMatchingRule * mr;\u2029\u2029const char * ldap_matchingrule2name(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029ldap_matchingrule_free(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_attributetype2str(at)\u2029const LDAPAttributeType * at;\u2029\u2029const char * ldap_attributetype2name(at)\u2029LDAPAttributeType * at;\u2029\u2029ldap_attributetype_free(at)\u2029LDAPAttributeType * at;\u2029\u2029LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_objectclass2str(oc)\u2029const LDAPObjectClass * oc;\u2029\u2029const char * ldap_objectclass2name(oc)\u2029LDAPObjectClass * oc;\u2029\u2029ldap_objectclass_free(oc)\u2029LDAPObjectClass * oc;\u2029\u2029char * ldap_scherr2str(code)\u2029int code;\u2029\u2029DESCRIPTION\u2029These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:\u2029syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.\u2029\u2029ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate\u2029kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,\u2029the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter\u2010\u2029minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a\u2029bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:\u2029\u2029LDAP_SCHEMA_ALLOW_NONE\u2029strict parsing according to RFC 4512.\u2029\u2029LDAP_SCHEMA_ALLOW_NO_OID\u2029permit definitions that do not contain an initial OID.\u2029\u2029LDAP_SCHEMA_ALLOW_QUOTED\u2029permit quotes around some items that should not have them.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR\u2029permit a descr instead of a numeric OID in places where the syntax expect the latter.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR_PREFIX\u2029permit that the initial numeric OID contains a prefix in descr format.\u2029\u2029LDAP_SCHEMA_ALLOW_ALL\u2029be very liberal, include all options.\u2029\u2029The structures returned are as follows:\u2029\u2029typedef struct ldap_schema_extension_item {\u2029char *lsei_name;        /* Extension name */\u2029char **lsei_values;     /* Extension values */\u2029} LDAPSchemaExtensionItem;\u2029\u2029typedef struct ldap_syntax {\u2029char *syn_oid;          /* OID */\u2029char **syn_names;       /* Names */\u2029char *syn_desc;         /* Description */\u2029LDAPSchemaExtensionItem **syn_extensions; /* Extension */\u2029} LDAPSyntax;\u2029\u2029typedef struct ldap_matchingrule {\u2029char *mr_oid;           /* OID */\u2029char **mr_names;        /* Names */\u2029char *mr_desc;          /* Description */\u2029int  mr_obsolete;       /* Is obsolete? */\u2029char *mr_syntax_oid;    /* Syntax of asserted values */\u2029LDAPSchemaExtensionItem **mr_extensions; /* Extensions */\u2029} LDAPMatchingRule;\u2029\u2029typedef struct ldap_attributetype {\u2029char *at_oid;           /* OID */\u2029char **at_names;        /* Names */\u2029char *at_desc;          /* Description */\u2029int  at_obsolete;       /* Is obsolete? */\u2029char *at_sup_oid;       /* OID of superior type */\u2029char *at_equality_oid;  /* OID of equality matching rule */\u2029char *at_ordering_oid;  /* OID of ordering matching rule */\u2029char *at_substr_oid;    /* OID of substrings matching rule */\u2029char *at_syntax_oid;    /* OID of syntax of values */\u2029int  at_syntax_len;     /* Suggested minimum maximum length */\u2029int  at_single_value;   /* Is single-valued?  */\u2029int  at_collective;     /* Is collective? */\u2029int  at_no_user_mod;    /* Are changes forbidden through LDAP? */\u2029int  at_usage;          /* Usage, see below */\u2029LDAPSchemaExtensionItem **at_extensions; /* Extensions */\u2029} LDAPAttributeType;\u2029\u2029typedef struct ldap_objectclass {\u2029char *oc_oid;           /* OID */\u2029char **oc_names;        /* Names */\u2029char *oc_desc;          /* Description */\u2029int  oc_obsolete;       /* Is obsolete? */\u2029char **oc_sup_oids;     /* OIDs of superior classes */\u2029int  oc_kind;           /* Kind, see below */\u2029char **oc_at_oids_must; /* OIDs of required attribute types */\u2029char **oc_at_oids_may;  /* OIDs of optional attribute types */\u2029LDAPSchemaExtensionItem **oc_extensions; /* Extensions */\u2029} LDAPObjectClass;\u2029\u2029Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:\u2029\u2029LDAP_SCHEMA_NO\u2029The answer to the question is no.\u2029\u2029LDAP_SCHEMA_YES\u2029The answer to the question is yes.\u2029\u2029For attribute types, the following usages are possible:\u2029\u2029LDAP_SCHEMA_USER_APPLICATIONS\u2029the attribute type is non-operational.\u2029\u2029LDAP_SCHEMA_DIRECTORY_OPERATION\u2029the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.\u2029\u2029LDAP_SCHEMA_DISTRIBUTED_OPERATION\u2029the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.\u2029\u2029LDAP_SCHEMA_DSA_OPERATION\u2029the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.\u2029\u2029Object classes can be of three kinds:\u2029\u2029LDAP_SCHEMA_ABSTRACT\u2029the object class is abstract, i.e. there cannot be entries of this class alone.\u2029\u2029LDAP_SCHEMA_STRUCTURAL\u2029the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned\u2029cannot be changed: none of those present can be removed and none other can be added.\u2029\u2029LDAP_SCHEMA_AUXILIARY\u2029the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added\u2029or removed at the same time as needed by the set of object classes resulting from the operation.\u2029\u2029Routines ldap_xxx2name() return a canonical name for the definition.\u2029\u2029Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that\u2029must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.\u2029\u2029ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The\u2029argument code comes from one of the parsing routines and can adopt the following values:\u2029\u2029LDAP_SCHERR_OUTOFMEM\u2029Out of memory.\u2029\u2029LDAP_SCHERR_UNEXPTOKEN\u2029Unexpected token.\u2029\u2029LDAP_SCHERR_NOLEFTPAREN\u2029Missing opening parenthesis.\u2029\u2029LDAP_SCHERR_NORIGHTPAREN\u2029Missing closing parenthesis.\u2029\u2029LDAP_SCHERR_NODIGIT\u2029Expecting digit.\u2029\u2029LDAP_SCHERR_BADNAME\u2029Expecting a name.\u2029\u2029LDAP_SCHERR_BADDESC\u2029Bad description.\u2029\u2029LDAP_SCHERR_BADSUP\u2029Bad superiors.\u2029\u2029LDAP_SCHERR_DUPOPT\u2029Duplicate option.\u2029\u2029LDAP_SCHERR_EMPTY\u2029Unexpected end of data.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 877, "position": [925656, 934063], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,\u2029ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object\u2010\u2029class_free, ldap_scherr2str - Schema definition handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029#include &amp;lt;ldap_schema.h&amp;gt;\u2029\u2029LDAPSyntax * ldap_str2syntax(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_syntax2str(syn)\u2029const LDAPSyntax * syn;\u2029\u2029const char * ldap_syntax2name(syn)\u2029LDAPSyntax * syn;\u2029\u2029ldap_syntax_free(syn)\u2029LDAPSyntax * syn;\u2029\u2029LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_matchingrule2str(mr);\u2029const LDAPMatchingRule * mr;\u2029\u2029const char * ldap_matchingrule2name(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029ldap_matchingrule_free(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_attributetype2str(at)\u2029const LDAPAttributeType * at;\u2029\u2029const char * ldap_attributetype2name(at)\u2029LDAPAttributeType * at;\u2029\u2029ldap_attributetype_free(at)\u2029LDAPAttributeType * at;\u2029\u2029LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_objectclass2str(oc)\u2029const LDAPObjectClass * oc;\u2029\u2029const char * ldap_objectclass2name(oc)\u2029LDAPObjectClass * oc;\u2029\u2029ldap_objectclass_free(oc)\u2029LDAPObjectClass * oc;\u2029\u2029char * ldap_scherr2str(code)\u2029int code;\u2029\u2029DESCRIPTION\u2029These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:\u2029syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.\u2029\u2029ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate\u2029kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,\u2029the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter\u2010\u2029minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a\u2029bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:\u2029\u2029LDAP_SCHEMA_ALLOW_NONE\u2029strict parsing according to RFC 4512.\u2029\u2029LDAP_SCHEMA_ALLOW_NO_OID\u2029permit definitions that do not contain an initial OID.\u2029\u2029LDAP_SCHEMA_ALLOW_QUOTED\u2029permit quotes around some items that should not have them.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR\u2029permit a descr instead of a numeric OID in places where the syntax expect the latter.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR_PREFIX\u2029permit that the initial numeric OID contains a prefix in descr format.\u2029\u2029LDAP_SCHEMA_ALLOW_ALL\u2029be very liberal, include all options.\u2029\u2029The structures returned are as follows:\u2029\u2029typedef struct ldap_schema_extension_item {\u2029char *lsei_name;        /* Extension name */\u2029char **lsei_values;     /* Extension values */\u2029} LDAPSchemaExtensionItem;\u2029\u2029typedef struct ldap_syntax {\u2029char *syn_oid;          /* OID */\u2029char **syn_names;       /* Names */\u2029char *syn_desc;         /* Description */\u2029LDAPSchemaExtensionItem **syn_extensions; /* Extension */\u2029} LDAPSyntax;\u2029\u2029typedef struct ldap_matchingrule {\u2029char *mr_oid;           /* OID */\u2029char **mr_names;        /* Names */\u2029char *mr_desc;          /* Description */\u2029int  mr_obsolete;       /* Is obsolete? */\u2029char *mr_syntax_oid;    /* Syntax of asserted values */\u2029LDAPSchemaExtensionItem **mr_extensions; /* Extensions */\u2029} LDAPMatchingRule;\u2029\u2029typedef struct ldap_attributetype {\u2029char *at_oid;           /* OID */\u2029char **at_names;        /* Names */\u2029char *at_desc;          /* Description */\u2029int  at_obsolete;       /* Is obsolete? */\u2029char *at_sup_oid;       /* OID of superior type */\u2029char *at_equality_oid;  /* OID of equality matching rule */\u2029char *at_ordering_oid;  /* OID of ordering matching rule */\u2029char *at_substr_oid;    /* OID of substrings matching rule */\u2029char *at_syntax_oid;    /* OID of syntax of values */\u2029int  at_syntax_len;     /* Suggested minimum maximum length */\u2029int  at_single_value;   /* Is single-valued?  */\u2029int  at_collective;     /* Is collective? */\u2029int  at_no_user_mod;    /* Are changes forbidden through LDAP? */\u2029int  at_usage;          /* Usage, see below */\u2029LDAPSchemaExtensionItem **at_extensions; /* Extensions */\u2029} LDAPAttributeType;\u2029\u2029typedef struct ldap_objectclass {\u2029char *oc_oid;           /* OID */\u2029char **oc_names;        /* Names */\u2029char *oc_desc;          /* Description */\u2029int  oc_obsolete;       /* Is obsolete? */\u2029char **oc_sup_oids;     /* OIDs of superior classes */\u2029int  oc_kind;           /* Kind, see below */\u2029char **oc_at_oids_must; /* OIDs of required attribute types */\u2029char **oc_at_oids_may;  /* OIDs of optional attribute types */\u2029LDAPSchemaExtensionItem **oc_extensions; /* Extensions */\u2029} LDAPObjectClass;\u2029\u2029Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:\u2029\u2029LDAP_SCHEMA_NO\u2029The answer to the question is no.\u2029\u2029LDAP_SCHEMA_YES\u2029The answer to the question is yes.\u2029\u2029For attribute types, the following usages are possible:\u2029\u2029LDAP_SCHEMA_USER_APPLICATIONS\u2029the attribute type is non-operational.\u2029\u2029LDAP_SCHEMA_DIRECTORY_OPERATION\u2029the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.\u2029\u2029LDAP_SCHEMA_DISTRIBUTED_OPERATION\u2029the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.\u2029\u2029LDAP_SCHEMA_DSA_OPERATION\u2029the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.\u2029\u2029Object classes can be of three kinds:\u2029\u2029LDAP_SCHEMA_ABSTRACT\u2029the object class is abstract, i.e. there cannot be entries of this class alone.\u2029\u2029LDAP_SCHEMA_STRUCTURAL\u2029the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned\u2029cannot be changed: none of those present can be removed and none other can be added.\u2029\u2029LDAP_SCHEMA_AUXILIARY\u2029the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added\u2029or removed at the same time as needed by the set of object classes resulting from the operation.\u2029\u2029Routines ldap_xxx2name() return a canonical name for the definition.\u2029\u2029Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that\u2029must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.\u2029\u2029ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The\u2029argument code comes from one of the parsing routines and can adopt the following values:\u2029\u2029LDAP_SCHERR_OUTOFMEM\u2029Out of memory.\u2029\u2029LDAP_SCHERR_UNEXPTOKEN\u2029Unexpected token.\u2029\u2029LDAP_SCHERR_NOLEFTPAREN\u2029Missing opening parenthesis.\u2029\u2029LDAP_SCHERR_NORIGHTPAREN\u2029Missing closing parenthesis.\u2029\u2029LDAP_SCHERR_NODIGIT\u2029Expecting digit.\u2029\u2029LDAP_SCHERR_BADNAME\u2029Expecting a name.\u2029\u2029LDAP_SCHERR_BADDESC\u2029Bad description.\u2029\u2029LDAP_SCHERR_BADSUP\u2029Bad superiors.\u2029\u2029LDAP_SCHERR_DUPOPT\u2029Duplicate option.\u2029\u2029LDAP_SCHERR_EMPTY\u2029Unexpected end of data.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 876, "position": [826310, 834717], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,\u2029ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object\u2010\u2029class_free, ldap_scherr2str - Schema definition handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029#include &amp;lt;ldap_schema.h&amp;gt;\u2029\u2029LDAPSyntax * ldap_str2syntax(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_syntax2str(syn)\u2029const LDAPSyntax * syn;\u2029\u2029const char * ldap_syntax2name(syn)\u2029LDAPSyntax * syn;\u2029\u2029ldap_syntax_free(syn)\u2029LDAPSyntax * syn;\u2029\u2029LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_matchingrule2str(mr);\u2029const LDAPMatchingRule * mr;\u2029\u2029const char * ldap_matchingrule2name(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029ldap_matchingrule_free(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_attributetype2str(at)\u2029const LDAPAttributeType * at;\u2029\u2029const char * ldap_attributetype2name(at)\u2029LDAPAttributeType * at;\u2029\u2029ldap_attributetype_free(at)\u2029LDAPAttributeType * at;\u2029\u2029LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_objectclass2str(oc)\u2029const LDAPObjectClass * oc;\u2029\u2029const char * ldap_objectclass2name(oc)\u2029LDAPObjectClass * oc;\u2029\u2029ldap_objectclass_free(oc)\u2029LDAPObjectClass * oc;\u2029\u2029char * ldap_scherr2str(code)\u2029int code;\u2029\u2029DESCRIPTION\u2029These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:\u2029syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.\u2029\u2029ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate\u2029kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,\u2029the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter\u2010\u2029minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a\u2029bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:\u2029\u2029LDAP_SCHEMA_ALLOW_NONE\u2029strict parsing according to RFC 4512.\u2029\u2029LDAP_SCHEMA_ALLOW_NO_OID\u2029permit definitions that do not contain an initial OID.\u2029\u2029LDAP_SCHEMA_ALLOW_QUOTED\u2029permit quotes around some items that should not have them.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR\u2029permit a descr instead of a numeric OID in places where the syntax expect the latter.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR_PREFIX\u2029permit that the initial numeric OID contains a prefix in descr format.\u2029\u2029LDAP_SCHEMA_ALLOW_ALL\u2029be very liberal, include all options.\u2029\u2029The structures returned are as follows:\u2029\u2029typedef struct ldap_schema_extension_item {\u2029char *lsei_name;        /* Extension name */\u2029char **lsei_values;     /* Extension values */\u2029} LDAPSchemaExtensionItem;\u2029\u2029typedef struct ldap_syntax {\u2029char *syn_oid;          /* OID */\u2029char **syn_names;       /* Names */\u2029char *syn_desc;         /* Description */\u2029LDAPSchemaExtensionItem **syn_extensions; /* Extension */\u2029} LDAPSyntax;\u2029\u2029typedef struct ldap_matchingrule {\u2029char *mr_oid;           /* OID */\u2029char **mr_names;        /* Names */\u2029char *mr_desc;          /* Description */\u2029int  mr_obsolete;       /* Is obsolete? */\u2029char *mr_syntax_oid;    /* Syntax of asserted values */\u2029LDAPSchemaExtensionItem **mr_extensions; /* Extensions */\u2029} LDAPMatchingRule;\u2029\u2029typedef struct ldap_attributetype {\u2029char *at_oid;           /* OID */\u2029char **at_names;        /* Names */\u2029char *at_desc;          /* Description */\u2029int  at_obsolete;       /* Is obsolete? */\u2029char *at_sup_oid;       /* OID of superior type */\u2029char *at_equality_oid;  /* OID of equality matching rule */\u2029char *at_ordering_oid;  /* OID of ordering matching rule */\u2029char *at_substr_oid;    /* OID of substrings matching rule */\u2029char *at_syntax_oid;    /* OID of syntax of values */\u2029int  at_syntax_len;     /* Suggested minimum maximum length */\u2029int  at_single_value;   /* Is single-valued?  */\u2029int  at_collective;     /* Is collective? */\u2029int  at_no_user_mod;    /* Are changes forbidden through LDAP? */\u2029int  at_usage;          /* Usage, see below */\u2029LDAPSchemaExtensionItem **at_extensions; /* Extensions */\u2029} LDAPAttributeType;\u2029\u2029typedef struct ldap_objectclass {\u2029char *oc_oid;           /* OID */\u2029char **oc_names;        /* Names */\u2029char *oc_desc;          /* Description */\u2029int  oc_obsolete;       /* Is obsolete? */\u2029char **oc_sup_oids;     /* OIDs of superior classes */\u2029int  oc_kind;           /* Kind, see below */\u2029char **oc_at_oids_must; /* OIDs of required attribute types */\u2029char **oc_at_oids_may;  /* OIDs of optional attribute types */\u2029LDAPSchemaExtensionItem **oc_extensions; /* Extensions */\u2029} LDAPObjectClass;\u2029\u2029Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:\u2029\u2029LDAP_SCHEMA_NO\u2029The answer to the question is no.\u2029\u2029LDAP_SCHEMA_YES\u2029The answer to the question is yes.\u2029\u2029For attribute types, the following usages are possible:\u2029\u2029LDAP_SCHEMA_USER_APPLICATIONS\u2029the attribute type is non-operational.\u2029\u2029LDAP_SCHEMA_DIRECTORY_OPERATION\u2029the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.\u2029\u2029LDAP_SCHEMA_DISTRIBUTED_OPERATION\u2029the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.\u2029\u2029LDAP_SCHEMA_DSA_OPERATION\u2029the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.\u2029\u2029Object classes can be of three kinds:\u2029\u2029LDAP_SCHEMA_ABSTRACT\u2029the object class is abstract, i.e. there cannot be entries of this class alone.\u2029\u2029LDAP_SCHEMA_STRUCTURAL\u2029the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned\u2029cannot be changed: none of those present can be removed and none other can be added.\u2029\u2029LDAP_SCHEMA_AUXILIARY\u2029the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added\u2029or removed at the same time as needed by the set of object classes resulting from the operation.\u2029\u2029Routines ldap_xxx2name() return a canonical name for the definition.\u2029\u2029Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that\u2029must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.\u2029\u2029ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The\u2029argument code comes from one of the parsing routines and can adopt the following values:\u2029\u2029LDAP_SCHERR_OUTOFMEM\u2029Out of memory.\u2029\u2029LDAP_SCHERR_UNEXPTOKEN\u2029Unexpected token.\u2029\u2029LDAP_SCHERR_NOLEFTPAREN\u2029Missing opening parenthesis.\u2029\u2029LDAP_SCHERR_NORIGHTPAREN\u2029Missing closing parenthesis.\u2029\u2029LDAP_SCHERR_NODIGIT\u2029Expecting digit.\u2029\u2029LDAP_SCHERR_BADNAME\u2029Expecting a name.\u2029\u2029LDAP_SCHERR_BADDESC\u2029Bad description.\u2029\u2029LDAP_SCHERR_BADSUP\u2029Bad superiors.\u2029\u2029LDAP_SCHERR_DUPOPT\u2029Duplicate option.\u2029\u2029LDAP_SCHERR_EMPTY\u2029Unexpected end of data.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 875, "position": [817530, 825937], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,\u2029ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object\u2010\u2029class_free, ldap_scherr2str - Schema definition handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029#include &amp;lt;ldap_schema.h&amp;gt;\u2029\u2029LDAPSyntax * ldap_str2syntax(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_syntax2str(syn)\u2029const LDAPSyntax * syn;\u2029\u2029const char * ldap_syntax2name(syn)\u2029LDAPSyntax * syn;\u2029\u2029ldap_syntax_free(syn)\u2029LDAPSyntax * syn;\u2029\u2029LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_matchingrule2str(mr);\u2029const LDAPMatchingRule * mr;\u2029\u2029const char * ldap_matchingrule2name(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029ldap_matchingrule_free(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_attributetype2str(at)\u2029const LDAPAttributeType * at;\u2029\u2029const char * ldap_attributetype2name(at)\u2029LDAPAttributeType * at;\u2029\u2029ldap_attributetype_free(at)\u2029LDAPAttributeType * at;\u2029\u2029LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_objectclass2str(oc)\u2029const LDAPObjectClass * oc;\u2029\u2029const char * ldap_objectclass2name(oc)\u2029LDAPObjectClass * oc;\u2029\u2029ldap_objectclass_free(oc)\u2029LDAPObjectClass * oc;\u2029\u2029char * ldap_scherr2str(code)\u2029int code;\u2029\u2029DESCRIPTION\u2029These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:\u2029syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.\u2029\u2029ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate\u2029kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,\u2029the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter\u2010\u2029minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a\u2029bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:\u2029\u2029LDAP_SCHEMA_ALLOW_NONE\u2029strict parsing according to RFC 4512.\u2029\u2029LDAP_SCHEMA_ALLOW_NO_OID\u2029permit definitions that do not contain an initial OID.\u2029\u2029LDAP_SCHEMA_ALLOW_QUOTED\u2029permit quotes around some items that should not have them.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR\u2029permit a descr instead of a numeric OID in places where the syntax expect the latter.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR_PREFIX\u2029permit that the initial numeric OID contains a prefix in descr format.\u2029\u2029LDAP_SCHEMA_ALLOW_ALL\u2029be very liberal, include all options.\u2029\u2029The structures returned are as follows:\u2029\u2029typedef struct ldap_schema_extension_item {\u2029char *lsei_name;        /* Extension name */\u2029char **lsei_values;     /* Extension values */\u2029} LDAPSchemaExtensionItem;\u2029\u2029typedef struct ldap_syntax {\u2029char *syn_oid;          /* OID */\u2029char **syn_names;       /* Names */\u2029char *syn_desc;         /* Description */\u2029LDAPSchemaExtensionItem **syn_extensions; /* Extension */\u2029} LDAPSyntax;\u2029\u2029typedef struct ldap_matchingrule {\u2029char *mr_oid;           /* OID */\u2029char **mr_names;        /* Names */\u2029char *mr_desc;          /* Description */\u2029int  mr_obsolete;       /* Is obsolete? */\u2029char *mr_syntax_oid;    /* Syntax of asserted values */\u2029LDAPSchemaExtensionItem **mr_extensions; /* Extensions */\u2029} LDAPMatchingRule;\u2029\u2029typedef struct ldap_attributetype {\u2029char *at_oid;           /* OID */\u2029char **at_names;        /* Names */\u2029char *at_desc;          /* Description */\u2029int  at_obsolete;       /* Is obsolete? */\u2029char *at_sup_oid;       /* OID of superior type */\u2029char *at_equality_oid;  /* OID of equality matching rule */\u2029char *at_ordering_oid;  /* OID of ordering matching rule */\u2029char *at_substr_oid;    /* OID of substrings matching rule */\u2029char *at_syntax_oid;    /* OID of syntax of values */\u2029int  at_syntax_len;     /* Suggested minimum maximum length */\u2029int  at_single_value;   /* Is single-valued?  */\u2029int  at_collective;     /* Is collective? */\u2029int  at_no_user_mod;    /* Are changes forbidden through LDAP? */\u2029int  at_usage;          /* Usage, see below */\u2029LDAPSchemaExtensionItem **at_extensions; /* Extensions */\u2029} LDAPAttributeType;\u2029\u2029typedef struct ldap_objectclass {\u2029char *oc_oid;           /* OID */\u2029char **oc_names;        /* Names */\u2029char *oc_desc;          /* Description */\u2029int  oc_obsolete;       /* Is obsolete? */\u2029char **oc_sup_oids;     /* OIDs of superior classes */\u2029int  oc_kind;           /* Kind, see below */\u2029char **oc_at_oids_must; /* OIDs of required attribute types */\u2029char **oc_at_oids_may;  /* OIDs of optional attribute types */\u2029LDAPSchemaExtensionItem **oc_extensions; /* Extensions */\u2029} LDAPObjectClass;\u2029\u2029Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:\u2029\u2029LDAP_SCHEMA_NO\u2029The answer to the question is no.\u2029\u2029LDAP_SCHEMA_YES\u2029The answer to the question is yes.\u2029\u2029For attribute types, the following usages are possible:\u2029\u2029LDAP_SCHEMA_USER_APPLICATIONS\u2029the attribute type is non-operational.\u2029\u2029LDAP_SCHEMA_DIRECTORY_OPERATION\u2029the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.\u2029\u2029LDAP_SCHEMA_DISTRIBUTED_OPERATION\u2029the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.\u2029\u2029LDAP_SCHEMA_DSA_OPERATION\u2029the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.\u2029\u2029Object classes can be of three kinds:\u2029\u2029LDAP_SCHEMA_ABSTRACT\u2029the object class is abstract, i.e. there cannot be entries of this class alone.\u2029\u2029LDAP_SCHEMA_STRUCTURAL\u2029the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned\u2029cannot be changed: none of those present can be removed and none other can be added.\u2029\u2029LDAP_SCHEMA_AUXILIARY\u2029the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added\u2029or removed at the same time as needed by the set of object classes resulting from the operation.\u2029\u2029Routines ldap_xxx2name() return a canonical name for the definition.\u2029\u2029Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that\u2029must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.\u2029\u2029ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The\u2029argument code comes from one of the parsing routines and can adopt the following values:\u2029\u2029LDAP_SCHERR_OUTOFMEM\u2029Out of memory.\u2029\u2029LDAP_SCHERR_UNEXPTOKEN\u2029Unexpected token.\u2029\u2029LDAP_SCHERR_NOLEFTPAREN\u2029Missing opening parenthesis.\u2029\u2029LDAP_SCHERR_NORIGHTPAREN\u2029Missing closing parenthesis.\u2029\u2029LDAP_SCHERR_NODIGIT\u2029Expecting digit.\u2029\u2029LDAP_SCHERR_BADNAME\u2029Expecting a name.\u2029\u2029LDAP_SCHERR_BADDESC\u2029Bad description.\u2029\u2029LDAP_SCHERR_BADSUP\u2029Bad superiors.\u2029\u2029LDAP_SCHERR_DUPOPT\u2029Duplicate option.\u2029\u2029LDAP_SCHERR_EMPTY\u2029Unexpected end of data.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 874, "position": [739987, 748394], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,\u2029ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object\u2010\u2029class_free, ldap_scherr2str - Schema definition handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029#include &amp;lt;ldap_schema.h&amp;gt;\u2029\u2029LDAPSyntax * ldap_str2syntax(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_syntax2str(syn)\u2029const LDAPSyntax * syn;\u2029\u2029const char * ldap_syntax2name(syn)\u2029LDAPSyntax * syn;\u2029\u2029ldap_syntax_free(syn)\u2029LDAPSyntax * syn;\u2029\u2029LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_matchingrule2str(mr);\u2029const LDAPMatchingRule * mr;\u2029\u2029const char * ldap_matchingrule2name(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029ldap_matchingrule_free(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_attributetype2str(at)\u2029const LDAPAttributeType * at;\u2029\u2029const char * ldap_attributetype2name(at)\u2029LDAPAttributeType * at;\u2029\u2029ldap_attributetype_free(at)\u2029LDAPAttributeType * at;\u2029\u2029LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_objectclass2str(oc)\u2029const LDAPObjectClass * oc;\u2029\u2029const char * ldap_objectclass2name(oc)\u2029LDAPObjectClass * oc;\u2029\u2029ldap_objectclass_free(oc)\u2029LDAPObjectClass * oc;\u2029\u2029char * ldap_scherr2str(code)\u2029int code;\u2029\u2029DESCRIPTION\u2029These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:\u2029syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.\u2029\u2029ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate\u2029kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,\u2029the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter\u2010\u2029minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a\u2029bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:\u2029\u2029LDAP_SCHEMA_ALLOW_NONE\u2029strict parsing according to RFC 4512.\u2029\u2029LDAP_SCHEMA_ALLOW_NO_OID\u2029permit definitions that do not contain an initial OID.\u2029\u2029LDAP_SCHEMA_ALLOW_QUOTED\u2029permit quotes around some items that should not have them.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR\u2029permit a descr instead of a numeric OID in places where the syntax expect the latter.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR_PREFIX\u2029permit that the initial numeric OID contains a prefix in descr format.\u2029\u2029LDAP_SCHEMA_ALLOW_ALL\u2029be very liberal, include all options.\u2029\u2029The structures returned are as follows:\u2029\u2029typedef struct ldap_schema_extension_item {\u2029char *lsei_name;        /* Extension name */\u2029char **lsei_values;     /* Extension values */\u2029} LDAPSchemaExtensionItem;\u2029\u2029typedef struct ldap_syntax {\u2029char *syn_oid;          /* OID */\u2029char **syn_names;       /* Names */\u2029char *syn_desc;         /* Description */\u2029LDAPSchemaExtensionItem **syn_extensions; /* Extension */\u2029} LDAPSyntax;\u2029\u2029typedef struct ldap_matchingrule {\u2029char *mr_oid;           /* OID */\u2029char **mr_names;        /* Names */\u2029char *mr_desc;          /* Description */\u2029int  mr_obsolete;       /* Is obsolete? */\u2029char *mr_syntax_oid;    /* Syntax of asserted values */\u2029LDAPSchemaExtensionItem **mr_extensions; /* Extensions */\u2029} LDAPMatchingRule;\u2029\u2029typedef struct ldap_attributetype {\u2029char *at_oid;           /* OID */\u2029char **at_names;        /* Names */\u2029char *at_desc;          /* Description */\u2029int  at_obsolete;       /* Is obsolete? */\u2029char *at_sup_oid;       /* OID of superior type */\u2029char *at_equality_oid;  /* OID of equality matching rule */\u2029char *at_ordering_oid;  /* OID of ordering matching rule */\u2029char *at_substr_oid;    /* OID of substrings matching rule */\u2029char *at_syntax_oid;    /* OID of syntax of values */\u2029int  at_syntax_len;     /* Suggested minimum maximum length */\u2029int  at_single_value;   /* Is single-valued?  */\u2029int  at_collective;     /* Is collective? */\u2029int  at_no_user_mod;    /* Are changes forbidden through LDAP? */\u2029int  at_usage;          /* Usage, see below */\u2029LDAPSchemaExtensionItem **at_extensions; /* Extensions */\u2029} LDAPAttributeType;\u2029\u2029typedef struct ldap_objectclass {\u2029char *oc_oid;           /* OID */\u2029char **oc_names;        /* Names */\u2029char *oc_desc;          /* Description */\u2029int  oc_obsolete;       /* Is obsolete? */\u2029char **oc_sup_oids;     /* OIDs of superior classes */\u2029int  oc_kind;           /* Kind, see below */\u2029char **oc_at_oids_must; /* OIDs of required attribute types */\u2029char **oc_at_oids_may;  /* OIDs of optional attribute types */\u2029LDAPSchemaExtensionItem **oc_extensions; /* Extensions */\u2029} LDAPObjectClass;\u2029\u2029Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:\u2029\u2029LDAP_SCHEMA_NO\u2029The answer to the question is no.\u2029\u2029LDAP_SCHEMA_YES\u2029The answer to the question is yes.\u2029\u2029For attribute types, the following usages are possible:\u2029\u2029LDAP_SCHEMA_USER_APPLICATIONS\u2029the attribute type is non-operational.\u2029\u2029LDAP_SCHEMA_DIRECTORY_OPERATION\u2029the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.\u2029\u2029LDAP_SCHEMA_DISTRIBUTED_OPERATION\u2029the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.\u2029\u2029LDAP_SCHEMA_DSA_OPERATION\u2029the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.\u2029\u2029Object classes can be of three kinds:\u2029\u2029LDAP_SCHEMA_ABSTRACT\u2029the object class is abstract, i.e. there cannot be entries of this class alone.\u2029\u2029LDAP_SCHEMA_STRUCTURAL\u2029the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned\u2029cannot be changed: none of those present can be removed and none other can be added.\u2029\u2029LDAP_SCHEMA_AUXILIARY\u2029the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added\u2029or removed at the same time as needed by the set of object classes resulting from the operation.\u2029\u2029Routines ldap_xxx2name() return a canonical name for the definition.\u2029\u2029Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that\u2029must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.\u2029\u2029ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The\u2029argument code comes from one of the parsing routines and can adopt the following values:\u2029\u2029LDAP_SCHERR_OUTOFMEM\u2029Out of memory.\u2029\u2029LDAP_SCHERR_UNEXPTOKEN\u2029Unexpected token.\u2029\u2029LDAP_SCHERR_NOLEFTPAREN\u2029Missing opening parenthesis.\u2029\u2029LDAP_SCHERR_NORIGHTPAREN\u2029Missing closing parenthesis.\u2029\u2029LDAP_SCHERR_NODIGIT\u2029Expecting digit.\u2029\u2029LDAP_SCHERR_BADNAME\u2029Expecting a name.\u2029\u2029LDAP_SCHERR_BADDESC\u2029Bad description.\u2029\u2029LDAP_SCHERR_BADSUP\u2029Bad superiors.\u2029\u2029LDAP_SCHERR_DUPOPT\u2029Duplicate option.\u2029\u2029LDAP_SCHERR_EMPTY\u2029Unexpected end of data.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 873, "position": [731207, 739614], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,\u2029ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object\u2010\u2029class_free, ldap_scherr2str - Schema definition handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029#include &amp;lt;ldap_schema.h&amp;gt;\u2029\u2029LDAPSyntax * ldap_str2syntax(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_syntax2str(syn)\u2029const LDAPSyntax * syn;\u2029\u2029const char * ldap_syntax2name(syn)\u2029LDAPSyntax * syn;\u2029\u2029ldap_syntax_free(syn)\u2029LDAPSyntax * syn;\u2029\u2029LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_matchingrule2str(mr);\u2029const LDAPMatchingRule * mr;\u2029\u2029const char * ldap_matchingrule2name(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029ldap_matchingrule_free(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_attributetype2str(at)\u2029const LDAPAttributeType * at;\u2029\u2029const char * ldap_attributetype2name(at)\u2029LDAPAttributeType * at;\u2029\u2029ldap_attributetype_free(at)\u2029LDAPAttributeType * at;\u2029\u2029LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_objectclass2str(oc)\u2029const LDAPObjectClass * oc;\u2029\u2029const char * ldap_objectclass2name(oc)\u2029LDAPObjectClass * oc;\u2029\u2029ldap_objectclass_free(oc)\u2029LDAPObjectClass * oc;\u2029\u2029char * ldap_scherr2str(code)\u2029int code;\u2029\u2029DESCRIPTION\u2029These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:\u2029syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.\u2029\u2029ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate\u2029kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,\u2029the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter\u2010\u2029minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a\u2029bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:\u2029\u2029LDAP_SCHEMA_ALLOW_NONE\u2029strict parsing according to RFC 4512.\u2029\u2029LDAP_SCHEMA_ALLOW_NO_OID\u2029permit definitions that do not contain an initial OID.\u2029\u2029LDAP_SCHEMA_ALLOW_QUOTED\u2029permit quotes around some items that should not have them.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR\u2029permit a descr instead of a numeric OID in places where the syntax expect the latter.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR_PREFIX\u2029permit that the initial numeric OID contains a prefix in descr format.\u2029\u2029LDAP_SCHEMA_ALLOW_ALL\u2029be very liberal, include all options.\u2029\u2029The structures returned are as follows:\u2029\u2029typedef struct ldap_schema_extension_item {\u2029char *lsei_name;        /* Extension name */\u2029char **lsei_values;     /* Extension values */\u2029} LDAPSchemaExtensionItem;\u2029\u2029typedef struct ldap_syntax {\u2029char *syn_oid;          /* OID */\u2029char **syn_names;       /* Names */\u2029char *syn_desc;         /* Description */\u2029LDAPSchemaExtensionItem **syn_extensions; /* Extension */\u2029} LDAPSyntax;\u2029\u2029typedef struct ldap_matchingrule {\u2029char *mr_oid;           /* OID */\u2029char **mr_names;        /* Names */\u2029char *mr_desc;          /* Description */\u2029int  mr_obsolete;       /* Is obsolete? */\u2029char *mr_syntax_oid;    /* Syntax of asserted values */\u2029LDAPSchemaExtensionItem **mr_extensions; /* Extensions */\u2029} LDAPMatchingRule;\u2029\u2029typedef struct ldap_attributetype {\u2029char *at_oid;           /* OID */\u2029char **at_names;        /* Names */\u2029char *at_desc;          /* Description */\u2029int  at_obsolete;       /* Is obsolete? */\u2029char *at_sup_oid;       /* OID of superior type */\u2029char *at_equality_oid;  /* OID of equality matching rule */\u2029char *at_ordering_oid;  /* OID of ordering matching rule */\u2029char *at_substr_oid;    /* OID of substrings matching rule */\u2029char *at_syntax_oid;    /* OID of syntax of values */\u2029int  at_syntax_len;     /* Suggested minimum maximum length */\u2029int  at_single_value;   /* Is single-valued?  */\u2029int  at_collective;     /* Is collective? */\u2029int  at_no_user_mod;    /* Are changes forbidden through LDAP? */\u2029int  at_usage;          /* Usage, see below */\u2029LDAPSchemaExtensionItem **at_extensions; /* Extensions */\u2029} LDAPAttributeType;\u2029\u2029typedef struct ldap_objectclass {\u2029char *oc_oid;           /* OID */\u2029char **oc_names;        /* Names */\u2029char *oc_desc;          /* Description */\u2029int  oc_obsolete;       /* Is obsolete? */\u2029char **oc_sup_oids;     /* OIDs of superior classes */\u2029int  oc_kind;           /* Kind, see below */\u2029char **oc_at_oids_must; /* OIDs of required attribute types */\u2029char **oc_at_oids_may;  /* OIDs of optional attribute types */\u2029LDAPSchemaExtensionItem **oc_extensions; /* Extensions */\u2029} LDAPObjectClass;\u2029\u2029Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:\u2029\u2029LDAP_SCHEMA_NO\u2029The answer to the question is no.\u2029\u2029LDAP_SCHEMA_YES\u2029The answer to the question is yes.\u2029\u2029For attribute types, the following usages are possible:\u2029\u2029LDAP_SCHEMA_USER_APPLICATIONS\u2029the attribute type is non-operational.\u2029\u2029LDAP_SCHEMA_DIRECTORY_OPERATION\u2029the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.\u2029\u2029LDAP_SCHEMA_DISTRIBUTED_OPERATION\u2029the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.\u2029\u2029LDAP_SCHEMA_DSA_OPERATION\u2029the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.\u2029\u2029Object classes can be of three kinds:\u2029\u2029LDAP_SCHEMA_ABSTRACT\u2029the object class is abstract, i.e. there cannot be entries of this class alone.\u2029\u2029LDAP_SCHEMA_STRUCTURAL\u2029the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned\u2029cannot be changed: none of those present can be removed and none other can be added.\u2029\u2029LDAP_SCHEMA_AUXILIARY\u2029the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added\u2029or removed at the same time as needed by the set of object classes resulting from the operation.\u2029\u2029Routines ldap_xxx2name() return a canonical name for the definition.\u2029\u2029Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that\u2029must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.\u2029\u2029ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The\u2029argument code comes from one of the parsing routines and can adopt the following values:\u2029\u2029LDAP_SCHERR_OUTOFMEM\u2029Out of memory.\u2029\u2029LDAP_SCHERR_UNEXPTOKEN\u2029Unexpected token.\u2029\u2029LDAP_SCHERR_NOLEFTPAREN\u2029Missing opening parenthesis.\u2029\u2029LDAP_SCHERR_NORIGHTPAREN\u2029Missing closing parenthesis.\u2029\u2029LDAP_SCHERR_NODIGIT\u2029Expecting digit.\u2029\u2029LDAP_SCHERR_BADNAME\u2029Expecting a name.\u2029\u2029LDAP_SCHERR_BADDESC\u2029Bad description.\u2029\u2029LDAP_SCHERR_BADSUP\u2029Bad superiors.\u2029\u2029LDAP_SCHERR_DUPOPT\u2029Duplicate option.\u2029\u2029LDAP_SCHERR_EMPTY\u2029Unexpected end of data.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 872, "position": [651187, 659594], "check": 1, "intersection": 8408, "FP_dupl": 19474, "FN_dupl": 0, "F": 0.46337834114081017, "Prec_Dupl": 0.30155655978767665, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,\u2029ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object\u2010\u2029class_free, ldap_scherr2str - Schema definition handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029#include &amp;lt;ldap_schema.h&amp;gt;\u2029\u2029LDAPSyntax * ldap_str2syntax(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_syntax2str(syn)\u2029const LDAPSyntax * syn;\u2029\u2029const char * ldap_syntax2name(syn)\u2029LDAPSyntax * syn;\u2029\u2029ldap_syntax_free(syn)\u2029LDAPSyntax * syn;\u2029\u2029LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_matchingrule2str(mr);\u2029const LDAPMatchingRule * mr;\u2029\u2029const char * ldap_matchingrule2name(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029ldap_matchingrule_free(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_attributetype2str(at)\u2029const LDAPAttributeType * at;\u2029\u2029const char * ldap_attributetype2name(at)\u2029LDAPAttributeType * at;\u2029\u2029ldap_attributetype_free(at)\u2029LDAPAttributeType * at;\u2029\u2029LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_objectclass2str(oc)\u2029const LDAPObjectClass * oc;\u2029\u2029const char * ldap_objectclass2name(oc)\u2029LDAPObjectClass * oc;\u2029\u2029ldap_objectclass_free(oc)\u2029LDAPObjectClass * oc;\u2029\u2029char * ldap_scherr2str(code)\u2029int code;\u2029\u2029DESCRIPTION\u2029These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:\u2029syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.\u2029\u2029ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate\u2029kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,\u2029the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter\u2010\u2029minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a\u2029bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:\u2029\u2029LDAP_SCHEMA_ALLOW_NONE\u2029strict parsing according to RFC 4512.\u2029\u2029LDAP_SCHEMA_ALLOW_NO_OID\u2029permit definitions that do not contain an initial OID.\u2029\u2029LDAP_SCHEMA_ALLOW_QUOTED\u2029permit quotes around some items that should not have them.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR\u2029permit a descr instead of a numeric OID in places where the syntax expect the latter.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR_PREFIX\u2029permit that the initial numeric OID contains a prefix in descr format.\u2029\u2029LDAP_SCHEMA_ALLOW_ALL\u2029be very liberal, include all options.\u2029\u2029The structures returned are as follows:\u2029\u2029typedef struct ldap_schema_extension_item {\u2029char *lsei_name;        /* Extension name */\u2029char **lsei_values;     /* Extension values */\u2029} LDAPSchemaExtensionItem;\u2029\u2029typedef struct ldap_syntax {\u2029char *syn_oid;          /* OID */\u2029char **syn_names;       /* Names */\u2029char *syn_desc;         /* Description */\u2029LDAPSchemaExtensionItem **syn_extensions; /* Extension */\u2029} LDAPSyntax;\u2029\u2029typedef struct ldap_matchingrule {\u2029char *mr_oid;           /* OID */\u2029char **mr_names;        /* Names */\u2029char *mr_desc;          /* Description */\u2029int  mr_obsolete;       /* Is obsolete? */\u2029char *mr_syntax_oid;    /* Syntax of asserted values */\u2029LDAPSchemaExtensionItem **mr_extensions; /* Extensions */\u2029} LDAPMatchingRule;\u2029\u2029typedef struct ldap_attributetype {\u2029char *at_oid;           /* OID */\u2029char **at_names;        /* Names */\u2029char *at_desc;          /* Description */\u2029int  at_obsolete;       /* Is obsolete? */\u2029char *at_sup_oid;       /* OID of superior type */\u2029char *at_equality_oid;  /* OID of equality matching rule */\u2029char *at_ordering_oid;  /* OID of ordering matching rule */\u2029char *at_substr_oid;    /* OID of substrings matching rule */\u2029char *at_syntax_oid;    /* OID of syntax of values */\u2029int  at_syntax_len;     /* Suggested minimum maximum length */\u2029int  at_single_value;   /* Is single-valued?  */\u2029int  at_collective;     /* Is collective? */\u2029int  at_no_user_mod;    /* Are changes forbidden through LDAP? */\u2029int  at_usage;          /* Usage, see below */\u2029LDAPSchemaExtensionItem **at_extensions; /* Extensions */\u2029} LDAPAttributeType;\u2029\u2029typedef struct ldap_objectclass {\u2029char *oc_oid;           /* OID */\u2029char **oc_names;        /* Names */\u2029char *oc_desc;          /* Description */\u2029int  oc_obsolete;       /* Is obsolete? */\u2029char **oc_sup_oids;     /* OIDs of superior classes */\u2029int  oc_kind;           /* Kind, see below */\u2029char **oc_at_oids_must; /* OIDs of required attribute types */\u2029char **oc_at_oids_may;  /* OIDs of optional attribute types */\u2029LDAPSchemaExtensionItem **oc_extensions; /* Extensions */\u2029} LDAPObjectClass;\u2029\u2029Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:\u2029\u2029LDAP_SCHEMA_NO\u2029The answer to the question is no.\u2029\u2029LDAP_SCHEMA_YES\u2029The answer to the question is yes.\u2029\u2029For attribute types, the following usages are possible:\u2029\u2029LDAP_SCHEMA_USER_APPLICATIONS\u2029the attribute type is non-operational.\u2029\u2029LDAP_SCHEMA_DIRECTORY_OPERATION\u2029the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.\u2029\u2029LDAP_SCHEMA_DISTRIBUTED_OPERATION\u2029the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.\u2029\u2029LDAP_SCHEMA_DSA_OPERATION\u2029the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.\u2029\u2029Object classes can be of three kinds:\u2029\u2029LDAP_SCHEMA_ABSTRACT\u2029the object class is abstract, i.e. there cannot be entries of this class alone.\u2029\u2029LDAP_SCHEMA_STRUCTURAL\u2029the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned\u2029cannot be changed: none of those present can be removed and none other can be added.\u2029\u2029LDAP_SCHEMA_AUXILIARY\u2029the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added\u2029or removed at the same time as needed by the set of object classes resulting from the operation.\u2029\u2029Routines ldap_xxx2name() return a canonical name for the definition.\u2029\u2029Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that\u2029must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.\u2029\u2029ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The\u2029argument code comes from one of the parsing routines and can adopt the following values:\u2029\u2029LDAP_SCHERR_OUTOFMEM\u2029Out of memory.\u2029\u2029LDAP_SCHERR_UNEXPTOKEN\u2029Unexpected token.\u2029\u2029LDAP_SCHERR_NOLEFTPAREN\u2029Missing opening parenthesis.\u2029\u2029LDAP_SCHERR_NORIGHTPAREN\u2029Missing closing parenthesis.\u2029\u2029LDAP_SCHERR_NODIGIT\u2029Expecting digit.\u2029\u2029LDAP_SCHERR_BADNAME\u2029Expecting a name.\u2029\u2029LDAP_SCHERR_BADDESC\u2029Bad description.\u2029\u2029LDAP_SCHERR_BADSUP\u2029Bad superiors.\u2029\u2029LDAP_SCHERR_DUPOPT\u2029Duplicate option.\u2029\u2029LDAP_SCHERR_EMPTY\u2029Unexpected end of data.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 871, "position": [642407, 650814], "check": 1, "intersection": 8408, "FP_dupl": 19474, "FN_dupl": 0, "F": 0.46337834114081017, "Prec_Dupl": 0.30155655978767665, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,\u2029ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object\u2010\u2029class_free, ldap_scherr2str - Schema definition handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029#include &amp;lt;ldap_schema.h&amp;gt;\u2029\u2029LDAPSyntax * ldap_str2syntax(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_syntax2str(syn)\u2029const LDAPSyntax * syn;\u2029\u2029const char * ldap_syntax2name(syn)\u2029LDAPSyntax * syn;\u2029\u2029ldap_syntax_free(syn)\u2029LDAPSyntax * syn;\u2029\u2029LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_matchingrule2str(mr);\u2029const LDAPMatchingRule * mr;\u2029\u2029const char * ldap_matchingrule2name(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029ldap_matchingrule_free(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_attributetype2str(at)\u2029const LDAPAttributeType * at;\u2029\u2029const char * ldap_attributetype2name(at)\u2029LDAPAttributeType * at;\u2029\u2029ldap_attributetype_free(at)\u2029LDAPAttributeType * at;\u2029\u2029LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_objectclass2str(oc)\u2029const LDAPObjectClass * oc;\u2029\u2029const char * ldap_objectclass2name(oc)\u2029LDAPObjectClass * oc;\u2029\u2029ldap_objectclass_free(oc)\u2029LDAPObjectClass * oc;\u2029\u2029char * ldap_scherr2str(code)\u2029int code;\u2029\u2029DESCRIPTION\u2029These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:\u2029syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.\u2029\u2029ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate\u2029kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,\u2029the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter\u2010\u2029minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a\u2029bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:\u2029\u2029LDAP_SCHEMA_ALLOW_NONE\u2029strict parsing according to RFC 4512.\u2029\u2029LDAP_SCHEMA_ALLOW_NO_OID\u2029permit definitions that do not contain an initial OID.\u2029\u2029LDAP_SCHEMA_ALLOW_QUOTED\u2029permit quotes around some items that should not have them.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR\u2029permit a descr instead of a numeric OID in places where the syntax expect the latter.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR_PREFIX\u2029permit that the initial numeric OID contains a prefix in descr format.\u2029\u2029LDAP_SCHEMA_ALLOW_ALL\u2029be very liberal, include all options.\u2029\u2029The structures returned are as follows:\u2029\u2029typedef struct ldap_schema_extension_item {\u2029char *lsei_name;        /* Extension name */\u2029char **lsei_values;     /* Extension values */\u2029} LDAPSchemaExtensionItem;\u2029\u2029typedef struct ldap_syntax {\u2029char *syn_oid;          /* OID */\u2029char **syn_names;       /* Names */\u2029char *syn_desc;         /* Description */\u2029LDAPSchemaExtensionItem **syn_extensions; /* Extension */\u2029} LDAPSyntax;\u2029\u2029typedef struct ldap_matchingrule {\u2029char *mr_oid;           /* OID */\u2029char **mr_names;        /* Names */\u2029char *mr_desc;          /* Description */\u2029int  mr_obsolete;       /* Is obsolete? */\u2029char *mr_syntax_oid;    /* Syntax of asserted values */\u2029LDAPSchemaExtensionItem **mr_extensions; /* Extensions */\u2029} LDAPMatchingRule;\u2029\u2029typedef struct ldap_attributetype {\u2029char *at_oid;           /* OID */\u2029char **at_names;        /* Names */\u2029char *at_desc;          /* Description */\u2029int  at_obsolete;       /* Is obsolete? */\u2029char *at_sup_oid;       /* OID of superior type */\u2029char *at_equality_oid;  /* OID of equality matching rule */\u2029char *at_ordering_oid;  /* OID of ordering matching rule */\u2029char *at_substr_oid;    /* OID of substrings matching rule */\u2029char *at_syntax_oid;    /* OID of syntax of values */\u2029int  at_syntax_len;     /* Suggested minimum maximum length */\u2029int  at_single_value;   /* Is single-valued?  */\u2029int  at_collective;     /* Is collective? */\u2029int  at_no_user_mod;    /* Are changes forbidden through LDAP? */\u2029int  at_usage;          /* Usage, see below */\u2029LDAPSchemaExtensionItem **at_extensions; /* Extensions */\u2029} LDAPAttributeType;\u2029\u2029typedef struct ldap_objectclass {\u2029char *oc_oid;           /* OID */\u2029char **oc_names;        /* Names */\u2029char *oc_desc;          /* Description */\u2029int  oc_obsolete;       /* Is obsolete? */\u2029char **oc_sup_oids;     /* OIDs of superior classes */\u2029int  oc_kind;           /* Kind, see below */\u2029char **oc_at_oids_must; /* OIDs of required attribute types */\u2029char **oc_at_oids_may;  /* OIDs of optional attribute types */\u2029LDAPSchemaExtensionItem **oc_extensions; /* Extensions */\u2029} LDAPObjectClass;\u2029\u2029Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:\u2029\u2029LDAP_SCHEMA_NO\u2029The answer to the question is no.\u2029\u2029LDAP_SCHEMA_YES\u2029The answer to the question is yes.\u2029\u2029For attribute types, the following usages are possible:\u2029\u2029LDAP_SCHEMA_USER_APPLICATIONS\u2029the attribute type is non-operational.\u2029\u2029LDAP_SCHEMA_DIRECTORY_OPERATION\u2029the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.\u2029\u2029LDAP_SCHEMA_DISTRIBUTED_OPERATION\u2029the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.\u2029\u2029LDAP_SCHEMA_DSA_OPERATION\u2029the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.\u2029\u2029Object classes can be of three kinds:\u2029\u2029LDAP_SCHEMA_ABSTRACT\u2029the object class is abstract, i.e. there cannot be entries of this class alone.\u2029\u2029LDAP_SCHEMA_STRUCTURAL\u2029the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned\u2029cannot be changed: none of those present can be removed and none other can be added.\u2029\u2029LDAP_SCHEMA_AUXILIARY\u2029the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added\u2029or removed at the same time as needed by the set of object classes resulting from the operation.\u2029\u2029Routines ldap_xxx2name() return a canonical name for the definition.\u2029\u2029Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that\u2029must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.\u2029\u2029ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The\u2029argument code comes from one of the parsing routines and can adopt the following values:\u2029\u2029LDAP_SCHERR_OUTOFMEM\u2029Out of memory.\u2029\u2029LDAP_SCHERR_UNEXPTOKEN\u2029Unexpected token.\u2029\u2029LDAP_SCHERR_NOLEFTPAREN\u2029Missing opening parenthesis.\u2029\u2029LDAP_SCHERR_NORIGHTPAREN\u2029Missing closing parenthesis.\u2029\u2029LDAP_SCHERR_NODIGIT\u2029Expecting digit.\u2029\u2029LDAP_SCHERR_BADNAME\u2029Expecting a name.\u2029\u2029LDAP_SCHERR_BADDESC\u2029Bad description.\u2029\u2029LDAP_SCHERR_BADSUP\u2029Bad superiors.\u2029\u2029LDAP_SCHERR_DUPOPT\u2029Duplicate option.\u2029\u2029LDAP_SCHERR_EMPTY\u2029Unexpected end of data.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 870, "position": [633627, 642034], "check": 1, "intersection": 8408, "FP_dupl": 19474, "FN_dupl": 0, "F": 0.46337834114081017, "Prec_Dupl": 0.30155655978767665, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,\u2029ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object\u2010\u2029class_free, ldap_scherr2str - Schema definition handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029#include &amp;lt;ldap_schema.h&amp;gt;\u2029\u2029LDAPSyntax * ldap_str2syntax(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_syntax2str(syn)\u2029const LDAPSyntax * syn;\u2029\u2029const char * ldap_syntax2name(syn)\u2029LDAPSyntax * syn;\u2029\u2029ldap_syntax_free(syn)\u2029LDAPSyntax * syn;\u2029\u2029LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_matchingrule2str(mr);\u2029const LDAPMatchingRule * mr;\u2029\u2029const char * ldap_matchingrule2name(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029ldap_matchingrule_free(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_attributetype2str(at)\u2029const LDAPAttributeType * at;\u2029\u2029const char * ldap_attributetype2name(at)\u2029LDAPAttributeType * at;\u2029\u2029ldap_attributetype_free(at)\u2029LDAPAttributeType * at;\u2029\u2029LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_objectclass2str(oc)\u2029const LDAPObjectClass * oc;\u2029\u2029const char * ldap_objectclass2name(oc)\u2029LDAPObjectClass * oc;\u2029\u2029ldap_objectclass_free(oc)\u2029LDAPObjectClass * oc;\u2029\u2029char * ldap_scherr2str(code)\u2029int code;\u2029\u2029DESCRIPTION\u2029These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:\u2029syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.\u2029\u2029ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate\u2029kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,\u2029the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter\u2010\u2029minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a\u2029bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:\u2029\u2029LDAP_SCHEMA_ALLOW_NONE\u2029strict parsing according to RFC 4512.\u2029\u2029LDAP_SCHEMA_ALLOW_NO_OID\u2029permit definitions that do not contain an initial OID.\u2029\u2029LDAP_SCHEMA_ALLOW_QUOTED\u2029permit quotes around some items that should not have them.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR\u2029permit a descr instead of a numeric OID in places where the syntax expect the latter.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR_PREFIX\u2029permit that the initial numeric OID contains a prefix in descr format.\u2029\u2029LDAP_SCHEMA_ALLOW_ALL\u2029be very liberal, include all options.\u2029\u2029The structures returned are as follows:\u2029\u2029typedef struct ldap_schema_extension_item {\u2029char *lsei_name;        /* Extension name */\u2029char **lsei_values;     /* Extension values */\u2029} LDAPSchemaExtensionItem;\u2029\u2029typedef struct ldap_syntax {\u2029char *syn_oid;          /* OID */\u2029char **syn_names;       /* Names */\u2029char *syn_desc;         /* Description */\u2029LDAPSchemaExtensionItem **syn_extensions; /* Extension */\u2029} LDAPSyntax;\u2029\u2029typedef struct ldap_matchingrule {\u2029char *mr_oid;           /* OID */\u2029char **mr_names;        /* Names */\u2029char *mr_desc;          /* Description */\u2029int  mr_obsolete;       /* Is obsolete? */\u2029char *mr_syntax_oid;    /* Syntax of asserted values */\u2029LDAPSchemaExtensionItem **mr_extensions; /* Extensions */\u2029} LDAPMatchingRule;\u2029\u2029typedef struct ldap_attributetype {\u2029char *at_oid;           /* OID */\u2029char **at_names;        /* Names */\u2029char *at_desc;          /* Description */\u2029int  at_obsolete;       /* Is obsolete? */\u2029char *at_sup_oid;       /* OID of superior type */\u2029char *at_equality_oid;  /* OID of equality matching rule */\u2029char *at_ordering_oid;  /* OID of ordering matching rule */\u2029char *at_substr_oid;    /* OID of substrings matching rule */\u2029char *at_syntax_oid;    /* OID of syntax of values */\u2029int  at_syntax_len;     /* Suggested minimum maximum length */\u2029int  at_single_value;   /* Is single-valued?  */\u2029int  at_collective;     /* Is collective? */\u2029int  at_no_user_mod;    /* Are changes forbidden through LDAP? */\u2029int  at_usage;          /* Usage, see below */\u2029LDAPSchemaExtensionItem **at_extensions; /* Extensions */\u2029} LDAPAttributeType;\u2029\u2029typedef struct ldap_objectclass {\u2029char *oc_oid;           /* OID */\u2029char **oc_names;        /* Names */\u2029char *oc_desc;          /* Description */\u2029int  oc_obsolete;       /* Is obsolete? */\u2029char **oc_sup_oids;     /* OIDs of superior classes */\u2029int  oc_kind;           /* Kind, see below */\u2029char **oc_at_oids_must; /* OIDs of required attribute types */\u2029char **oc_at_oids_may;  /* OIDs of optional attribute types */\u2029LDAPSchemaExtensionItem **oc_extensions; /* Extensions */\u2029} LDAPObjectClass;\u2029\u2029Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:\u2029\u2029LDAP_SCHEMA_NO\u2029The answer to the question is no.\u2029\u2029LDAP_SCHEMA_YES\u2029The answer to the question is yes.\u2029\u2029For attribute types, the following usages are possible:\u2029\u2029LDAP_SCHEMA_USER_APPLICATIONS\u2029the attribute type is non-operational.\u2029\u2029LDAP_SCHEMA_DIRECTORY_OPERATION\u2029the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.\u2029\u2029LDAP_SCHEMA_DISTRIBUTED_OPERATION\u2029the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.\u2029\u2029LDAP_SCHEMA_DSA_OPERATION\u2029the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.\u2029\u2029Object classes can be of three kinds:\u2029\u2029LDAP_SCHEMA_ABSTRACT\u2029the object class is abstract, i.e. there cannot be entries of this class alone.\u2029\u2029LDAP_SCHEMA_STRUCTURAL\u2029the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned\u2029cannot be changed: none of those present can be removed and none other can be added.\u2029\u2029LDAP_SCHEMA_AUXILIARY\u2029the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added\u2029or removed at the same time as needed by the set of object classes resulting from the operation.\u2029\u2029Routines ldap_xxx2name() return a canonical name for the definition.\u2029\u2029Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that\u2029must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.\u2029\u2029ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The\u2029argument code comes from one of the parsing routines and can adopt the following values:\u2029\u2029LDAP_SCHERR_OUTOFMEM\u2029Out of memory.\u2029\u2029LDAP_SCHERR_UNEXPTOKEN\u2029Unexpected token.\u2029\u2029LDAP_SCHERR_NOLEFTPAREN\u2029Missing opening parenthesis.\u2029\u2029LDAP_SCHERR_NORIGHTPAREN\u2029Missing closing parenthesis.\u2029\u2029LDAP_SCHERR_NODIGIT\u2029Expecting digit.\u2029\u2029LDAP_SCHERR_BADNAME\u2029Expecting a name.\u2029\u2029LDAP_SCHERR_BADDESC\u2029Bad description.\u2029\u2029LDAP_SCHERR_BADSUP\u2029Bad superiors.\u2029\u2029LDAP_SCHERR_DUPOPT\u2029Duplicate option.\u2029\u2029LDAP_SCHERR_EMPTY\u2029Unexpected end of data.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 869, "position": [401817, 410224], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,\u2029ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object\u2010\u2029class_free, ldap_scherr2str - Schema definition handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029#include &amp;lt;ldap_schema.h&amp;gt;\u2029\u2029LDAPSyntax * ldap_str2syntax(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_syntax2str(syn)\u2029const LDAPSyntax * syn;\u2029\u2029const char * ldap_syntax2name(syn)\u2029LDAPSyntax * syn;\u2029\u2029ldap_syntax_free(syn)\u2029LDAPSyntax * syn;\u2029\u2029LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_matchingrule2str(mr);\u2029const LDAPMatchingRule * mr;\u2029\u2029const char * ldap_matchingrule2name(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029ldap_matchingrule_free(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_attributetype2str(at)\u2029const LDAPAttributeType * at;\u2029\u2029const char * ldap_attributetype2name(at)\u2029LDAPAttributeType * at;\u2029\u2029ldap_attributetype_free(at)\u2029LDAPAttributeType * at;\u2029\u2029LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_objectclass2str(oc)\u2029const LDAPObjectClass * oc;\u2029\u2029const char * ldap_objectclass2name(oc)\u2029LDAPObjectClass * oc;\u2029\u2029ldap_objectclass_free(oc)\u2029LDAPObjectClass * oc;\u2029\u2029char * ldap_scherr2str(code)\u2029int code;\u2029\u2029DESCRIPTION\u2029These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:\u2029syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.\u2029\u2029ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate\u2029kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,\u2029the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter\u2010\u2029minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a\u2029bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:\u2029\u2029LDAP_SCHEMA_ALLOW_NONE\u2029strict parsing according to RFC 4512.\u2029\u2029LDAP_SCHEMA_ALLOW_NO_OID\u2029permit definitions that do not contain an initial OID.\u2029\u2029LDAP_SCHEMA_ALLOW_QUOTED\u2029permit quotes around some items that should not have them.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR\u2029permit a descr instead of a numeric OID in places where the syntax expect the latter.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR_PREFIX\u2029permit that the initial numeric OID contains a prefix in descr format.\u2029\u2029LDAP_SCHEMA_ALLOW_ALL\u2029be very liberal, include all options.\u2029\u2029The structures returned are as follows:\u2029\u2029typedef struct ldap_schema_extension_item {\u2029char *lsei_name;        /* Extension name */\u2029char **lsei_values;     /* Extension values */\u2029} LDAPSchemaExtensionItem;\u2029\u2029typedef struct ldap_syntax {\u2029char *syn_oid;          /* OID */\u2029char **syn_names;       /* Names */\u2029char *syn_desc;         /* Description */\u2029LDAPSchemaExtensionItem **syn_extensions; /* Extension */\u2029} LDAPSyntax;\u2029\u2029typedef struct ldap_matchingrule {\u2029char *mr_oid;           /* OID */\u2029char **mr_names;        /* Names */\u2029char *mr_desc;          /* Description */\u2029int  mr_obsolete;       /* Is obsolete? */\u2029char *mr_syntax_oid;    /* Syntax of asserted values */\u2029LDAPSchemaExtensionItem **mr_extensions; /* Extensions */\u2029} LDAPMatchingRule;\u2029\u2029typedef struct ldap_attributetype {\u2029char *at_oid;           /* OID */\u2029char **at_names;        /* Names */\u2029char *at_desc;          /* Description */\u2029int  at_obsolete;       /* Is obsolete? */\u2029char *at_sup_oid;       /* OID of superior type */\u2029char *at_equality_oid;  /* OID of equality matching rule */\u2029char *at_ordering_oid;  /* OID of ordering matching rule */\u2029char *at_substr_oid;    /* OID of substrings matching rule */\u2029char *at_syntax_oid;    /* OID of syntax of values */\u2029int  at_syntax_len;     /* Suggested minimum maximum length */\u2029int  at_single_value;   /* Is single-valued?  */\u2029int  at_collective;     /* Is collective? */\u2029int  at_no_user_mod;    /* Are changes forbidden through LDAP? */\u2029int  at_usage;          /* Usage, see below */\u2029LDAPSchemaExtensionItem **at_extensions; /* Extensions */\u2029} LDAPAttributeType;\u2029\u2029typedef struct ldap_objectclass {\u2029char *oc_oid;           /* OID */\u2029char **oc_names;        /* Names */\u2029char *oc_desc;          /* Description */\u2029int  oc_obsolete;       /* Is obsolete? */\u2029char **oc_sup_oids;     /* OIDs of superior classes */\u2029int  oc_kind;           /* Kind, see below */\u2029char **oc_at_oids_must; /* OIDs of required attribute types */\u2029char **oc_at_oids_may;  /* OIDs of optional attribute types */\u2029LDAPSchemaExtensionItem **oc_extensions; /* Extensions */\u2029} LDAPObjectClass;\u2029\u2029Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:\u2029\u2029LDAP_SCHEMA_NO\u2029The answer to the question is no.\u2029\u2029LDAP_SCHEMA_YES\u2029The answer to the question is yes.\u2029\u2029For attribute types, the following usages are possible:\u2029\u2029LDAP_SCHEMA_USER_APPLICATIONS\u2029the attribute type is non-operational.\u2029\u2029LDAP_SCHEMA_DIRECTORY_OPERATION\u2029the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.\u2029\u2029LDAP_SCHEMA_DISTRIBUTED_OPERATION\u2029the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.\u2029\u2029LDAP_SCHEMA_DSA_OPERATION\u2029the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.\u2029\u2029Object classes can be of three kinds:\u2029\u2029LDAP_SCHEMA_ABSTRACT\u2029the object class is abstract, i.e. there cannot be entries of this class alone.\u2029\u2029LDAP_SCHEMA_STRUCTURAL\u2029the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned\u2029cannot be changed: none of those present can be removed and none other can be added.\u2029\u2029LDAP_SCHEMA_AUXILIARY\u2029the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added\u2029or removed at the same time as needed by the set of object classes resulting from the operation.\u2029\u2029Routines ldap_xxx2name() return a canonical name for the definition.\u2029\u2029Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that\u2029must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.\u2029\u2029ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The\u2029argument code comes from one of the parsing routines and can adopt the following values:\u2029\u2029LDAP_SCHERR_OUTOFMEM\u2029Out of memory.\u2029\u2029LDAP_SCHERR_UNEXPTOKEN\u2029Unexpected token.\u2029\u2029LDAP_SCHERR_NOLEFTPAREN\u2029Missing opening parenthesis.\u2029\u2029LDAP_SCHERR_NORIGHTPAREN\u2029Missing closing parenthesis.\u2029\u2029LDAP_SCHERR_NODIGIT\u2029Expecting digit.\u2029\u2029LDAP_SCHERR_BADNAME\u2029Expecting a name.\u2029\u2029LDAP_SCHERR_BADDESC\u2029Bad description.\u2029\u2029LDAP_SCHERR_BADSUP\u2029Bad superiors.\u2029\u2029LDAP_SCHERR_DUPOPT\u2029Duplicate option.\u2029\u2029LDAP_SCHERR_EMPTY\u2029Unexpected end of data.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 868, "position": [393037, 401444], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,\u2029ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object\u2010\u2029class_free, ldap_scherr2str - Schema definition handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029#include &amp;lt;ldap_schema.h&amp;gt;\u2029\u2029LDAPSyntax * ldap_str2syntax(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_syntax2str(syn)\u2029const LDAPSyntax * syn;\u2029\u2029const char * ldap_syntax2name(syn)\u2029LDAPSyntax * syn;\u2029\u2029ldap_syntax_free(syn)\u2029LDAPSyntax * syn;\u2029\u2029LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_matchingrule2str(mr);\u2029const LDAPMatchingRule * mr;\u2029\u2029const char * ldap_matchingrule2name(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029ldap_matchingrule_free(mr)\u2029LDAPMatchingRule * mr;\u2029\u2029LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_attributetype2str(at)\u2029const LDAPAttributeType * at;\u2029\u2029const char * ldap_attributetype2name(at)\u2029LDAPAttributeType * at;\u2029\u2029ldap_attributetype_free(at)\u2029LDAPAttributeType * at;\u2029\u2029LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)\u2029const char * s;\u2029int * code;\u2029const char ** errp;\u2029const int flags;\u2029\u2029char * ldap_objectclass2str(oc)\u2029const LDAPObjectClass * oc;\u2029\u2029const char * ldap_objectclass2name(oc)\u2029LDAPObjectClass * oc;\u2029\u2029ldap_objectclass_free(oc)\u2029LDAPObjectClass * oc;\u2029\u2029char * ldap_scherr2str(code)\u2029int code;\u2029\u2029DESCRIPTION\u2029These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:\u2029syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.\u2029\u2029ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate\u2029kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,\u2029the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter\u2010\u2029minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a\u2029bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:\u2029\u2029LDAP_SCHEMA_ALLOW_NONE\u2029strict parsing according to RFC 4512.\u2029\u2029LDAP_SCHEMA_ALLOW_NO_OID\u2029permit definitions that do not contain an initial OID.\u2029\u2029LDAP_SCHEMA_ALLOW_QUOTED\u2029permit quotes around some items that should not have them.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR\u2029permit a descr instead of a numeric OID in places where the syntax expect the latter.\u2029\u2029LDAP_SCHEMA_ALLOW_DESCR_PREFIX\u2029permit that the initial numeric OID contains a prefix in descr format.\u2029\u2029LDAP_SCHEMA_ALLOW_ALL\u2029be very liberal, include all options.\u2029\u2029The structures returned are as follows:\u2029\u2029typedef struct ldap_schema_extension_item {\u2029char *lsei_name;        /* Extension name */\u2029char **lsei_values;     /* Extension values */\u2029} LDAPSchemaExtensionItem;\u2029\u2029typedef struct ldap_syntax {\u2029char *syn_oid;          /* OID */\u2029char **syn_names;       /* Names */\u2029char *syn_desc;         /* Description */\u2029LDAPSchemaExtensionItem **syn_extensions; /* Extension */\u2029} LDAPSyntax;\u2029\u2029typedef struct ldap_matchingrule {\u2029char *mr_oid;           /* OID */\u2029char **mr_names;        /* Names */\u2029char *mr_desc;          /* Description */\u2029int  mr_obsolete;       /* Is obsolete? */\u2029char *mr_syntax_oid;    /* Syntax of asserted values */\u2029LDAPSchemaExtensionItem **mr_extensions; /* Extensions */\u2029} LDAPMatchingRule;\u2029\u2029typedef struct ldap_attributetype {\u2029char *at_oid;           /* OID */\u2029char **at_names;        /* Names */\u2029char *at_desc;          /* Description */\u2029int  at_obsolete;       /* Is obsolete? */\u2029char *at_sup_oid;       /* OID of superior type */\u2029char *at_equality_oid;  /* OID of equality matching rule */\u2029char *at_ordering_oid;  /* OID of ordering matching rule */\u2029char *at_substr_oid;    /* OID of substrings matching rule */\u2029char *at_syntax_oid;    /* OID of syntax of values */\u2029int  at_syntax_len;     /* Suggested minimum maximum length */\u2029int  at_single_value;   /* Is single-valued?  */\u2029int  at_collective;     /* Is collective? */\u2029int  at_no_user_mod;    /* Are changes forbidden through LDAP? */\u2029int  at_usage;          /* Usage, see below */\u2029LDAPSchemaExtensionItem **at_extensions; /* Extensions */\u2029} LDAPAttributeType;\u2029\u2029typedef struct ldap_objectclass {\u2029char *oc_oid;           /* OID */\u2029char **oc_names;        /* Names */\u2029char *oc_desc;          /* Description */\u2029int  oc_obsolete;       /* Is obsolete? */\u2029char **oc_sup_oids;     /* OIDs of superior classes */\u2029int  oc_kind;           /* Kind, see below */\u2029char **oc_at_oids_must; /* OIDs of required attribute types */\u2029char **oc_at_oids_may;  /* OIDs of optional attribute types */\u2029LDAPSchemaExtensionItem **oc_extensions; /* Extensions */\u2029} LDAPObjectClass;\u2029\u2029Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:\u2029\u2029LDAP_SCHEMA_NO\u2029The answer to the question is no.\u2029\u2029LDAP_SCHEMA_YES\u2029The answer to the question is yes.\u2029\u2029For attribute types, the following usages are possible:\u2029\u2029LDAP_SCHEMA_USER_APPLICATIONS\u2029the attribute type is non-operational.\u2029\u2029LDAP_SCHEMA_DIRECTORY_OPERATION\u2029the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute\u2029type.\u2029\u2029LDAP_SCHEMA_DISTRIBUTED_OPERATION\u2029the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.\u2029\u2029LDAP_SCHEMA_DSA_OPERATION\u2029the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different\u2029servers that master the entry.\u2029\u2029Object classes can be of three kinds:\u2029\u2029LDAP_SCHEMA_ABSTRACT\u2029the object class is abstract, i.e. there cannot be entries of this class alone.\u2029\u2029LDAP_SCHEMA_STRUCTURAL\u2029the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned\u2029cannot be changed: none of those present can be removed and none other can be added.\u2029\u2029LDAP_SCHEMA_AUXILIARY\u2029the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added\u2029or removed at the same time as needed by the set of object classes resulting from the operation.\u2029\u2029Routines ldap_xxx2name() return a canonical name for the definition.\u2029\u2029Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that\u2029must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.\u2029\u2029ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The\u2029argument code comes from one of the parsing routines and can adopt the following values:\u2029\u2029LDAP_SCHERR_OUTOFMEM\u2029Out of memory.\u2029\u2029LDAP_SCHERR_UNEXPTOKEN\u2029Unexpected token.\u2029\u2029LDAP_SCHERR_NOLEFTPAREN\u2029Missing opening parenthesis.\u2029\u2029LDAP_SCHERR_NORIGHTPAREN\u2029Missing closing parenthesis.\u2029\u2029LDAP_SCHERR_NODIGIT\u2029Expecting digit.\u2029\u2029LDAP_SCHERR_BADNAME\u2029Expecting a name.\u2029\u2029LDAP_SCHERR_BADDESC\u2029Bad description.\u2029\u2029LDAP_SCHERR_BADSUP\u2029Bad superiors.\u2029\u2029LDAP_SCHERR_DUPOPT\u2029Duplicate option.\u2029\u2029LDAP_SCHERR_EMPTY\u2029Unexpected end of data.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 867, "position": [384257, 392664], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "48", "annotation": "LDAP_BIND", "group_ids": [{"name2": "NAME\u2029ldap_bind,   ldap_bind_s,   ldap_simple_bind,  ldap_simple_bind_s,  ldap_sasl_bind,  ldap_sasl_bind_s,  ldap_sasl_interactive_bind_s,  ldap_parse_sasl_bind_result,  ldap_unbind,\u2029ldap_unbind_s, ldap_unbind_ext, ldap_unbind_ext_s, ldap_set_rebind_proc - LDAP bind routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_bind(LDAP *ld, const char *who, const char *cred,\u2029int method);\u2029\u2029int ldap_bind_s(LDAP *ld, const char *who, const char *cred,\u2029int method);\u2029\u2029int ldap_simple_bind(LDAP *ld, const char *who, const char *passwd);\u2029\u2029int ldap_simple_bind_s(LDAP *ld, const char *who, const char *passwd);\u2029\u2029int ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,\u2029struct berval *cred, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[], int *msgidp);\u2029\u2029int ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,\u2029struct berval *cred, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[], struct berval **servercredp);\u2029\u2029int ldap_parse_sasl_bind_result(LDAP *ld, LDAPMessage *res,\u2029struct berval **servercredp, int freeit);\u2029\u2029int ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn,\u2029const char *mechs,\u2029LDAPControl *sctrls[], LDAPControl *cctrls[],\u2029unsigned flags, LDAP_SASL_INTERACT_PROC *interact,\u2029void *defaults);\u2029\u2029int ldap_sasl_interactive_bind(LDAP *ld, const char *dn,\u2029const char *mechs,\u2029LDAPControl *sctrls[], LDAPControl *cctrls[],\u2029unsigned flags, LDAP_SASL_INTERACT_PROC *interact,\u2029void *defaults, LDAPMessage *result,\u2029const char **rmechp, int *msgidp);\u2029\u2029int (LDAP_SASL_INTERACT_PROC)(LDAP *ld, unsigned flags, void *defaults, void *sasl_interact);\u2029\u2029int ldap_unbind(LDAP *ld);\u2029\u2029int ldap_unbind_s(LDAP *ld);\u2029\u2029int ldap_unbind_ext(LDAP *ld, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[]);\u2029\u2029int ldap_unbind_ext_s(LDAP *ld, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[]);\u2029\u2029int ldap_set_rebind_proc (LDAP *ld, LDAP_REBIND_PROC *ldap_proc, void *params);\u2029\u2029int (LDAP_REBIND_PROC)(LDAP *ld, LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *params);\u2029\u2029DESCRIPTION\u2029These routines provide various interfaces to the LDAP bind operation.  After an association with an LDAP server is made using ldap_init(3), an LDAP bind operation should be per\u2010\u2029formed  before  other operations are attempted over the connection.  An LDAP bind is required when using Version 2 of the LDAP protocol; it is optional for Version 3 but is usu\u2010\u2029ally needed due to security considerations.\u2029\u2029There are three types of bind calls, ones providing simple authentication, ones providing SASL authentication, and general routines  capable  of  doing  either  simple  or  SASL\u2029authentication.\u2029\u2029SASL  (Simple  Authentication and Security Layer) can negotiate one of many different kinds of authentication.  Both synchronous and asynchronous versions of each variant of the\u2029bind call are provided.  All routines take ld as their first parameter, as returned from ldap_init(3).\u2029\u2029SIMPLE AUTHENTICATION\u2029The simplest form of the bind call is ldap_simple_bind_s().  It takes the DN to bind as in who, and the userPassword associated with the entry in passwd.   It  returns  an  LDAP\u2029error  indication  (see ldap_error(3)).  The ldap_simple_bind() call is asynchronous, taking the same parameters but only initiating the bind operation and returning the message\u2029id of the request it sent.  The result of the operation can be obtained by a subsequent call to ldap_result(3).\u2029\u2029GENERAL AUTHENTICATION\u2029The ldap_bind() and ldap_bind_s() routines can be used when the authentication method to use needs to be selected at runtime.  They both take an extra method parameter selecting\u2029the  authentication  method  to  use.   It  should  be  set to LDAP_AUTH_SIMPLE to select simple authentication.  ldap_bind() returns the message id of the request it initiates.\u2029ldap_bind_s() returns an LDAP error indication.\u2029\u2029SASL AUTHENTICATION\u2029For SASL binds the server always ignores any provided DN, so the dn parameter should always be NULL.  ldap_sasl_bind_s() sends a single SASL bind request  with  the  given  SASL\u2029mechanism and credentials in the cred parameter. The format of the credentials depends on the particular SASL mechanism in use. For mechanisms that provide mutual authentication\u2029the server's credentials will be returned in the servercredp parameter.  The routine returns an LDAP error indication (see ldap_error(3)).  The ldap_sasl_bind()  call  is  asyn\u2010\u2029chronous,  taking  the  same parameters but only sending the request and returning the message id of the request it sent. The result of the operation can be obtained by a subse\u2010\u2029quent call to ldap_result(3).  The result must be additionally parsed by ldap_parse_sasl_bind_result() to obtain any server credentials sent from the server.\u2029\u2029Many SASL mechanisms require multiple message exchanges to perform a complete authentication. Applications should generally use ldap_sasl_interactive_bind_s() rather than  call\u2010\u2029ing  the  basic ldap_sasl_bind() functions directly. The mechs parameter should contain a space-separated list of candidate mechanisms to use. If this parameter is NULL or empty\u2029the library will query the supportedSASLMechanisms attribute from the server's rootDSE for the list of SASL mechanisms the server supports.  The  flags  parameter  controls  the\u2029interaction used to retrieve any necessary SASL authentication parameters and should be one of:\u2029\u2029LDAP_SASL_AUTOMATIC\u2029use defaults if available, prompt otherwise\u2029\u2029LDAP_SASL_INTERACTIVE\u2029always prompt\u2029\u2029LDAP_SASL_QUIET\u2029never prompt\u2029\u2029The  interact  function uses the provided defaults to handle requests from the SASL library for particular authentication parameters. There is no defined format for the defaults\u2029information; it is up to the caller to use whatever format is appropriate for the supplied interact function.   The  sasl_interact  parameter  comes  from  the  underlying  SASL\u2029library. When used with Cyrus SASL this is an array of sasl_interact_t structures. The Cyrus SASL library will prompt for a variety of inputs, including:\u2029\u2029SASL_CB_GETREALM\u2029the realm for the authentication attempt\u2029\u2029SASL_CB_AUTHNAME\u2029the username to authenticate\u2029\u2029SASL_CB_PASS\u2029the password for the provided username\u2029\u2029SASL_CB_USER\u2029the username to use for proxy authorization\u2029\u2029SASL_CB_NOECHOPROMPT\u2029generic prompt for input with input echoing disabled\u2029\u2029SASL_CB_ECHOPROMPT\u2029generic prompt for input with input echoing enabled\u2029\u2029SASL_CB_LIST_END\u2029indicates the end of the array of prompts\u2029\u2029See the Cyrus SASL documentation for more details.\u2029\u2029Applications  which need to manage connections asynchronously may use ldap_sasl_interactive_bind() instead of the synchronous version.  A valid mechs parameter must be supplied,\u2029otherwise the library will be forced to query the server for a list of supported mechanisms, and this query will be performed synchronously.  The other parameters are  the  same\u2029as  for  the  synchronous function, with three additional parameters.  The actual SASL mechanism that was used, and the message ID for use with ldap_result() will be returned in\u2029rmechp and msgidp, respectively.  The value in rmechp must not be modified by the caller and must be passed back on each subsequent call. The message obtained from ldap_result()\u2029must  be  passed  in the result parameter.  This parameter must be NULL when initiating a new Bind. The caller must free the result message after each call using ldap_msgfree().\u2029The ldap_sasl_interactive_bind() function returns an LDAP result code. If the code is LDAP_SASL_BIND_IN_PROGRESS then the Bind is not complete yet, and  this  function  must  be\u2029called again with the next result from the server.\u2029\u2029REBINDING\u2029The  ldap_set_rebind_proc function() sets the process to use for binding when an operation returns a referral. This function is used when an application needs to bind to another\u2029server in order to follow a referral or search continuation reference.\u2029\u2029The function takes ld, the rebind function, and the params, the arbitrary data like state information which the client might need to  properly  rebind.   The  LDAP_OPT_REFERRALS\u2029option in the ld must be set to ON for the libraries to use the rebind function. Use the ldap_set_option function to set the value.\u2029\u2029The rebind function parameters are as follows:\u2029\u2029The ld parameter must be used by the application when binding to the referred server if the application wants the libraries to follow the referral.\u2029\u2029The url parameter points to the URL referral string received from the LDAP server.  The LDAP application can use the ldap_url_parse(3) function to parse the string into its com\u2010\u2029ponents.\u2029\u2029The request parameter specifies the type of request that generated the referral.\u2029\u2029The msgid parameter specifies the message ID of the request generating the referral.\u2029\u2029The params parameter is the same value as passed originally to the ldap_set_rebind_proc() function.\u2029\u2029The LDAP libraries set all the parameters when they call the rebind function. The application should not attempt to free either the ld or the url structures in the rebind  func\u2010\u2029tion.\u2029\u2029The  application  must  supply to the rebind function the required authentication information such as, user name, password, and certificates. The rebind function must use a syn\u2010\u2029chronous bind method.\u2029\u2029UNBINDING\u2029The ldap_unbind() call is used to unbind from the directory, terminate the current association, and free the resources contained in the ld structure.  Once  it  is  called,  the\u2029connection  to  the LDAP server is closed, and the ld structure is invalid.  The ldap_unbind_s() call is just another name for ldap_unbind(); both of these calls are synchronous\u2029in nature.\u2029\u2029The ldap_unbind_ext() and ldap_unbind_ext_s() allows the operations to specify  controls.\u2029\u2029ERRORS\u2029Asynchronous routines will return -1 in case of error, setting the ld_errno parameter of the ld structure.  Synchronous  routines  return  whatever  ld_errno  is  set  to.   See\u2029ldap_error(3) for more information.\u2029\u2029NOTES\u2029If  an anonymous bind is sufficient for the application, the rebind process need not be provided. The LDAP libraries with the LDAP_OPT_REFERRALS option set to ON (default value)\u2029will automatically follow referrals using an anonymous bind.\u2029\u2029If the application needs stronger authentication than an anonymous bind, you need to provide a rebind process for that authentication method.  The bind method must  be  synchro\u2010\u2029nous.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_open(3), ldap_set_option(3), ldap_url_parse(3) RFC 4422 (http://www.rfc-editor.org), Cyrus SASL (http://asg.web.cmu.edu/sasl/)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 895, "position": [1040923, 1051605], "check": 1, "intersection": 10683, "FP_dupl": 11430, "FN_dupl": 0, "F": 0.6514818880351262, "Prec_Dupl": 0.4831094831094831, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_bind,   ldap_bind_s,   ldap_simple_bind,  ldap_simple_bind_s,  ldap_sasl_bind,  ldap_sasl_bind_s,  ldap_sasl_interactive_bind_s,  ldap_parse_sasl_bind_result,  ldap_unbind,\u2029ldap_unbind_s, ldap_unbind_ext, ldap_unbind_ext_s, ldap_set_rebind_proc - LDAP bind routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_bind(LDAP *ld, const char *who, const char *cred,\u2029int method);\u2029\u2029int ldap_bind_s(LDAP *ld, const char *who, const char *cred,\u2029int method);\u2029\u2029int ldap_simple_bind(LDAP *ld, const char *who, const char *passwd);\u2029\u2029int ldap_simple_bind_s(LDAP *ld, const char *who, const char *passwd);\u2029\u2029int ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,\u2029struct berval *cred, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[], int *msgidp);\u2029\u2029int ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,\u2029struct berval *cred, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[], struct berval **servercredp);\u2029\u2029int ldap_parse_sasl_bind_result(LDAP *ld, LDAPMessage *res,\u2029struct berval **servercredp, int freeit);\u2029\u2029int ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn,\u2029const char *mechs,\u2029LDAPControl *sctrls[], LDAPControl *cctrls[],\u2029unsigned flags, LDAP_SASL_INTERACT_PROC *interact,\u2029void *defaults);\u2029\u2029int ldap_sasl_interactive_bind(LDAP *ld, const char *dn,\u2029const char *mechs,\u2029LDAPControl *sctrls[], LDAPControl *cctrls[],\u2029unsigned flags, LDAP_SASL_INTERACT_PROC *interact,\u2029void *defaults, LDAPMessage *result,\u2029const char **rmechp, int *msgidp);\u2029\u2029int (LDAP_SASL_INTERACT_PROC)(LDAP *ld, unsigned flags, void *defaults, void *sasl_interact);\u2029\u2029int ldap_unbind(LDAP *ld);\u2029\u2029int ldap_unbind_s(LDAP *ld);\u2029\u2029int ldap_unbind_ext(LDAP *ld, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[]);\u2029\u2029int ldap_unbind_ext_s(LDAP *ld, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[]);\u2029\u2029int ldap_set_rebind_proc (LDAP *ld, LDAP_REBIND_PROC *ldap_proc, void *params);\u2029\u2029int (LDAP_REBIND_PROC)(LDAP *ld, LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *params);\u2029\u2029DESCRIPTION\u2029These routines provide various interfaces to the LDAP bind operation.  After an association with an LDAP server is made using ldap_init(3), an LDAP bind operation should be per\u2010\u2029formed  before  other operations are attempted over the connection.  An LDAP bind is required when using Version 2 of the LDAP protocol; it is optional for Version 3 but is usu\u2010\u2029ally needed due to security considerations.\u2029\u2029There are three types of bind calls, ones providing simple authentication, ones providing SASL authentication, and general routines  capable  of  doing  either  simple  or  SASL\u2029authentication.\u2029\u2029SASL  (Simple  Authentication and Security Layer) can negotiate one of many different kinds of authentication.  Both synchronous and asynchronous versions of each variant of the\u2029bind call are provided.  All routines take ld as their first parameter, as returned from ldap_init(3).\u2029\u2029SIMPLE AUTHENTICATION\u2029The simplest form of the bind call is ldap_simple_bind_s().  It takes the DN to bind as in who, and the userPassword associated with the entry in passwd.   It  returns  an  LDAP\u2029error  indication  (see ldap_error(3)).  The ldap_simple_bind() call is asynchronous, taking the same parameters but only initiating the bind operation and returning the message\u2029id of the request it sent.  The result of the operation can be obtained by a subsequent call to ldap_result(3).\u2029\u2029GENERAL AUTHENTICATION\u2029The ldap_bind() and ldap_bind_s() routines can be used when the authentication method to use needs to be selected at runtime.  They both take an extra method parameter selecting\u2029the  authentication  method  to  use.   It  should  be  set to LDAP_AUTH_SIMPLE to select simple authentication.  ldap_bind() returns the message id of the request it initiates.\u2029ldap_bind_s() returns an LDAP error indication.\u2029\u2029SASL AUTHENTICATION\u2029For SASL binds the server always ignores any provided DN, so the dn parameter should always be NULL.  ldap_sasl_bind_s() sends a single SASL bind request  with  the  given  SASL\u2029mechanism and credentials in the cred parameter. The format of the credentials depends on the particular SASL mechanism in use. For mechanisms that provide mutual authentication\u2029the server's credentials will be returned in the servercredp parameter.  The routine returns an LDAP error indication (see ldap_error(3)).  The ldap_sasl_bind()  call  is  asyn\u2010\u2029chronous,  taking  the  same parameters but only sending the request and returning the message id of the request it sent. The result of the operation can be obtained by a subse\u2010\u2029quent call to ldap_result(3).  The result must be additionally parsed by ldap_parse_sasl_bind_result() to obtain any server credentials sent from the server.\u2029\u2029Many SASL mechanisms require multiple message exchanges to perform a complete authentication. Applications should generally use ldap_sasl_interactive_bind_s() rather than  call\u2010\u2029ing  the  basic ldap_sasl_bind() functions directly. The mechs parameter should contain a space-separated list of candidate mechanisms to use. If this parameter is NULL or empty\u2029the library will query the supportedSASLMechanisms attribute from the server's rootDSE for the list of SASL mechanisms the server supports.  The  flags  parameter  controls  the\u2029interaction used to retrieve any necessary SASL authentication parameters and should be one of:\u2029\u2029LDAP_SASL_AUTOMATIC\u2029use defaults if available, prompt otherwise\u2029\u2029LDAP_SASL_INTERACTIVE\u2029always prompt\u2029\u2029LDAP_SASL_QUIET\u2029never prompt\u2029\u2029The  interact  function uses the provided defaults to handle requests from the SASL library for particular authentication parameters. There is no defined format for the defaults\u2029information; it is up to the caller to use whatever format is appropriate for the supplied interact function.   The  sasl_interact  parameter  comes  from  the  underlying  SASL\u2029library. When used with Cyrus SASL this is an array of sasl_interact_t structures. The Cyrus SASL library will prompt for a variety of inputs, including:\u2029\u2029SASL_CB_GETREALM\u2029the realm for the authentication attempt\u2029\u2029SASL_CB_AUTHNAME\u2029the username to authenticate\u2029\u2029SASL_CB_PASS\u2029the password for the provided username\u2029\u2029SASL_CB_USER\u2029the username to use for proxy authorization\u2029\u2029SASL_CB_NOECHOPROMPT\u2029generic prompt for input with input echoing disabled\u2029\u2029SASL_CB_ECHOPROMPT\u2029generic prompt for input with input echoing enabled\u2029\u2029SASL_CB_LIST_END\u2029indicates the end of the array of prompts\u2029\u2029See the Cyrus SASL documentation for more details.\u2029\u2029Applications  which need to manage connections asynchronously may use ldap_sasl_interactive_bind() instead of the synchronous version.  A valid mechs parameter must be supplied,\u2029otherwise the library will be forced to query the server for a list of supported mechanisms, and this query will be performed synchronously.  The other parameters are  the  same\u2029as  for  the  synchronous function, with three additional parameters.  The actual SASL mechanism that was used, and the message ID for use with ldap_result() will be returned in\u2029rmechp and msgidp, respectively.  The value in rmechp must not be modified by the caller and must be passed back on each subsequent call. The message obtained from ldap_result()\u2029must  be  passed  in the result parameter.  This parameter must be NULL when initiating a new Bind. The caller must free the result message after each call using ldap_msgfree().\u2029The ldap_sasl_interactive_bind() function returns an LDAP result code. If the code is LDAP_SASL_BIND_IN_PROGRESS then the Bind is not complete yet, and  this  function  must  be\u2029called again with the next result from the server.\u2029\u2029REBINDING\u2029The  ldap_set_rebind_proc function() sets the process to use for binding when an operation returns a referral. This function is used when an application needs to bind to another\u2029server in order to follow a referral or search continuation reference.\u2029\u2029The function takes ld, the rebind function, and the params, the arbitrary data like state information which the client might need to  properly  rebind.   The  LDAP_OPT_REFERRALS\u2029option in the ld must be set to ON for the libraries to use the rebind function. Use the ldap_set_option function to set the value.\u2029\u2029The rebind function parameters are as follows:\u2029\u2029The ld parameter must be used by the application when binding to the referred server if the application wants the libraries to follow the referral.\u2029\u2029The url parameter points to the URL referral string received from the LDAP server.  The LDAP application can use the ldap_url_parse(3) function to parse the string into its com\u2010\u2029ponents.\u2029\u2029The request parameter specifies the type of request that generated the referral.\u2029\u2029The msgid parameter specifies the message ID of the request generating the referral.\u2029\u2029The params parameter is the same value as passed originally to the ldap_set_rebind_proc() function.\u2029\u2029The LDAP libraries set all the parameters when they call the rebind function. The application should not attempt to free either the ld or the url structures in the rebind  func\u2010\u2029tion.\u2029\u2029The  application  must  supply to the rebind function the required authentication information such as, user name, password, and certificates. The rebind function must use a syn\u2010\u2029chronous bind method.\u2029\u2029UNBINDING\u2029The ldap_unbind() call is used to unbind from the directory, terminate the current association, and free the resources contained in the ld structure.  Once  it  is  called,  the\u2029connection  to  the LDAP server is closed, and the ld structure is invalid.  The ldap_unbind_s() call is just another name for ldap_unbind(); both of these calls are synchronous\u2029in nature.\u2029\u2029The ldap_unbind_ext() and ldap_unbind_ext_s() allows the operations to specify  controls.\u2029\u2029ERRORS\u2029Asynchronous routines will return -1 in case of error, setting the ld_errno parameter of the ld structure.  Synchronous  routines  return  whatever  ld_errno  is  set  to.   See\u2029ldap_error(3) for more information.\u2029\u2029NOTES\u2029If  an anonymous bind is sufficient for the application, the rebind process need not be provided. The LDAP libraries with the LDAP_OPT_REFERRALS option set to ON (default value)\u2029will automatically follow referrals using an anonymous bind.\u2029\u2029If the application needs stronger authentication than an anonymous bind, you need to provide a rebind process for that authentication method.  The bind method must  be  synchro\u2010\u2029nous.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_open(3), ldap_set_option(3), ldap_url_parse(3) RFC 4422 (http://www.rfc-editor.org), Cyrus SASL (http://asg.web.cmu.edu/sasl/)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 894, "position": [1029868, 1040550], "check": 1, "intersection": 10683, "FP_dupl": 11430, "FN_dupl": 0, "F": 0.6514818880351262, "Prec_Dupl": 0.4831094831094831, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_bind,   ldap_bind_s,   ldap_simple_bind,  ldap_simple_bind_s,  ldap_sasl_bind,  ldap_sasl_bind_s,  ldap_sasl_interactive_bind_s,  ldap_parse_sasl_bind_result,  ldap_unbind,\u2029ldap_unbind_s, ldap_unbind_ext, ldap_unbind_ext_s, ldap_set_rebind_proc - LDAP bind routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_bind(LDAP *ld, const char *who, const char *cred,\u2029int method);\u2029\u2029int ldap_bind_s(LDAP *ld, const char *who, const char *cred,\u2029int method);\u2029\u2029int ldap_simple_bind(LDAP *ld, const char *who, const char *passwd);\u2029\u2029int ldap_simple_bind_s(LDAP *ld, const char *who, const char *passwd);\u2029\u2029int ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,\u2029struct berval *cred, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[], int *msgidp);\u2029\u2029int ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,\u2029struct berval *cred, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[], struct berval **servercredp);\u2029\u2029int ldap_parse_sasl_bind_result(LDAP *ld, LDAPMessage *res,\u2029struct berval **servercredp, int freeit);\u2029\u2029int ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn,\u2029const char *mechs,\u2029LDAPControl *sctrls[], LDAPControl *cctrls[],\u2029unsigned flags, LDAP_SASL_INTERACT_PROC *interact,\u2029void *defaults);\u2029\u2029int ldap_sasl_interactive_bind(LDAP *ld, const char *dn,\u2029const char *mechs,\u2029LDAPControl *sctrls[], LDAPControl *cctrls[],\u2029unsigned flags, LDAP_SASL_INTERACT_PROC *interact,\u2029void *defaults, LDAPMessage *result,\u2029const char **rmechp, int *msgidp);\u2029\u2029int (LDAP_SASL_INTERACT_PROC)(LDAP *ld, unsigned flags, void *defaults, void *sasl_interact);\u2029\u2029int ldap_unbind(LDAP *ld);\u2029\u2029int ldap_unbind_s(LDAP *ld);\u2029\u2029int ldap_unbind_ext(LDAP *ld, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[]);\u2029\u2029int ldap_unbind_ext_s(LDAP *ld, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[]);\u2029\u2029int ldap_set_rebind_proc (LDAP *ld, LDAP_REBIND_PROC *ldap_proc, void *params);\u2029\u2029int (LDAP_REBIND_PROC)(LDAP *ld, LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *params);\u2029\u2029DESCRIPTION\u2029These routines provide various interfaces to the LDAP bind operation.  After an association with an LDAP server is made using ldap_init(3), an LDAP bind operation should be per\u2010\u2029formed  before  other operations are attempted over the connection.  An LDAP bind is required when using Version 2 of the LDAP protocol; it is optional for Version 3 but is usu\u2010\u2029ally needed due to security considerations.\u2029\u2029There are three types of bind calls, ones providing simple authentication, ones providing SASL authentication, and general routines  capable  of  doing  either  simple  or  SASL\u2029authentication.\u2029\u2029SASL  (Simple  Authentication and Security Layer) can negotiate one of many different kinds of authentication.  Both synchronous and asynchronous versions of each variant of the\u2029bind call are provided.  All routines take ld as their first parameter, as returned from ldap_init(3).\u2029\u2029SIMPLE AUTHENTICATION\u2029The simplest form of the bind call is ldap_simple_bind_s().  It takes the DN to bind as in who, and the userPassword associated with the entry in passwd.   It  returns  an  LDAP\u2029error  indication  (see ldap_error(3)).  The ldap_simple_bind() call is asynchronous, taking the same parameters but only initiating the bind operation and returning the message\u2029id of the request it sent.  The result of the operation can be obtained by a subsequent call to ldap_result(3).\u2029\u2029GENERAL AUTHENTICATION\u2029The ldap_bind() and ldap_bind_s() routines can be used when the authentication method to use needs to be selected at runtime.  They both take an extra method parameter selecting\u2029the  authentication  method  to  use.   It  should  be  set to LDAP_AUTH_SIMPLE to select simple authentication.  ldap_bind() returns the message id of the request it initiates.\u2029ldap_bind_s() returns an LDAP error indication.\u2029\u2029SASL AUTHENTICATION\u2029For SASL binds the server always ignores any provided DN, so the dn parameter should always be NULL.  ldap_sasl_bind_s() sends a single SASL bind request  with  the  given  SASL\u2029mechanism and credentials in the cred parameter. The format of the credentials depends on the particular SASL mechanism in use. For mechanisms that provide mutual authentication\u2029the server's credentials will be returned in the servercredp parameter.  The routine returns an LDAP error indication (see ldap_error(3)).  The ldap_sasl_bind()  call  is  asyn\u2010\u2029chronous,  taking  the  same parameters but only sending the request and returning the message id of the request it sent. The result of the operation can be obtained by a subse\u2010\u2029quent call to ldap_result(3).  The result must be additionally parsed by ldap_parse_sasl_bind_result() to obtain any server credentials sent from the server.\u2029\u2029Many SASL mechanisms require multiple message exchanges to perform a complete authentication. Applications should generally use ldap_sasl_interactive_bind_s() rather than  call\u2010\u2029ing  the  basic ldap_sasl_bind() functions directly. The mechs parameter should contain a space-separated list of candidate mechanisms to use. If this parameter is NULL or empty\u2029the library will query the supportedSASLMechanisms attribute from the server's rootDSE for the list of SASL mechanisms the server supports.  The  flags  parameter  controls  the\u2029interaction used to retrieve any necessary SASL authentication parameters and should be one of:\u2029\u2029LDAP_SASL_AUTOMATIC\u2029use defaults if available, prompt otherwise\u2029\u2029LDAP_SASL_INTERACTIVE\u2029always prompt\u2029\u2029LDAP_SASL_QUIET\u2029never prompt\u2029\u2029The  interact  function uses the provided defaults to handle requests from the SASL library for particular authentication parameters. There is no defined format for the defaults\u2029information; it is up to the caller to use whatever format is appropriate for the supplied interact function.   The  sasl_interact  parameter  comes  from  the  underlying  SASL\u2029library. When used with Cyrus SASL this is an array of sasl_interact_t structures. The Cyrus SASL library will prompt for a variety of inputs, including:\u2029\u2029SASL_CB_GETREALM\u2029the realm for the authentication attempt\u2029\u2029SASL_CB_AUTHNAME\u2029the username to authenticate\u2029\u2029SASL_CB_PASS\u2029the password for the provided username\u2029\u2029SASL_CB_USER\u2029the username to use for proxy authorization\u2029\u2029SASL_CB_NOECHOPROMPT\u2029generic prompt for input with input echoing disabled\u2029\u2029SASL_CB_ECHOPROMPT\u2029generic prompt for input with input echoing enabled\u2029\u2029SASL_CB_LIST_END\u2029indicates the end of the array of prompts\u2029\u2029See the Cyrus SASL documentation for more details.\u2029\u2029Applications  which need to manage connections asynchronously may use ldap_sasl_interactive_bind() instead of the synchronous version.  A valid mechs parameter must be supplied,\u2029otherwise the library will be forced to query the server for a list of supported mechanisms, and this query will be performed synchronously.  The other parameters are  the  same\u2029as  for  the  synchronous function, with three additional parameters.  The actual SASL mechanism that was used, and the message ID for use with ldap_result() will be returned in\u2029rmechp and msgidp, respectively.  The value in rmechp must not be modified by the caller and must be passed back on each subsequent call. The message obtained from ldap_result()\u2029must  be  passed  in the result parameter.  This parameter must be NULL when initiating a new Bind. The caller must free the result message after each call using ldap_msgfree().\u2029The ldap_sasl_interactive_bind() function returns an LDAP result code. If the code is LDAP_SASL_BIND_IN_PROGRESS then the Bind is not complete yet, and  this  function  must  be\u2029called again with the next result from the server.\u2029\u2029REBINDING\u2029The  ldap_set_rebind_proc function() sets the process to use for binding when an operation returns a referral. This function is used when an application needs to bind to another\u2029server in order to follow a referral or search continuation reference.\u2029\u2029The function takes ld, the rebind function, and the params, the arbitrary data like state information which the client might need to  properly  rebind.   The  LDAP_OPT_REFERRALS\u2029option in the ld must be set to ON for the libraries to use the rebind function. Use the ldap_set_option function to set the value.\u2029\u2029The rebind function parameters are as follows:\u2029\u2029The ld parameter must be used by the application when binding to the referred server if the application wants the libraries to follow the referral.\u2029\u2029The url parameter points to the URL referral string received from the LDAP server.  The LDAP application can use the ldap_url_parse(3) function to parse the string into its com\u2010\u2029ponents.\u2029\u2029The request parameter specifies the type of request that generated the referral.\u2029\u2029The msgid parameter specifies the message ID of the request generating the referral.\u2029\u2029The params parameter is the same value as passed originally to the ldap_set_rebind_proc() function.\u2029\u2029The LDAP libraries set all the parameters when they call the rebind function. The application should not attempt to free either the ld or the url structures in the rebind  func\u2010\u2029tion.\u2029\u2029The  application  must  supply to the rebind function the required authentication information such as, user name, password, and certificates. The rebind function must use a syn\u2010\u2029chronous bind method.\u2029\u2029UNBINDING\u2029The ldap_unbind() call is used to unbind from the directory, terminate the current association, and free the resources contained in the ld structure.  Once  it  is  called,  the\u2029connection  to  the LDAP server is closed, and the ld structure is invalid.  The ldap_unbind_s() call is just another name for ldap_unbind(); both of these calls are synchronous\u2029in nature.\u2029\u2029The ldap_unbind_ext() and ldap_unbind_ext_s() allows the operations to specify  controls.\u2029\u2029ERRORS\u2029Asynchronous routines will return -1 in case of error, setting the ld_errno parameter of the ld structure.  Synchronous  routines  return  whatever  ld_errno  is  set  to.   See\u2029ldap_error(3) for more information.\u2029\u2029NOTES\u2029If  an anonymous bind is sufficient for the application, the rebind process need not be provided. The LDAP libraries with the LDAP_OPT_REFERRALS option set to ON (default value)\u2029will automatically follow referrals using an anonymous bind.\u2029\u2029If the application needs stronger authentication than an anonymous bind, you need to provide a rebind process for that authentication method.  The bind method must  be  synchro\u2010\u2029nous.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_open(3), ldap_set_option(3), ldap_url_parse(3) RFC 4422 (http://www.rfc-editor.org), Cyrus SASL (http://asg.web.cmu.edu/sasl/)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 893, "position": [1018813, 1029495], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_bind,   ldap_bind_s,   ldap_simple_bind,  ldap_simple_bind_s,  ldap_sasl_bind,  ldap_sasl_bind_s,  ldap_sasl_interactive_bind_s,  ldap_parse_sasl_bind_result,  ldap_unbind,\u2029ldap_unbind_s, ldap_unbind_ext, ldap_unbind_ext_s, ldap_set_rebind_proc - LDAP bind routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_bind(LDAP *ld, const char *who, const char *cred,\u2029int method);\u2029\u2029int ldap_bind_s(LDAP *ld, const char *who, const char *cred,\u2029int method);\u2029\u2029int ldap_simple_bind(LDAP *ld, const char *who, const char *passwd);\u2029\u2029int ldap_simple_bind_s(LDAP *ld, const char *who, const char *passwd);\u2029\u2029int ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,\u2029struct berval *cred, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[], int *msgidp);\u2029\u2029int ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,\u2029struct berval *cred, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[], struct berval **servercredp);\u2029\u2029int ldap_parse_sasl_bind_result(LDAP *ld, LDAPMessage *res,\u2029struct berval **servercredp, int freeit);\u2029\u2029int ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn,\u2029const char *mechs,\u2029LDAPControl *sctrls[], LDAPControl *cctrls[],\u2029unsigned flags, LDAP_SASL_INTERACT_PROC *interact,\u2029void *defaults);\u2029\u2029int ldap_sasl_interactive_bind(LDAP *ld, const char *dn,\u2029const char *mechs,\u2029LDAPControl *sctrls[], LDAPControl *cctrls[],\u2029unsigned flags, LDAP_SASL_INTERACT_PROC *interact,\u2029void *defaults, LDAPMessage *result,\u2029const char **rmechp, int *msgidp);\u2029\u2029int (LDAP_SASL_INTERACT_PROC)(LDAP *ld, unsigned flags, void *defaults, void *sasl_interact);\u2029\u2029int ldap_unbind(LDAP *ld);\u2029\u2029int ldap_unbind_s(LDAP *ld);\u2029\u2029int ldap_unbind_ext(LDAP *ld, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[]);\u2029\u2029int ldap_unbind_ext_s(LDAP *ld, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[]);\u2029\u2029int ldap_set_rebind_proc (LDAP *ld, LDAP_REBIND_PROC *ldap_proc, void *params);\u2029\u2029int (LDAP_REBIND_PROC)(LDAP *ld, LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *params);\u2029\u2029DESCRIPTION\u2029These routines provide various interfaces to the LDAP bind operation.  After an association with an LDAP server is made using ldap_init(3), an LDAP bind operation should be per\u2010\u2029formed  before  other operations are attempted over the connection.  An LDAP bind is required when using Version 2 of the LDAP protocol; it is optional for Version 3 but is usu\u2010\u2029ally needed due to security considerations.\u2029\u2029There are three types of bind calls, ones providing simple authentication, ones providing SASL authentication, and general routines  capable  of  doing  either  simple  or  SASL\u2029authentication.\u2029\u2029SASL  (Simple  Authentication and Security Layer) can negotiate one of many different kinds of authentication.  Both synchronous and asynchronous versions of each variant of the\u2029bind call are provided.  All routines take ld as their first parameter, as returned from ldap_init(3).\u2029\u2029SIMPLE AUTHENTICATION\u2029The simplest form of the bind call is ldap_simple_bind_s().  It takes the DN to bind as in who, and the userPassword associated with the entry in passwd.   It  returns  an  LDAP\u2029error  indication  (see ldap_error(3)).  The ldap_simple_bind() call is asynchronous, taking the same parameters but only initiating the bind operation and returning the message\u2029id of the request it sent.  The result of the operation can be obtained by a subsequent call to ldap_result(3).\u2029\u2029GENERAL AUTHENTICATION\u2029The ldap_bind() and ldap_bind_s() routines can be used when the authentication method to use needs to be selected at runtime.  They both take an extra method parameter selecting\u2029the  authentication  method  to  use.   It  should  be  set to LDAP_AUTH_SIMPLE to select simple authentication.  ldap_bind() returns the message id of the request it initiates.\u2029ldap_bind_s() returns an LDAP error indication.\u2029\u2029SASL AUTHENTICATION\u2029For SASL binds the server always ignores any provided DN, so the dn parameter should always be NULL.  ldap_sasl_bind_s() sends a single SASL bind request  with  the  given  SASL\u2029mechanism and credentials in the cred parameter. The format of the credentials depends on the particular SASL mechanism in use. For mechanisms that provide mutual authentication\u2029the server's credentials will be returned in the servercredp parameter.  The routine returns an LDAP error indication (see ldap_error(3)).  The ldap_sasl_bind()  call  is  asyn\u2010\u2029chronous,  taking  the  same parameters but only sending the request and returning the message id of the request it sent. The result of the operation can be obtained by a subse\u2010\u2029quent call to ldap_result(3).  The result must be additionally parsed by ldap_parse_sasl_bind_result() to obtain any server credentials sent from the server.\u2029\u2029Many SASL mechanisms require multiple message exchanges to perform a complete authentication. Applications should generally use ldap_sasl_interactive_bind_s() rather than  call\u2010\u2029ing  the  basic ldap_sasl_bind() functions directly. The mechs parameter should contain a space-separated list of candidate mechanisms to use. If this parameter is NULL or empty\u2029the library will query the supportedSASLMechanisms attribute from the server's rootDSE for the list of SASL mechanisms the server supports.  The  flags  parameter  controls  the\u2029interaction used to retrieve any necessary SASL authentication parameters and should be one of:\u2029\u2029LDAP_SASL_AUTOMATIC\u2029use defaults if available, prompt otherwise\u2029\u2029LDAP_SASL_INTERACTIVE\u2029always prompt\u2029\u2029LDAP_SASL_QUIET\u2029never prompt\u2029\u2029The  interact  function uses the provided defaults to handle requests from the SASL library for particular authentication parameters. There is no defined format for the defaults\u2029information; it is up to the caller to use whatever format is appropriate for the supplied interact function.   The  sasl_interact  parameter  comes  from  the  underlying  SASL\u2029library. When used with Cyrus SASL this is an array of sasl_interact_t structures. The Cyrus SASL library will prompt for a variety of inputs, including:\u2029\u2029SASL_CB_GETREALM\u2029the realm for the authentication attempt\u2029\u2029SASL_CB_AUTHNAME\u2029the username to authenticate\u2029\u2029SASL_CB_PASS\u2029the password for the provided username\u2029\u2029SASL_CB_USER\u2029the username to use for proxy authorization\u2029\u2029SASL_CB_NOECHOPROMPT\u2029generic prompt for input with input echoing disabled\u2029\u2029SASL_CB_ECHOPROMPT\u2029generic prompt for input with input echoing enabled\u2029\u2029SASL_CB_LIST_END\u2029indicates the end of the array of prompts\u2029\u2029See the Cyrus SASL documentation for more details.\u2029\u2029Applications  which need to manage connections asynchronously may use ldap_sasl_interactive_bind() instead of the synchronous version.  A valid mechs parameter must be supplied,\u2029otherwise the library will be forced to query the server for a list of supported mechanisms, and this query will be performed synchronously.  The other parameters are  the  same\u2029as  for  the  synchronous function, with three additional parameters.  The actual SASL mechanism that was used, and the message ID for use with ldap_result() will be returned in\u2029rmechp and msgidp, respectively.  The value in rmechp must not be modified by the caller and must be passed back on each subsequent call. The message obtained from ldap_result()\u2029must  be  passed  in the result parameter.  This parameter must be NULL when initiating a new Bind. The caller must free the result message after each call using ldap_msgfree().\u2029The ldap_sasl_interactive_bind() function returns an LDAP result code. If the code is LDAP_SASL_BIND_IN_PROGRESS then the Bind is not complete yet, and  this  function  must  be\u2029called again with the next result from the server.\u2029\u2029REBINDING\u2029The  ldap_set_rebind_proc function() sets the process to use for binding when an operation returns a referral. This function is used when an application needs to bind to another\u2029server in order to follow a referral or search continuation reference.\u2029\u2029The function takes ld, the rebind function, and the params, the arbitrary data like state information which the client might need to  properly  rebind.   The  LDAP_OPT_REFERRALS\u2029option in the ld must be set to ON for the libraries to use the rebind function. Use the ldap_set_option function to set the value.\u2029\u2029The rebind function parameters are as follows:\u2029\u2029The ld parameter must be used by the application when binding to the referred server if the application wants the libraries to follow the referral.\u2029\u2029The url parameter points to the URL referral string received from the LDAP server.  The LDAP application can use the ldap_url_parse(3) function to parse the string into its com\u2010\u2029ponents.\u2029\u2029The request parameter specifies the type of request that generated the referral.\u2029\u2029The msgid parameter specifies the message ID of the request generating the referral.\u2029\u2029The params parameter is the same value as passed originally to the ldap_set_rebind_proc() function.\u2029\u2029The LDAP libraries set all the parameters when they call the rebind function. The application should not attempt to free either the ld or the url structures in the rebind  func\u2010\u2029tion.\u2029\u2029The  application  must  supply to the rebind function the required authentication information such as, user name, password, and certificates. The rebind function must use a syn\u2010\u2029chronous bind method.\u2029\u2029UNBINDING\u2029The ldap_unbind() call is used to unbind from the directory, terminate the current association, and free the resources contained in the ld structure.  Once  it  is  called,  the\u2029connection  to  the LDAP server is closed, and the ld structure is invalid.  The ldap_unbind_s() call is just another name for ldap_unbind(); both of these calls are synchronous\u2029in nature.\u2029\u2029The ldap_unbind_ext() and ldap_unbind_ext_s() allows the operations to specify  controls.\u2029\u2029ERRORS\u2029Asynchronous routines will return -1 in case of error, setting the ld_errno parameter of the ld structure.  Synchronous  routines  return  whatever  ld_errno  is  set  to.   See\u2029ldap_error(3) for more information.\u2029\u2029NOTES\u2029If  an anonymous bind is sufficient for the application, the rebind process need not be provided. The LDAP libraries with the LDAP_OPT_REFERRALS option set to ON (default value)\u2029will automatically follow referrals using an anonymous bind.\u2029\u2029If the application needs stronger authentication than an anonymous bind, you need to provide a rebind process for that authentication method.  The bind method must  be  synchro\u2010\u2029nous.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_open(3), ldap_set_option(3), ldap_url_parse(3) RFC 4422 (http://www.rfc-editor.org), Cyrus SASL (http://asg.web.cmu.edu/sasl/)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 892, "position": [1007758, 1018440], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_bind,   ldap_bind_s,   ldap_simple_bind,  ldap_simple_bind_s,  ldap_sasl_bind,  ldap_sasl_bind_s,  ldap_sasl_interactive_bind_s,  ldap_parse_sasl_bind_result,  ldap_unbind,\u2029ldap_unbind_s, ldap_unbind_ext, ldap_unbind_ext_s, ldap_set_rebind_proc - LDAP bind routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_bind(LDAP *ld, const char *who, const char *cred,\u2029int method);\u2029\u2029int ldap_bind_s(LDAP *ld, const char *who, const char *cred,\u2029int method);\u2029\u2029int ldap_simple_bind(LDAP *ld, const char *who, const char *passwd);\u2029\u2029int ldap_simple_bind_s(LDAP *ld, const char *who, const char *passwd);\u2029\u2029int ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,\u2029struct berval *cred, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[], int *msgidp);\u2029\u2029int ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,\u2029struct berval *cred, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[], struct berval **servercredp);\u2029\u2029int ldap_parse_sasl_bind_result(LDAP *ld, LDAPMessage *res,\u2029struct berval **servercredp, int freeit);\u2029\u2029int ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn,\u2029const char *mechs,\u2029LDAPControl *sctrls[], LDAPControl *cctrls[],\u2029unsigned flags, LDAP_SASL_INTERACT_PROC *interact,\u2029void *defaults);\u2029\u2029int ldap_sasl_interactive_bind(LDAP *ld, const char *dn,\u2029const char *mechs,\u2029LDAPControl *sctrls[], LDAPControl *cctrls[],\u2029unsigned flags, LDAP_SASL_INTERACT_PROC *interact,\u2029void *defaults, LDAPMessage *result,\u2029const char **rmechp, int *msgidp);\u2029\u2029int (LDAP_SASL_INTERACT_PROC)(LDAP *ld, unsigned flags, void *defaults, void *sasl_interact);\u2029\u2029int ldap_unbind(LDAP *ld);\u2029\u2029int ldap_unbind_s(LDAP *ld);\u2029\u2029int ldap_unbind_ext(LDAP *ld, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[]);\u2029\u2029int ldap_unbind_ext_s(LDAP *ld, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[]);\u2029\u2029int ldap_set_rebind_proc (LDAP *ld, LDAP_REBIND_PROC *ldap_proc, void *params);\u2029\u2029int (LDAP_REBIND_PROC)(LDAP *ld, LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *params);\u2029\u2029DESCRIPTION\u2029These routines provide various interfaces to the LDAP bind operation.  After an association with an LDAP server is made using ldap_init(3), an LDAP bind operation should be per\u2010\u2029formed  before  other operations are attempted over the connection.  An LDAP bind is required when using Version 2 of the LDAP protocol; it is optional for Version 3 but is usu\u2010\u2029ally needed due to security considerations.\u2029\u2029There are three types of bind calls, ones providing simple authentication, ones providing SASL authentication, and general routines  capable  of  doing  either  simple  or  SASL\u2029authentication.\u2029\u2029SASL  (Simple  Authentication and Security Layer) can negotiate one of many different kinds of authentication.  Both synchronous and asynchronous versions of each variant of the\u2029bind call are provided.  All routines take ld as their first parameter, as returned from ldap_init(3).\u2029\u2029SIMPLE AUTHENTICATION\u2029The simplest form of the bind call is ldap_simple_bind_s().  It takes the DN to bind as in who, and the userPassword associated with the entry in passwd.   It  returns  an  LDAP\u2029error  indication  (see ldap_error(3)).  The ldap_simple_bind() call is asynchronous, taking the same parameters but only initiating the bind operation and returning the message\u2029id of the request it sent.  The result of the operation can be obtained by a subsequent call to ldap_result(3).\u2029\u2029GENERAL AUTHENTICATION\u2029The ldap_bind() and ldap_bind_s() routines can be used when the authentication method to use needs to be selected at runtime.  They both take an extra method parameter selecting\u2029the  authentication  method  to  use.   It  should  be  set to LDAP_AUTH_SIMPLE to select simple authentication.  ldap_bind() returns the message id of the request it initiates.\u2029ldap_bind_s() returns an LDAP error indication.\u2029\u2029SASL AUTHENTICATION\u2029For SASL binds the server always ignores any provided DN, so the dn parameter should always be NULL.  ldap_sasl_bind_s() sends a single SASL bind request  with  the  given  SASL\u2029mechanism and credentials in the cred parameter. The format of the credentials depends on the particular SASL mechanism in use. For mechanisms that provide mutual authentication\u2029the server's credentials will be returned in the servercredp parameter.  The routine returns an LDAP error indication (see ldap_error(3)).  The ldap_sasl_bind()  call  is  asyn\u2010\u2029chronous,  taking  the  same parameters but only sending the request and returning the message id of the request it sent. The result of the operation can be obtained by a subse\u2010\u2029quent call to ldap_result(3).  The result must be additionally parsed by ldap_parse_sasl_bind_result() to obtain any server credentials sent from the server.\u2029\u2029Many SASL mechanisms require multiple message exchanges to perform a complete authentication. Applications should generally use ldap_sasl_interactive_bind_s() rather than  call\u2010\u2029ing  the  basic ldap_sasl_bind() functions directly. The mechs parameter should contain a space-separated list of candidate mechanisms to use. If this parameter is NULL or empty\u2029the library will query the supportedSASLMechanisms attribute from the server's rootDSE for the list of SASL mechanisms the server supports.  The  flags  parameter  controls  the\u2029interaction used to retrieve any necessary SASL authentication parameters and should be one of:\u2029\u2029LDAP_SASL_AUTOMATIC\u2029use defaults if available, prompt otherwise\u2029\u2029LDAP_SASL_INTERACTIVE\u2029always prompt\u2029\u2029LDAP_SASL_QUIET\u2029never prompt\u2029\u2029The  interact  function uses the provided defaults to handle requests from the SASL library for particular authentication parameters. There is no defined format for the defaults\u2029information; it is up to the caller to use whatever format is appropriate for the supplied interact function.   The  sasl_interact  parameter  comes  from  the  underlying  SASL\u2029library. When used with Cyrus SASL this is an array of sasl_interact_t structures. The Cyrus SASL library will prompt for a variety of inputs, including:\u2029\u2029SASL_CB_GETREALM\u2029the realm for the authentication attempt\u2029\u2029SASL_CB_AUTHNAME\u2029the username to authenticate\u2029\u2029SASL_CB_PASS\u2029the password for the provided username\u2029\u2029SASL_CB_USER\u2029the username to use for proxy authorization\u2029\u2029SASL_CB_NOECHOPROMPT\u2029generic prompt for input with input echoing disabled\u2029\u2029SASL_CB_ECHOPROMPT\u2029generic prompt for input with input echoing enabled\u2029\u2029SASL_CB_LIST_END\u2029indicates the end of the array of prompts\u2029\u2029See the Cyrus SASL documentation for more details.\u2029\u2029Applications  which need to manage connections asynchronously may use ldap_sasl_interactive_bind() instead of the synchronous version.  A valid mechs parameter must be supplied,\u2029otherwise the library will be forced to query the server for a list of supported mechanisms, and this query will be performed synchronously.  The other parameters are  the  same\u2029as  for  the  synchronous function, with three additional parameters.  The actual SASL mechanism that was used, and the message ID for use with ldap_result() will be returned in\u2029rmechp and msgidp, respectively.  The value in rmechp must not be modified by the caller and must be passed back on each subsequent call. The message obtained from ldap_result()\u2029must  be  passed  in the result parameter.  This parameter must be NULL when initiating a new Bind. The caller must free the result message after each call using ldap_msgfree().\u2029The ldap_sasl_interactive_bind() function returns an LDAP result code. If the code is LDAP_SASL_BIND_IN_PROGRESS then the Bind is not complete yet, and  this  function  must  be\u2029called again with the next result from the server.\u2029\u2029REBINDING\u2029The  ldap_set_rebind_proc function() sets the process to use for binding when an operation returns a referral. This function is used when an application needs to bind to another\u2029server in order to follow a referral or search continuation reference.\u2029\u2029The function takes ld, the rebind function, and the params, the arbitrary data like state information which the client might need to  properly  rebind.   The  LDAP_OPT_REFERRALS\u2029option in the ld must be set to ON for the libraries to use the rebind function. Use the ldap_set_option function to set the value.\u2029\u2029The rebind function parameters are as follows:\u2029\u2029The ld parameter must be used by the application when binding to the referred server if the application wants the libraries to follow the referral.\u2029\u2029The url parameter points to the URL referral string received from the LDAP server.  The LDAP application can use the ldap_url_parse(3) function to parse the string into its com\u2010\u2029ponents.\u2029\u2029The request parameter specifies the type of request that generated the referral.\u2029\u2029The msgid parameter specifies the message ID of the request generating the referral.\u2029\u2029The params parameter is the same value as passed originally to the ldap_set_rebind_proc() function.\u2029\u2029The LDAP libraries set all the parameters when they call the rebind function. The application should not attempt to free either the ld or the url structures in the rebind  func\u2010\u2029tion.\u2029\u2029The  application  must  supply to the rebind function the required authentication information such as, user name, password, and certificates. The rebind function must use a syn\u2010\u2029chronous bind method.\u2029\u2029UNBINDING\u2029The ldap_unbind() call is used to unbind from the directory, terminate the current association, and free the resources contained in the ld structure.  Once  it  is  called,  the\u2029connection  to  the LDAP server is closed, and the ld structure is invalid.  The ldap_unbind_s() call is just another name for ldap_unbind(); both of these calls are synchronous\u2029in nature.\u2029\u2029The ldap_unbind_ext() and ldap_unbind_ext_s() allows the operations to specify  controls.\u2029\u2029ERRORS\u2029Asynchronous routines will return -1 in case of error, setting the ld_errno parameter of the ld structure.  Synchronous  routines  return  whatever  ld_errno  is  set  to.   See\u2029ldap_error(3) for more information.\u2029\u2029NOTES\u2029If  an anonymous bind is sufficient for the application, the rebind process need not be provided. The LDAP libraries with the LDAP_OPT_REFERRALS option set to ON (default value)\u2029will automatically follow referrals using an anonymous bind.\u2029\u2029If the application needs stronger authentication than an anonymous bind, you need to provide a rebind process for that authentication method.  The bind method must  be  synchro\u2010\u2029nous.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_open(3), ldap_set_option(3), ldap_url_parse(3) RFC 4422 (http://www.rfc-editor.org), Cyrus SASL (http://asg.web.cmu.edu/sasl/)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 891, "position": [906045, 916727], "check": 1, "intersection": 10683, "FP_dupl": 11430, "FN_dupl": 0, "F": 0.6514818880351262, "Prec_Dupl": 0.4831094831094831, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_bind,   ldap_bind_s,   ldap_simple_bind,  ldap_simple_bind_s,  ldap_sasl_bind,  ldap_sasl_bind_s,  ldap_sasl_interactive_bind_s,  ldap_parse_sasl_bind_result,  ldap_unbind,\u2029ldap_unbind_s, ldap_unbind_ext, ldap_unbind_ext_s, ldap_set_rebind_proc - LDAP bind routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_bind(LDAP *ld, const char *who, const char *cred,\u2029int method);\u2029\u2029int ldap_bind_s(LDAP *ld, const char *who, const char *cred,\u2029int method);\u2029\u2029int ldap_simple_bind(LDAP *ld, const char *who, const char *passwd);\u2029\u2029int ldap_simple_bind_s(LDAP *ld, const char *who, const char *passwd);\u2029\u2029int ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,\u2029struct berval *cred, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[], int *msgidp);\u2029\u2029int ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,\u2029struct berval *cred, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[], struct berval **servercredp);\u2029\u2029int ldap_parse_sasl_bind_result(LDAP *ld, LDAPMessage *res,\u2029struct berval **servercredp, int freeit);\u2029\u2029int ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn,\u2029const char *mechs,\u2029LDAPControl *sctrls[], LDAPControl *cctrls[],\u2029unsigned flags, LDAP_SASL_INTERACT_PROC *interact,\u2029void *defaults);\u2029\u2029int ldap_sasl_interactive_bind(LDAP *ld, const char *dn,\u2029const char *mechs,\u2029LDAPControl *sctrls[], LDAPControl *cctrls[],\u2029unsigned flags, LDAP_SASL_INTERACT_PROC *interact,\u2029void *defaults, LDAPMessage *result,\u2029const char **rmechp, int *msgidp);\u2029\u2029int (LDAP_SASL_INTERACT_PROC)(LDAP *ld, unsigned flags, void *defaults, void *sasl_interact);\u2029\u2029int ldap_unbind(LDAP *ld);\u2029\u2029int ldap_unbind_s(LDAP *ld);\u2029\u2029int ldap_unbind_ext(LDAP *ld, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[]);\u2029\u2029int ldap_unbind_ext_s(LDAP *ld, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[]);\u2029\u2029int ldap_set_rebind_proc (LDAP *ld, LDAP_REBIND_PROC *ldap_proc, void *params);\u2029\u2029int (LDAP_REBIND_PROC)(LDAP *ld, LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *params);\u2029\u2029DESCRIPTION\u2029These routines provide various interfaces to the LDAP bind operation.  After an association with an LDAP server is made using ldap_init(3), an LDAP bind operation should be per\u2010\u2029formed  before  other operations are attempted over the connection.  An LDAP bind is required when using Version 2 of the LDAP protocol; it is optional for Version 3 but is usu\u2010\u2029ally needed due to security considerations.\u2029\u2029There are three types of bind calls, ones providing simple authentication, ones providing SASL authentication, and general routines  capable  of  doing  either  simple  or  SASL\u2029authentication.\u2029\u2029SASL  (Simple  Authentication and Security Layer) can negotiate one of many different kinds of authentication.  Both synchronous and asynchronous versions of each variant of the\u2029bind call are provided.  All routines take ld as their first parameter, as returned from ldap_init(3).\u2029\u2029SIMPLE AUTHENTICATION\u2029The simplest form of the bind call is ldap_simple_bind_s().  It takes the DN to bind as in who, and the userPassword associated with the entry in passwd.   It  returns  an  LDAP\u2029error  indication  (see ldap_error(3)).  The ldap_simple_bind() call is asynchronous, taking the same parameters but only initiating the bind operation and returning the message\u2029id of the request it sent.  The result of the operation can be obtained by a subsequent call to ldap_result(3).\u2029\u2029GENERAL AUTHENTICATION\u2029The ldap_bind() and ldap_bind_s() routines can be used when the authentication method to use needs to be selected at runtime.  They both take an extra method parameter selecting\u2029the  authentication  method  to  use.   It  should  be  set to LDAP_AUTH_SIMPLE to select simple authentication.  ldap_bind() returns the message id of the request it initiates.\u2029ldap_bind_s() returns an LDAP error indication.\u2029\u2029SASL AUTHENTICATION\u2029For SASL binds the server always ignores any provided DN, so the dn parameter should always be NULL.  ldap_sasl_bind_s() sends a single SASL bind request  with  the  given  SASL\u2029mechanism and credentials in the cred parameter. The format of the credentials depends on the particular SASL mechanism in use. For mechanisms that provide mutual authentication\u2029the server's credentials will be returned in the servercredp parameter.  The routine returns an LDAP error indication (see ldap_error(3)).  The ldap_sasl_bind()  call  is  asyn\u2010\u2029chronous,  taking  the  same parameters but only sending the request and returning the message id of the request it sent. The result of the operation can be obtained by a subse\u2010\u2029quent call to ldap_result(3).  The result must be additionally parsed by ldap_parse_sasl_bind_result() to obtain any server credentials sent from the server.\u2029\u2029Many SASL mechanisms require multiple message exchanges to perform a complete authentication. Applications should generally use ldap_sasl_interactive_bind_s() rather than  call\u2010\u2029ing  the  basic ldap_sasl_bind() functions directly. The mechs parameter should contain a space-separated list of candidate mechanisms to use. If this parameter is NULL or empty\u2029the library will query the supportedSASLMechanisms attribute from the server's rootDSE for the list of SASL mechanisms the server supports.  The  flags  parameter  controls  the\u2029interaction used to retrieve any necessary SASL authentication parameters and should be one of:\u2029\u2029LDAP_SASL_AUTOMATIC\u2029use defaults if available, prompt otherwise\u2029\u2029LDAP_SASL_INTERACTIVE\u2029always prompt\u2029\u2029LDAP_SASL_QUIET\u2029never prompt\u2029\u2029The  interact  function uses the provided defaults to handle requests from the SASL library for particular authentication parameters. There is no defined format for the defaults\u2029information; it is up to the caller to use whatever format is appropriate for the supplied interact function.   The  sasl_interact  parameter  comes  from  the  underlying  SASL\u2029library. When used with Cyrus SASL this is an array of sasl_interact_t structures. The Cyrus SASL library will prompt for a variety of inputs, including:\u2029\u2029SASL_CB_GETREALM\u2029the realm for the authentication attempt\u2029\u2029SASL_CB_AUTHNAME\u2029the username to authenticate\u2029\u2029SASL_CB_PASS\u2029the password for the provided username\u2029\u2029SASL_CB_USER\u2029the username to use for proxy authorization\u2029\u2029SASL_CB_NOECHOPROMPT\u2029generic prompt for input with input echoing disabled\u2029\u2029SASL_CB_ECHOPROMPT\u2029generic prompt for input with input echoing enabled\u2029\u2029SASL_CB_LIST_END\u2029indicates the end of the array of prompts\u2029\u2029See the Cyrus SASL documentation for more details.\u2029\u2029Applications  which need to manage connections asynchronously may use ldap_sasl_interactive_bind() instead of the synchronous version.  A valid mechs parameter must be supplied,\u2029otherwise the library will be forced to query the server for a list of supported mechanisms, and this query will be performed synchronously.  The other parameters are  the  same\u2029as  for  the  synchronous function, with three additional parameters.  The actual SASL mechanism that was used, and the message ID for use with ldap_result() will be returned in\u2029rmechp and msgidp, respectively.  The value in rmechp must not be modified by the caller and must be passed back on each subsequent call. The message obtained from ldap_result()\u2029must  be  passed  in the result parameter.  This parameter must be NULL when initiating a new Bind. The caller must free the result message after each call using ldap_msgfree().\u2029The ldap_sasl_interactive_bind() function returns an LDAP result code. If the code is LDAP_SASL_BIND_IN_PROGRESS then the Bind is not complete yet, and  this  function  must  be\u2029called again with the next result from the server.\u2029\u2029REBINDING\u2029The  ldap_set_rebind_proc function() sets the process to use for binding when an operation returns a referral. This function is used when an application needs to bind to another\u2029server in order to follow a referral or search continuation reference.\u2029\u2029The function takes ld, the rebind function, and the params, the arbitrary data like state information which the client might need to  properly  rebind.   The  LDAP_OPT_REFERRALS\u2029option in the ld must be set to ON for the libraries to use the rebind function. Use the ldap_set_option function to set the value.\u2029\u2029The rebind function parameters are as follows:\u2029\u2029The ld parameter must be used by the application when binding to the referred server if the application wants the libraries to follow the referral.\u2029\u2029The url parameter points to the URL referral string received from the LDAP server.  The LDAP application can use the ldap_url_parse(3) function to parse the string into its com\u2010\u2029ponents.\u2029\u2029The request parameter specifies the type of request that generated the referral.\u2029\u2029The msgid parameter specifies the message ID of the request generating the referral.\u2029\u2029The params parameter is the same value as passed originally to the ldap_set_rebind_proc() function.\u2029\u2029The LDAP libraries set all the parameters when they call the rebind function. The application should not attempt to free either the ld or the url structures in the rebind  func\u2010\u2029tion.\u2029\u2029The  application  must  supply to the rebind function the required authentication information such as, user name, password, and certificates. The rebind function must use a syn\u2010\u2029chronous bind method.\u2029\u2029UNBINDING\u2029The ldap_unbind() call is used to unbind from the directory, terminate the current association, and free the resources contained in the ld structure.  Once  it  is  called,  the\u2029connection  to  the LDAP server is closed, and the ld structure is invalid.  The ldap_unbind_s() call is just another name for ldap_unbind(); both of these calls are synchronous\u2029in nature.\u2029\u2029The ldap_unbind_ext() and ldap_unbind_ext_s() allows the operations to specify  controls.\u2029\u2029ERRORS\u2029Asynchronous routines will return -1 in case of error, setting the ld_errno parameter of the ld structure.  Synchronous  routines  return  whatever  ld_errno  is  set  to.   See\u2029ldap_error(3) for more information.\u2029\u2029NOTES\u2029If  an anonymous bind is sufficient for the application, the rebind process need not be provided. The LDAP libraries with the LDAP_OPT_REFERRALS option set to ON (default value)\u2029will automatically follow referrals using an anonymous bind.\u2029\u2029If the application needs stronger authentication than an anonymous bind, you need to provide a rebind process for that authentication method.  The bind method must  be  synchro\u2010\u2029nous.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_open(3), ldap_set_option(3), ldap_url_parse(3) RFC 4422 (http://www.rfc-editor.org), Cyrus SASL (http://asg.web.cmu.edu/sasl/)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 890, "position": [894990, 905672], "check": 1, "intersection": 10683, "FP_dupl": 11430, "FN_dupl": 0, "F": 0.6514818880351262, "Prec_Dupl": 0.4831094831094831, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_bind,   ldap_bind_s,   ldap_simple_bind,  ldap_simple_bind_s,  ldap_sasl_bind,  ldap_sasl_bind_s,  ldap_sasl_interactive_bind_s,  ldap_parse_sasl_bind_result,  ldap_unbind,\u2029ldap_unbind_s, ldap_unbind_ext, ldap_unbind_ext_s, ldap_set_rebind_proc - LDAP bind routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_bind(LDAP *ld, const char *who, const char *cred,\u2029int method);\u2029\u2029int ldap_bind_s(LDAP *ld, const char *who, const char *cred,\u2029int method);\u2029\u2029int ldap_simple_bind(LDAP *ld, const char *who, const char *passwd);\u2029\u2029int ldap_simple_bind_s(LDAP *ld, const char *who, const char *passwd);\u2029\u2029int ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,\u2029struct berval *cred, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[], int *msgidp);\u2029\u2029int ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,\u2029struct berval *cred, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[], struct berval **servercredp);\u2029\u2029int ldap_parse_sasl_bind_result(LDAP *ld, LDAPMessage *res,\u2029struct berval **servercredp, int freeit);\u2029\u2029int ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn,\u2029const char *mechs,\u2029LDAPControl *sctrls[], LDAPControl *cctrls[],\u2029unsigned flags, LDAP_SASL_INTERACT_PROC *interact,\u2029void *defaults);\u2029\u2029int ldap_sasl_interactive_bind(LDAP *ld, const char *dn,\u2029const char *mechs,\u2029LDAPControl *sctrls[], LDAPControl *cctrls[],\u2029unsigned flags, LDAP_SASL_INTERACT_PROC *interact,\u2029void *defaults, LDAPMessage *result,\u2029const char **rmechp, int *msgidp);\u2029\u2029int (LDAP_SASL_INTERACT_PROC)(LDAP *ld, unsigned flags, void *defaults, void *sasl_interact);\u2029\u2029int ldap_unbind(LDAP *ld);\u2029\u2029int ldap_unbind_s(LDAP *ld);\u2029\u2029int ldap_unbind_ext(LDAP *ld, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[]);\u2029\u2029int ldap_unbind_ext_s(LDAP *ld, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[]);\u2029\u2029int ldap_set_rebind_proc (LDAP *ld, LDAP_REBIND_PROC *ldap_proc, void *params);\u2029\u2029int (LDAP_REBIND_PROC)(LDAP *ld, LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *params);\u2029\u2029DESCRIPTION\u2029These routines provide various interfaces to the LDAP bind operation.  After an association with an LDAP server is made using ldap_init(3), an LDAP bind operation should be per\u2010\u2029formed  before  other operations are attempted over the connection.  An LDAP bind is required when using Version 2 of the LDAP protocol; it is optional for Version 3 but is usu\u2010\u2029ally needed due to security considerations.\u2029\u2029There are three types of bind calls, ones providing simple authentication, ones providing SASL authentication, and general routines  capable  of  doing  either  simple  or  SASL\u2029authentication.\u2029\u2029SASL  (Simple  Authentication and Security Layer) can negotiate one of many different kinds of authentication.  Both synchronous and asynchronous versions of each variant of the\u2029bind call are provided.  All routines take ld as their first parameter, as returned from ldap_init(3).\u2029\u2029SIMPLE AUTHENTICATION\u2029The simplest form of the bind call is ldap_simple_bind_s().  It takes the DN to bind as in who, and the userPassword associated with the entry in passwd.   It  returns  an  LDAP\u2029error  indication  (see ldap_error(3)).  The ldap_simple_bind() call is asynchronous, taking the same parameters but only initiating the bind operation and returning the message\u2029id of the request it sent.  The result of the operation can be obtained by a subsequent call to ldap_result(3).\u2029\u2029GENERAL AUTHENTICATION\u2029The ldap_bind() and ldap_bind_s() routines can be used when the authentication method to use needs to be selected at runtime.  They both take an extra method parameter selecting\u2029the  authentication  method  to  use.   It  should  be  set to LDAP_AUTH_SIMPLE to select simple authentication.  ldap_bind() returns the message id of the request it initiates.\u2029ldap_bind_s() returns an LDAP error indication.\u2029\u2029SASL AUTHENTICATION\u2029For SASL binds the server always ignores any provided DN, so the dn parameter should always be NULL.  ldap_sasl_bind_s() sends a single SASL bind request  with  the  given  SASL\u2029mechanism and credentials in the cred parameter. The format of the credentials depends on the particular SASL mechanism in use. For mechanisms that provide mutual authentication\u2029the server's credentials will be returned in the servercredp parameter.  The routine returns an LDAP error indication (see ldap_error(3)).  The ldap_sasl_bind()  call  is  asyn\u2010\u2029chronous,  taking  the  same parameters but only sending the request and returning the message id of the request it sent. The result of the operation can be obtained by a subse\u2010\u2029quent call to ldap_result(3).  The result must be additionally parsed by ldap_parse_sasl_bind_result() to obtain any server credentials sent from the server.\u2029\u2029Many SASL mechanisms require multiple message exchanges to perform a complete authentication. Applications should generally use ldap_sasl_interactive_bind_s() rather than  call\u2010\u2029ing  the  basic ldap_sasl_bind() functions directly. The mechs parameter should contain a space-separated list of candidate mechanisms to use. If this parameter is NULL or empty\u2029the library will query the supportedSASLMechanisms attribute from the server's rootDSE for the list of SASL mechanisms the server supports.  The  flags  parameter  controls  the\u2029interaction used to retrieve any necessary SASL authentication parameters and should be one of:\u2029\u2029LDAP_SASL_AUTOMATIC\u2029use defaults if available, prompt otherwise\u2029\u2029LDAP_SASL_INTERACTIVE\u2029always prompt\u2029\u2029LDAP_SASL_QUIET\u2029never prompt\u2029\u2029The  interact  function uses the provided defaults to handle requests from the SASL library for particular authentication parameters. There is no defined format for the defaults\u2029information; it is up to the caller to use whatever format is appropriate for the supplied interact function.   The  sasl_interact  parameter  comes  from  the  underlying  SASL\u2029library. When used with Cyrus SASL this is an array of sasl_interact_t structures. The Cyrus SASL library will prompt for a variety of inputs, including:\u2029\u2029SASL_CB_GETREALM\u2029the realm for the authentication attempt\u2029\u2029SASL_CB_AUTHNAME\u2029the username to authenticate\u2029\u2029SASL_CB_PASS\u2029the password for the provided username\u2029\u2029SASL_CB_USER\u2029the username to use for proxy authorization\u2029\u2029SASL_CB_NOECHOPROMPT\u2029generic prompt for input with input echoing disabled\u2029\u2029SASL_CB_ECHOPROMPT\u2029generic prompt for input with input echoing enabled\u2029\u2029SASL_CB_LIST_END\u2029indicates the end of the array of prompts\u2029\u2029See the Cyrus SASL documentation for more details.\u2029\u2029Applications  which need to manage connections asynchronously may use ldap_sasl_interactive_bind() instead of the synchronous version.  A valid mechs parameter must be supplied,\u2029otherwise the library will be forced to query the server for a list of supported mechanisms, and this query will be performed synchronously.  The other parameters are  the  same\u2029as  for  the  synchronous function, with three additional parameters.  The actual SASL mechanism that was used, and the message ID for use with ldap_result() will be returned in\u2029rmechp and msgidp, respectively.  The value in rmechp must not be modified by the caller and must be passed back on each subsequent call. The message obtained from ldap_result()\u2029must  be  passed  in the result parameter.  This parameter must be NULL when initiating a new Bind. The caller must free the result message after each call using ldap_msgfree().\u2029The ldap_sasl_interactive_bind() function returns an LDAP result code. If the code is LDAP_SASL_BIND_IN_PROGRESS then the Bind is not complete yet, and  this  function  must  be\u2029called again with the next result from the server.\u2029\u2029REBINDING\u2029The  ldap_set_rebind_proc function() sets the process to use for binding when an operation returns a referral. This function is used when an application needs to bind to another\u2029server in order to follow a referral or search continuation reference.\u2029\u2029The function takes ld, the rebind function, and the params, the arbitrary data like state information which the client might need to  properly  rebind.   The  LDAP_OPT_REFERRALS\u2029option in the ld must be set to ON for the libraries to use the rebind function. Use the ldap_set_option function to set the value.\u2029\u2029The rebind function parameters are as follows:\u2029\u2029The ld parameter must be used by the application when binding to the referred server if the application wants the libraries to follow the referral.\u2029\u2029The url parameter points to the URL referral string received from the LDAP server.  The LDAP application can use the ldap_url_parse(3) function to parse the string into its com\u2010\u2029ponents.\u2029\u2029The request parameter specifies the type of request that generated the referral.\u2029\u2029The msgid parameter specifies the message ID of the request generating the referral.\u2029\u2029The params parameter is the same value as passed originally to the ldap_set_rebind_proc() function.\u2029\u2029The LDAP libraries set all the parameters when they call the rebind function. The application should not attempt to free either the ld or the url structures in the rebind  func\u2010\u2029tion.\u2029\u2029The  application  must  supply to the rebind function the required authentication information such as, user name, password, and certificates. The rebind function must use a syn\u2010\u2029chronous bind method.\u2029\u2029UNBINDING\u2029The ldap_unbind() call is used to unbind from the directory, terminate the current association, and free the resources contained in the ld structure.  Once  it  is  called,  the\u2029connection  to  the LDAP server is closed, and the ld structure is invalid.  The ldap_unbind_s() call is just another name for ldap_unbind(); both of these calls are synchronous\u2029in nature.\u2029\u2029The ldap_unbind_ext() and ldap_unbind_ext_s() allows the operations to specify  controls.\u2029\u2029ERRORS\u2029Asynchronous routines will return -1 in case of error, setting the ld_errno parameter of the ld structure.  Synchronous  routines  return  whatever  ld_errno  is  set  to.   See\u2029ldap_error(3) for more information.\u2029\u2029NOTES\u2029If  an anonymous bind is sufficient for the application, the rebind process need not be provided. The LDAP libraries with the LDAP_OPT_REFERRALS option set to ON (default value)\u2029will automatically follow referrals using an anonymous bind.\u2029\u2029If the application needs stronger authentication than an anonymous bind, you need to provide a rebind process for that authentication method.  The bind method must  be  synchro\u2010\u2029nous.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_open(3), ldap_set_option(3), ldap_url_parse(3) RFC 4422 (http://www.rfc-editor.org), Cyrus SASL (http://asg.web.cmu.edu/sasl/)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 889, "position": [878010, 888692], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_bind,   ldap_bind_s,   ldap_simple_bind,  ldap_simple_bind_s,  ldap_sasl_bind,  ldap_sasl_bind_s,  ldap_sasl_interactive_bind_s,  ldap_parse_sasl_bind_result,  ldap_unbind,\u2029ldap_unbind_s, ldap_unbind_ext, ldap_unbind_ext_s, ldap_set_rebind_proc - LDAP bind routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_bind(LDAP *ld, const char *who, const char *cred,\u2029int method);\u2029\u2029int ldap_bind_s(LDAP *ld, const char *who, const char *cred,\u2029int method);\u2029\u2029int ldap_simple_bind(LDAP *ld, const char *who, const char *passwd);\u2029\u2029int ldap_simple_bind_s(LDAP *ld, const char *who, const char *passwd);\u2029\u2029int ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,\u2029struct berval *cred, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[], int *msgidp);\u2029\u2029int ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,\u2029struct berval *cred, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[], struct berval **servercredp);\u2029\u2029int ldap_parse_sasl_bind_result(LDAP *ld, LDAPMessage *res,\u2029struct berval **servercredp, int freeit);\u2029\u2029int ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn,\u2029const char *mechs,\u2029LDAPControl *sctrls[], LDAPControl *cctrls[],\u2029unsigned flags, LDAP_SASL_INTERACT_PROC *interact,\u2029void *defaults);\u2029\u2029int ldap_sasl_interactive_bind(LDAP *ld, const char *dn,\u2029const char *mechs,\u2029LDAPControl *sctrls[], LDAPControl *cctrls[],\u2029unsigned flags, LDAP_SASL_INTERACT_PROC *interact,\u2029void *defaults, LDAPMessage *result,\u2029const char **rmechp, int *msgidp);\u2029\u2029int (LDAP_SASL_INTERACT_PROC)(LDAP *ld, unsigned flags, void *defaults, void *sasl_interact);\u2029\u2029int ldap_unbind(LDAP *ld);\u2029\u2029int ldap_unbind_s(LDAP *ld);\u2029\u2029int ldap_unbind_ext(LDAP *ld, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[]);\u2029\u2029int ldap_unbind_ext_s(LDAP *ld, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[]);\u2029\u2029int ldap_set_rebind_proc (LDAP *ld, LDAP_REBIND_PROC *ldap_proc, void *params);\u2029\u2029int (LDAP_REBIND_PROC)(LDAP *ld, LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *params);\u2029\u2029DESCRIPTION\u2029These routines provide various interfaces to the LDAP bind operation.  After an association with an LDAP server is made using ldap_init(3), an LDAP bind operation should be per\u2010\u2029formed  before  other operations are attempted over the connection.  An LDAP bind is required when using Version 2 of the LDAP protocol; it is optional for Version 3 but is usu\u2010\u2029ally needed due to security considerations.\u2029\u2029There are three types of bind calls, ones providing simple authentication, ones providing SASL authentication, and general routines  capable  of  doing  either  simple  or  SASL\u2029authentication.\u2029\u2029SASL  (Simple  Authentication and Security Layer) can negotiate one of many different kinds of authentication.  Both synchronous and asynchronous versions of each variant of the\u2029bind call are provided.  All routines take ld as their first parameter, as returned from ldap_init(3).\u2029\u2029SIMPLE AUTHENTICATION\u2029The simplest form of the bind call is ldap_simple_bind_s().  It takes the DN to bind as in who, and the userPassword associated with the entry in passwd.   It  returns  an  LDAP\u2029error  indication  (see ldap_error(3)).  The ldap_simple_bind() call is asynchronous, taking the same parameters but only initiating the bind operation and returning the message\u2029id of the request it sent.  The result of the operation can be obtained by a subsequent call to ldap_result(3).\u2029\u2029GENERAL AUTHENTICATION\u2029The ldap_bind() and ldap_bind_s() routines can be used when the authentication method to use needs to be selected at runtime.  They both take an extra method parameter selecting\u2029the  authentication  method  to  use.   It  should  be  set to LDAP_AUTH_SIMPLE to select simple authentication.  ldap_bind() returns the message id of the request it initiates.\u2029ldap_bind_s() returns an LDAP error indication.\u2029\u2029SASL AUTHENTICATION\u2029For SASL binds the server always ignores any provided DN, so the dn parameter should always be NULL.  ldap_sasl_bind_s() sends a single SASL bind request  with  the  given  SASL\u2029mechanism and credentials in the cred parameter. The format of the credentials depends on the particular SASL mechanism in use. For mechanisms that provide mutual authentication\u2029the server's credentials will be returned in the servercredp parameter.  The routine returns an LDAP error indication (see ldap_error(3)).  The ldap_sasl_bind()  call  is  asyn\u2010\u2029chronous,  taking  the  same parameters but only sending the request and returning the message id of the request it sent. The result of the operation can be obtained by a subse\u2010\u2029quent call to ldap_result(3).  The result must be additionally parsed by ldap_parse_sasl_bind_result() to obtain any server credentials sent from the server.\u2029\u2029Many SASL mechanisms require multiple message exchanges to perform a complete authentication. Applications should generally use ldap_sasl_interactive_bind_s() rather than  call\u2010\u2029ing  the  basic ldap_sasl_bind() functions directly. The mechs parameter should contain a space-separated list of candidate mechanisms to use. If this parameter is NULL or empty\u2029the library will query the supportedSASLMechanisms attribute from the server's rootDSE for the list of SASL mechanisms the server supports.  The  flags  parameter  controls  the\u2029interaction used to retrieve any necessary SASL authentication parameters and should be one of:\u2029\u2029LDAP_SASL_AUTOMATIC\u2029use defaults if available, prompt otherwise\u2029\u2029LDAP_SASL_INTERACTIVE\u2029always prompt\u2029\u2029LDAP_SASL_QUIET\u2029never prompt\u2029\u2029The  interact  function uses the provided defaults to handle requests from the SASL library for particular authentication parameters. There is no defined format for the defaults\u2029information; it is up to the caller to use whatever format is appropriate for the supplied interact function.   The  sasl_interact  parameter  comes  from  the  underlying  SASL\u2029library. When used with Cyrus SASL this is an array of sasl_interact_t structures. The Cyrus SASL library will prompt for a variety of inputs, including:\u2029\u2029SASL_CB_GETREALM\u2029the realm for the authentication attempt\u2029\u2029SASL_CB_AUTHNAME\u2029the username to authenticate\u2029\u2029SASL_CB_PASS\u2029the password for the provided username\u2029\u2029SASL_CB_USER\u2029the username to use for proxy authorization\u2029\u2029SASL_CB_NOECHOPROMPT\u2029generic prompt for input with input echoing disabled\u2029\u2029SASL_CB_ECHOPROMPT\u2029generic prompt for input with input echoing enabled\u2029\u2029SASL_CB_LIST_END\u2029indicates the end of the array of prompts\u2029\u2029See the Cyrus SASL documentation for more details.\u2029\u2029Applications  which need to manage connections asynchronously may use ldap_sasl_interactive_bind() instead of the synchronous version.  A valid mechs parameter must be supplied,\u2029otherwise the library will be forced to query the server for a list of supported mechanisms, and this query will be performed synchronously.  The other parameters are  the  same\u2029as  for  the  synchronous function, with three additional parameters.  The actual SASL mechanism that was used, and the message ID for use with ldap_result() will be returned in\u2029rmechp and msgidp, respectively.  The value in rmechp must not be modified by the caller and must be passed back on each subsequent call. The message obtained from ldap_result()\u2029must  be  passed  in the result parameter.  This parameter must be NULL when initiating a new Bind. The caller must free the result message after each call using ldap_msgfree().\u2029The ldap_sasl_interactive_bind() function returns an LDAP result code. If the code is LDAP_SASL_BIND_IN_PROGRESS then the Bind is not complete yet, and  this  function  must  be\u2029called again with the next result from the server.\u2029\u2029REBINDING\u2029The  ldap_set_rebind_proc function() sets the process to use for binding when an operation returns a referral. This function is used when an application needs to bind to another\u2029server in order to follow a referral or search continuation reference.\u2029\u2029The function takes ld, the rebind function, and the params, the arbitrary data like state information which the client might need to  properly  rebind.   The  LDAP_OPT_REFERRALS\u2029option in the ld must be set to ON for the libraries to use the rebind function. Use the ldap_set_option function to set the value.\u2029\u2029The rebind function parameters are as follows:\u2029\u2029The ld parameter must be used by the application when binding to the referred server if the application wants the libraries to follow the referral.\u2029\u2029The url parameter points to the URL referral string received from the LDAP server.  The LDAP application can use the ldap_url_parse(3) function to parse the string into its com\u2010\u2029ponents.\u2029\u2029The request parameter specifies the type of request that generated the referral.\u2029\u2029The msgid parameter specifies the message ID of the request generating the referral.\u2029\u2029The params parameter is the same value as passed originally to the ldap_set_rebind_proc() function.\u2029\u2029The LDAP libraries set all the parameters when they call the rebind function. The application should not attempt to free either the ld or the url structures in the rebind  func\u2010\u2029tion.\u2029\u2029The  application  must  supply to the rebind function the required authentication information such as, user name, password, and certificates. The rebind function must use a syn\u2010\u2029chronous bind method.\u2029\u2029UNBINDING\u2029The ldap_unbind() call is used to unbind from the directory, terminate the current association, and free the resources contained in the ld structure.  Once  it  is  called,  the\u2029connection  to  the LDAP server is closed, and the ld structure is invalid.  The ldap_unbind_s() call is just another name for ldap_unbind(); both of these calls are synchronous\u2029in nature.\u2029\u2029The ldap_unbind_ext() and ldap_unbind_ext_s() allows the operations to specify  controls.\u2029\u2029ERRORS\u2029Asynchronous routines will return -1 in case of error, setting the ld_errno parameter of the ld structure.  Synchronous  routines  return  whatever  ld_errno  is  set  to.   See\u2029ldap_error(3) for more information.\u2029\u2029NOTES\u2029If  an anonymous bind is sufficient for the application, the rebind process need not be provided. The LDAP libraries with the LDAP_OPT_REFERRALS option set to ON (default value)\u2029will automatically follow referrals using an anonymous bind.\u2029\u2029If the application needs stronger authentication than an anonymous bind, you need to provide a rebind process for that authentication method.  The bind method must  be  synchro\u2010\u2029nous.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_open(3), ldap_set_option(3), ldap_url_parse(3) RFC 4422 (http://www.rfc-editor.org), Cyrus SASL (http://asg.web.cmu.edu/sasl/)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 888, "position": [806475, 817157], "check": 1, "intersection": 10683, "FP_dupl": 11430, "FN_dupl": 0, "F": 0.6514818880351262, "Prec_Dupl": 0.4831094831094831, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_bind,   ldap_bind_s,   ldap_simple_bind,  ldap_simple_bind_s,  ldap_sasl_bind,  ldap_sasl_bind_s,  ldap_sasl_interactive_bind_s,  ldap_parse_sasl_bind_result,  ldap_unbind,\u2029ldap_unbind_s, ldap_unbind_ext, ldap_unbind_ext_s, ldap_set_rebind_proc - LDAP bind routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_bind(LDAP *ld, const char *who, const char *cred,\u2029int method);\u2029\u2029int ldap_bind_s(LDAP *ld, const char *who, const char *cred,\u2029int method);\u2029\u2029int ldap_simple_bind(LDAP *ld, const char *who, const char *passwd);\u2029\u2029int ldap_simple_bind_s(LDAP *ld, const char *who, const char *passwd);\u2029\u2029int ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,\u2029struct berval *cred, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[], int *msgidp);\u2029\u2029int ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,\u2029struct berval *cred, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[], struct berval **servercredp);\u2029\u2029int ldap_parse_sasl_bind_result(LDAP *ld, LDAPMessage *res,\u2029struct berval **servercredp, int freeit);\u2029\u2029int ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn,\u2029const char *mechs,\u2029LDAPControl *sctrls[], LDAPControl *cctrls[],\u2029unsigned flags, LDAP_SASL_INTERACT_PROC *interact,\u2029void *defaults);\u2029\u2029int ldap_sasl_interactive_bind(LDAP *ld, const char *dn,\u2029const char *mechs,\u2029LDAPControl *sctrls[], LDAPControl *cctrls[],\u2029unsigned flags, LDAP_SASL_INTERACT_PROC *interact,\u2029void *defaults, LDAPMessage *result,\u2029const char **rmechp, int *msgidp);\u2029\u2029int (LDAP_SASL_INTERACT_PROC)(LDAP *ld, unsigned flags, void *defaults, void *sasl_interact);\u2029\u2029int ldap_unbind(LDAP *ld);\u2029\u2029int ldap_unbind_s(LDAP *ld);\u2029\u2029int ldap_unbind_ext(LDAP *ld, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[]);\u2029\u2029int ldap_unbind_ext_s(LDAP *ld, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[]);\u2029\u2029int ldap_set_rebind_proc (LDAP *ld, LDAP_REBIND_PROC *ldap_proc, void *params);\u2029\u2029int (LDAP_REBIND_PROC)(LDAP *ld, LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *params);\u2029\u2029DESCRIPTION\u2029These routines provide various interfaces to the LDAP bind operation.  After an association with an LDAP server is made using ldap_init(3), an LDAP bind operation should be per\u2010\u2029formed  before  other operations are attempted over the connection.  An LDAP bind is required when using Version 2 of the LDAP protocol; it is optional for Version 3 but is usu\u2010\u2029ally needed due to security considerations.\u2029\u2029There are three types of bind calls, ones providing simple authentication, ones providing SASL authentication, and general routines  capable  of  doing  either  simple  or  SASL\u2029authentication.\u2029\u2029SASL  (Simple  Authentication and Security Layer) can negotiate one of many different kinds of authentication.  Both synchronous and asynchronous versions of each variant of the\u2029bind call are provided.  All routines take ld as their first parameter, as returned from ldap_init(3).\u2029\u2029SIMPLE AUTHENTICATION\u2029The simplest form of the bind call is ldap_simple_bind_s().  It takes the DN to bind as in who, and the userPassword associated with the entry in passwd.   It  returns  an  LDAP\u2029error  indication  (see ldap_error(3)).  The ldap_simple_bind() call is asynchronous, taking the same parameters but only initiating the bind operation and returning the message\u2029id of the request it sent.  The result of the operation can be obtained by a subsequent call to ldap_result(3).\u2029\u2029GENERAL AUTHENTICATION\u2029The ldap_bind() and ldap_bind_s() routines can be used when the authentication method to use needs to be selected at runtime.  They both take an extra method parameter selecting\u2029the  authentication  method  to  use.   It  should  be  set to LDAP_AUTH_SIMPLE to select simple authentication.  ldap_bind() returns the message id of the request it initiates.\u2029ldap_bind_s() returns an LDAP error indication.\u2029\u2029SASL AUTHENTICATION\u2029For SASL binds the server always ignores any provided DN, so the dn parameter should always be NULL.  ldap_sasl_bind_s() sends a single SASL bind request  with  the  given  SASL\u2029mechanism and credentials in the cred parameter. The format of the credentials depends on the particular SASL mechanism in use. For mechanisms that provide mutual authentication\u2029the server's credentials will be returned in the servercredp parameter.  The routine returns an LDAP error indication (see ldap_error(3)).  The ldap_sasl_bind()  call  is  asyn\u2010\u2029chronous,  taking  the  same parameters but only sending the request and returning the message id of the request it sent. The result of the operation can be obtained by a subse\u2010\u2029quent call to ldap_result(3).  The result must be additionally parsed by ldap_parse_sasl_bind_result() to obtain any server credentials sent from the server.\u2029\u2029Many SASL mechanisms require multiple message exchanges to perform a complete authentication. Applications should generally use ldap_sasl_interactive_bind_s() rather than  call\u2010\u2029ing  the  basic ldap_sasl_bind() functions directly. The mechs parameter should contain a space-separated list of candidate mechanisms to use. If this parameter is NULL or empty\u2029the library will query the supportedSASLMechanisms attribute from the server's rootDSE for the list of SASL mechanisms the server supports.  The  flags  parameter  controls  the\u2029interaction used to retrieve any necessary SASL authentication parameters and should be one of:\u2029\u2029LDAP_SASL_AUTOMATIC\u2029use defaults if available, prompt otherwise\u2029\u2029LDAP_SASL_INTERACTIVE\u2029always prompt\u2029\u2029LDAP_SASL_QUIET\u2029never prompt\u2029\u2029The  interact  function uses the provided defaults to handle requests from the SASL library for particular authentication parameters. There is no defined format for the defaults\u2029information; it is up to the caller to use whatever format is appropriate for the supplied interact function.   The  sasl_interact  parameter  comes  from  the  underlying  SASL\u2029library. When used with Cyrus SASL this is an array of sasl_interact_t structures. The Cyrus SASL library will prompt for a variety of inputs, including:\u2029\u2029SASL_CB_GETREALM\u2029the realm for the authentication attempt\u2029\u2029SASL_CB_AUTHNAME\u2029the username to authenticate\u2029\u2029SASL_CB_PASS\u2029the password for the provided username\u2029\u2029SASL_CB_USER\u2029the username to use for proxy authorization\u2029\u2029SASL_CB_NOECHOPROMPT\u2029generic prompt for input with input echoing disabled\u2029\u2029SASL_CB_ECHOPROMPT\u2029generic prompt for input with input echoing enabled\u2029\u2029SASL_CB_LIST_END\u2029indicates the end of the array of prompts\u2029\u2029See the Cyrus SASL documentation for more details.\u2029\u2029Applications  which need to manage connections asynchronously may use ldap_sasl_interactive_bind() instead of the synchronous version.  A valid mechs parameter must be supplied,\u2029otherwise the library will be forced to query the server for a list of supported mechanisms, and this query will be performed synchronously.  The other parameters are  the  same\u2029as  for  the  synchronous function, with three additional parameters.  The actual SASL mechanism that was used, and the message ID for use with ldap_result() will be returned in\u2029rmechp and msgidp, respectively.  The value in rmechp must not be modified by the caller and must be passed back on each subsequent call. The message obtained from ldap_result()\u2029must  be  passed  in the result parameter.  This parameter must be NULL when initiating a new Bind. The caller must free the result message after each call using ldap_msgfree().\u2029The ldap_sasl_interactive_bind() function returns an LDAP result code. If the code is LDAP_SASL_BIND_IN_PROGRESS then the Bind is not complete yet, and  this  function  must  be\u2029called again with the next result from the server.\u2029\u2029REBINDING\u2029The  ldap_set_rebind_proc function() sets the process to use for binding when an operation returns a referral. This function is used when an application needs to bind to another\u2029server in order to follow a referral or search continuation reference.\u2029\u2029The function takes ld, the rebind function, and the params, the arbitrary data like state information which the client might need to  properly  rebind.   The  LDAP_OPT_REFERRALS\u2029option in the ld must be set to ON for the libraries to use the rebind function. Use the ldap_set_option function to set the value.\u2029\u2029The rebind function parameters are as follows:\u2029\u2029The ld parameter must be used by the application when binding to the referred server if the application wants the libraries to follow the referral.\u2029\u2029The url parameter points to the URL referral string received from the LDAP server.  The LDAP application can use the ldap_url_parse(3) function to parse the string into its com\u2010\u2029ponents.\u2029\u2029The request parameter specifies the type of request that generated the referral.\u2029\u2029The msgid parameter specifies the message ID of the request generating the referral.\u2029\u2029The params parameter is the same value as passed originally to the ldap_set_rebind_proc() function.\u2029\u2029The LDAP libraries set all the parameters when they call the rebind function. The application should not attempt to free either the ld or the url structures in the rebind  func\u2010\u2029tion.\u2029\u2029The  application  must  supply to the rebind function the required authentication information such as, user name, password, and certificates. The rebind function must use a syn\u2010\u2029chronous bind method.\u2029\u2029UNBINDING\u2029The ldap_unbind() call is used to unbind from the directory, terminate the current association, and free the resources contained in the ld structure.  Once  it  is  called,  the\u2029connection  to  the LDAP server is closed, and the ld structure is invalid.  The ldap_unbind_s() call is just another name for ldap_unbind(); both of these calls are synchronous\u2029in nature.\u2029\u2029The ldap_unbind_ext() and ldap_unbind_ext_s() allows the operations to specify  controls.\u2029\u2029ERRORS\u2029Asynchronous routines will return -1 in case of error, setting the ld_errno parameter of the ld structure.  Synchronous  routines  return  whatever  ld_errno  is  set  to.   See\u2029ldap_error(3) for more information.\u2029\u2029NOTES\u2029If  an anonymous bind is sufficient for the application, the rebind process need not be provided. The LDAP libraries with the LDAP_OPT_REFERRALS option set to ON (default value)\u2029will automatically follow referrals using an anonymous bind.\u2029\u2029If the application needs stronger authentication than an anonymous bind, you need to provide a rebind process for that authentication method.  The bind method must  be  synchro\u2010\u2029nous.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_open(3), ldap_set_option(3), ldap_url_parse(3) RFC 4422 (http://www.rfc-editor.org), Cyrus SASL (http://asg.web.cmu.edu/sasl/)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 887, "position": [795420, 806102], "check": 1, "intersection": 10683, "FP_dupl": 11430, "FN_dupl": 0, "F": 0.6514818880351262, "Prec_Dupl": 0.4831094831094831, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_bind,   ldap_bind_s,   ldap_simple_bind,  ldap_simple_bind_s,  ldap_sasl_bind,  ldap_sasl_bind_s,  ldap_sasl_interactive_bind_s,  ldap_parse_sasl_bind_result,  ldap_unbind,\u2029ldap_unbind_s, ldap_unbind_ext, ldap_unbind_ext_s, ldap_set_rebind_proc - LDAP bind routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_bind(LDAP *ld, const char *who, const char *cred,\u2029int method);\u2029\u2029int ldap_bind_s(LDAP *ld, const char *who, const char *cred,\u2029int method);\u2029\u2029int ldap_simple_bind(LDAP *ld, const char *who, const char *passwd);\u2029\u2029int ldap_simple_bind_s(LDAP *ld, const char *who, const char *passwd);\u2029\u2029int ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,\u2029struct berval *cred, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[], int *msgidp);\u2029\u2029int ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,\u2029struct berval *cred, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[], struct berval **servercredp);\u2029\u2029int ldap_parse_sasl_bind_result(LDAP *ld, LDAPMessage *res,\u2029struct berval **servercredp, int freeit);\u2029\u2029int ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn,\u2029const char *mechs,\u2029LDAPControl *sctrls[], LDAPControl *cctrls[],\u2029unsigned flags, LDAP_SASL_INTERACT_PROC *interact,\u2029void *defaults);\u2029\u2029int ldap_sasl_interactive_bind(LDAP *ld, const char *dn,\u2029const char *mechs,\u2029LDAPControl *sctrls[], LDAPControl *cctrls[],\u2029unsigned flags, LDAP_SASL_INTERACT_PROC *interact,\u2029void *defaults, LDAPMessage *result,\u2029const char **rmechp, int *msgidp);\u2029\u2029int (LDAP_SASL_INTERACT_PROC)(LDAP *ld, unsigned flags, void *defaults, void *sasl_interact);\u2029\u2029int ldap_unbind(LDAP *ld);\u2029\u2029int ldap_unbind_s(LDAP *ld);\u2029\u2029int ldap_unbind_ext(LDAP *ld, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[]);\u2029\u2029int ldap_unbind_ext_s(LDAP *ld, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[]);\u2029\u2029int ldap_set_rebind_proc (LDAP *ld, LDAP_REBIND_PROC *ldap_proc, void *params);\u2029\u2029int (LDAP_REBIND_PROC)(LDAP *ld, LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *params);\u2029\u2029DESCRIPTION\u2029These routines provide various interfaces to the LDAP bind operation.  After an association with an LDAP server is made using ldap_init(3), an LDAP bind operation should be per\u2010\u2029formed  before  other operations are attempted over the connection.  An LDAP bind is required when using Version 2 of the LDAP protocol; it is optional for Version 3 but is usu\u2010\u2029ally needed due to security considerations.\u2029\u2029There are three types of bind calls, ones providing simple authentication, ones providing SASL authentication, and general routines  capable  of  doing  either  simple  or  SASL\u2029authentication.\u2029\u2029SASL  (Simple  Authentication and Security Layer) can negotiate one of many different kinds of authentication.  Both synchronous and asynchronous versions of each variant of the\u2029bind call are provided.  All routines take ld as their first parameter, as returned from ldap_init(3).\u2029\u2029SIMPLE AUTHENTICATION\u2029The simplest form of the bind call is ldap_simple_bind_s().  It takes the DN to bind as in who, and the userPassword associated with the entry in passwd.   It  returns  an  LDAP\u2029error  indication  (see ldap_error(3)).  The ldap_simple_bind() call is asynchronous, taking the same parameters but only initiating the bind operation and returning the message\u2029id of the request it sent.  The result of the operation can be obtained by a subsequent call to ldap_result(3).\u2029\u2029GENERAL AUTHENTICATION\u2029The ldap_bind() and ldap_bind_s() routines can be used when the authentication method to use needs to be selected at runtime.  They both take an extra method parameter selecting\u2029the  authentication  method  to  use.   It  should  be  set to LDAP_AUTH_SIMPLE to select simple authentication.  ldap_bind() returns the message id of the request it initiates.\u2029ldap_bind_s() returns an LDAP error indication.\u2029\u2029SASL AUTHENTICATION\u2029For SASL binds the server always ignores any provided DN, so the dn parameter should always be NULL.  ldap_sasl_bind_s() sends a single SASL bind request  with  the  given  SASL\u2029mechanism and credentials in the cred parameter. The format of the credentials depends on the particular SASL mechanism in use. For mechanisms that provide mutual authentication\u2029the server's credentials will be returned in the servercredp parameter.  The routine returns an LDAP error indication (see ldap_error(3)).  The ldap_sasl_bind()  call  is  asyn\u2010\u2029chronous,  taking  the  same parameters but only sending the request and returning the message id of the request it sent. The result of the operation can be obtained by a subse\u2010\u2029quent call to ldap_result(3).  The result must be additionally parsed by ldap_parse_sasl_bind_result() to obtain any server credentials sent from the server.\u2029\u2029Many SASL mechanisms require multiple message exchanges to perform a complete authentication. Applications should generally use ldap_sasl_interactive_bind_s() rather than  call\u2010\u2029ing  the  basic ldap_sasl_bind() functions directly. The mechs parameter should contain a space-separated list of candidate mechanisms to use. If this parameter is NULL or empty\u2029the library will query the supportedSASLMechanisms attribute from the server's rootDSE for the list of SASL mechanisms the server supports.  The  flags  parameter  controls  the\u2029interaction used to retrieve any necessary SASL authentication parameters and should be one of:\u2029\u2029LDAP_SASL_AUTOMATIC\u2029use defaults if available, prompt otherwise\u2029\u2029LDAP_SASL_INTERACTIVE\u2029always prompt\u2029\u2029LDAP_SASL_QUIET\u2029never prompt\u2029\u2029The  interact  function uses the provided defaults to handle requests from the SASL library for particular authentication parameters. There is no defined format for the defaults\u2029information; it is up to the caller to use whatever format is appropriate for the supplied interact function.   The  sasl_interact  parameter  comes  from  the  underlying  SASL\u2029library. When used with Cyrus SASL this is an array of sasl_interact_t structures. The Cyrus SASL library will prompt for a variety of inputs, including:\u2029\u2029SASL_CB_GETREALM\u2029the realm for the authentication attempt\u2029\u2029SASL_CB_AUTHNAME\u2029the username to authenticate\u2029\u2029SASL_CB_PASS\u2029the password for the provided username\u2029\u2029SASL_CB_USER\u2029the username to use for proxy authorization\u2029\u2029SASL_CB_NOECHOPROMPT\u2029generic prompt for input with input echoing disabled\u2029\u2029SASL_CB_ECHOPROMPT\u2029generic prompt for input with input echoing enabled\u2029\u2029SASL_CB_LIST_END\u2029indicates the end of the array of prompts\u2029\u2029See the Cyrus SASL documentation for more details.\u2029\u2029Applications  which need to manage connections asynchronously may use ldap_sasl_interactive_bind() instead of the synchronous version.  A valid mechs parameter must be supplied,\u2029otherwise the library will be forced to query the server for a list of supported mechanisms, and this query will be performed synchronously.  The other parameters are  the  same\u2029as  for  the  synchronous function, with three additional parameters.  The actual SASL mechanism that was used, and the message ID for use with ldap_result() will be returned in\u2029rmechp and msgidp, respectively.  The value in rmechp must not be modified by the caller and must be passed back on each subsequent call. The message obtained from ldap_result()\u2029must  be  passed  in the result parameter.  This parameter must be NULL when initiating a new Bind. The caller must free the result message after each call using ldap_msgfree().\u2029The ldap_sasl_interactive_bind() function returns an LDAP result code. If the code is LDAP_SASL_BIND_IN_PROGRESS then the Bind is not complete yet, and  this  function  must  be\u2029called again with the next result from the server.\u2029\u2029REBINDING\u2029The  ldap_set_rebind_proc function() sets the process to use for binding when an operation returns a referral. This function is used when an application needs to bind to another\u2029server in order to follow a referral or search continuation reference.\u2029\u2029The function takes ld, the rebind function, and the params, the arbitrary data like state information which the client might need to  properly  rebind.   The  LDAP_OPT_REFERRALS\u2029option in the ld must be set to ON for the libraries to use the rebind function. Use the ldap_set_option function to set the value.\u2029\u2029The rebind function parameters are as follows:\u2029\u2029The ld parameter must be used by the application when binding to the referred server if the application wants the libraries to follow the referral.\u2029\u2029The url parameter points to the URL referral string received from the LDAP server.  The LDAP application can use the ldap_url_parse(3) function to parse the string into its com\u2010\u2029ponents.\u2029\u2029The request parameter specifies the type of request that generated the referral.\u2029\u2029The msgid parameter specifies the message ID of the request generating the referral.\u2029\u2029The params parameter is the same value as passed originally to the ldap_set_rebind_proc() function.\u2029\u2029The LDAP libraries set all the parameters when they call the rebind function. The application should not attempt to free either the ld or the url structures in the rebind  func\u2010\u2029tion.\u2029\u2029The  application  must  supply to the rebind function the required authentication information such as, user name, password, and certificates. The rebind function must use a syn\u2010\u2029chronous bind method.\u2029\u2029UNBINDING\u2029The ldap_unbind() call is used to unbind from the directory, terminate the current association, and free the resources contained in the ld structure.  Once  it  is  called,  the\u2029connection  to  the LDAP server is closed, and the ld structure is invalid.  The ldap_unbind_s() call is just another name for ldap_unbind(); both of these calls are synchronous\u2029in nature.\u2029\u2029The ldap_unbind_ext() and ldap_unbind_ext_s() allows the operations to specify  controls.\u2029\u2029ERRORS\u2029Asynchronous routines will return -1 in case of error, setting the ld_errno parameter of the ld structure.  Synchronous  routines  return  whatever  ld_errno  is  set  to.   See\u2029ldap_error(3) for more information.\u2029\u2029NOTES\u2029If  an anonymous bind is sufficient for the application, the rebind process need not be provided. The LDAP libraries with the LDAP_OPT_REFERRALS option set to ON (default value)\u2029will automatically follow referrals using an anonymous bind.\u2029\u2029If the application needs stronger authentication than an anonymous bind, you need to provide a rebind process for that authentication method.  The bind method must  be  synchro\u2010\u2029nous.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_open(3), ldap_set_option(3), ldap_url_parse(3) RFC 4422 (http://www.rfc-editor.org), Cyrus SASL (http://asg.web.cmu.edu/sasl/)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 886, "position": [421652, 432334], "check": 1, "intersection": 10683, "FP_dupl": 11430, "FN_dupl": 0, "F": 0.6514818880351262, "Prec_Dupl": 0.4831094831094831, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_bind,   ldap_bind_s,   ldap_simple_bind,  ldap_simple_bind_s,  ldap_sasl_bind,  ldap_sasl_bind_s,  ldap_sasl_interactive_bind_s,  ldap_parse_sasl_bind_result,  ldap_unbind,\u2029ldap_unbind_s, ldap_unbind_ext, ldap_unbind_ext_s, ldap_set_rebind_proc - LDAP bind routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_bind(LDAP *ld, const char *who, const char *cred,\u2029int method);\u2029\u2029int ldap_bind_s(LDAP *ld, const char *who, const char *cred,\u2029int method);\u2029\u2029int ldap_simple_bind(LDAP *ld, const char *who, const char *passwd);\u2029\u2029int ldap_simple_bind_s(LDAP *ld, const char *who, const char *passwd);\u2029\u2029int ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,\u2029struct berval *cred, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[], int *msgidp);\u2029\u2029int ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,\u2029struct berval *cred, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[], struct berval **servercredp);\u2029\u2029int ldap_parse_sasl_bind_result(LDAP *ld, LDAPMessage *res,\u2029struct berval **servercredp, int freeit);\u2029\u2029int ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn,\u2029const char *mechs,\u2029LDAPControl *sctrls[], LDAPControl *cctrls[],\u2029unsigned flags, LDAP_SASL_INTERACT_PROC *interact,\u2029void *defaults);\u2029\u2029int ldap_sasl_interactive_bind(LDAP *ld, const char *dn,\u2029const char *mechs,\u2029LDAPControl *sctrls[], LDAPControl *cctrls[],\u2029unsigned flags, LDAP_SASL_INTERACT_PROC *interact,\u2029void *defaults, LDAPMessage *result,\u2029const char **rmechp, int *msgidp);\u2029\u2029int (LDAP_SASL_INTERACT_PROC)(LDAP *ld, unsigned flags, void *defaults, void *sasl_interact);\u2029\u2029int ldap_unbind(LDAP *ld);\u2029\u2029int ldap_unbind_s(LDAP *ld);\u2029\u2029int ldap_unbind_ext(LDAP *ld, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[]);\u2029\u2029int ldap_unbind_ext_s(LDAP *ld, LDAPControl *sctrls[],\u2029LDAPControl *cctrls[]);\u2029\u2029int ldap_set_rebind_proc (LDAP *ld, LDAP_REBIND_PROC *ldap_proc, void *params);\u2029\u2029int (LDAP_REBIND_PROC)(LDAP *ld, LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *params);\u2029\u2029DESCRIPTION\u2029These routines provide various interfaces to the LDAP bind operation.  After an association with an LDAP server is made using ldap_init(3), an LDAP bind operation should be per\u2010\u2029formed  before  other operations are attempted over the connection.  An LDAP bind is required when using Version 2 of the LDAP protocol; it is optional for Version 3 but is usu\u2010\u2029ally needed due to security considerations.\u2029\u2029There are three types of bind calls, ones providing simple authentication, ones providing SASL authentication, and general routines  capable  of  doing  either  simple  or  SASL\u2029authentication.\u2029\u2029SASL  (Simple  Authentication and Security Layer) can negotiate one of many different kinds of authentication.  Both synchronous and asynchronous versions of each variant of the\u2029bind call are provided.  All routines take ld as their first parameter, as returned from ldap_init(3).\u2029\u2029SIMPLE AUTHENTICATION\u2029The simplest form of the bind call is ldap_simple_bind_s().  It takes the DN to bind as in who, and the userPassword associated with the entry in passwd.   It  returns  an  LDAP\u2029error  indication  (see ldap_error(3)).  The ldap_simple_bind() call is asynchronous, taking the same parameters but only initiating the bind operation and returning the message\u2029id of the request it sent.  The result of the operation can be obtained by a subsequent call to ldap_result(3).\u2029\u2029GENERAL AUTHENTICATION\u2029The ldap_bind() and ldap_bind_s() routines can be used when the authentication method to use needs to be selected at runtime.  They both take an extra method parameter selecting\u2029the  authentication  method  to  use.   It  should  be  set to LDAP_AUTH_SIMPLE to select simple authentication.  ldap_bind() returns the message id of the request it initiates.\u2029ldap_bind_s() returns an LDAP error indication.\u2029\u2029SASL AUTHENTICATION\u2029For SASL binds the server always ignores any provided DN, so the dn parameter should always be NULL.  ldap_sasl_bind_s() sends a single SASL bind request  with  the  given  SASL\u2029mechanism and credentials in the cred parameter. The format of the credentials depends on the particular SASL mechanism in use. For mechanisms that provide mutual authentication\u2029the server's credentials will be returned in the servercredp parameter.  The routine returns an LDAP error indication (see ldap_error(3)).  The ldap_sasl_bind()  call  is  asyn\u2010\u2029chronous,  taking  the  same parameters but only sending the request and returning the message id of the request it sent. The result of the operation can be obtained by a subse\u2010\u2029quent call to ldap_result(3).  The result must be additionally parsed by ldap_parse_sasl_bind_result() to obtain any server credentials sent from the server.\u2029\u2029Many SASL mechanisms require multiple message exchanges to perform a complete authentication. Applications should generally use ldap_sasl_interactive_bind_s() rather than  call\u2010\u2029ing  the  basic ldap_sasl_bind() functions directly. The mechs parameter should contain a space-separated list of candidate mechanisms to use. If this parameter is NULL or empty\u2029the library will query the supportedSASLMechanisms attribute from the server's rootDSE for the list of SASL mechanisms the server supports.  The  flags  parameter  controls  the\u2029interaction used to retrieve any necessary SASL authentication parameters and should be one of:\u2029\u2029LDAP_SASL_AUTOMATIC\u2029use defaults if available, prompt otherwise\u2029\u2029LDAP_SASL_INTERACTIVE\u2029always prompt\u2029\u2029LDAP_SASL_QUIET\u2029never prompt\u2029\u2029The  interact  function uses the provided defaults to handle requests from the SASL library for particular authentication parameters. There is no defined format for the defaults\u2029information; it is up to the caller to use whatever format is appropriate for the supplied interact function.   The  sasl_interact  parameter  comes  from  the  underlying  SASL\u2029library. When used with Cyrus SASL this is an array of sasl_interact_t structures. The Cyrus SASL library will prompt for a variety of inputs, including:\u2029\u2029SASL_CB_GETREALM\u2029the realm for the authentication attempt\u2029\u2029SASL_CB_AUTHNAME\u2029the username to authenticate\u2029\u2029SASL_CB_PASS\u2029the password for the provided username\u2029\u2029SASL_CB_USER\u2029the username to use for proxy authorization\u2029\u2029SASL_CB_NOECHOPROMPT\u2029generic prompt for input with input echoing disabled\u2029\u2029SASL_CB_ECHOPROMPT\u2029generic prompt for input with input echoing enabled\u2029\u2029SASL_CB_LIST_END\u2029indicates the end of the array of prompts\u2029\u2029See the Cyrus SASL documentation for more details.\u2029\u2029Applications  which need to manage connections asynchronously may use ldap_sasl_interactive_bind() instead of the synchronous version.  A valid mechs parameter must be supplied,\u2029otherwise the library will be forced to query the server for a list of supported mechanisms, and this query will be performed synchronously.  The other parameters are  the  same\u2029as  for  the  synchronous function, with three additional parameters.  The actual SASL mechanism that was used, and the message ID for use with ldap_result() will be returned in\u2029rmechp and msgidp, respectively.  The value in rmechp must not be modified by the caller and must be passed back on each subsequent call. The message obtained from ldap_result()\u2029must  be  passed  in the result parameter.  This parameter must be NULL when initiating a new Bind. The caller must free the result message after each call using ldap_msgfree().\u2029The ldap_sasl_interactive_bind() function returns an LDAP result code. If the code is LDAP_SASL_BIND_IN_PROGRESS then the Bind is not complete yet, and  this  function  must  be\u2029called again with the next result from the server.\u2029\u2029REBINDING\u2029The  ldap_set_rebind_proc function() sets the process to use for binding when an operation returns a referral. This function is used when an application needs to bind to another\u2029server in order to follow a referral or search continuation reference.\u2029\u2029The function takes ld, the rebind function, and the params, the arbitrary data like state information which the client might need to  properly  rebind.   The  LDAP_OPT_REFERRALS\u2029option in the ld must be set to ON for the libraries to use the rebind function. Use the ldap_set_option function to set the value.\u2029\u2029The rebind function parameters are as follows:\u2029\u2029The ld parameter must be used by the application when binding to the referred server if the application wants the libraries to follow the referral.\u2029\u2029The url parameter points to the URL referral string received from the LDAP server.  The LDAP application can use the ldap_url_parse(3) function to parse the string into its com\u2010\u2029ponents.\u2029\u2029The request parameter specifies the type of request that generated the referral.\u2029\u2029The msgid parameter specifies the message ID of the request generating the referral.\u2029\u2029The params parameter is the same value as passed originally to the ldap_set_rebind_proc() function.\u2029\u2029The LDAP libraries set all the parameters when they call the rebind function. The application should not attempt to free either the ld or the url structures in the rebind  func\u2010\u2029tion.\u2029\u2029The  application  must  supply to the rebind function the required authentication information such as, user name, password, and certificates. The rebind function must use a syn\u2010\u2029chronous bind method.\u2029\u2029UNBINDING\u2029The ldap_unbind() call is used to unbind from the directory, terminate the current association, and free the resources contained in the ld structure.  Once  it  is  called,  the\u2029connection  to  the LDAP server is closed, and the ld structure is invalid.  The ldap_unbind_s() call is just another name for ldap_unbind(); both of these calls are synchronous\u2029in nature.\u2029\u2029The ldap_unbind_ext() and ldap_unbind_ext_s() allows the operations to specify  controls.\u2029\u2029ERRORS\u2029Asynchronous routines will return -1 in case of error, setting the ld_errno parameter of the ld structure.  Synchronous  routines  return  whatever  ld_errno  is  set  to.   See\u2029ldap_error(3) for more information.\u2029\u2029NOTES\u2029If  an anonymous bind is sufficient for the application, the rebind process need not be provided. The LDAP libraries with the LDAP_OPT_REFERRALS option set to ON (default value)\u2029will automatically follow referrals using an anonymous bind.\u2029\u2029If the application needs stronger authentication than an anonymous bind, you need to provide a rebind process for that authentication method.  The bind method must  be  synchro\u2010\u2029nous.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_open(3), ldap_set_option(3), ldap_url_parse(3) RFC 4422 (http://www.rfc-editor.org), Cyrus SASL (http://asg.web.cmu.edu/sasl/)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 885, "position": [410597, 421279], "check": 1, "intersection": 10683, "FP_dupl": 11430, "FN_dupl": 0, "F": 0.6514818880351262, "Prec_Dupl": 0.4831094831094831, "Recall_Dupl": 1.0}]}, {"name": "49", "annotation": "LDAP_COMPARE", "group_ids": [{"name2": "NAME\u2029ldap_compare, ldap_compare_s, ldap_compare_ext, ldap_compare_ext_s - Perform an LDAP compare operation.\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_compare_ext(\u2029LDAP *ld,\u2029char *dn,\u2029char *attr,\u2029const struct berval *bvalue,\u2029LDAPControl **serverctrls,\u2029LDAPControl **clientctrls,\u2029int *msgidp );\u2029\u2029int ldap_compare_ext_s(\u2029LDAP *ld,\u2029char *dn,\u2029char *attr,\u2029const struct berval *bvalue,\u2029LDAPControl **serverctrls,\u2029LDAPControl **clientctrls );\u2029\u2029DESCRIPTION\u2029The  ldap_compare_ext_s()  routine  is used to perform an LDAP compare operation synchronously.  It takes dn, the DN of the entry upon which to perform the compare, and attr and\u2029value, the attribute description and value to compare to those found in the entry.  It returns a code, which will be LDAP_COMPARE_TRUE if the entry contains the attribute  value\u2029and LDAP_COMPARE_FALSE if it does not.  Otherwise, an error code is returned that indicates the nature of the problem.  See ldap(3) for details.\u2029\u2029The ldap_compare_ext() routine is used to perform an LDAP compare operation asynchronously.  It takes the same parameters as ldap_compare_ext_s(), but provides the message id of\u2029the request it initiated in the integer pointed to msgidp.  The result of the compare can be obtained by a subsequent call to ldap_result(3).\u2029\u2029Both routines allow server and client controls to be specified to extend the compare request.\u2029\u2029DEPRECATED INTERFACES\u2029The routines ldap_compare() and ldap_compare_s() are deprecated in favor of ldap_compare_ext() and ldap_compare_ext_s(), respectively.\u2029\u2029Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 899, "position": [440606, 442866], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_compare, ldap_compare_s, ldap_compare_ext, ldap_compare_ext_s - Perform an LDAP compare operation.\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_compare_ext(\u2029LDAP *ld,\u2029char *dn,\u2029char *attr,\u2029const struct berval *bvalue,\u2029LDAPControl **serverctrls,\u2029LDAPControl **clientctrls,\u2029int *msgidp );\u2029\u2029int ldap_compare_ext_s(\u2029LDAP *ld,\u2029char *dn,\u2029char *attr,\u2029const struct berval *bvalue,\u2029LDAPControl **serverctrls,\u2029LDAPControl **clientctrls );\u2029\u2029DESCRIPTION\u2029The  ldap_compare_ext_s()  routine  is used to perform an LDAP compare operation synchronously.  It takes dn, the DN of the entry upon which to perform the compare, and attr and\u2029value, the attribute description and value to compare to those found in the entry.  It returns a code, which will be LDAP_COMPARE_TRUE if the entry contains the attribute  value\u2029and LDAP_COMPARE_FALSE if it does not.  Otherwise, an error code is returned that indicates the nature of the problem.  See ldap(3) for details.\u2029\u2029The ldap_compare_ext() routine is used to perform an LDAP compare operation asynchronously.  It takes the same parameters as ldap_compare_ext_s(), but provides the message id of\u2029the request it initiated in the integer pointed to msgidp.  The result of the compare can be obtained by a subsequent call to ldap_result(3).\u2029\u2029Both routines allow server and client controls to be specified to extend the compare request.\u2029\u2029DEPRECATED INTERFACES\u2029The routines ldap_compare() and ldap_compare_s() are deprecated in favor of ldap_compare_ext() and ldap_compare_ext_s(), respectively.\u2029\u2029Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 898, "position": [437973, 440233], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_compare, ldap_compare_s, ldap_compare_ext, ldap_compare_ext_s - Perform an LDAP compare operation.\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_compare_ext(\u2029LDAP *ld,\u2029char *dn,\u2029char *attr,\u2029const struct berval *bvalue,\u2029LDAPControl **serverctrls,\u2029LDAPControl **clientctrls,\u2029int *msgidp );\u2029\u2029int ldap_compare_ext_s(\u2029LDAP *ld,\u2029char *dn,\u2029char *attr,\u2029const struct berval *bvalue,\u2029LDAPControl **serverctrls,\u2029LDAPControl **clientctrls );\u2029\u2029DESCRIPTION\u2029The  ldap_compare_ext_s()  routine  is used to perform an LDAP compare operation synchronously.  It takes dn, the DN of the entry upon which to perform the compare, and attr and\u2029value, the attribute description and value to compare to those found in the entry.  It returns a code, which will be LDAP_COMPARE_TRUE if the entry contains the attribute  value\u2029and LDAP_COMPARE_FALSE if it does not.  Otherwise, an error code is returned that indicates the nature of the problem.  See ldap(3) for details.\u2029\u2029The ldap_compare_ext() routine is used to perform an LDAP compare operation asynchronously.  It takes the same parameters as ldap_compare_ext_s(), but provides the message id of\u2029the request it initiated in the integer pointed to msgidp.  The result of the compare can be obtained by a subsequent call to ldap_result(3).\u2029\u2029Both routines allow server and client controls to be specified to extend the compare request.\u2029\u2029DEPRECATED INTERFACES\u2029The routines ldap_compare() and ldap_compare_s() are deprecated in favor of ldap_compare_ext() and ldap_compare_ext_s(), respectively.\u2029\u2029Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 897, "position": [435340, 437600], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_compare, ldap_compare_s, ldap_compare_ext, ldap_compare_ext_s - Perform an LDAP compare operation.\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_compare_ext(\u2029LDAP *ld,\u2029char *dn,\u2029char *attr,\u2029const struct berval *bvalue,\u2029LDAPControl **serverctrls,\u2029LDAPControl **clientctrls,\u2029int *msgidp );\u2029\u2029int ldap_compare_ext_s(\u2029LDAP *ld,\u2029char *dn,\u2029char *attr,\u2029const struct berval *bvalue,\u2029LDAPControl **serverctrls,\u2029LDAPControl **clientctrls );\u2029\u2029DESCRIPTION\u2029The  ldap_compare_ext_s()  routine  is used to perform an LDAP compare operation synchronously.  It takes dn, the DN of the entry upon which to perform the compare, and attr and\u2029value, the attribute description and value to compare to those found in the entry.  It returns a code, which will be LDAP_COMPARE_TRUE if the entry contains the attribute  value\u2029and LDAP_COMPARE_FALSE if it does not.  Otherwise, an error code is returned that indicates the nature of the problem.  See ldap(3) for details.\u2029\u2029The ldap_compare_ext() routine is used to perform an LDAP compare operation asynchronously.  It takes the same parameters as ldap_compare_ext_s(), but provides the message id of\u2029the request it initiated in the integer pointed to msgidp.  The result of the compare can be obtained by a subsequent call to ldap_result(3).\u2029\u2029Both routines allow server and client controls to be specified to extend the compare request.\u2029\u2029DEPRECATED INTERFACES\u2029The routines ldap_compare() and ldap_compare_s() are deprecated in favor of ldap_compare_ext() and ldap_compare_ext_s(), respectively.\u2029\u2029Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 896, "position": [432707, 434967], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "50", "annotation": "LDAP_CONTROLS", "group_ids": [{"name2": "NAME\u2029ldap_control_create, ldap_control_find, ldap_control_dup, ldap_controls_dup, ldap_control_free, ldap_controls_free - LDAP control manipulation routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_control_create(const char *oid, int iscritical, struct berval *value, int dupval, LDAPControl **ctrlp);\u2029\u2029LDAPControl *ldap_control_find( const char *oid, LDAPControl **ctrls, LDAPControl ***nextctrlp);\u2029\u2029LDAPControl *ldap_control_dup(LDAPControl *ctrl);\u2029\u2029LDAPControl **ldap_controls_dup(LDAPControl **ctrls);\u2029\u2029void ldap_control_free(LDAPControl *ctrl);\u2029\u2029void ldap_controls_free(LDAPControl **ctrls);\u2029\u2029DESCRIPTION\u2029These routines are used to manipulate structures used for LDAP controls.\u2029\u2029ldap_control_create()  creates  a  control with the specified OID using the contents of the value parameter for the control value, if any.  The content of value is duplicated if\u2029dupval is non-zero.  The iscritical parameter must be non-zero for a critical control. The created control is returned in the ctrlp parameter.  The routine returns  LDAP_SUCCESS\u2029on  success  or  some  other error code on failure.  The content of value, for supported control types, can be prepared using helpers provided by this implementation of libldap,\u2029usually in the form ldap_create_&amp;lt;control name&amp;gt;_control_value().  Otherwise, it can be BER-encoded using the functionalities of liblber.\u2029\u2029ldap_control_find() searches the NULL-terminated ctrls array for a control whose OID matches the oid parameter.  The routine returns a pointer to the control if found, NULL oth\u2010\u2029erwise.   If  the  parameter nextctrlp is not NULL, on return it will point to the next control in the array, and can be passed to the ldap_control_find() routine for subsequent\u2029calls, to find further occurrences of the same control type.  The use of this function is discouraged; the recommended way of handling controls in responses  consists  in  going\u2029through the array of controls, dealing with each of them in the returned order, since it could matter.\u2029\u2029ldap_control_dup() duplicates an individual control structure, and ldap_controls_dup() duplicates a NULL-terminated array of controls.\u2029\u2029ldap_control_free() frees an individual control structure, and ldap_controls_free() frees a NULL-terminated array of controls.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 906, "position": [460837, 463397], "check": 1, "intersection": 38, "FP_dupl": 0, "FN_dupl": 2523, "F": 0.029242016160061564, "Prec_Dupl": 1.0, "Recall_Dupl": 0.01483795392424834}, {"name2": "NAME\u2029ldap_control_create, ldap_control_find, ldap_control_dup, ldap_controls_dup, ldap_control_free, ldap_controls_free - LDAP control manipulation routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_control_create(const char *oid, int iscritical, struct berval *value, int dupval, LDAPControl **ctrlp);\u2029\u2029LDAPControl *ldap_control_find( const char *oid, LDAPControl **ctrls, LDAPControl ***nextctrlp);\u2029\u2029LDAPControl *ldap_control_dup(LDAPControl *ctrl);\u2029\u2029LDAPControl **ldap_controls_dup(LDAPControl **ctrls);\u2029\u2029void ldap_control_free(LDAPControl *ctrl);\u2029\u2029void ldap_controls_free(LDAPControl **ctrls);\u2029\u2029DESCRIPTION\u2029These routines are used to manipulate structures used for LDAP controls.\u2029\u2029ldap_control_create()  creates  a  control with the specified OID using the contents of the value parameter for the control value, if any.  The content of value is duplicated if\u2029dupval is non-zero.  The iscritical parameter must be non-zero for a critical control. The created control is returned in the ctrlp parameter.  The routine returns  LDAP_SUCCESS\u2029on  success  or  some  other error code on failure.  The content of value, for supported control types, can be prepared using helpers provided by this implementation of libldap,\u2029usually in the form ldap_create_&amp;lt;control name&amp;gt;_control_value().  Otherwise, it can be BER-encoded using the functionalities of liblber.\u2029\u2029ldap_control_find() searches the NULL-terminated ctrls array for a control whose OID matches the oid parameter.  The routine returns a pointer to the control if found, NULL oth\u2010\u2029erwise.   If  the  parameter nextctrlp is not NULL, on return it will point to the next control in the array, and can be passed to the ldap_control_find() routine for subsequent\u2029calls, to find further occurrences of the same control type.  The use of this function is discouraged; the recommended way of handling controls in responses  consists  in  going\u2029through the array of controls, dealing with each of them in the returned order, since it could matter.\u2029\u2029ldap_control_dup() duplicates an individual control structure, and ldap_controls_dup() duplicates a NULL-terminated array of controls.\u2029\u2029ldap_control_free() frees an individual control structure, and ldap_controls_free() frees a NULL-terminated array of controls.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 905, "position": [457904, 460464], "check": 1, "intersection": 38, "FP_dupl": 0, "FN_dupl": 2523, "F": 0.029242016160061564, "Prec_Dupl": 1.0, "Recall_Dupl": 0.01483795392424834}, {"name2": "NAME\u2029ldap_control_create, ldap_control_find, ldap_control_dup, ldap_controls_dup, ldap_control_free, ldap_controls_free - LDAP control manipulation routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_control_create(const char *oid, int iscritical, struct berval *value, int dupval, LDAPControl **ctrlp);\u2029\u2029LDAPControl *ldap_control_find( const char *oid, LDAPControl **ctrls, LDAPControl ***nextctrlp);\u2029\u2029LDAPControl *ldap_control_dup(LDAPControl *ctrl);\u2029\u2029LDAPControl **ldap_controls_dup(LDAPControl **ctrls);\u2029\u2029void ldap_control_free(LDAPControl *ctrl);\u2029\u2029void ldap_controls_free(LDAPControl **ctrls);\u2029\u2029DESCRIPTION\u2029These routines are used to manipulate structures used for LDAP controls.\u2029\u2029ldap_control_create()  creates  a  control with the specified OID using the contents of the value parameter for the control value, if any.  The content of value is duplicated if\u2029dupval is non-zero.  The iscritical parameter must be non-zero for a critical control. The created control is returned in the ctrlp parameter.  The routine returns  LDAP_SUCCESS\u2029on  success  or  some  other error code on failure.  The content of value, for supported control types, can be prepared using helpers provided by this implementation of libldap,\u2029usually in the form ldap_create_&amp;lt;control name&amp;gt;_control_value().  Otherwise, it can be BER-encoded using the functionalities of liblber.\u2029\u2029ldap_control_find() searches the NULL-terminated ctrls array for a control whose OID matches the oid parameter.  The routine returns a pointer to the control if found, NULL oth\u2010\u2029erwise.   If  the  parameter nextctrlp is not NULL, on return it will point to the next control in the array, and can be passed to the ldap_control_find() routine for subsequent\u2029calls, to find further occurrences of the same control type.  The use of this function is discouraged; the recommended way of handling controls in responses  consists  in  going\u2029through the array of controls, dealing with each of them in the returned order, since it could matter.\u2029\u2029ldap_control_dup() duplicates an individual control structure, and ldap_controls_dup() duplicates a NULL-terminated array of controls.\u2029\u2029ldap_control_free() frees an individual control structure, and ldap_controls_free() frees a NULL-terminated array of controls.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 904, "position": [454971, 457531], "check": 1, "intersection": 38, "FP_dupl": 0, "FN_dupl": 2523, "F": 0.029242016160061564, "Prec_Dupl": 1.0, "Recall_Dupl": 0.01483795392424834}, {"name2": "NAME\u2029ldap_control_create, ldap_control_find, ldap_control_dup, ldap_controls_dup, ldap_control_free, ldap_controls_free - LDAP control manipulation routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_control_create(const char *oid, int iscritical, struct berval *value, int dupval, LDAPControl **ctrlp);\u2029\u2029LDAPControl *ldap_control_find( const char *oid, LDAPControl **ctrls, LDAPControl ***nextctrlp);\u2029\u2029LDAPControl *ldap_control_dup(LDAPControl *ctrl);\u2029\u2029LDAPControl **ldap_controls_dup(LDAPControl **ctrls);\u2029\u2029void ldap_control_free(LDAPControl *ctrl);\u2029\u2029void ldap_controls_free(LDAPControl **ctrls);\u2029\u2029DESCRIPTION\u2029These routines are used to manipulate structures used for LDAP controls.\u2029\u2029ldap_control_create()  creates  a  control with the specified OID using the contents of the value parameter for the control value, if any.  The content of value is duplicated if\u2029dupval is non-zero.  The iscritical parameter must be non-zero for a critical control. The created control is returned in the ctrlp parameter.  The routine returns  LDAP_SUCCESS\u2029on  success  or  some  other error code on failure.  The content of value, for supported control types, can be prepared using helpers provided by this implementation of libldap,\u2029usually in the form ldap_create_&amp;lt;control name&amp;gt;_control_value().  Otherwise, it can be BER-encoded using the functionalities of liblber.\u2029\u2029ldap_control_find() searches the NULL-terminated ctrls array for a control whose OID matches the oid parameter.  The routine returns a pointer to the control if found, NULL oth\u2010\u2029erwise.   If  the  parameter nextctrlp is not NULL, on return it will point to the next control in the array, and can be passed to the ldap_control_find() routine for subsequent\u2029calls, to find further occurrences of the same control type.  The use of this function is discouraged; the recommended way of handling controls in responses  consists  in  going\u2029through the array of controls, dealing with each of them in the returned order, since it could matter.\u2029\u2029ldap_control_dup() duplicates an individual control structure, and ldap_controls_dup() duplicates a NULL-terminated array of controls.\u2029\u2029ldap_control_free() frees an individual control structure, and ldap_controls_free() frees a NULL-terminated array of controls.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 903, "position": [452038, 454598], "check": 1, "intersection": 38, "FP_dupl": 0, "FN_dupl": 2523, "F": 0.029242016160061564, "Prec_Dupl": 1.0, "Recall_Dupl": 0.01483795392424834}, {"name2": "NAME\u2029ldap_control_create, ldap_control_find, ldap_control_dup, ldap_controls_dup, ldap_control_free, ldap_controls_free - LDAP control manipulation routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_control_create(const char *oid, int iscritical, struct berval *value, int dupval, LDAPControl **ctrlp);\u2029\u2029LDAPControl *ldap_control_find( const char *oid, LDAPControl **ctrls, LDAPControl ***nextctrlp);\u2029\u2029LDAPControl *ldap_control_dup(LDAPControl *ctrl);\u2029\u2029LDAPControl **ldap_controls_dup(LDAPControl **ctrls);\u2029\u2029void ldap_control_free(LDAPControl *ctrl);\u2029\u2029void ldap_controls_free(LDAPControl **ctrls);\u2029\u2029DESCRIPTION\u2029These routines are used to manipulate structures used for LDAP controls.\u2029\u2029ldap_control_create()  creates  a  control with the specified OID using the contents of the value parameter for the control value, if any.  The content of value is duplicated if\u2029dupval is non-zero.  The iscritical parameter must be non-zero for a critical control. The created control is returned in the ctrlp parameter.  The routine returns  LDAP_SUCCESS\u2029on  success  or  some  other error code on failure.  The content of value, for supported control types, can be prepared using helpers provided by this implementation of libldap,\u2029usually in the form ldap_create_&amp;lt;control name&amp;gt;_control_value().  Otherwise, it can be BER-encoded using the functionalities of liblber.\u2029\u2029ldap_control_find() searches the NULL-terminated ctrls array for a control whose OID matches the oid parameter.  The routine returns a pointer to the control if found, NULL oth\u2010\u2029erwise.   If  the  parameter nextctrlp is not NULL, on return it will point to the next control in the array, and can be passed to the ldap_control_find() routine for subsequent\u2029calls, to find further occurrences of the same control type.  The use of this function is discouraged; the recommended way of handling controls in responses  consists  in  going\u2029through the array of controls, dealing with each of them in the returned order, since it could matter.\u2029\u2029ldap_control_dup() duplicates an individual control structure, and ldap_controls_dup() duplicates a NULL-terminated array of controls.\u2029\u2029ldap_control_free() frees an individual control structure, and ldap_controls_free() frees a NULL-terminated array of controls.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 902, "position": [449105, 451665], "check": 1, "intersection": 38, "FP_dupl": 0, "FN_dupl": 2523, "F": 0.029242016160061564, "Prec_Dupl": 1.0, "Recall_Dupl": 0.01483795392424834}, {"name2": "NAME\u2029ldap_control_create, ldap_control_find, ldap_control_dup, ldap_controls_dup, ldap_control_free, ldap_controls_free - LDAP control manipulation routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_control_create(const char *oid, int iscritical, struct berval *value, int dupval, LDAPControl **ctrlp);\u2029\u2029LDAPControl *ldap_control_find( const char *oid, LDAPControl **ctrls, LDAPControl ***nextctrlp);\u2029\u2029LDAPControl *ldap_control_dup(LDAPControl *ctrl);\u2029\u2029LDAPControl **ldap_controls_dup(LDAPControl **ctrls);\u2029\u2029void ldap_control_free(LDAPControl *ctrl);\u2029\u2029void ldap_controls_free(LDAPControl **ctrls);\u2029\u2029DESCRIPTION\u2029These routines are used to manipulate structures used for LDAP controls.\u2029\u2029ldap_control_create()  creates  a  control with the specified OID using the contents of the value parameter for the control value, if any.  The content of value is duplicated if\u2029dupval is non-zero.  The iscritical parameter must be non-zero for a critical control. The created control is returned in the ctrlp parameter.  The routine returns  LDAP_SUCCESS\u2029on  success  or  some  other error code on failure.  The content of value, for supported control types, can be prepared using helpers provided by this implementation of libldap,\u2029usually in the form ldap_create_&amp;lt;control name&amp;gt;_control_value().  Otherwise, it can be BER-encoded using the functionalities of liblber.\u2029\u2029ldap_control_find() searches the NULL-terminated ctrls array for a control whose OID matches the oid parameter.  The routine returns a pointer to the control if found, NULL oth\u2010\u2029erwise.   If  the  parameter nextctrlp is not NULL, on return it will point to the next control in the array, and can be passed to the ldap_control_find() routine for subsequent\u2029calls, to find further occurrences of the same control type.  The use of this function is discouraged; the recommended way of handling controls in responses  consists  in  going\u2029through the array of controls, dealing with each of them in the returned order, since it could matter.\u2029\u2029ldap_control_dup() duplicates an individual control structure, and ldap_controls_dup() duplicates a NULL-terminated array of controls.\u2029\u2029ldap_control_free() frees an individual control structure, and ldap_controls_free() frees a NULL-terminated array of controls.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 901, "position": [446172, 448732], "check": 1, "intersection": 38, "FP_dupl": 0, "FN_dupl": 2523, "F": 0.029242016160061564, "Prec_Dupl": 1.0, "Recall_Dupl": 0.01483795392424834}, {"name2": "NAME\u2029ldap_control_create, ldap_control_find, ldap_control_dup, ldap_controls_dup, ldap_control_free, ldap_controls_free - LDAP control manipulation routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_control_create(const char *oid, int iscritical, struct berval *value, int dupval, LDAPControl **ctrlp);\u2029\u2029LDAPControl *ldap_control_find( const char *oid, LDAPControl **ctrls, LDAPControl ***nextctrlp);\u2029\u2029LDAPControl *ldap_control_dup(LDAPControl *ctrl);\u2029\u2029LDAPControl **ldap_controls_dup(LDAPControl **ctrls);\u2029\u2029void ldap_control_free(LDAPControl *ctrl);\u2029\u2029void ldap_controls_free(LDAPControl **ctrls);\u2029\u2029DESCRIPTION\u2029These routines are used to manipulate structures used for LDAP controls.\u2029\u2029ldap_control_create()  creates  a  control with the specified OID using the contents of the value parameter for the control value, if any.  The content of value is duplicated if\u2029dupval is non-zero.  The iscritical parameter must be non-zero for a critical control. The created control is returned in the ctrlp parameter.  The routine returns  LDAP_SUCCESS\u2029on  success  or  some  other error code on failure.  The content of value, for supported control types, can be prepared using helpers provided by this implementation of libldap,\u2029usually in the form ldap_create_&amp;lt;control name&amp;gt;_control_value().  Otherwise, it can be BER-encoded using the functionalities of liblber.\u2029\u2029ldap_control_find() searches the NULL-terminated ctrls array for a control whose OID matches the oid parameter.  The routine returns a pointer to the control if found, NULL oth\u2010\u2029erwise.   If  the  parameter nextctrlp is not NULL, on return it will point to the next control in the array, and can be passed to the ldap_control_find() routine for subsequent\u2029calls, to find further occurrences of the same control type.  The use of this function is discouraged; the recommended way of handling controls in responses  consists  in  going\u2029through the array of controls, dealing with each of them in the returned order, since it could matter.\u2029\u2029ldap_control_dup() duplicates an individual control structure, and ldap_controls_dup() duplicates a NULL-terminated array of controls.\u2029\u2029ldap_control_free() frees an individual control structure, and ldap_controls_free() frees a NULL-terminated array of controls.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 900, "position": [443239, 445799], "check": 1, "intersection": 38, "FP_dupl": 0, "FN_dupl": 2523, "F": 0.029242016160061564, "Prec_Dupl": 1.0, "Recall_Dupl": 0.01483795392424834}]}, {"name": "51", "annotation": "LDAP_FIRST_ENTRY", "group_ids": [{"name2": "NAME\u2029ldap_first_entry, ldap_next_entry, ldap_count_entries - LDAP result entry parsing and counting routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_count_entries( LDAP *ld, LDAPMessage *result )\u2029\u2029LDAPMessage *ldap_first_entry( LDAP *ld, LDAPMessage *result )\u2029\u2029LDAPMessage *ldap_next_entry( LDAP *ld, LDAPMessage *entry )\u2029\u2029DESCRIPTION\u2029These routines are used to parse results received from ldap_result(3) or the synchronous LDAP search operation routines ldap_search_s(3) and ldap_search_st(3).\u2029\u2029The ldap_first_entry() routine is used to retrieve the first entry in a chain of search results.  It takes the result as returned by a call to ldap_result(3) or ldap_search_s(3)\u2029or ldap_search_st(3) and returns a pointer to the first entry in the result.\u2029\u2029This pointer should be supplied on a subsequent call to ldap_next_entry() to get the next entry, the result of which should be supplied to the next  call  to  ldap_next_entry(),\u2029etc.   ldap_next_entry()  will  return NULL when there are no more entries.  The entries returned from these calls are used in calls to the routines described in ldap_get_dn(3),\u2029ldap_first_attribute(3), ldap_get_values(3), etc.\u2029\u2029A count of the number of entries in the search result can be obtained by calling ldap_count_entries().\u2029\u2029ERRORS\u2029If an error occurs in ldap_first_entry() or ldap_next_entry(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  If an error  occurs  in\u2029ldap_count_entries(), -1 is returned, and ld_errno is set appropriately.  See ldap_error(3) for a description of possible error codes.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_result(3), ldap_search(3), ldap_first_attribute(3), ldap_get_values(3), ldap_get_dn(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 909, "position": [715210, 717162], "check": 1, "intersection": 1953, "FP_dupl": 7587, "FN_dupl": 0, "F": 0.3398590446358653, "Prec_Dupl": 0.20471698113207548, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_first_entry, ldap_next_entry, ldap_count_entries - LDAP result entry parsing and counting routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_count_entries( LDAP *ld, LDAPMessage *result )\u2029\u2029LDAPMessage *ldap_first_entry( LDAP *ld, LDAPMessage *result )\u2029\u2029LDAPMessage *ldap_next_entry( LDAP *ld, LDAPMessage *entry )\u2029\u2029DESCRIPTION\u2029These routines are used to parse results received from ldap_result(3) or the synchronous LDAP search operation routines ldap_search_s(3) and ldap_search_st(3).\u2029\u2029The ldap_first_entry() routine is used to retrieve the first entry in a chain of search results.  It takes the result as returned by a call to ldap_result(3) or ldap_search_s(3)\u2029or ldap_search_st(3) and returns a pointer to the first entry in the result.\u2029\u2029This pointer should be supplied on a subsequent call to ldap_next_entry() to get the next entry, the result of which should be supplied to the next  call  to  ldap_next_entry(),\u2029etc.   ldap_next_entry()  will  return NULL when there are no more entries.  The entries returned from these calls are used in calls to the routines described in ldap_get_dn(3),\u2029ldap_first_attribute(3), ldap_get_values(3), etc.\u2029\u2029A count of the number of entries in the search result can be obtained by calling ldap_count_entries().\u2029\u2029ERRORS\u2029If an error occurs in ldap_first_entry() or ldap_next_entry(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  If an error  occurs  in\u2029ldap_count_entries(), -1 is returned, and ld_errno is set appropriately.  See ldap_error(3) for a description of possible error codes.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_result(3), ldap_search(3), ldap_first_attribute(3), ldap_get_values(3), ldap_get_dn(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 908, "position": [571531, 573483], "check": 1, "intersection": 1953, "FP_dupl": 7587, "FN_dupl": 0, "F": 0.3398590446358653, "Prec_Dupl": 0.20471698113207548, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_first_entry, ldap_next_entry, ldap_count_entries - LDAP result entry parsing and counting routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_count_entries( LDAP *ld, LDAPMessage *result )\u2029\u2029LDAPMessage *ldap_first_entry( LDAP *ld, LDAPMessage *result )\u2029\u2029LDAPMessage *ldap_next_entry( LDAP *ld, LDAPMessage *entry )\u2029\u2029DESCRIPTION\u2029These routines are used to parse results received from ldap_result(3) or the synchronous LDAP search operation routines ldap_search_s(3) and ldap_search_st(3).\u2029\u2029The ldap_first_entry() routine is used to retrieve the first entry in a chain of search results.  It takes the result as returned by a call to ldap_result(3) or ldap_search_s(3)\u2029or ldap_search_st(3) and returns a pointer to the first entry in the result.\u2029\u2029This pointer should be supplied on a subsequent call to ldap_next_entry() to get the next entry, the result of which should be supplied to the next  call  to  ldap_next_entry(),\u2029etc.   ldap_next_entry()  will  return NULL when there are no more entries.  The entries returned from these calls are used in calls to the routines described in ldap_get_dn(3),\u2029ldap_first_attribute(3), ldap_get_values(3), etc.\u2029\u2029A count of the number of entries in the search result can be obtained by calling ldap_count_entries().\u2029\u2029ERRORS\u2029If an error occurs in ldap_first_entry() or ldap_next_entry(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  If an error  occurs  in\u2029ldap_count_entries(), -1 is returned, and ld_errno is set appropriately.  See ldap_error(3) for a description of possible error codes.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_result(3), ldap_search(3), ldap_first_attribute(3), ldap_get_values(3), ldap_get_dn(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 907, "position": [463770, 465722], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "52", "annotation": "LDAP_FIRST_MESSAGE", "group_ids": [{"name2": "NAME\u2029ldap_first_message, ldap_next_message, ldap_count_messages - Stepping through messages in a result chain\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_count_messages( LDAP *ld, LDAPMessage *result )\u2029\u2029LDAPMessage *ldap_first_message( LDAP *ld, LDAPMessage *result )\u2029\u2029LDAPMessage *ldap_next_message( LDAP *ld, LDAPMessage *message )\u2029\u2029DESCRIPTION\u2029These  routines  are  used  to step through the messages in a result chain received from ldap_result(3).  For search operations, the result chain can contain referral, entry and\u2029result messages. The ldap_msgtype(3) function can be used to distinguish between the different message types.\u2029\u2029The ldap_first_message() routine is used to retrieve the first message in a result chain.  It takes the result as returned by  a  call  to  ldap_result(3),  ldap_search_s(3)  or\u2029ldap_search_st(3) and returns a pointer to the first message in the result chain.\u2029\u2029This  pointer  should  be supplied on a subsequent call to ldap_next_message() to get the next message, the result of which should be supplied to the next call to ldap_next_mes\u2010\u2029sage(), etc.  ldap_next_message() will return NULL when there are no more messages.\u2029\u2029These functions are useful when using routines like ldap_parse_result(3) that only operate on the first result in the chain.\u2029\u2029A count of the number of messages in the result chain can be obtained by calling ldap_count_messages().  It can also be used to count the number of remaining messages in a chain\u2029if  called  with  a  message,  entry  or  reference  returned  by  ldap_first_message() , ldap_next_message() , ldap_first_entry(3), ldap_next_entry(3), ldap_first_reference(3),\u2029ldap_next_reference(3).\u2029\u2029ERRORS\u2029If an error occurs in ldap_first_message() or ldap_next_message(), NULL is returned.  If an error occurs in ldap_count_messages(), -1 is returned.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_search(3), ldap_result(3), ldap_parse_result(3), ldap_first_entry(3), ldap_first_reference(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 912, "position": [717535, 719728], "check": 1, "intersection": 2194, "FP_dupl": 7346, "FN_dupl": 0, "F": 0.3739560252258395, "Prec_Dupl": 0.229979035639413, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_first_message, ldap_next_message, ldap_count_messages - Stepping through messages in a result chain\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_count_messages( LDAP *ld, LDAPMessage *result )\u2029\u2029LDAPMessage *ldap_first_message( LDAP *ld, LDAPMessage *result )\u2029\u2029LDAPMessage *ldap_next_message( LDAP *ld, LDAPMessage *message )\u2029\u2029DESCRIPTION\u2029These  routines  are  used  to step through the messages in a result chain received from ldap_result(3).  For search operations, the result chain can contain referral, entry and\u2029result messages. The ldap_msgtype(3) function can be used to distinguish between the different message types.\u2029\u2029The ldap_first_message() routine is used to retrieve the first message in a result chain.  It takes the result as returned by  a  call  to  ldap_result(3),  ldap_search_s(3)  or\u2029ldap_search_st(3) and returns a pointer to the first message in the result chain.\u2029\u2029This  pointer  should  be supplied on a subsequent call to ldap_next_message() to get the next message, the result of which should be supplied to the next call to ldap_next_mes\u2010\u2029sage(), etc.  ldap_next_message() will return NULL when there are no more messages.\u2029\u2029These functions are useful when using routines like ldap_parse_result(3) that only operate on the first result in the chain.\u2029\u2029A count of the number of messages in the result chain can be obtained by calling ldap_count_messages().  It can also be used to count the number of remaining messages in a chain\u2029if  called  with  a  message,  entry  or  reference  returned  by  ldap_first_message() , ldap_next_message() , ldap_first_entry(3), ldap_next_entry(3), ldap_first_reference(3),\u2029ldap_next_reference(3).\u2029\u2029ERRORS\u2029If an error occurs in ldap_first_message() or ldap_next_message(), NULL is returned.  If an error occurs in ldap_count_messages(), -1 is returned.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_search(3), ldap_result(3), ldap_parse_result(3), ldap_first_entry(3), ldap_first_reference(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 911, "position": [573856, 576049], "check": 1, "intersection": 2194, "FP_dupl": 7346, "FN_dupl": 0, "F": 0.3739560252258395, "Prec_Dupl": 0.229979035639413, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_first_message, ldap_next_message, ldap_count_messages - Stepping through messages in a result chain\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_count_messages( LDAP *ld, LDAPMessage *result )\u2029\u2029LDAPMessage *ldap_first_message( LDAP *ld, LDAPMessage *result )\u2029\u2029LDAPMessage *ldap_next_message( LDAP *ld, LDAPMessage *message )\u2029\u2029DESCRIPTION\u2029These  routines  are  used  to step through the messages in a result chain received from ldap_result(3).  For search operations, the result chain can contain referral, entry and\u2029result messages. The ldap_msgtype(3) function can be used to distinguish between the different message types.\u2029\u2029The ldap_first_message() routine is used to retrieve the first message in a result chain.  It takes the result as returned by  a  call  to  ldap_result(3),  ldap_search_s(3)  or\u2029ldap_search_st(3) and returns a pointer to the first message in the result chain.\u2029\u2029This  pointer  should  be supplied on a subsequent call to ldap_next_message() to get the next message, the result of which should be supplied to the next call to ldap_next_mes\u2010\u2029sage(), etc.  ldap_next_message() will return NULL when there are no more messages.\u2029\u2029These functions are useful when using routines like ldap_parse_result(3) that only operate on the first result in the chain.\u2029\u2029A count of the number of messages in the result chain can be obtained by calling ldap_count_messages().  It can also be used to count the number of remaining messages in a chain\u2029if  called  with  a  message,  entry  or  reference  returned  by  ldap_first_message() , ldap_next_message() , ldap_first_entry(3), ldap_next_entry(3), ldap_first_reference(3),\u2029ldap_next_reference(3).\u2029\u2029ERRORS\u2029If an error occurs in ldap_first_message() or ldap_next_message(), NULL is returned.  If an error occurs in ldap_count_messages(), -1 is returned.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_search(3), ldap_result(3), ldap_parse_result(3), ldap_first_entry(3), ldap_first_reference(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 910, "position": [466095, 468288], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "53", "annotation": "LDAP_FIRST_REFERENCE", "group_ids": [{"name2": "NAME\u2029ldap_first_reference, ldap_next_reference, ldap_count_references - Stepping through continuation references in a result chain\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_count_references( LDAP *ld, LDAPMessage *result )\u2029\u2029LDAPMessage *ldap_first_reference( LDAP *ld, LDAPMessage *result )\u2029\u2029LDAPMessage *ldap_next_reference( LDAP *ld, LDAPMessage *reference )\u2029\u2029DESCRIPTION\u2029These routines are used to step through the continuation references in a result chain received from ldap_result(3) or the synchronous LDAP search operation routines.\u2029\u2029The  ldap_first_reference()  routine  is  used  to  retrieve  the  first  reference  message  in  a  result  chain.  It takes the result as returned by a call to ldap_result(3),\u2029ldap_search_s(3) or ldap_search_st(3) and returns a pointer to the first reference message in the result chain.\u2029\u2029This pointer should be supplied on a subsequent call to ldap_next_reference() to get the next reference message, the result of which should be  supplied  to  the  next  call  to\u2029ldap_next_reference(),  etc.   ldap_next_reference()  will  return  NULL when there are no more reference messages.  The reference messages returned from these calls are used by\u2029ldap_parse_reference(3) to extract referrals and controls.\u2029\u2029A count of the number of reference messages in the search result can be obtained by calling ldap_count_references().  It can also be used to count the number of  reference  mes\u2010\u2029sages remaining in a result chain.\u2029\u2029ERRORS\u2029If an error occurs in ldap_first_reference() or ldap_next_reference(), NULL is returned.  If an error occurs in ldap_count_references(), -1 is returned.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_result(3), ldap_search(3), ldap_parse_reference(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 915, "position": [720101, 722054], "check": 1, "intersection": 1954, "FP_dupl": 7586, "FN_dupl": 0, "F": 0.3400034800765617, "Prec_Dupl": 0.20482180293501048, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_first_reference, ldap_next_reference, ldap_count_references - Stepping through continuation references in a result chain\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_count_references( LDAP *ld, LDAPMessage *result )\u2029\u2029LDAPMessage *ldap_first_reference( LDAP *ld, LDAPMessage *result )\u2029\u2029LDAPMessage *ldap_next_reference( LDAP *ld, LDAPMessage *reference )\u2029\u2029DESCRIPTION\u2029These routines are used to step through the continuation references in a result chain received from ldap_result(3) or the synchronous LDAP search operation routines.\u2029\u2029The  ldap_first_reference()  routine  is  used  to  retrieve  the  first  reference  message  in  a  result  chain.  It takes the result as returned by a call to ldap_result(3),\u2029ldap_search_s(3) or ldap_search_st(3) and returns a pointer to the first reference message in the result chain.\u2029\u2029This pointer should be supplied on a subsequent call to ldap_next_reference() to get the next reference message, the result of which should be  supplied  to  the  next  call  to\u2029ldap_next_reference(),  etc.   ldap_next_reference()  will  return  NULL when there are no more reference messages.  The reference messages returned from these calls are used by\u2029ldap_parse_reference(3) to extract referrals and controls.\u2029\u2029A count of the number of reference messages in the search result can be obtained by calling ldap_count_references().  It can also be used to count the number of  reference  mes\u2010\u2029sages remaining in a result chain.\u2029\u2029ERRORS\u2029If an error occurs in ldap_first_reference() or ldap_next_reference(), NULL is returned.  If an error occurs in ldap_count_references(), -1 is returned.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_result(3), ldap_search(3), ldap_parse_reference(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 914, "position": [576422, 578375], "check": 1, "intersection": 1954, "FP_dupl": 7586, "FN_dupl": 0, "F": 0.3400034800765617, "Prec_Dupl": 0.20482180293501048, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_first_reference, ldap_next_reference, ldap_count_references - Stepping through continuation references in a result chain\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_count_references( LDAP *ld, LDAPMessage *result )\u2029\u2029LDAPMessage *ldap_first_reference( LDAP *ld, LDAPMessage *result )\u2029\u2029LDAPMessage *ldap_next_reference( LDAP *ld, LDAPMessage *reference )\u2029\u2029DESCRIPTION\u2029These routines are used to step through the continuation references in a result chain received from ldap_result(3) or the synchronous LDAP search operation routines.\u2029\u2029The  ldap_first_reference()  routine  is  used  to  retrieve  the  first  reference  message  in  a  result  chain.  It takes the result as returned by a call to ldap_result(3),\u2029ldap_search_s(3) or ldap_search_st(3) and returns a pointer to the first reference message in the result chain.\u2029\u2029This pointer should be supplied on a subsequent call to ldap_next_reference() to get the next reference message, the result of which should be  supplied  to  the  next  call  to\u2029ldap_next_reference(),  etc.   ldap_next_reference()  will  return  NULL when there are no more reference messages.  The reference messages returned from these calls are used by\u2029ldap_parse_reference(3) to extract referrals and controls.\u2029\u2029A count of the number of reference messages in the search result can be obtained by calling ldap_count_references().  It can also be used to count the number of  reference  mes\u2010\u2029sages remaining in a result chain.\u2029\u2029ERRORS\u2029If an error occurs in ldap_first_reference() or ldap_next_reference(), NULL is returned.  If an error occurs in ldap_count_references(), -1 is returned.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_result(3), ldap_search(3), ldap_parse_reference(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 913, "position": [468661, 470614], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "54", "annotation": "LDAP_GET_VALUES", "group_ids": [{"name2": "NAME\u2029ldap_get_values, ldap_get_values_len, ldap_count_values - LDAP attribute value handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029char **ldap_get_values(ld, entry, attr)\u2029LDAP *ld;\u2029LDAPMessage *entry;\u2029char *attr;\u2029\u2029struct berval **ldap_get_values_len(ld, entry, attr)\u2029LDAP *ld;\u2029LDAPMessage *entry;\u2029char *attr;\u2029\u2029int ldap_count_values(vals)\u2029char **vals;\u2029\u2029int ldap_count_values_len(vals)\u2029struct berval **vals;\u2029\u2029void ldap_value_free(vals)\u2029char **vals;\u2029\u2029void ldap_value_free_len(vals)\u2029struct berval **vals;\u2029\u2029DESCRIPTION\u2029These  routines  are  used  to retrieve and manipulate attribute values from an LDAP entry as returned by ldap_first_entry(3) or ldap_next_entry(3).  ldap_get_values() takes the\u2029entry and the attribute attr whose values are desired and returns a NULL-terminated array  of  the  attribute's  values.   attr  may  be  an  attribute  type  as  returned  from\u2029ldap_first_attribute(3) or ldap_next_attribute(3), or if the attribute type is known it can simply be given.\u2029\u2029The number of values in the array can be counted by calling ldap_count_values().  The array of values returned can be freed by calling ldap_value_free().\u2029\u2029If  the attribute values are binary in nature, and thus not suitable to be returned as an array of char *'s, the ldap_get_values_len() routine can be used instead.  It takes the\u2029same parameters as ldap_get_values(), but returns a NULL-terminated array of pointers to berval structures, each containing the length of and a pointer to a value.\u2029\u2029The number of values in the array can be counted by calling ldap_count_values_len().  The array of values returned can be freed by calling ldap_value_free_len().\u2029\u2029ERRORS\u2029If an error occurs in ldap_get_values() or ldap_get_values_len(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the  error.   See  ldap_error(3)\u2029for a description of possible error codes.\u2029\u2029NOTES\u2029These routines dynamically allocate memory which the caller must free using the supplied routines.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_first_entry(3), ldap_first_attribute(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 921, "position": [1060535, 1062849], "check": 1, "intersection": 2315, "FP_dupl": 375, "FN_dupl": 0, "F": 0.9250749250749251, "Prec_Dupl": 0.8605947955390335, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_get_values, ldap_get_values_len, ldap_count_values - LDAP attribute value handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029char **ldap_get_values(ld, entry, attr)\u2029LDAP *ld;\u2029LDAPMessage *entry;\u2029char *attr;\u2029\u2029struct berval **ldap_get_values_len(ld, entry, attr)\u2029LDAP *ld;\u2029LDAPMessage *entry;\u2029char *attr;\u2029\u2029int ldap_count_values(vals)\u2029char **vals;\u2029\u2029int ldap_count_values_len(vals)\u2029struct berval **vals;\u2029\u2029void ldap_value_free(vals)\u2029char **vals;\u2029\u2029void ldap_value_free_len(vals)\u2029struct berval **vals;\u2029\u2029DESCRIPTION\u2029These  routines  are  used  to retrieve and manipulate attribute values from an LDAP entry as returned by ldap_first_entry(3) or ldap_next_entry(3).  ldap_get_values() takes the\u2029entry and the attribute attr whose values are desired and returns a NULL-terminated array  of  the  attribute's  values.   attr  may  be  an  attribute  type  as  returned  from\u2029ldap_first_attribute(3) or ldap_next_attribute(3), or if the attribute type is known it can simply be given.\u2029\u2029The number of values in the array can be counted by calling ldap_count_values().  The array of values returned can be freed by calling ldap_value_free().\u2029\u2029If  the attribute values are binary in nature, and thus not suitable to be returned as an array of char *'s, the ldap_get_values_len() routine can be used instead.  It takes the\u2029same parameters as ldap_get_values(), but returns a NULL-terminated array of pointers to berval structures, each containing the length of and a pointer to a value.\u2029\u2029The number of values in the array can be counted by calling ldap_count_values_len().  The array of values returned can be freed by calling ldap_value_free_len().\u2029\u2029ERRORS\u2029If an error occurs in ldap_get_values() or ldap_get_values_len(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the  error.   See  ldap_error(3)\u2029for a description of possible error codes.\u2029\u2029NOTES\u2029These routines dynamically allocate memory which the caller must free using the supplied routines.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_first_entry(3), ldap_first_attribute(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 920, "position": [1057848, 1060162], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_get_values, ldap_get_values_len, ldap_count_values - LDAP attribute value handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029char **ldap_get_values(ld, entry, attr)\u2029LDAP *ld;\u2029LDAPMessage *entry;\u2029char *attr;\u2029\u2029struct berval **ldap_get_values_len(ld, entry, attr)\u2029LDAP *ld;\u2029LDAPMessage *entry;\u2029char *attr;\u2029\u2029int ldap_count_values(vals)\u2029char **vals;\u2029\u2029int ldap_count_values_len(vals)\u2029struct berval **vals;\u2029\u2029void ldap_value_free(vals)\u2029char **vals;\u2029\u2029void ldap_value_free_len(vals)\u2029struct berval **vals;\u2029\u2029DESCRIPTION\u2029These  routines  are  used  to retrieve and manipulate attribute values from an LDAP entry as returned by ldap_first_entry(3) or ldap_next_entry(3).  ldap_get_values() takes the\u2029entry and the attribute attr whose values are desired and returns a NULL-terminated array  of  the  attribute's  values.   attr  may  be  an  attribute  type  as  returned  from\u2029ldap_first_attribute(3) or ldap_next_attribute(3), or if the attribute type is known it can simply be given.\u2029\u2029The number of values in the array can be counted by calling ldap_count_values().  The array of values returned can be freed by calling ldap_value_free().\u2029\u2029If  the attribute values are binary in nature, and thus not suitable to be returned as an array of char *'s, the ldap_get_values_len() routine can be used instead.  It takes the\u2029same parameters as ldap_get_values(), but returns a NULL-terminated array of pointers to berval structures, each containing the length of and a pointer to a value.\u2029\u2029The number of values in the array can be counted by calling ldap_count_values_len().  The array of values returned can be freed by calling ldap_value_free_len().\u2029\u2029ERRORS\u2029If an error occurs in ldap_get_values() or ldap_get_values_len(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the  error.   See  ldap_error(3)\u2029for a description of possible error codes.\u2029\u2029NOTES\u2029These routines dynamically allocate memory which the caller must free using the supplied routines.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_first_entry(3), ldap_first_attribute(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 919, "position": [608522, 610836], "check": 1, "intersection": 2315, "FP_dupl": 375, "FN_dupl": 0, "F": 0.9250749250749251, "Prec_Dupl": 0.8605947955390335, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_get_values, ldap_get_values_len, ldap_count_values - LDAP attribute value handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029char **ldap_get_values(ld, entry, attr)\u2029LDAP *ld;\u2029LDAPMessage *entry;\u2029char *attr;\u2029\u2029struct berval **ldap_get_values_len(ld, entry, attr)\u2029LDAP *ld;\u2029LDAPMessage *entry;\u2029char *attr;\u2029\u2029int ldap_count_values(vals)\u2029char **vals;\u2029\u2029int ldap_count_values_len(vals)\u2029struct berval **vals;\u2029\u2029void ldap_value_free(vals)\u2029char **vals;\u2029\u2029void ldap_value_free_len(vals)\u2029struct berval **vals;\u2029\u2029DESCRIPTION\u2029These  routines  are  used  to retrieve and manipulate attribute values from an LDAP entry as returned by ldap_first_entry(3) or ldap_next_entry(3).  ldap_get_values() takes the\u2029entry and the attribute attr whose values are desired and returns a NULL-terminated array  of  the  attribute's  values.   attr  may  be  an  attribute  type  as  returned  from\u2029ldap_first_attribute(3) or ldap_next_attribute(3), or if the attribute type is known it can simply be given.\u2029\u2029The number of values in the array can be counted by calling ldap_count_values().  The array of values returned can be freed by calling ldap_value_free().\u2029\u2029If  the attribute values are binary in nature, and thus not suitable to be returned as an array of char *'s, the ldap_get_values_len() routine can be used instead.  It takes the\u2029same parameters as ldap_get_values(), but returns a NULL-terminated array of pointers to berval structures, each containing the length of and a pointer to a value.\u2029\u2029The number of values in the array can be counted by calling ldap_count_values_len().  The array of values returned can be freed by calling ldap_value_free_len().\u2029\u2029ERRORS\u2029If an error occurs in ldap_get_values() or ldap_get_values_len(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the  error.   See  ldap_error(3)\u2029for a description of possible error codes.\u2029\u2029NOTES\u2029These routines dynamically allocate memory which the caller must free using the supplied routines.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_first_entry(3), ldap_first_attribute(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 918, "position": [605835, 608149], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_get_values, ldap_get_values_len, ldap_count_values - LDAP attribute value handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029char **ldap_get_values(ld, entry, attr)\u2029LDAP *ld;\u2029LDAPMessage *entry;\u2029char *attr;\u2029\u2029struct berval **ldap_get_values_len(ld, entry, attr)\u2029LDAP *ld;\u2029LDAPMessage *entry;\u2029char *attr;\u2029\u2029int ldap_count_values(vals)\u2029char **vals;\u2029\u2029int ldap_count_values_len(vals)\u2029struct berval **vals;\u2029\u2029void ldap_value_free(vals)\u2029char **vals;\u2029\u2029void ldap_value_free_len(vals)\u2029struct berval **vals;\u2029\u2029DESCRIPTION\u2029These  routines  are  used  to retrieve and manipulate attribute values from an LDAP entry as returned by ldap_first_entry(3) or ldap_next_entry(3).  ldap_get_values() takes the\u2029entry and the attribute attr whose values are desired and returns a NULL-terminated array  of  the  attribute's  values.   attr  may  be  an  attribute  type  as  returned  from\u2029ldap_first_attribute(3) or ldap_next_attribute(3), or if the attribute type is known it can simply be given.\u2029\u2029The number of values in the array can be counted by calling ldap_count_values().  The array of values returned can be freed by calling ldap_value_free().\u2029\u2029If  the attribute values are binary in nature, and thus not suitable to be returned as an array of char *'s, the ldap_get_values_len() routine can be used instead.  It takes the\u2029same parameters as ldap_get_values(), but returns a NULL-terminated array of pointers to berval structures, each containing the length of and a pointer to a value.\u2029\u2029The number of values in the array can be counted by calling ldap_count_values_len().  The array of values returned can be freed by calling ldap_value_free_len().\u2029\u2029ERRORS\u2029If an error occurs in ldap_get_values() or ldap_get_values_len(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the  error.   See  ldap_error(3)\u2029for a description of possible error codes.\u2029\u2029NOTES\u2029These routines dynamically allocate memory which the caller must free using the supplied routines.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_first_entry(3), ldap_first_attribute(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 917, "position": [473674, 475988], "check": 1, "intersection": 2315, "FP_dupl": 375, "FN_dupl": 0, "F": 0.9250749250749251, "Prec_Dupl": 0.8605947955390335, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_get_values, ldap_get_values_len, ldap_count_values - LDAP attribute value handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029char **ldap_get_values(ld, entry, attr)\u2029LDAP *ld;\u2029LDAPMessage *entry;\u2029char *attr;\u2029\u2029struct berval **ldap_get_values_len(ld, entry, attr)\u2029LDAP *ld;\u2029LDAPMessage *entry;\u2029char *attr;\u2029\u2029int ldap_count_values(vals)\u2029char **vals;\u2029\u2029int ldap_count_values_len(vals)\u2029struct berval **vals;\u2029\u2029void ldap_value_free(vals)\u2029char **vals;\u2029\u2029void ldap_value_free_len(vals)\u2029struct berval **vals;\u2029\u2029DESCRIPTION\u2029These  routines  are  used  to retrieve and manipulate attribute values from an LDAP entry as returned by ldap_first_entry(3) or ldap_next_entry(3).  ldap_get_values() takes the\u2029entry and the attribute attr whose values are desired and returns a NULL-terminated array  of  the  attribute's  values.   attr  may  be  an  attribute  type  as  returned  from\u2029ldap_first_attribute(3) or ldap_next_attribute(3), or if the attribute type is known it can simply be given.\u2029\u2029The number of values in the array can be counted by calling ldap_count_values().  The array of values returned can be freed by calling ldap_value_free().\u2029\u2029If  the attribute values are binary in nature, and thus not suitable to be returned as an array of char *'s, the ldap_get_values_len() routine can be used instead.  It takes the\u2029same parameters as ldap_get_values(), but returns a NULL-terminated array of pointers to berval structures, each containing the length of and a pointer to a value.\u2029\u2029The number of values in the array can be counted by calling ldap_count_values_len().  The array of values returned can be freed by calling ldap_value_free_len().\u2029\u2029ERRORS\u2029If an error occurs in ldap_get_values() or ldap_get_values_len(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the  error.   See  ldap_error(3)\u2029for a description of possible error codes.\u2029\u2029NOTES\u2029These routines dynamically allocate memory which the caller must free using the supplied routines.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_first_entry(3), ldap_first_attribute(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 916, "position": [470987, 473301], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "55", "annotation": "LDAP_GET_DN", "group_ids": [{"name2": "NAME\u2029ldap_get_dn, ldap_explode_dn, ldap_explode_rdn, ldap_dn2ufn - LDAP DN handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029char *ldap_get_dn( LDAP *ld, LDAPMessage *entry )\u2029\u2029int ldap_str2dn( const char *str, LDAPDN *dn, unsigned flags )\u2029\u2029void ldap_dnfree( LDAPDN dn )\u2029\u2029int ldap_dn2str( LDAPDN dn, char **str, unsigned flags )\u2029\u2029char **ldap_explode_dn( const char *dn, int notypes )\u2029\u2029char **ldap_explode_rdn( const char *rdn, int notypes )\u2029\u2029char *ldap_dn2ufn( const char * dn )\u2029\u2029char *ldap_dn2dcedn( const char * dn )\u2029\u2029char *ldap_dcedn2dn( const char * dn )\u2029\u2029char *ldap_dn2ad_canonical( const char * dn )\u2029\u2029DESCRIPTION\u2029These  routines  allow  LDAP entry names (Distinguished Names, or DNs) to be obtained, parsed, converted to a user-friendly form, and tested.  A DN has the form described in RFC\u20294414 \"Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names\".\u2029\u2029The ldap_get_dn() routine takes an entry as returned by ldap_first_entry(3) or ldap_next_entry(3) and returns a copy of the entry's DN.  Space for the DN will be obtained dynam\u2010\u2029ically and should be freed by the caller using ldap_memfree(3).\u2029\u2029ldap_str2dn()  parses  a  string representation of a distinguished name contained in str into its components, which are stored in dn as ldap_ava structures, arranged in LDAPAVA,\u2029LDAPRDN, and LDAPDN terms.  Space for dn will be obtained dynamically and should be freed by the caller using ldap_dnfree(3).  The LDAPDN is defined as:\u2029\u2029typedef struct ldap_ava {\u2029struct berval la_attr;\u2029struct berval la_value;\u2029unsigned la_flags;\u2029} LDAPAVA;\u2029\u2029typedef LDAPAVA** LDAPRDN;\u2029typedef LDAPRDN* LDAPDN;\u2029\u2029The attribute types and the attribute values are not normalized.  The la_flags can be either LDAP_AVA_STRING or LDAP_AVA_BINARY, the latter meaning that  the  value  is  BER/DER\u2029encoded  and  thus must be represented as, quoting from RFC 4514, \" ... an octothorpe character ('#' ASCII 35) followed by the hexadecimal representation of each of the bytes of\u2029the BER encoding of the X.500 AttributeValue.\"  The flags parameter to ldap_str2dn() can be\u2029\u2029LDAP_DN_FORMAT_LDAPV3\u2029LDAP_DN_FORMAT_LDAPV2\u2029LDAP_DN_FORMAT_DCE\u2029\u2029which defines what DN syntax is expected (according to RFC 4514, RFC 1779 and DCE, respectively).  The format can be ORed to the flags\u2029\u2029LDAP_DN_P_NO_SPACES\u2029LDAP_DN_P_NO_SPACE_AFTER_RDN\u2029...\u2029LDAP_DN_PEDANTIC\u2029\u2029The latter is a shortcut for all the previous limitations.\u2029\u2029LDAP_DN_P_NO_SPACES does not allow extra spaces in the dn; the default is to  silently  eliminate  spaces  around  AVA  separators  ('='),  RDN  component  separators  ('+'  for\u2029LDAPv3/LDAPv2 or ',' for DCE) and RDN separators (',' LDAPv3/LDAPv2 or '/' for DCE).\u2029\u2029LDAP_DN_P_NO_SPACE_AFTER_RDN does not allow a single space after RDN separators.\u2029\u2029ldap_dn2str() performs the inverse operation, yielding in str a string representation of dn.  It allows the same values for flags as ldap_str2dn(), plus\u2029\u2029LDAP_DN_FORMAT_UFN\u2029LDAP_DN_FORMAT_AD_CANONICAL\u2029\u2029for user-friendly naming (RFC 1781) and AD canonical.\u2029\u2029The following routines are viewed as deprecated in favor of ldap_str2dn() and ldap_dn2str().  They are provided to support legacy applications.\u2029\u2029The  ldap_explode_dn()  routine  takes a DN as returned by ldap_get_dn() and breaks it up into its component parts.  Each part is known as a Relative Distinguished Name, or RDN.\u2029ldap_explode_dn() returns a NULL-terminated array, each component of which contains an RDN from the DN.  The notypes parameter is used to request that only  the  RDN  values  be\u2029returned,  not their types.  For example, the DN \"cn=Bob, c=US\" would return as either { \"cn=Bob\", \"c=US\", NULL } or { \"Bob\", \"US\", NULL }, depending on whether notypes was 0 or\u20291, respectively.  Assertion values in RDN strings may included escaped characters.  The result can be freed by calling ldap_value_free(3).\u2029\u2029Similarly, the ldap_explode_rdn() routine takes an RDN as returned by ldap_explode_dn(dn,0) and breaks it up into its \"type=value\" component  parts  (or  just  \"value\",  if  the\u2029notypes parameter is set).  Note the value is not unescaped.  The result can be freed by calling ldap_value_free(3).\u2029\u2029ldap_dn2ufn() is used to turn a DN as returned by ldap_get_dn(3) into a more user-friendly form, stripping off all type names.  See \"Using the Directory to Achieve User Friendly\u2029Naming\" (RFC 1781) for more details on the UFN format.  Due to the ambiguous nature of the format, it is generally only used  for  display  purposes.   The  space  for  the  UFN\u2029returned is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).\u2029\u2029ldap_dn2dcedn() is used to turn a DN as returned by ldap_get_dn(3) into a DCE-style DN, e.g. a string with most-significant to least significant rdns separated by slashes ('/');\u2029rdn components are separated by commas (',').  Only printable chars (e.g. LDAPv2 printable string) are allowed, at least in this implementation.   ldap_dcedn2dn()  performs  the\u2029opposite  operation.   ldap_dn2ad_canonical() turns a DN into a AD canonical name, which is basically a DCE dn with attribute types omitted.  The trailing domain, if present, is\u2029turned in a DNS-like domain.  The space for the returned value is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).\u2029\u2029ERRORS\u2029If an error occurs in ldap_get_dn(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  See ldap_error(3) for a description  of  possible\u2029error codes.  ldap_explode_dn(), ldap_explode_rdn(), ldap_dn2ufn(), ldap_dn2dcedn(), ldap_dcedn2dn(), and ldap_dn2ad_canonical() will return NULL with errno(3) set appropriately\u2029in case of trouble.\u2029\u2029NOTES\u2029These routines dynamically allocate memory that the caller must free.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_first_entry(3), ldap_memfree(3), ldap_value_free(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 931, "position": [934436, 940530], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_get_dn, ldap_explode_dn, ldap_explode_rdn, ldap_dn2ufn - LDAP DN handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029char *ldap_get_dn( LDAP *ld, LDAPMessage *entry )\u2029\u2029int ldap_str2dn( const char *str, LDAPDN *dn, unsigned flags )\u2029\u2029void ldap_dnfree( LDAPDN dn )\u2029\u2029int ldap_dn2str( LDAPDN dn, char **str, unsigned flags )\u2029\u2029char **ldap_explode_dn( const char *dn, int notypes )\u2029\u2029char **ldap_explode_rdn( const char *rdn, int notypes )\u2029\u2029char *ldap_dn2ufn( const char * dn )\u2029\u2029char *ldap_dn2dcedn( const char * dn )\u2029\u2029char *ldap_dcedn2dn( const char * dn )\u2029\u2029char *ldap_dn2ad_canonical( const char * dn )\u2029\u2029DESCRIPTION\u2029These  routines  allow  LDAP entry names (Distinguished Names, or DNs) to be obtained, parsed, converted to a user-friendly form, and tested.  A DN has the form described in RFC\u20294414 \"Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names\".\u2029\u2029The ldap_get_dn() routine takes an entry as returned by ldap_first_entry(3) or ldap_next_entry(3) and returns a copy of the entry's DN.  Space for the DN will be obtained dynam\u2010\u2029ically and should be freed by the caller using ldap_memfree(3).\u2029\u2029ldap_str2dn()  parses  a  string representation of a distinguished name contained in str into its components, which are stored in dn as ldap_ava structures, arranged in LDAPAVA,\u2029LDAPRDN, and LDAPDN terms.  Space for dn will be obtained dynamically and should be freed by the caller using ldap_dnfree(3).  The LDAPDN is defined as:\u2029\u2029typedef struct ldap_ava {\u2029struct berval la_attr;\u2029struct berval la_value;\u2029unsigned la_flags;\u2029} LDAPAVA;\u2029\u2029typedef LDAPAVA** LDAPRDN;\u2029typedef LDAPRDN* LDAPDN;\u2029\u2029The attribute types and the attribute values are not normalized.  The la_flags can be either LDAP_AVA_STRING or LDAP_AVA_BINARY, the latter meaning that  the  value  is  BER/DER\u2029encoded  and  thus must be represented as, quoting from RFC 4514, \" ... an octothorpe character ('#' ASCII 35) followed by the hexadecimal representation of each of the bytes of\u2029the BER encoding of the X.500 AttributeValue.\"  The flags parameter to ldap_str2dn() can be\u2029\u2029LDAP_DN_FORMAT_LDAPV3\u2029LDAP_DN_FORMAT_LDAPV2\u2029LDAP_DN_FORMAT_DCE\u2029\u2029which defines what DN syntax is expected (according to RFC 4514, RFC 1779 and DCE, respectively).  The format can be ORed to the flags\u2029\u2029LDAP_DN_P_NO_SPACES\u2029LDAP_DN_P_NO_SPACE_AFTER_RDN\u2029...\u2029LDAP_DN_PEDANTIC\u2029\u2029The latter is a shortcut for all the previous limitations.\u2029\u2029LDAP_DN_P_NO_SPACES does not allow extra spaces in the dn; the default is to  silently  eliminate  spaces  around  AVA  separators  ('='),  RDN  component  separators  ('+'  for\u2029LDAPv3/LDAPv2 or ',' for DCE) and RDN separators (',' LDAPv3/LDAPv2 or '/' for DCE).\u2029\u2029LDAP_DN_P_NO_SPACE_AFTER_RDN does not allow a single space after RDN separators.\u2029\u2029ldap_dn2str() performs the inverse operation, yielding in str a string representation of dn.  It allows the same values for flags as ldap_str2dn(), plus\u2029\u2029LDAP_DN_FORMAT_UFN\u2029LDAP_DN_FORMAT_AD_CANONICAL\u2029\u2029for user-friendly naming (RFC 1781) and AD canonical.\u2029\u2029The following routines are viewed as deprecated in favor of ldap_str2dn() and ldap_dn2str().  They are provided to support legacy applications.\u2029\u2029The  ldap_explode_dn()  routine  takes a DN as returned by ldap_get_dn() and breaks it up into its component parts.  Each part is known as a Relative Distinguished Name, or RDN.\u2029ldap_explode_dn() returns a NULL-terminated array, each component of which contains an RDN from the DN.  The notypes parameter is used to request that only  the  RDN  values  be\u2029returned,  not their types.  For example, the DN \"cn=Bob, c=US\" would return as either { \"cn=Bob\", \"c=US\", NULL } or { \"Bob\", \"US\", NULL }, depending on whether notypes was 0 or\u20291, respectively.  Assertion values in RDN strings may included escaped characters.  The result can be freed by calling ldap_value_free(3).\u2029\u2029Similarly, the ldap_explode_rdn() routine takes an RDN as returned by ldap_explode_dn(dn,0) and breaks it up into its \"type=value\" component  parts  (or  just  \"value\",  if  the\u2029notypes parameter is set).  Note the value is not unescaped.  The result can be freed by calling ldap_value_free(3).\u2029\u2029ldap_dn2ufn() is used to turn a DN as returned by ldap_get_dn(3) into a more user-friendly form, stripping off all type names.  See \"Using the Directory to Achieve User Friendly\u2029Naming\" (RFC 1781) for more details on the UFN format.  Due to the ambiguous nature of the format, it is generally only used  for  display  purposes.   The  space  for  the  UFN\u2029returned is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).\u2029\u2029ldap_dn2dcedn() is used to turn a DN as returned by ldap_get_dn(3) into a DCE-style DN, e.g. a string with most-significant to least significant rdns separated by slashes ('/');\u2029rdn components are separated by commas (',').  Only printable chars (e.g. LDAPv2 printable string) are allowed, at least in this implementation.   ldap_dcedn2dn()  performs  the\u2029opposite  operation.   ldap_dn2ad_canonical() turns a DN into a AD canonical name, which is basically a DCE dn with attribute types omitted.  The trailing domain, if present, is\u2029turned in a DNS-like domain.  The space for the returned value is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).\u2029\u2029ERRORS\u2029If an error occurs in ldap_get_dn(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  See ldap_error(3) for a description  of  possible\u2029error codes.  ldap_explode_dn(), ldap_explode_rdn(), ldap_dn2ufn(), ldap_dn2dcedn(), ldap_dcedn2dn(), and ldap_dn2ad_canonical() will return NULL with errno(3) set appropriately\u2029in case of trouble.\u2029\u2029NOTES\u2029These routines dynamically allocate memory that the caller must free.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_first_entry(3), ldap_memfree(3), ldap_value_free(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 930, "position": [581683, 587777], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_get_dn, ldap_explode_dn, ldap_explode_rdn, ldap_dn2ufn - LDAP DN handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029char *ldap_get_dn( LDAP *ld, LDAPMessage *entry )\u2029\u2029int ldap_str2dn( const char *str, LDAPDN *dn, unsigned flags )\u2029\u2029void ldap_dnfree( LDAPDN dn )\u2029\u2029int ldap_dn2str( LDAPDN dn, char **str, unsigned flags )\u2029\u2029char **ldap_explode_dn( const char *dn, int notypes )\u2029\u2029char **ldap_explode_rdn( const char *rdn, int notypes )\u2029\u2029char *ldap_dn2ufn( const char * dn )\u2029\u2029char *ldap_dn2dcedn( const char * dn )\u2029\u2029char *ldap_dcedn2dn( const char * dn )\u2029\u2029char *ldap_dn2ad_canonical( const char * dn )\u2029\u2029DESCRIPTION\u2029These  routines  allow  LDAP entry names (Distinguished Names, or DNs) to be obtained, parsed, converted to a user-friendly form, and tested.  A DN has the form described in RFC\u20294414 \"Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names\".\u2029\u2029The ldap_get_dn() routine takes an entry as returned by ldap_first_entry(3) or ldap_next_entry(3) and returns a copy of the entry's DN.  Space for the DN will be obtained dynam\u2010\u2029ically and should be freed by the caller using ldap_memfree(3).\u2029\u2029ldap_str2dn()  parses  a  string representation of a distinguished name contained in str into its components, which are stored in dn as ldap_ava structures, arranged in LDAPAVA,\u2029LDAPRDN, and LDAPDN terms.  Space for dn will be obtained dynamically and should be freed by the caller using ldap_dnfree(3).  The LDAPDN is defined as:\u2029\u2029typedef struct ldap_ava {\u2029struct berval la_attr;\u2029struct berval la_value;\u2029unsigned la_flags;\u2029} LDAPAVA;\u2029\u2029typedef LDAPAVA** LDAPRDN;\u2029typedef LDAPRDN* LDAPDN;\u2029\u2029The attribute types and the attribute values are not normalized.  The la_flags can be either LDAP_AVA_STRING or LDAP_AVA_BINARY, the latter meaning that  the  value  is  BER/DER\u2029encoded  and  thus must be represented as, quoting from RFC 4514, \" ... an octothorpe character ('#' ASCII 35) followed by the hexadecimal representation of each of the bytes of\u2029the BER encoding of the X.500 AttributeValue.\"  The flags parameter to ldap_str2dn() can be\u2029\u2029LDAP_DN_FORMAT_LDAPV3\u2029LDAP_DN_FORMAT_LDAPV2\u2029LDAP_DN_FORMAT_DCE\u2029\u2029which defines what DN syntax is expected (according to RFC 4514, RFC 1779 and DCE, respectively).  The format can be ORed to the flags\u2029\u2029LDAP_DN_P_NO_SPACES\u2029LDAP_DN_P_NO_SPACE_AFTER_RDN\u2029...\u2029LDAP_DN_PEDANTIC\u2029\u2029The latter is a shortcut for all the previous limitations.\u2029\u2029LDAP_DN_P_NO_SPACES does not allow extra spaces in the dn; the default is to  silently  eliminate  spaces  around  AVA  separators  ('='),  RDN  component  separators  ('+'  for\u2029LDAPv3/LDAPv2 or ',' for DCE) and RDN separators (',' LDAPv3/LDAPv2 or '/' for DCE).\u2029\u2029LDAP_DN_P_NO_SPACE_AFTER_RDN does not allow a single space after RDN separators.\u2029\u2029ldap_dn2str() performs the inverse operation, yielding in str a string representation of dn.  It allows the same values for flags as ldap_str2dn(), plus\u2029\u2029LDAP_DN_FORMAT_UFN\u2029LDAP_DN_FORMAT_AD_CANONICAL\u2029\u2029for user-friendly naming (RFC 1781) and AD canonical.\u2029\u2029The following routines are viewed as deprecated in favor of ldap_str2dn() and ldap_dn2str().  They are provided to support legacy applications.\u2029\u2029The  ldap_explode_dn()  routine  takes a DN as returned by ldap_get_dn() and breaks it up into its component parts.  Each part is known as a Relative Distinguished Name, or RDN.\u2029ldap_explode_dn() returns a NULL-terminated array, each component of which contains an RDN from the DN.  The notypes parameter is used to request that only  the  RDN  values  be\u2029returned,  not their types.  For example, the DN \"cn=Bob, c=US\" would return as either { \"cn=Bob\", \"c=US\", NULL } or { \"Bob\", \"US\", NULL }, depending on whether notypes was 0 or\u20291, respectively.  Assertion values in RDN strings may included escaped characters.  The result can be freed by calling ldap_value_free(3).\u2029\u2029Similarly, the ldap_explode_rdn() routine takes an RDN as returned by ldap_explode_dn(dn,0) and breaks it up into its \"type=value\" component  parts  (or  just  \"value\",  if  the\u2029notypes parameter is set).  Note the value is not unescaped.  The result can be freed by calling ldap_value_free(3).\u2029\u2029ldap_dn2ufn() is used to turn a DN as returned by ldap_get_dn(3) into a more user-friendly form, stripping off all type names.  See \"Using the Directory to Achieve User Friendly\u2029Naming\" (RFC 1781) for more details on the UFN format.  Due to the ambiguous nature of the format, it is generally only used  for  display  purposes.   The  space  for  the  UFN\u2029returned is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).\u2029\u2029ldap_dn2dcedn() is used to turn a DN as returned by ldap_get_dn(3) into a DCE-style DN, e.g. a string with most-significant to least significant rdns separated by slashes ('/');\u2029rdn components are separated by commas (',').  Only printable chars (e.g. LDAPv2 printable string) are allowed, at least in this implementation.   ldap_dcedn2dn()  performs  the\u2029opposite  operation.   ldap_dn2ad_canonical() turns a DN into a AD canonical name, which is basically a DCE dn with attribute types omitted.  The trailing domain, if present, is\u2029turned in a DNS-like domain.  The space for the returned value is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).\u2029\u2029ERRORS\u2029If an error occurs in ldap_get_dn(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  See ldap_error(3) for a description  of  possible\u2029error codes.  ldap_explode_dn(), ldap_explode_rdn(), ldap_dn2ufn(), ldap_dn2dcedn(), ldap_dcedn2dn(), and ldap_dn2ad_canonical() will return NULL with errno(3) set appropriately\u2029in case of trouble.\u2029\u2029NOTES\u2029These routines dynamically allocate memory that the caller must free.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_first_entry(3), ldap_memfree(3), ldap_value_free(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 929, "position": [557952, 564046], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_get_dn, ldap_explode_dn, ldap_explode_rdn, ldap_dn2ufn - LDAP DN handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029char *ldap_get_dn( LDAP *ld, LDAPMessage *entry )\u2029\u2029int ldap_str2dn( const char *str, LDAPDN *dn, unsigned flags )\u2029\u2029void ldap_dnfree( LDAPDN dn )\u2029\u2029int ldap_dn2str( LDAPDN dn, char **str, unsigned flags )\u2029\u2029char **ldap_explode_dn( const char *dn, int notypes )\u2029\u2029char **ldap_explode_rdn( const char *rdn, int notypes )\u2029\u2029char *ldap_dn2ufn( const char * dn )\u2029\u2029char *ldap_dn2dcedn( const char * dn )\u2029\u2029char *ldap_dcedn2dn( const char * dn )\u2029\u2029char *ldap_dn2ad_canonical( const char * dn )\u2029\u2029DESCRIPTION\u2029These  routines  allow  LDAP entry names (Distinguished Names, or DNs) to be obtained, parsed, converted to a user-friendly form, and tested.  A DN has the form described in RFC\u20294414 \"Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names\".\u2029\u2029The ldap_get_dn() routine takes an entry as returned by ldap_first_entry(3) or ldap_next_entry(3) and returns a copy of the entry's DN.  Space for the DN will be obtained dynam\u2010\u2029ically and should be freed by the caller using ldap_memfree(3).\u2029\u2029ldap_str2dn()  parses  a  string representation of a distinguished name contained in str into its components, which are stored in dn as ldap_ava structures, arranged in LDAPAVA,\u2029LDAPRDN, and LDAPDN terms.  Space for dn will be obtained dynamically and should be freed by the caller using ldap_dnfree(3).  The LDAPDN is defined as:\u2029\u2029typedef struct ldap_ava {\u2029struct berval la_attr;\u2029struct berval la_value;\u2029unsigned la_flags;\u2029} LDAPAVA;\u2029\u2029typedef LDAPAVA** LDAPRDN;\u2029typedef LDAPRDN* LDAPDN;\u2029\u2029The attribute types and the attribute values are not normalized.  The la_flags can be either LDAP_AVA_STRING or LDAP_AVA_BINARY, the latter meaning that  the  value  is  BER/DER\u2029encoded  and  thus must be represented as, quoting from RFC 4514, \" ... an octothorpe character ('#' ASCII 35) followed by the hexadecimal representation of each of the bytes of\u2029the BER encoding of the X.500 AttributeValue.\"  The flags parameter to ldap_str2dn() can be\u2029\u2029LDAP_DN_FORMAT_LDAPV3\u2029LDAP_DN_FORMAT_LDAPV2\u2029LDAP_DN_FORMAT_DCE\u2029\u2029which defines what DN syntax is expected (according to RFC 4514, RFC 1779 and DCE, respectively).  The format can be ORed to the flags\u2029\u2029LDAP_DN_P_NO_SPACES\u2029LDAP_DN_P_NO_SPACE_AFTER_RDN\u2029...\u2029LDAP_DN_PEDANTIC\u2029\u2029The latter is a shortcut for all the previous limitations.\u2029\u2029LDAP_DN_P_NO_SPACES does not allow extra spaces in the dn; the default is to  silently  eliminate  spaces  around  AVA  separators  ('='),  RDN  component  separators  ('+'  for\u2029LDAPv3/LDAPv2 or ',' for DCE) and RDN separators (',' LDAPv3/LDAPv2 or '/' for DCE).\u2029\u2029LDAP_DN_P_NO_SPACE_AFTER_RDN does not allow a single space after RDN separators.\u2029\u2029ldap_dn2str() performs the inverse operation, yielding in str a string representation of dn.  It allows the same values for flags as ldap_str2dn(), plus\u2029\u2029LDAP_DN_FORMAT_UFN\u2029LDAP_DN_FORMAT_AD_CANONICAL\u2029\u2029for user-friendly naming (RFC 1781) and AD canonical.\u2029\u2029The following routines are viewed as deprecated in favor of ldap_str2dn() and ldap_dn2str().  They are provided to support legacy applications.\u2029\u2029The  ldap_explode_dn()  routine  takes a DN as returned by ldap_get_dn() and breaks it up into its component parts.  Each part is known as a Relative Distinguished Name, or RDN.\u2029ldap_explode_dn() returns a NULL-terminated array, each component of which contains an RDN from the DN.  The notypes parameter is used to request that only  the  RDN  values  be\u2029returned,  not their types.  For example, the DN \"cn=Bob, c=US\" would return as either { \"cn=Bob\", \"c=US\", NULL } or { \"Bob\", \"US\", NULL }, depending on whether notypes was 0 or\u20291, respectively.  Assertion values in RDN strings may included escaped characters.  The result can be freed by calling ldap_value_free(3).\u2029\u2029Similarly, the ldap_explode_rdn() routine takes an RDN as returned by ldap_explode_dn(dn,0) and breaks it up into its \"type=value\" component  parts  (or  just  \"value\",  if  the\u2029notypes parameter is set).  Note the value is not unescaped.  The result can be freed by calling ldap_value_free(3).\u2029\u2029ldap_dn2ufn() is used to turn a DN as returned by ldap_get_dn(3) into a more user-friendly form, stripping off all type names.  See \"Using the Directory to Achieve User Friendly\u2029Naming\" (RFC 1781) for more details on the UFN format.  Due to the ambiguous nature of the format, it is generally only used  for  display  purposes.   The  space  for  the  UFN\u2029returned is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).\u2029\u2029ldap_dn2dcedn() is used to turn a DN as returned by ldap_get_dn(3) into a DCE-style DN, e.g. a string with most-significant to least significant rdns separated by slashes ('/');\u2029rdn components are separated by commas (',').  Only printable chars (e.g. LDAPv2 printable string) are allowed, at least in this implementation.   ldap_dcedn2dn()  performs  the\u2029opposite  operation.   ldap_dn2ad_canonical() turns a DN into a AD canonical name, which is basically a DCE dn with attribute types omitted.  The trailing domain, if present, is\u2029turned in a DNS-like domain.  The space for the returned value is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).\u2029\u2029ERRORS\u2029If an error occurs in ldap_get_dn(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  See ldap_error(3) for a description  of  possible\u2029error codes.  ldap_explode_dn(), ldap_explode_rdn(), ldap_dn2ufn(), ldap_dn2dcedn(), ldap_dcedn2dn(), and ldap_dn2ad_canonical() will return NULL with errno(3) set appropriately\u2029in case of trouble.\u2029\u2029NOTES\u2029These routines dynamically allocate memory that the caller must free.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_first_entry(3), ldap_memfree(3), ldap_value_free(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 928, "position": [551485, 557579], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_get_dn, ldap_explode_dn, ldap_explode_rdn, ldap_dn2ufn - LDAP DN handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029char *ldap_get_dn( LDAP *ld, LDAPMessage *entry )\u2029\u2029int ldap_str2dn( const char *str, LDAPDN *dn, unsigned flags )\u2029\u2029void ldap_dnfree( LDAPDN dn )\u2029\u2029int ldap_dn2str( LDAPDN dn, char **str, unsigned flags )\u2029\u2029char **ldap_explode_dn( const char *dn, int notypes )\u2029\u2029char **ldap_explode_rdn( const char *rdn, int notypes )\u2029\u2029char *ldap_dn2ufn( const char * dn )\u2029\u2029char *ldap_dn2dcedn( const char * dn )\u2029\u2029char *ldap_dcedn2dn( const char * dn )\u2029\u2029char *ldap_dn2ad_canonical( const char * dn )\u2029\u2029DESCRIPTION\u2029These  routines  allow  LDAP entry names (Distinguished Names, or DNs) to be obtained, parsed, converted to a user-friendly form, and tested.  A DN has the form described in RFC\u20294414 \"Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names\".\u2029\u2029The ldap_get_dn() routine takes an entry as returned by ldap_first_entry(3) or ldap_next_entry(3) and returns a copy of the entry's DN.  Space for the DN will be obtained dynam\u2010\u2029ically and should be freed by the caller using ldap_memfree(3).\u2029\u2029ldap_str2dn()  parses  a  string representation of a distinguished name contained in str into its components, which are stored in dn as ldap_ava structures, arranged in LDAPAVA,\u2029LDAPRDN, and LDAPDN terms.  Space for dn will be obtained dynamically and should be freed by the caller using ldap_dnfree(3).  The LDAPDN is defined as:\u2029\u2029typedef struct ldap_ava {\u2029struct berval la_attr;\u2029struct berval la_value;\u2029unsigned la_flags;\u2029} LDAPAVA;\u2029\u2029typedef LDAPAVA** LDAPRDN;\u2029typedef LDAPRDN* LDAPDN;\u2029\u2029The attribute types and the attribute values are not normalized.  The la_flags can be either LDAP_AVA_STRING or LDAP_AVA_BINARY, the latter meaning that  the  value  is  BER/DER\u2029encoded  and  thus must be represented as, quoting from RFC 4514, \" ... an octothorpe character ('#' ASCII 35) followed by the hexadecimal representation of each of the bytes of\u2029the BER encoding of the X.500 AttributeValue.\"  The flags parameter to ldap_str2dn() can be\u2029\u2029LDAP_DN_FORMAT_LDAPV3\u2029LDAP_DN_FORMAT_LDAPV2\u2029LDAP_DN_FORMAT_DCE\u2029\u2029which defines what DN syntax is expected (according to RFC 4514, RFC 1779 and DCE, respectively).  The format can be ORed to the flags\u2029\u2029LDAP_DN_P_NO_SPACES\u2029LDAP_DN_P_NO_SPACE_AFTER_RDN\u2029...\u2029LDAP_DN_PEDANTIC\u2029\u2029The latter is a shortcut for all the previous limitations.\u2029\u2029LDAP_DN_P_NO_SPACES does not allow extra spaces in the dn; the default is to  silently  eliminate  spaces  around  AVA  separators  ('='),  RDN  component  separators  ('+'  for\u2029LDAPv3/LDAPv2 or ',' for DCE) and RDN separators (',' LDAPv3/LDAPv2 or '/' for DCE).\u2029\u2029LDAP_DN_P_NO_SPACE_AFTER_RDN does not allow a single space after RDN separators.\u2029\u2029ldap_dn2str() performs the inverse operation, yielding in str a string representation of dn.  It allows the same values for flags as ldap_str2dn(), plus\u2029\u2029LDAP_DN_FORMAT_UFN\u2029LDAP_DN_FORMAT_AD_CANONICAL\u2029\u2029for user-friendly naming (RFC 1781) and AD canonical.\u2029\u2029The following routines are viewed as deprecated in favor of ldap_str2dn() and ldap_dn2str().  They are provided to support legacy applications.\u2029\u2029The  ldap_explode_dn()  routine  takes a DN as returned by ldap_get_dn() and breaks it up into its component parts.  Each part is known as a Relative Distinguished Name, or RDN.\u2029ldap_explode_dn() returns a NULL-terminated array, each component of which contains an RDN from the DN.  The notypes parameter is used to request that only  the  RDN  values  be\u2029returned,  not their types.  For example, the DN \"cn=Bob, c=US\" would return as either { \"cn=Bob\", \"c=US\", NULL } or { \"Bob\", \"US\", NULL }, depending on whether notypes was 0 or\u20291, respectively.  Assertion values in RDN strings may included escaped characters.  The result can be freed by calling ldap_value_free(3).\u2029\u2029Similarly, the ldap_explode_rdn() routine takes an RDN as returned by ldap_explode_dn(dn,0) and breaks it up into its \"type=value\" component  parts  (or  just  \"value\",  if  the\u2029notypes parameter is set).  Note the value is not unescaped.  The result can be freed by calling ldap_value_free(3).\u2029\u2029ldap_dn2ufn() is used to turn a DN as returned by ldap_get_dn(3) into a more user-friendly form, stripping off all type names.  See \"Using the Directory to Achieve User Friendly\u2029Naming\" (RFC 1781) for more details on the UFN format.  Due to the ambiguous nature of the format, it is generally only used  for  display  purposes.   The  space  for  the  UFN\u2029returned is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).\u2029\u2029ldap_dn2dcedn() is used to turn a DN as returned by ldap_get_dn(3) into a DCE-style DN, e.g. a string with most-significant to least significant rdns separated by slashes ('/');\u2029rdn components are separated by commas (',').  Only printable chars (e.g. LDAPv2 printable string) are allowed, at least in this implementation.   ldap_dcedn2dn()  performs  the\u2029opposite  operation.   ldap_dn2ad_canonical() turns a DN into a AD canonical name, which is basically a DCE dn with attribute types omitted.  The trailing domain, if present, is\u2029turned in a DNS-like domain.  The space for the returned value is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).\u2029\u2029ERRORS\u2029If an error occurs in ldap_get_dn(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  See ldap_error(3) for a description  of  possible\u2029error codes.  ldap_explode_dn(), ldap_explode_rdn(), ldap_dn2ufn(), ldap_dn2dcedn(), ldap_dcedn2dn(), and ldap_dn2ad_canonical() will return NULL with errno(3) set appropriately\u2029in case of trouble.\u2029\u2029NOTES\u2029These routines dynamically allocate memory that the caller must free.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_first_entry(3), ldap_memfree(3), ldap_value_free(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 927, "position": [522259, 528353], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_get_dn, ldap_explode_dn, ldap_explode_rdn, ldap_dn2ufn - LDAP DN handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029char *ldap_get_dn( LDAP *ld, LDAPMessage *entry )\u2029\u2029int ldap_str2dn( const char *str, LDAPDN *dn, unsigned flags )\u2029\u2029void ldap_dnfree( LDAPDN dn )\u2029\u2029int ldap_dn2str( LDAPDN dn, char **str, unsigned flags )\u2029\u2029char **ldap_explode_dn( const char *dn, int notypes )\u2029\u2029char **ldap_explode_rdn( const char *rdn, int notypes )\u2029\u2029char *ldap_dn2ufn( const char * dn )\u2029\u2029char *ldap_dn2dcedn( const char * dn )\u2029\u2029char *ldap_dcedn2dn( const char * dn )\u2029\u2029char *ldap_dn2ad_canonical( const char * dn )\u2029\u2029DESCRIPTION\u2029These  routines  allow  LDAP entry names (Distinguished Names, or DNs) to be obtained, parsed, converted to a user-friendly form, and tested.  A DN has the form described in RFC\u20294414 \"Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names\".\u2029\u2029The ldap_get_dn() routine takes an entry as returned by ldap_first_entry(3) or ldap_next_entry(3) and returns a copy of the entry's DN.  Space for the DN will be obtained dynam\u2010\u2029ically and should be freed by the caller using ldap_memfree(3).\u2029\u2029ldap_str2dn()  parses  a  string representation of a distinguished name contained in str into its components, which are stored in dn as ldap_ava structures, arranged in LDAPAVA,\u2029LDAPRDN, and LDAPDN terms.  Space for dn will be obtained dynamically and should be freed by the caller using ldap_dnfree(3).  The LDAPDN is defined as:\u2029\u2029typedef struct ldap_ava {\u2029struct berval la_attr;\u2029struct berval la_value;\u2029unsigned la_flags;\u2029} LDAPAVA;\u2029\u2029typedef LDAPAVA** LDAPRDN;\u2029typedef LDAPRDN* LDAPDN;\u2029\u2029The attribute types and the attribute values are not normalized.  The la_flags can be either LDAP_AVA_STRING or LDAP_AVA_BINARY, the latter meaning that  the  value  is  BER/DER\u2029encoded  and  thus must be represented as, quoting from RFC 4514, \" ... an octothorpe character ('#' ASCII 35) followed by the hexadecimal representation of each of the bytes of\u2029the BER encoding of the X.500 AttributeValue.\"  The flags parameter to ldap_str2dn() can be\u2029\u2029LDAP_DN_FORMAT_LDAPV3\u2029LDAP_DN_FORMAT_LDAPV2\u2029LDAP_DN_FORMAT_DCE\u2029\u2029which defines what DN syntax is expected (according to RFC 4514, RFC 1779 and DCE, respectively).  The format can be ORed to the flags\u2029\u2029LDAP_DN_P_NO_SPACES\u2029LDAP_DN_P_NO_SPACE_AFTER_RDN\u2029...\u2029LDAP_DN_PEDANTIC\u2029\u2029The latter is a shortcut for all the previous limitations.\u2029\u2029LDAP_DN_P_NO_SPACES does not allow extra spaces in the dn; the default is to  silently  eliminate  spaces  around  AVA  separators  ('='),  RDN  component  separators  ('+'  for\u2029LDAPv3/LDAPv2 or ',' for DCE) and RDN separators (',' LDAPv3/LDAPv2 or '/' for DCE).\u2029\u2029LDAP_DN_P_NO_SPACE_AFTER_RDN does not allow a single space after RDN separators.\u2029\u2029ldap_dn2str() performs the inverse operation, yielding in str a string representation of dn.  It allows the same values for flags as ldap_str2dn(), plus\u2029\u2029LDAP_DN_FORMAT_UFN\u2029LDAP_DN_FORMAT_AD_CANONICAL\u2029\u2029for user-friendly naming (RFC 1781) and AD canonical.\u2029\u2029The following routines are viewed as deprecated in favor of ldap_str2dn() and ldap_dn2str().  They are provided to support legacy applications.\u2029\u2029The  ldap_explode_dn()  routine  takes a DN as returned by ldap_get_dn() and breaks it up into its component parts.  Each part is known as a Relative Distinguished Name, or RDN.\u2029ldap_explode_dn() returns a NULL-terminated array, each component of which contains an RDN from the DN.  The notypes parameter is used to request that only  the  RDN  values  be\u2029returned,  not their types.  For example, the DN \"cn=Bob, c=US\" would return as either { \"cn=Bob\", \"c=US\", NULL } or { \"Bob\", \"US\", NULL }, depending on whether notypes was 0 or\u20291, respectively.  Assertion values in RDN strings may included escaped characters.  The result can be freed by calling ldap_value_free(3).\u2029\u2029Similarly, the ldap_explode_rdn() routine takes an RDN as returned by ldap_explode_dn(dn,0) and breaks it up into its \"type=value\" component  parts  (or  just  \"value\",  if  the\u2029notypes parameter is set).  Note the value is not unescaped.  The result can be freed by calling ldap_value_free(3).\u2029\u2029ldap_dn2ufn() is used to turn a DN as returned by ldap_get_dn(3) into a more user-friendly form, stripping off all type names.  See \"Using the Directory to Achieve User Friendly\u2029Naming\" (RFC 1781) for more details on the UFN format.  Due to the ambiguous nature of the format, it is generally only used  for  display  purposes.   The  space  for  the  UFN\u2029returned is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).\u2029\u2029ldap_dn2dcedn() is used to turn a DN as returned by ldap_get_dn(3) into a DCE-style DN, e.g. a string with most-significant to least significant rdns separated by slashes ('/');\u2029rdn components are separated by commas (',').  Only printable chars (e.g. LDAPv2 printable string) are allowed, at least in this implementation.   ldap_dcedn2dn()  performs  the\u2029opposite  operation.   ldap_dn2ad_canonical() turns a DN into a AD canonical name, which is basically a DCE dn with attribute types omitted.  The trailing domain, if present, is\u2029turned in a DNS-like domain.  The space for the returned value is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).\u2029\u2029ERRORS\u2029If an error occurs in ldap_get_dn(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  See ldap_error(3) for a description  of  possible\u2029error codes.  ldap_explode_dn(), ldap_explode_rdn(), ldap_dn2ufn(), ldap_dn2dcedn(), ldap_dcedn2dn(), and ldap_dn2ad_canonical() will return NULL with errno(3) set appropriately\u2029in case of trouble.\u2029\u2029NOTES\u2029These routines dynamically allocate memory that the caller must free.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_first_entry(3), ldap_memfree(3), ldap_value_free(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 926, "position": [515792, 521886], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_get_dn, ldap_explode_dn, ldap_explode_rdn, ldap_dn2ufn - LDAP DN handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029char *ldap_get_dn( LDAP *ld, LDAPMessage *entry )\u2029\u2029int ldap_str2dn( const char *str, LDAPDN *dn, unsigned flags )\u2029\u2029void ldap_dnfree( LDAPDN dn )\u2029\u2029int ldap_dn2str( LDAPDN dn, char **str, unsigned flags )\u2029\u2029char **ldap_explode_dn( const char *dn, int notypes )\u2029\u2029char **ldap_explode_rdn( const char *rdn, int notypes )\u2029\u2029char *ldap_dn2ufn( const char * dn )\u2029\u2029char *ldap_dn2dcedn( const char * dn )\u2029\u2029char *ldap_dcedn2dn( const char * dn )\u2029\u2029char *ldap_dn2ad_canonical( const char * dn )\u2029\u2029DESCRIPTION\u2029These  routines  allow  LDAP entry names (Distinguished Names, or DNs) to be obtained, parsed, converted to a user-friendly form, and tested.  A DN has the form described in RFC\u20294414 \"Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names\".\u2029\u2029The ldap_get_dn() routine takes an entry as returned by ldap_first_entry(3) or ldap_next_entry(3) and returns a copy of the entry's DN.  Space for the DN will be obtained dynam\u2010\u2029ically and should be freed by the caller using ldap_memfree(3).\u2029\u2029ldap_str2dn()  parses  a  string representation of a distinguished name contained in str into its components, which are stored in dn as ldap_ava structures, arranged in LDAPAVA,\u2029LDAPRDN, and LDAPDN terms.  Space for dn will be obtained dynamically and should be freed by the caller using ldap_dnfree(3).  The LDAPDN is defined as:\u2029\u2029typedef struct ldap_ava {\u2029struct berval la_attr;\u2029struct berval la_value;\u2029unsigned la_flags;\u2029} LDAPAVA;\u2029\u2029typedef LDAPAVA** LDAPRDN;\u2029typedef LDAPRDN* LDAPDN;\u2029\u2029The attribute types and the attribute values are not normalized.  The la_flags can be either LDAP_AVA_STRING or LDAP_AVA_BINARY, the latter meaning that  the  value  is  BER/DER\u2029encoded  and  thus must be represented as, quoting from RFC 4514, \" ... an octothorpe character ('#' ASCII 35) followed by the hexadecimal representation of each of the bytes of\u2029the BER encoding of the X.500 AttributeValue.\"  The flags parameter to ldap_str2dn() can be\u2029\u2029LDAP_DN_FORMAT_LDAPV3\u2029LDAP_DN_FORMAT_LDAPV2\u2029LDAP_DN_FORMAT_DCE\u2029\u2029which defines what DN syntax is expected (according to RFC 4514, RFC 1779 and DCE, respectively).  The format can be ORed to the flags\u2029\u2029LDAP_DN_P_NO_SPACES\u2029LDAP_DN_P_NO_SPACE_AFTER_RDN\u2029...\u2029LDAP_DN_PEDANTIC\u2029\u2029The latter is a shortcut for all the previous limitations.\u2029\u2029LDAP_DN_P_NO_SPACES does not allow extra spaces in the dn; the default is to  silently  eliminate  spaces  around  AVA  separators  ('='),  RDN  component  separators  ('+'  for\u2029LDAPv3/LDAPv2 or ',' for DCE) and RDN separators (',' LDAPv3/LDAPv2 or '/' for DCE).\u2029\u2029LDAP_DN_P_NO_SPACE_AFTER_RDN does not allow a single space after RDN separators.\u2029\u2029ldap_dn2str() performs the inverse operation, yielding in str a string representation of dn.  It allows the same values for flags as ldap_str2dn(), plus\u2029\u2029LDAP_DN_FORMAT_UFN\u2029LDAP_DN_FORMAT_AD_CANONICAL\u2029\u2029for user-friendly naming (RFC 1781) and AD canonical.\u2029\u2029The following routines are viewed as deprecated in favor of ldap_str2dn() and ldap_dn2str().  They are provided to support legacy applications.\u2029\u2029The  ldap_explode_dn()  routine  takes a DN as returned by ldap_get_dn() and breaks it up into its component parts.  Each part is known as a Relative Distinguished Name, or RDN.\u2029ldap_explode_dn() returns a NULL-terminated array, each component of which contains an RDN from the DN.  The notypes parameter is used to request that only  the  RDN  values  be\u2029returned,  not their types.  For example, the DN \"cn=Bob, c=US\" would return as either { \"cn=Bob\", \"c=US\", NULL } or { \"Bob\", \"US\", NULL }, depending on whether notypes was 0 or\u20291, respectively.  Assertion values in RDN strings may included escaped characters.  The result can be freed by calling ldap_value_free(3).\u2029\u2029Similarly, the ldap_explode_rdn() routine takes an RDN as returned by ldap_explode_dn(dn,0) and breaks it up into its \"type=value\" component  parts  (or  just  \"value\",  if  the\u2029notypes parameter is set).  Note the value is not unescaped.  The result can be freed by calling ldap_value_free(3).\u2029\u2029ldap_dn2ufn() is used to turn a DN as returned by ldap_get_dn(3) into a more user-friendly form, stripping off all type names.  See \"Using the Directory to Achieve User Friendly\u2029Naming\" (RFC 1781) for more details on the UFN format.  Due to the ambiguous nature of the format, it is generally only used  for  display  purposes.   The  space  for  the  UFN\u2029returned is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).\u2029\u2029ldap_dn2dcedn() is used to turn a DN as returned by ldap_get_dn(3) into a DCE-style DN, e.g. a string with most-significant to least significant rdns separated by slashes ('/');\u2029rdn components are separated by commas (',').  Only printable chars (e.g. LDAPv2 printable string) are allowed, at least in this implementation.   ldap_dcedn2dn()  performs  the\u2029opposite  operation.   ldap_dn2ad_canonical() turns a DN into a AD canonical name, which is basically a DCE dn with attribute types omitted.  The trailing domain, if present, is\u2029turned in a DNS-like domain.  The space for the returned value is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).\u2029\u2029ERRORS\u2029If an error occurs in ldap_get_dn(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  See ldap_error(3) for a description  of  possible\u2029error codes.  ldap_explode_dn(), ldap_explode_rdn(), ldap_dn2ufn(), ldap_dn2dcedn(), ldap_dcedn2dn(), and ldap_dn2ad_canonical() will return NULL with errno(3) set appropriately\u2029in case of trouble.\u2029\u2029NOTES\u2029These routines dynamically allocate memory that the caller must free.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_first_entry(3), ldap_memfree(3), ldap_value_free(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 925, "position": [509325, 515419], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_get_dn, ldap_explode_dn, ldap_explode_rdn, ldap_dn2ufn - LDAP DN handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029char *ldap_get_dn( LDAP *ld, LDAPMessage *entry )\u2029\u2029int ldap_str2dn( const char *str, LDAPDN *dn, unsigned flags )\u2029\u2029void ldap_dnfree( LDAPDN dn )\u2029\u2029int ldap_dn2str( LDAPDN dn, char **str, unsigned flags )\u2029\u2029char **ldap_explode_dn( const char *dn, int notypes )\u2029\u2029char **ldap_explode_rdn( const char *rdn, int notypes )\u2029\u2029char *ldap_dn2ufn( const char * dn )\u2029\u2029char *ldap_dn2dcedn( const char * dn )\u2029\u2029char *ldap_dcedn2dn( const char * dn )\u2029\u2029char *ldap_dn2ad_canonical( const char * dn )\u2029\u2029DESCRIPTION\u2029These  routines  allow  LDAP entry names (Distinguished Names, or DNs) to be obtained, parsed, converted to a user-friendly form, and tested.  A DN has the form described in RFC\u20294414 \"Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names\".\u2029\u2029The ldap_get_dn() routine takes an entry as returned by ldap_first_entry(3) or ldap_next_entry(3) and returns a copy of the entry's DN.  Space for the DN will be obtained dynam\u2010\u2029ically and should be freed by the caller using ldap_memfree(3).\u2029\u2029ldap_str2dn()  parses  a  string representation of a distinguished name contained in str into its components, which are stored in dn as ldap_ava structures, arranged in LDAPAVA,\u2029LDAPRDN, and LDAPDN terms.  Space for dn will be obtained dynamically and should be freed by the caller using ldap_dnfree(3).  The LDAPDN is defined as:\u2029\u2029typedef struct ldap_ava {\u2029struct berval la_attr;\u2029struct berval la_value;\u2029unsigned la_flags;\u2029} LDAPAVA;\u2029\u2029typedef LDAPAVA** LDAPRDN;\u2029typedef LDAPRDN* LDAPDN;\u2029\u2029The attribute types and the attribute values are not normalized.  The la_flags can be either LDAP_AVA_STRING or LDAP_AVA_BINARY, the latter meaning that  the  value  is  BER/DER\u2029encoded  and  thus must be represented as, quoting from RFC 4514, \" ... an octothorpe character ('#' ASCII 35) followed by the hexadecimal representation of each of the bytes of\u2029the BER encoding of the X.500 AttributeValue.\"  The flags parameter to ldap_str2dn() can be\u2029\u2029LDAP_DN_FORMAT_LDAPV3\u2029LDAP_DN_FORMAT_LDAPV2\u2029LDAP_DN_FORMAT_DCE\u2029\u2029which defines what DN syntax is expected (according to RFC 4514, RFC 1779 and DCE, respectively).  The format can be ORed to the flags\u2029\u2029LDAP_DN_P_NO_SPACES\u2029LDAP_DN_P_NO_SPACE_AFTER_RDN\u2029...\u2029LDAP_DN_PEDANTIC\u2029\u2029The latter is a shortcut for all the previous limitations.\u2029\u2029LDAP_DN_P_NO_SPACES does not allow extra spaces in the dn; the default is to  silently  eliminate  spaces  around  AVA  separators  ('='),  RDN  component  separators  ('+'  for\u2029LDAPv3/LDAPv2 or ',' for DCE) and RDN separators (',' LDAPv3/LDAPv2 or '/' for DCE).\u2029\u2029LDAP_DN_P_NO_SPACE_AFTER_RDN does not allow a single space after RDN separators.\u2029\u2029ldap_dn2str() performs the inverse operation, yielding in str a string representation of dn.  It allows the same values for flags as ldap_str2dn(), plus\u2029\u2029LDAP_DN_FORMAT_UFN\u2029LDAP_DN_FORMAT_AD_CANONICAL\u2029\u2029for user-friendly naming (RFC 1781) and AD canonical.\u2029\u2029The following routines are viewed as deprecated in favor of ldap_str2dn() and ldap_dn2str().  They are provided to support legacy applications.\u2029\u2029The  ldap_explode_dn()  routine  takes a DN as returned by ldap_get_dn() and breaks it up into its component parts.  Each part is known as a Relative Distinguished Name, or RDN.\u2029ldap_explode_dn() returns a NULL-terminated array, each component of which contains an RDN from the DN.  The notypes parameter is used to request that only  the  RDN  values  be\u2029returned,  not their types.  For example, the DN \"cn=Bob, c=US\" would return as either { \"cn=Bob\", \"c=US\", NULL } or { \"Bob\", \"US\", NULL }, depending on whether notypes was 0 or\u20291, respectively.  Assertion values in RDN strings may included escaped characters.  The result can be freed by calling ldap_value_free(3).\u2029\u2029Similarly, the ldap_explode_rdn() routine takes an RDN as returned by ldap_explode_dn(dn,0) and breaks it up into its \"type=value\" component  parts  (or  just  \"value\",  if  the\u2029notypes parameter is set).  Note the value is not unescaped.  The result can be freed by calling ldap_value_free(3).\u2029\u2029ldap_dn2ufn() is used to turn a DN as returned by ldap_get_dn(3) into a more user-friendly form, stripping off all type names.  See \"Using the Directory to Achieve User Friendly\u2029Naming\" (RFC 1781) for more details on the UFN format.  Due to the ambiguous nature of the format, it is generally only used  for  display  purposes.   The  space  for  the  UFN\u2029returned is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).\u2029\u2029ldap_dn2dcedn() is used to turn a DN as returned by ldap_get_dn(3) into a DCE-style DN, e.g. a string with most-significant to least significant rdns separated by slashes ('/');\u2029rdn components are separated by commas (',').  Only printable chars (e.g. LDAPv2 printable string) are allowed, at least in this implementation.   ldap_dcedn2dn()  performs  the\u2029opposite  operation.   ldap_dn2ad_canonical() turns a DN into a AD canonical name, which is basically a DCE dn with attribute types omitted.  The trailing domain, if present, is\u2029turned in a DNS-like domain.  The space for the returned value is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).\u2029\u2029ERRORS\u2029If an error occurs in ldap_get_dn(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  See ldap_error(3) for a description  of  possible\u2029error codes.  ldap_explode_dn(), ldap_explode_rdn(), ldap_dn2ufn(), ldap_dn2dcedn(), ldap_dcedn2dn(), and ldap_dn2ad_canonical() will return NULL with errno(3) set appropriately\u2029in case of trouble.\u2029\u2029NOTES\u2029These routines dynamically allocate memory that the caller must free.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_first_entry(3), ldap_memfree(3), ldap_value_free(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 924, "position": [502858, 508952], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_get_dn, ldap_explode_dn, ldap_explode_rdn, ldap_dn2ufn - LDAP DN handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029char *ldap_get_dn( LDAP *ld, LDAPMessage *entry )\u2029\u2029int ldap_str2dn( const char *str, LDAPDN *dn, unsigned flags )\u2029\u2029void ldap_dnfree( LDAPDN dn )\u2029\u2029int ldap_dn2str( LDAPDN dn, char **str, unsigned flags )\u2029\u2029char **ldap_explode_dn( const char *dn, int notypes )\u2029\u2029char **ldap_explode_rdn( const char *rdn, int notypes )\u2029\u2029char *ldap_dn2ufn( const char * dn )\u2029\u2029char *ldap_dn2dcedn( const char * dn )\u2029\u2029char *ldap_dcedn2dn( const char * dn )\u2029\u2029char *ldap_dn2ad_canonical( const char * dn )\u2029\u2029DESCRIPTION\u2029These  routines  allow  LDAP entry names (Distinguished Names, or DNs) to be obtained, parsed, converted to a user-friendly form, and tested.  A DN has the form described in RFC\u20294414 \"Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names\".\u2029\u2029The ldap_get_dn() routine takes an entry as returned by ldap_first_entry(3) or ldap_next_entry(3) and returns a copy of the entry's DN.  Space for the DN will be obtained dynam\u2010\u2029ically and should be freed by the caller using ldap_memfree(3).\u2029\u2029ldap_str2dn()  parses  a  string representation of a distinguished name contained in str into its components, which are stored in dn as ldap_ava structures, arranged in LDAPAVA,\u2029LDAPRDN, and LDAPDN terms.  Space for dn will be obtained dynamically and should be freed by the caller using ldap_dnfree(3).  The LDAPDN is defined as:\u2029\u2029typedef struct ldap_ava {\u2029struct berval la_attr;\u2029struct berval la_value;\u2029unsigned la_flags;\u2029} LDAPAVA;\u2029\u2029typedef LDAPAVA** LDAPRDN;\u2029typedef LDAPRDN* LDAPDN;\u2029\u2029The attribute types and the attribute values are not normalized.  The la_flags can be either LDAP_AVA_STRING or LDAP_AVA_BINARY, the latter meaning that  the  value  is  BER/DER\u2029encoded  and  thus must be represented as, quoting from RFC 4514, \" ... an octothorpe character ('#' ASCII 35) followed by the hexadecimal representation of each of the bytes of\u2029the BER encoding of the X.500 AttributeValue.\"  The flags parameter to ldap_str2dn() can be\u2029\u2029LDAP_DN_FORMAT_LDAPV3\u2029LDAP_DN_FORMAT_LDAPV2\u2029LDAP_DN_FORMAT_DCE\u2029\u2029which defines what DN syntax is expected (according to RFC 4514, RFC 1779 and DCE, respectively).  The format can be ORed to the flags\u2029\u2029LDAP_DN_P_NO_SPACES\u2029LDAP_DN_P_NO_SPACE_AFTER_RDN\u2029...\u2029LDAP_DN_PEDANTIC\u2029\u2029The latter is a shortcut for all the previous limitations.\u2029\u2029LDAP_DN_P_NO_SPACES does not allow extra spaces in the dn; the default is to  silently  eliminate  spaces  around  AVA  separators  ('='),  RDN  component  separators  ('+'  for\u2029LDAPv3/LDAPv2 or ',' for DCE) and RDN separators (',' LDAPv3/LDAPv2 or '/' for DCE).\u2029\u2029LDAP_DN_P_NO_SPACE_AFTER_RDN does not allow a single space after RDN separators.\u2029\u2029ldap_dn2str() performs the inverse operation, yielding in str a string representation of dn.  It allows the same values for flags as ldap_str2dn(), plus\u2029\u2029LDAP_DN_FORMAT_UFN\u2029LDAP_DN_FORMAT_AD_CANONICAL\u2029\u2029for user-friendly naming (RFC 1781) and AD canonical.\u2029\u2029The following routines are viewed as deprecated in favor of ldap_str2dn() and ldap_dn2str().  They are provided to support legacy applications.\u2029\u2029The  ldap_explode_dn()  routine  takes a DN as returned by ldap_get_dn() and breaks it up into its component parts.  Each part is known as a Relative Distinguished Name, or RDN.\u2029ldap_explode_dn() returns a NULL-terminated array, each component of which contains an RDN from the DN.  The notypes parameter is used to request that only  the  RDN  values  be\u2029returned,  not their types.  For example, the DN \"cn=Bob, c=US\" would return as either { \"cn=Bob\", \"c=US\", NULL } or { \"Bob\", \"US\", NULL }, depending on whether notypes was 0 or\u20291, respectively.  Assertion values in RDN strings may included escaped characters.  The result can be freed by calling ldap_value_free(3).\u2029\u2029Similarly, the ldap_explode_rdn() routine takes an RDN as returned by ldap_explode_dn(dn,0) and breaks it up into its \"type=value\" component  parts  (or  just  \"value\",  if  the\u2029notypes parameter is set).  Note the value is not unescaped.  The result can be freed by calling ldap_value_free(3).\u2029\u2029ldap_dn2ufn() is used to turn a DN as returned by ldap_get_dn(3) into a more user-friendly form, stripping off all type names.  See \"Using the Directory to Achieve User Friendly\u2029Naming\" (RFC 1781) for more details on the UFN format.  Due to the ambiguous nature of the format, it is generally only used  for  display  purposes.   The  space  for  the  UFN\u2029returned is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).\u2029\u2029ldap_dn2dcedn() is used to turn a DN as returned by ldap_get_dn(3) into a DCE-style DN, e.g. a string with most-significant to least significant rdns separated by slashes ('/');\u2029rdn components are separated by commas (',').  Only printable chars (e.g. LDAPv2 printable string) are allowed, at least in this implementation.   ldap_dcedn2dn()  performs  the\u2029opposite  operation.   ldap_dn2ad_canonical() turns a DN into a AD canonical name, which is basically a DCE dn with attribute types omitted.  The trailing domain, if present, is\u2029turned in a DNS-like domain.  The space for the returned value is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).\u2029\u2029ERRORS\u2029If an error occurs in ldap_get_dn(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  See ldap_error(3) for a description  of  possible\u2029error codes.  ldap_explode_dn(), ldap_explode_rdn(), ldap_dn2ufn(), ldap_dn2dcedn(), ldap_dcedn2dn(), and ldap_dn2ad_canonical() will return NULL with errno(3) set appropriately\u2029in case of trouble.\u2029\u2029NOTES\u2029These routines dynamically allocate memory that the caller must free.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_first_entry(3), ldap_memfree(3), ldap_value_free(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 923, "position": [496391, 502485], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_get_dn, ldap_explode_dn, ldap_explode_rdn, ldap_dn2ufn - LDAP DN handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029char *ldap_get_dn( LDAP *ld, LDAPMessage *entry )\u2029\u2029int ldap_str2dn( const char *str, LDAPDN *dn, unsigned flags )\u2029\u2029void ldap_dnfree( LDAPDN dn )\u2029\u2029int ldap_dn2str( LDAPDN dn, char **str, unsigned flags )\u2029\u2029char **ldap_explode_dn( const char *dn, int notypes )\u2029\u2029char **ldap_explode_rdn( const char *rdn, int notypes )\u2029\u2029char *ldap_dn2ufn( const char * dn )\u2029\u2029char *ldap_dn2dcedn( const char * dn )\u2029\u2029char *ldap_dcedn2dn( const char * dn )\u2029\u2029char *ldap_dn2ad_canonical( const char * dn )\u2029\u2029DESCRIPTION\u2029These  routines  allow  LDAP entry names (Distinguished Names, or DNs) to be obtained, parsed, converted to a user-friendly form, and tested.  A DN has the form described in RFC\u20294414 \"Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names\".\u2029\u2029The ldap_get_dn() routine takes an entry as returned by ldap_first_entry(3) or ldap_next_entry(3) and returns a copy of the entry's DN.  Space for the DN will be obtained dynam\u2010\u2029ically and should be freed by the caller using ldap_memfree(3).\u2029\u2029ldap_str2dn()  parses  a  string representation of a distinguished name contained in str into its components, which are stored in dn as ldap_ava structures, arranged in LDAPAVA,\u2029LDAPRDN, and LDAPDN terms.  Space for dn will be obtained dynamically and should be freed by the caller using ldap_dnfree(3).  The LDAPDN is defined as:\u2029\u2029typedef struct ldap_ava {\u2029struct berval la_attr;\u2029struct berval la_value;\u2029unsigned la_flags;\u2029} LDAPAVA;\u2029\u2029typedef LDAPAVA** LDAPRDN;\u2029typedef LDAPRDN* LDAPDN;\u2029\u2029The attribute types and the attribute values are not normalized.  The la_flags can be either LDAP_AVA_STRING or LDAP_AVA_BINARY, the latter meaning that  the  value  is  BER/DER\u2029encoded  and  thus must be represented as, quoting from RFC 4514, \" ... an octothorpe character ('#' ASCII 35) followed by the hexadecimal representation of each of the bytes of\u2029the BER encoding of the X.500 AttributeValue.\"  The flags parameter to ldap_str2dn() can be\u2029\u2029LDAP_DN_FORMAT_LDAPV3\u2029LDAP_DN_FORMAT_LDAPV2\u2029LDAP_DN_FORMAT_DCE\u2029\u2029which defines what DN syntax is expected (according to RFC 4514, RFC 1779 and DCE, respectively).  The format can be ORed to the flags\u2029\u2029LDAP_DN_P_NO_SPACES\u2029LDAP_DN_P_NO_SPACE_AFTER_RDN\u2029...\u2029LDAP_DN_PEDANTIC\u2029\u2029The latter is a shortcut for all the previous limitations.\u2029\u2029LDAP_DN_P_NO_SPACES does not allow extra spaces in the dn; the default is to  silently  eliminate  spaces  around  AVA  separators  ('='),  RDN  component  separators  ('+'  for\u2029LDAPv3/LDAPv2 or ',' for DCE) and RDN separators (',' LDAPv3/LDAPv2 or '/' for DCE).\u2029\u2029LDAP_DN_P_NO_SPACE_AFTER_RDN does not allow a single space after RDN separators.\u2029\u2029ldap_dn2str() performs the inverse operation, yielding in str a string representation of dn.  It allows the same values for flags as ldap_str2dn(), plus\u2029\u2029LDAP_DN_FORMAT_UFN\u2029LDAP_DN_FORMAT_AD_CANONICAL\u2029\u2029for user-friendly naming (RFC 1781) and AD canonical.\u2029\u2029The following routines are viewed as deprecated in favor of ldap_str2dn() and ldap_dn2str().  They are provided to support legacy applications.\u2029\u2029The  ldap_explode_dn()  routine  takes a DN as returned by ldap_get_dn() and breaks it up into its component parts.  Each part is known as a Relative Distinguished Name, or RDN.\u2029ldap_explode_dn() returns a NULL-terminated array, each component of which contains an RDN from the DN.  The notypes parameter is used to request that only  the  RDN  values  be\u2029returned,  not their types.  For example, the DN \"cn=Bob, c=US\" would return as either { \"cn=Bob\", \"c=US\", NULL } or { \"Bob\", \"US\", NULL }, depending on whether notypes was 0 or\u20291, respectively.  Assertion values in RDN strings may included escaped characters.  The result can be freed by calling ldap_value_free(3).\u2029\u2029Similarly, the ldap_explode_rdn() routine takes an RDN as returned by ldap_explode_dn(dn,0) and breaks it up into its \"type=value\" component  parts  (or  just  \"value\",  if  the\u2029notypes parameter is set).  Note the value is not unescaped.  The result can be freed by calling ldap_value_free(3).\u2029\u2029ldap_dn2ufn() is used to turn a DN as returned by ldap_get_dn(3) into a more user-friendly form, stripping off all type names.  See \"Using the Directory to Achieve User Friendly\u2029Naming\" (RFC 1781) for more details on the UFN format.  Due to the ambiguous nature of the format, it is generally only used  for  display  purposes.   The  space  for  the  UFN\u2029returned is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).\u2029\u2029ldap_dn2dcedn() is used to turn a DN as returned by ldap_get_dn(3) into a DCE-style DN, e.g. a string with most-significant to least significant rdns separated by slashes ('/');\u2029rdn components are separated by commas (',').  Only printable chars (e.g. LDAPv2 printable string) are allowed, at least in this implementation.   ldap_dcedn2dn()  performs  the\u2029opposite  operation.   ldap_dn2ad_canonical() turns a DN into a AD canonical name, which is basically a DCE dn with attribute types omitted.  The trailing domain, if present, is\u2029turned in a DNS-like domain.  The space for the returned value is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).\u2029\u2029ERRORS\u2029If an error occurs in ldap_get_dn(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  See ldap_error(3) for a description  of  possible\u2029error codes.  ldap_explode_dn(), ldap_explode_rdn(), ldap_dn2ufn(), ldap_dn2dcedn(), ldap_dcedn2dn(), and ldap_dn2ad_canonical() will return NULL with errno(3) set appropriately\u2029in case of trouble.\u2029\u2029NOTES\u2029These routines dynamically allocate memory that the caller must free.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), ldap_first_entry(3), ldap_memfree(3), ldap_value_free(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 922, "position": [476361, 482455], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "56", "annotation": "LDAP_DELETE", "group_ids": [{"name2": "NAME\u2029ldap_delete, ldap_delete_s, ldap_delete_ext, ldap_delete_ext_s - Perform an LDAP delete operation.\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_delete_s(ld, dn)\u2029LDAP *ld;\u2029char *dn;\u2029\u2029int ldap_delete(ld, dn)\u2029LDAP *ld;\u2029char *dn;\u2029\u2029int ldap_delete_ext(ld, dn, serverctrls, clientctrls, msgidp)\u2029LDAP *ld;\u2029char *dn;\u2029LDAPControl **serverctrls, **clientctrls;\u2029int *msgidp;\u2029\u2029int ldap_delete_ext_s(ld, dn, serverctrls, clientctrls)\u2029LDAP *ld;\u2029char *dn;\u2029LDAPControl **serverctrls, **clientctrls;\u2029\u2029DESCRIPTION\u2029The ldap_delete_s() routine is used to perform an LDAP delete operation synchronously. It takes dn, the DN of the entry to be deleted.  It returns an LDAP error code, indicating\u2029the success or failure of the operation.\u2029\u2029The ldap_delete() routine is used to perform an LDAP delete operation asynchronously. It takes the same parameters as ldap_delete_s(), but returns the message id of the  request\u2029it initiated. The result of the delete can be obtained by a subsequent call to ldap_result(3).\u2029\u2029The  ldap_delete_ext() routine  allows  server  and client controls to be specified to extend the delete request. This routine is asynchronous like ldap_delete(), but its return\u2029value is an LDAP error code. It stores the message id of the request in the integer pointed to by msgidp.\u2029\u2029The ldap_delete_ext_s() routine is the synchronous version of ldap_delete_ext().  It also returns an LDAP error code indicating success or failure of the operation.\u2029\u2029ERRORS\u2029ldap_delete_s() returns an LDAP error code which can be interpreted by calling one of ldap_perror(3) and friends.  ldap_delete() returns -1 if something  went  wrong  initiating\u2029the request. It returns the non-negative message id of the request if things went ok.\u2029\u2029ldap_delete_ext() and ldap_delete_ext_s() return some Non-zero value if something  went wrong initiating the request, else return 0.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 935, "position": [490358, 492495], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_delete, ldap_delete_s, ldap_delete_ext, ldap_delete_ext_s - Perform an LDAP delete operation.\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_delete_s(ld, dn)\u2029LDAP *ld;\u2029char *dn;\u2029\u2029int ldap_delete(ld, dn)\u2029LDAP *ld;\u2029char *dn;\u2029\u2029int ldap_delete_ext(ld, dn, serverctrls, clientctrls, msgidp)\u2029LDAP *ld;\u2029char *dn;\u2029LDAPControl **serverctrls, **clientctrls;\u2029int *msgidp;\u2029\u2029int ldap_delete_ext_s(ld, dn, serverctrls, clientctrls)\u2029LDAP *ld;\u2029char *dn;\u2029LDAPControl **serverctrls, **clientctrls;\u2029\u2029DESCRIPTION\u2029The ldap_delete_s() routine is used to perform an LDAP delete operation synchronously. It takes dn, the DN of the entry to be deleted.  It returns an LDAP error code, indicating\u2029the success or failure of the operation.\u2029\u2029The ldap_delete() routine is used to perform an LDAP delete operation asynchronously. It takes the same parameters as ldap_delete_s(), but returns the message id of the  request\u2029it initiated. The result of the delete can be obtained by a subsequent call to ldap_result(3).\u2029\u2029The  ldap_delete_ext() routine  allows  server  and client controls to be specified to extend the delete request. This routine is asynchronous like ldap_delete(), but its return\u2029value is an LDAP error code. It stores the message id of the request in the integer pointed to by msgidp.\u2029\u2029The ldap_delete_ext_s() routine is the synchronous version of ldap_delete_ext().  It also returns an LDAP error code indicating success or failure of the operation.\u2029\u2029ERRORS\u2029ldap_delete_s() returns an LDAP error code which can be interpreted by calling one of ldap_perror(3) and friends.  ldap_delete() returns -1 if something  went  wrong  initiating\u2029the request. It returns the non-negative message id of the request if things went ok.\u2029\u2029ldap_delete_ext() and ldap_delete_ext_s() return some Non-zero value if something  went wrong initiating the request, else return 0.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 934, "position": [487848, 489985], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_delete, ldap_delete_s, ldap_delete_ext, ldap_delete_ext_s - Perform an LDAP delete operation.\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_delete_s(ld, dn)\u2029LDAP *ld;\u2029char *dn;\u2029\u2029int ldap_delete(ld, dn)\u2029LDAP *ld;\u2029char *dn;\u2029\u2029int ldap_delete_ext(ld, dn, serverctrls, clientctrls, msgidp)\u2029LDAP *ld;\u2029char *dn;\u2029LDAPControl **serverctrls, **clientctrls;\u2029int *msgidp;\u2029\u2029int ldap_delete_ext_s(ld, dn, serverctrls, clientctrls)\u2029LDAP *ld;\u2029char *dn;\u2029LDAPControl **serverctrls, **clientctrls;\u2029\u2029DESCRIPTION\u2029The ldap_delete_s() routine is used to perform an LDAP delete operation synchronously. It takes dn, the DN of the entry to be deleted.  It returns an LDAP error code, indicating\u2029the success or failure of the operation.\u2029\u2029The ldap_delete() routine is used to perform an LDAP delete operation asynchronously. It takes the same parameters as ldap_delete_s(), but returns the message id of the  request\u2029it initiated. The result of the delete can be obtained by a subsequent call to ldap_result(3).\u2029\u2029The  ldap_delete_ext() routine  allows  server  and client controls to be specified to extend the delete request. This routine is asynchronous like ldap_delete(), but its return\u2029value is an LDAP error code. It stores the message id of the request in the integer pointed to by msgidp.\u2029\u2029The ldap_delete_ext_s() routine is the synchronous version of ldap_delete_ext().  It also returns an LDAP error code indicating success or failure of the operation.\u2029\u2029ERRORS\u2029ldap_delete_s() returns an LDAP error code which can be interpreted by calling one of ldap_perror(3) and friends.  ldap_delete() returns -1 if something  went  wrong  initiating\u2029the request. It returns the non-negative message id of the request if things went ok.\u2029\u2029ldap_delete_ext() and ldap_delete_ext_s() return some Non-zero value if something  went wrong initiating the request, else return 0.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 933, "position": [485338, 487475], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_delete, ldap_delete_s, ldap_delete_ext, ldap_delete_ext_s - Perform an LDAP delete operation.\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_delete_s(ld, dn)\u2029LDAP *ld;\u2029char *dn;\u2029\u2029int ldap_delete(ld, dn)\u2029LDAP *ld;\u2029char *dn;\u2029\u2029int ldap_delete_ext(ld, dn, serverctrls, clientctrls, msgidp)\u2029LDAP *ld;\u2029char *dn;\u2029LDAPControl **serverctrls, **clientctrls;\u2029int *msgidp;\u2029\u2029int ldap_delete_ext_s(ld, dn, serverctrls, clientctrls)\u2029LDAP *ld;\u2029char *dn;\u2029LDAPControl **serverctrls, **clientctrls;\u2029\u2029DESCRIPTION\u2029The ldap_delete_s() routine is used to perform an LDAP delete operation synchronously. It takes dn, the DN of the entry to be deleted.  It returns an LDAP error code, indicating\u2029the success or failure of the operation.\u2029\u2029The ldap_delete() routine is used to perform an LDAP delete operation asynchronously. It takes the same parameters as ldap_delete_s(), but returns the message id of the  request\u2029it initiated. The result of the delete can be obtained by a subsequent call to ldap_result(3).\u2029\u2029The  ldap_delete_ext() routine  allows  server  and client controls to be specified to extend the delete request. This routine is asynchronous like ldap_delete(), but its return\u2029value is an LDAP error code. It stores the message id of the request in the integer pointed to by msgidp.\u2029\u2029The ldap_delete_ext_s() routine is the synchronous version of ldap_delete_ext().  It also returns an LDAP error code indicating success or failure of the operation.\u2029\u2029ERRORS\u2029ldap_delete_s() returns an LDAP error code which can be interpreted by calling one of ldap_perror(3) and friends.  ldap_delete() returns -1 if something  went  wrong  initiating\u2029the request. It returns the non-negative message id of the request if things went ok.\u2029\u2029ldap_delete_ext() and ldap_delete_ext_s() return some Non-zero value if something  went wrong initiating the request, else return 0.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 932, "position": [482828, 484965], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "57", "annotation": "LDAP_OPEN (\u0444\u0443\u043d\u043a\u0446\u0438\u0438, \u043e\u0442\u0432\u0435\u0447\u0430\u044e\u0449\u0438\u0435 \u0437\u0430 \u043f\u0440\u0435\u043a\u0440\u0430\u0449\u0435\u043d\u0438\u0435 \u0441\u0435\u0441\u0441\u0438\u0438)", "group_ids": [{"name2": "NAME\u2029ldap_dup, ldap_destroy, - Duplicate and destroy LDAP session handles\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029LDAP *ldap_dup(\u2029LDAP *old );\u2029\u2029int ldap_destroy(\u2029LDAP *old );\u2029\u2029DESCRIPTION\u2029ldap_dup()  duplicates  an  existing LDAP (LDAP *) session handle.  The new session handle may be used concurrently with the original session handle.  In a threaded environment,\u2029different threads may execute concurrent requests on the same connection/session without fear of contamination.  Each session handle manages its own private error results.\u2029\u2029ldap_destroy() destroys an existing session handle.\u2029\u2029The ldap_dup() and ldap_destroy() functions are used in conjunction with a \"thread safe\" version of libldap (libldap_r) to enable operation thread safe API calls, so that a sin\u2010\u2029gle session may be simultaneously used across multiple threads with consistent error handling.\u2029\u2029When  a session is created through the use of one of the session creation functions including ldap_open(3), ldap_init(3), ldap_initialize(3) or ldap_init_fd(3) an LDAP * session\u2029handle is returned to the application.  The session handle may be shared amongst threads, however the error codes are unique to a session handle.   Multiple  threads  performing\u2029different operations using the same session handle will result in inconsistent error codes and return values.\u2029\u2029To  prevent this confusion, ldap_dup() is used duplicate an existing session handle so that multiple threads can share the session, and maintain consistent error information and\u2029results.\u2029\u2029The message queues for a session are shared between sibling session handles.  Results of operations on a sibling session handles are accessible to all the sibling  session  han\u2010\u2029dles.  Applications desiring results associated with a specific operation should provide the appropriate msgid to ldap_result().  Applications should avoid calling ldap_result()\u2029with LDAP_RES_ANY as that may \"steal\" and return results in the calling thread that another operation in a different thread, using a different session  handle,  may  require  to\u2029complete.\u2029\u2029When ldap_unbind() is called on a session handle with siblings, all the siblings become invalid.\u2029\u2029Siblings  must be destroyed using ldap_destroy().  Session handle resources associated with the original (LDAP *) will be freed when the last session handle is destroyed or when\u2029ldap_unbind() is called, if no other session handles currently exist.\u2029\u2029ERRORS\u2029If an error occurs, ldap_dup() will return NULL and errno should be set appropriately.  ldap_destroy() will directly return the LDAP code associated to the error  (or  LDAP_SUC\u2010\u2029CESS in case of success); errno should be set as well whenever appropriate.\u2029\u2029SEE ALSO\u2029ldap_open(3), ldap_init(3), ldap_initialize(3), ldap_init_fd(3), errno(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029This  work is based on the previously proposed LDAP C API Concurrency Extensions draft (draft-zeilenga-ldap-c-api-concurrency-00.txt) effort.  OpenLDAP Software is developed and\u2029maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 937, "position": [528726, 531876], "check": 1, "intersection": 3151, "FP_dupl": 375, "FN_dupl": 0, "F": 0.9438370525685188, "Prec_Dupl": 0.8936471922858763, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_dup, ldap_destroy, - Duplicate and destroy LDAP session handles\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029LDAP *ldap_dup(\u2029LDAP *old );\u2029\u2029int ldap_destroy(\u2029LDAP *old );\u2029\u2029DESCRIPTION\u2029ldap_dup()  duplicates  an  existing LDAP (LDAP *) session handle.  The new session handle may be used concurrently with the original session handle.  In a threaded environment,\u2029different threads may execute concurrent requests on the same connection/session without fear of contamination.  Each session handle manages its own private error results.\u2029\u2029ldap_destroy() destroys an existing session handle.\u2029\u2029The ldap_dup() and ldap_destroy() functions are used in conjunction with a \"thread safe\" version of libldap (libldap_r) to enable operation thread safe API calls, so that a sin\u2010\u2029gle session may be simultaneously used across multiple threads with consistent error handling.\u2029\u2029When  a session is created through the use of one of the session creation functions including ldap_open(3), ldap_init(3), ldap_initialize(3) or ldap_init_fd(3) an LDAP * session\u2029handle is returned to the application.  The session handle may be shared amongst threads, however the error codes are unique to a session handle.   Multiple  threads  performing\u2029different operations using the same session handle will result in inconsistent error codes and return values.\u2029\u2029To  prevent this confusion, ldap_dup() is used duplicate an existing session handle so that multiple threads can share the session, and maintain consistent error information and\u2029results.\u2029\u2029The message queues for a session are shared between sibling session handles.  Results of operations on a sibling session handles are accessible to all the sibling  session  han\u2010\u2029dles.  Applications desiring results associated with a specific operation should provide the appropriate msgid to ldap_result().  Applications should avoid calling ldap_result()\u2029with LDAP_RES_ANY as that may \"steal\" and return results in the calling thread that another operation in a different thread, using a different session  handle,  may  require  to\u2029complete.\u2029\u2029When ldap_unbind() is called on a session handle with siblings, all the siblings become invalid.\u2029\u2029Siblings  must be destroyed using ldap_destroy().  Session handle resources associated with the original (LDAP *) will be freed when the last session handle is destroyed or when\u2029ldap_unbind() is called, if no other session handles currently exist.\u2029\u2029ERRORS\u2029If an error occurs, ldap_dup() will return NULL and errno should be set appropriately.  ldap_destroy() will directly return the LDAP code associated to the error  (or  LDAP_SUC\u2010\u2029CESS in case of success); errno should be set as well whenever appropriate.\u2029\u2029SEE ALSO\u2029ldap_open(3), ldap_init(3), ldap_initialize(3), ldap_init_fd(3), errno(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029This  work is based on the previously proposed LDAP C API Concurrency Extensions draft (draft-zeilenga-ldap-c-api-concurrency-00.txt) effort.  OpenLDAP Software is developed and\u2029maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 936, "position": [492868, 496018], "check": 1, "intersection": 3151, "FP_dupl": 375, "FN_dupl": 0, "F": 0.9438370525685188, "Prec_Dupl": 0.8936471922858763, "Recall_Dupl": 1.0}]}, {"name": "58", "annotation": "LDAP_OPEN (\u0444\u0443\u043d\u043a\u0446\u0438\u0438, \u043e\u0442\u0432\u0435\u0447\u0430\u044e\u0449\u0438\u0435 \u0437\u0430 \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044e \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 LDAP \u0438 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0443 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u044f \u0441 \u0441\u0435\u0440\u0432\u0435\u0440\u043e\u043c)", "group_ids": [{"name2": "NAME\u2029ldap_init, ldap_initialize, ldap_open - Initialize the LDAP library and open a connection to an LDAP server\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029LDAP *ldap_open(host, port)\u2029char *host;\u2029int port;\u2029\u2029LDAP *ldap_init(host, port)\u2029char *host;\u2029int port;\u2029\u2029int ldap_initialize(ldp, uri)\u2029LDAP **ldp;\u2029char *uri;\u2029\u2029int ldap_set_urllist_proc(ld, proc, params)\u2029LDAP *ld;\u2029LDAP_URLLIST_PROC *proc;\u2029void *params;\u2029\u2029int (LDAP_URLLIST_PROC)(ld, urllist, url, params);\u2029LDAP *ld;\u2029LDAPURLDesc **urllist;\u2029LDAPURLDesc **url;\u2029void *params;\u2029\u2029#include &amp;lt;ldap_pvt.h&amp;gt;\u2029\u2029int ldap_init_fd(fd, proto, uri, ldp)\u2029ber_socket_t fd;\u2029int proto;\u2029char *uri;\u2029LDAP **ldp;\u2029\u2029DESCRIPTION\u2029ldap_open()  opens  a  connection  to  an  LDAP  server  and  allocates  an  LDAP  structure which is used to identify the connection and to maintain per-connection information.\u2029ldap_init() allocates an LDAP structure but does not open an initial connection.  ldap_initialize() allocates an  LDAP  structure  but  does  not  open  an  initial  connection.\u2029ldap_init_fd() allocates an LDAP structure using an existing connection on the provided socket.  One of these routines must be called before any operations are attempted.\u2029\u2029ldap_open()  takes  host,  the hostname on which the LDAP server is running, and port, the port number to which to connect.  If the default IANA-assigned port of 389 is desired,\u2029LDAP_PORT should be specified for port.  The host parameter may contain a blank-separated list of hosts to try to connect to, and  each  host  may  optionally  by  of  the  form\u2029host:port.   If  present,  the  :port  overrides the port parameter to ldap_open().  Upon successfully making a connection to an LDAP server, ldap_open() returns a pointer to an\u2029opaque LDAP structure, which should be passed to subsequent calls to ldap_bind(), ldap_search(), etc. Certain fields in the LDAP structure can be set  to  indicate  size  limit,\u2029time  limit,  and  how aliases are handled during operations; read and write access to those fields must occur by calling ldap_get_option(3) and ldap_set_option(3) respectively,\u2029whenever possible.\u2029\u2029ldap_init() acts just like ldap_open(), but does not open a connection to the LDAP server.  The actual connection open will occur when the first operation is attempted.\u2029\u2029ldap_initialize() acts like ldap_init(), but it returns an integer indicating either success or the failure reason, and it allows to specify details for the  connection  in  the\u2029schema  portion  of the URI.  The uri parameter may be a comma- or whitespace-separated list of URIs containing only the schema, the host, and the port fields.  Apart from ldap,\u2029other (non-standard) recognized values of the schema field are ldaps (LDAP over TLS), ldapi (LDAP over IPC), and cldap (connectionless LDAP).  If other fields are  present,  the\u2029behavior is undefined.\u2029\u2029At  this  time,  ldap_open() and ldap_init() are deprecated in favor of ldap_initialize(), essentially because the latter allows to specify a schema in the URI and it explicitly\u2029returns an error code.\u2029\u2029ldap_init_fd() allows an LDAP structure to be initialized using an  already-opened  connection.  The  proto  parameter  should  be  one  of  LDAP_PROTO_TCP,  LDAP_PROTO_UDP,  or\u2029LDAP_PROTO_IPC for a connection using TCP, UDP, or IPC, respectively. The value LDAP_PROTO_EXT may also be specified if user-supplied sockbuf handlers are going to be used. Note\u2029that support for UDP is not implemented unless libldap was built with LDAP_CONNECTIONLESS defined.  The uri parameter may optionally be provided for informational purposes.\u2029\u2029ldap_set_urllist_proc() allows to set a function proc of type LDAP_URLLIST_PROC that is called when a successful connection can be established.  This function receives the  list\u2029of  URIs  parsed  from the uri string originally passed to ldap_initialize(), and the one that successfully connected.  The function may manipulate the URI list; the typical use\u2029consists in moving the successful URI to the head of the list, so that subsequent attempts to connect to one of the URIs using the same LDAP handle will try it first.  If ld  is\u2029null,  proc  is  set  as  a  global  parameter  that  is inherited by all handlers within the process that are created after the call to ldap_set_urllist_proc().  By default, no\u2029LDAP_URLLIST_PROC is set.  In a multithreaded environment, ldap_set_urllist_proc() must be called before any concurrent operation using the LDAP handle is started.\u2029\u2029Note: the first call into the LDAP library also initializes the global options for the library. As such the first call should be single-threaded or otherwise protected to insure\u2029that  only one call is active. It is recommended that ldap_get_option() or ldap_set_option() be used in the program's main thread before any additional threads are created.  See\u2029ldap_get_option(3).\u2029\u2029ERRORS\u2029If an error occurs, ldap_open() and ldap_init() will return NULL and errno should be set appropriately.  ldap_initialize() and ldap_init_fd() will directly return the LDAP  code\u2029associated  to  the  error  (or LDAP_SUCCESS in case of success); errno should be set as well whenever appropriate.  ldap_set_urllist_proc() returns LDAP_OPT_ERROR on error, and\u2029LDAP_OPT_SUCCESS on success.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_bind(3), ldap_get_option(3), ldap_set_option(3), lber-sockbuf(3), errno(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 942, "position": [889065, 894617], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_init, ldap_initialize, ldap_open - Initialize the LDAP library and open a connection to an LDAP server\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029LDAP *ldap_open(host, port)\u2029char *host;\u2029int port;\u2029\u2029LDAP *ldap_init(host, port)\u2029char *host;\u2029int port;\u2029\u2029int ldap_initialize(ldp, uri)\u2029LDAP **ldp;\u2029char *uri;\u2029\u2029int ldap_set_urllist_proc(ld, proc, params)\u2029LDAP *ld;\u2029LDAP_URLLIST_PROC *proc;\u2029void *params;\u2029\u2029int (LDAP_URLLIST_PROC)(ld, urllist, url, params);\u2029LDAP *ld;\u2029LDAPURLDesc **urllist;\u2029LDAPURLDesc **url;\u2029void *params;\u2029\u2029#include &amp;lt;ldap_pvt.h&amp;gt;\u2029\u2029int ldap_init_fd(fd, proto, uri, ldp)\u2029ber_socket_t fd;\u2029int proto;\u2029char *uri;\u2029LDAP **ldp;\u2029\u2029DESCRIPTION\u2029ldap_open()  opens  a  connection  to  an  LDAP  server  and  allocates  an  LDAP  structure which is used to identify the connection and to maintain per-connection information.\u2029ldap_init() allocates an LDAP structure but does not open an initial connection.  ldap_initialize() allocates an  LDAP  structure  but  does  not  open  an  initial  connection.\u2029ldap_init_fd() allocates an LDAP structure using an existing connection on the provided socket.  One of these routines must be called before any operations are attempted.\u2029\u2029ldap_open()  takes  host,  the hostname on which the LDAP server is running, and port, the port number to which to connect.  If the default IANA-assigned port of 389 is desired,\u2029LDAP_PORT should be specified for port.  The host parameter may contain a blank-separated list of hosts to try to connect to, and  each  host  may  optionally  by  of  the  form\u2029host:port.   If  present,  the  :port  overrides the port parameter to ldap_open().  Upon successfully making a connection to an LDAP server, ldap_open() returns a pointer to an\u2029opaque LDAP structure, which should be passed to subsequent calls to ldap_bind(), ldap_search(), etc. Certain fields in the LDAP structure can be set  to  indicate  size  limit,\u2029time  limit,  and  how aliases are handled during operations; read and write access to those fields must occur by calling ldap_get_option(3) and ldap_set_option(3) respectively,\u2029whenever possible.\u2029\u2029ldap_init() acts just like ldap_open(), but does not open a connection to the LDAP server.  The actual connection open will occur when the first operation is attempted.\u2029\u2029ldap_initialize() acts like ldap_init(), but it returns an integer indicating either success or the failure reason, and it allows to specify details for the  connection  in  the\u2029schema  portion  of the URI.  The uri parameter may be a comma- or whitespace-separated list of URIs containing only the schema, the host, and the port fields.  Apart from ldap,\u2029other (non-standard) recognized values of the schema field are ldaps (LDAP over TLS), ldapi (LDAP over IPC), and cldap (connectionless LDAP).  If other fields are  present,  the\u2029behavior is undefined.\u2029\u2029At  this  time,  ldap_open() and ldap_init() are deprecated in favor of ldap_initialize(), essentially because the latter allows to specify a schema in the URI and it explicitly\u2029returns an error code.\u2029\u2029ldap_init_fd() allows an LDAP structure to be initialized using an  already-opened  connection.  The  proto  parameter  should  be  one  of  LDAP_PROTO_TCP,  LDAP_PROTO_UDP,  or\u2029LDAP_PROTO_IPC for a connection using TCP, UDP, or IPC, respectively. The value LDAP_PROTO_EXT may also be specified if user-supplied sockbuf handlers are going to be used. Note\u2029that support for UDP is not implemented unless libldap was built with LDAP_CONNECTIONLESS defined.  The uri parameter may optionally be provided for informational purposes.\u2029\u2029ldap_set_urllist_proc() allows to set a function proc of type LDAP_URLLIST_PROC that is called when a successful connection can be established.  This function receives the  list\u2029of  URIs  parsed  from the uri string originally passed to ldap_initialize(), and the one that successfully connected.  The function may manipulate the URI list; the typical use\u2029consists in moving the successful URI to the head of the list, so that subsequent attempts to connect to one of the URIs using the same LDAP handle will try it first.  If ld  is\u2029null,  proc  is  set  as  a  global  parameter  that  is inherited by all handlers within the process that are created after the call to ldap_set_urllist_proc().  By default, no\u2029LDAP_URLLIST_PROC is set.  In a multithreaded environment, ldap_set_urllist_proc() must be called before any concurrent operation using the LDAP handle is started.\u2029\u2029Note: the first call into the LDAP library also initializes the global options for the library. As such the first call should be single-threaded or otherwise protected to insure\u2029that  only one call is active. It is recommended that ldap_get_option() or ldap_set_option() be used in the program's main thread before any additional threads are created.  See\u2029ldap_get_option(3).\u2029\u2029ERRORS\u2029If an error occurs, ldap_open() and ldap_init() will return NULL and errno should be set appropriately.  ldap_initialize() and ldap_init_fd() will directly return the LDAP  code\u2029associated  to  the  error  (or LDAP_SUCCESS in case of success); errno should be set as well whenever appropriate.  ldap_set_urllist_proc() returns LDAP_OPT_ERROR on error, and\u2029LDAP_OPT_SUCCESS on success.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_bind(3), ldap_get_option(3), ldap_set_option(3), lber-sockbuf(3), errno(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 941, "position": [748767, 754319], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_init, ldap_initialize, ldap_open - Initialize the LDAP library and open a connection to an LDAP server\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029LDAP *ldap_open(host, port)\u2029char *host;\u2029int port;\u2029\u2029LDAP *ldap_init(host, port)\u2029char *host;\u2029int port;\u2029\u2029int ldap_initialize(ldp, uri)\u2029LDAP **ldp;\u2029char *uri;\u2029\u2029int ldap_set_urllist_proc(ld, proc, params)\u2029LDAP *ld;\u2029LDAP_URLLIST_PROC *proc;\u2029void *params;\u2029\u2029int (LDAP_URLLIST_PROC)(ld, urllist, url, params);\u2029LDAP *ld;\u2029LDAPURLDesc **urllist;\u2029LDAPURLDesc **url;\u2029void *params;\u2029\u2029#include &amp;lt;ldap_pvt.h&amp;gt;\u2029\u2029int ldap_init_fd(fd, proto, uri, ldp)\u2029ber_socket_t fd;\u2029int proto;\u2029char *uri;\u2029LDAP **ldp;\u2029\u2029DESCRIPTION\u2029ldap_open()  opens  a  connection  to  an  LDAP  server  and  allocates  an  LDAP  structure which is used to identify the connection and to maintain per-connection information.\u2029ldap_init() allocates an LDAP structure but does not open an initial connection.  ldap_initialize() allocates an  LDAP  structure  but  does  not  open  an  initial  connection.\u2029ldap_init_fd() allocates an LDAP structure using an existing connection on the provided socket.  One of these routines must be called before any operations are attempted.\u2029\u2029ldap_open()  takes  host,  the hostname on which the LDAP server is running, and port, the port number to which to connect.  If the default IANA-assigned port of 389 is desired,\u2029LDAP_PORT should be specified for port.  The host parameter may contain a blank-separated list of hosts to try to connect to, and  each  host  may  optionally  by  of  the  form\u2029host:port.   If  present,  the  :port  overrides the port parameter to ldap_open().  Upon successfully making a connection to an LDAP server, ldap_open() returns a pointer to an\u2029opaque LDAP structure, which should be passed to subsequent calls to ldap_bind(), ldap_search(), etc. Certain fields in the LDAP structure can be set  to  indicate  size  limit,\u2029time  limit,  and  how aliases are handled during operations; read and write access to those fields must occur by calling ldap_get_option(3) and ldap_set_option(3) respectively,\u2029whenever possible.\u2029\u2029ldap_init() acts just like ldap_open(), but does not open a connection to the LDAP server.  The actual connection open will occur when the first operation is attempted.\u2029\u2029ldap_initialize() acts like ldap_init(), but it returns an integer indicating either success or the failure reason, and it allows to specify details for the  connection  in  the\u2029schema  portion  of the URI.  The uri parameter may be a comma- or whitespace-separated list of URIs containing only the schema, the host, and the port fields.  Apart from ldap,\u2029other (non-standard) recognized values of the schema field are ldaps (LDAP over TLS), ldapi (LDAP over IPC), and cldap (connectionless LDAP).  If other fields are  present,  the\u2029behavior is undefined.\u2029\u2029At  this  time,  ldap_open() and ldap_init() are deprecated in favor of ldap_initialize(), essentially because the latter allows to specify a schema in the URI and it explicitly\u2029returns an error code.\u2029\u2029ldap_init_fd() allows an LDAP structure to be initialized using an  already-opened  connection.  The  proto  parameter  should  be  one  of  LDAP_PROTO_TCP,  LDAP_PROTO_UDP,  or\u2029LDAP_PROTO_IPC for a connection using TCP, UDP, or IPC, respectively. The value LDAP_PROTO_EXT may also be specified if user-supplied sockbuf handlers are going to be used. Note\u2029that support for UDP is not implemented unless libldap was built with LDAP_CONNECTIONLESS defined.  The uri parameter may optionally be provided for informational purposes.\u2029\u2029ldap_set_urllist_proc() allows to set a function proc of type LDAP_URLLIST_PROC that is called when a successful connection can be established.  This function receives the  list\u2029of  URIs  parsed  from the uri string originally passed to ldap_initialize(), and the one that successfully connected.  The function may manipulate the URI list; the typical use\u2029consists in moving the successful URI to the head of the list, so that subsequent attempts to connect to one of the URIs using the same LDAP handle will try it first.  If ld  is\u2029null,  proc  is  set  as  a  global  parameter  that  is inherited by all handlers within the process that are created after the call to ldap_set_urllist_proc().  By default, no\u2029LDAP_URLLIST_PROC is set.  In a multithreaded environment, ldap_set_urllist_proc() must be called before any concurrent operation using the LDAP handle is started.\u2029\u2029Note: the first call into the LDAP library also initializes the global options for the library. As such the first call should be single-threaded or otherwise protected to insure\u2029that  only one call is active. It is recommended that ldap_get_option() or ldap_set_option() be used in the program's main thread before any additional threads are created.  See\u2029ldap_get_option(3).\u2029\u2029ERRORS\u2029If an error occurs, ldap_open() and ldap_init() will return NULL and errno should be set appropriately.  ldap_initialize() and ldap_init_fd() will directly return the LDAP  code\u2029associated  to  the  error  (or LDAP_SUCCESS in case of success); errno should be set as well whenever appropriate.  ldap_set_urllist_proc() returns LDAP_OPT_ERROR on error, and\u2029LDAP_OPT_SUCCESS on success.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_bind(3), ldap_get_option(3), ldap_set_option(3), lber-sockbuf(3), errno(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 940, "position": [623059, 628611], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_init, ldap_initialize, ldap_open - Initialize the LDAP library and open a connection to an LDAP server\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029LDAP *ldap_open(host, port)\u2029char *host;\u2029int port;\u2029\u2029LDAP *ldap_init(host, port)\u2029char *host;\u2029int port;\u2029\u2029int ldap_initialize(ldp, uri)\u2029LDAP **ldp;\u2029char *uri;\u2029\u2029int ldap_set_urllist_proc(ld, proc, params)\u2029LDAP *ld;\u2029LDAP_URLLIST_PROC *proc;\u2029void *params;\u2029\u2029int (LDAP_URLLIST_PROC)(ld, urllist, url, params);\u2029LDAP *ld;\u2029LDAPURLDesc **urllist;\u2029LDAPURLDesc **url;\u2029void *params;\u2029\u2029#include &amp;lt;ldap_pvt.h&amp;gt;\u2029\u2029int ldap_init_fd(fd, proto, uri, ldp)\u2029ber_socket_t fd;\u2029int proto;\u2029char *uri;\u2029LDAP **ldp;\u2029\u2029DESCRIPTION\u2029ldap_open()  opens  a  connection  to  an  LDAP  server  and  allocates  an  LDAP  structure which is used to identify the connection and to maintain per-connection information.\u2029ldap_init() allocates an LDAP structure but does not open an initial connection.  ldap_initialize() allocates an  LDAP  structure  but  does  not  open  an  initial  connection.\u2029ldap_init_fd() allocates an LDAP structure using an existing connection on the provided socket.  One of these routines must be called before any operations are attempted.\u2029\u2029ldap_open()  takes  host,  the hostname on which the LDAP server is running, and port, the port number to which to connect.  If the default IANA-assigned port of 389 is desired,\u2029LDAP_PORT should be specified for port.  The host parameter may contain a blank-separated list of hosts to try to connect to, and  each  host  may  optionally  by  of  the  form\u2029host:port.   If  present,  the  :port  overrides the port parameter to ldap_open().  Upon successfully making a connection to an LDAP server, ldap_open() returns a pointer to an\u2029opaque LDAP structure, which should be passed to subsequent calls to ldap_bind(), ldap_search(), etc. Certain fields in the LDAP structure can be set  to  indicate  size  limit,\u2029time  limit,  and  how aliases are handled during operations; read and write access to those fields must occur by calling ldap_get_option(3) and ldap_set_option(3) respectively,\u2029whenever possible.\u2029\u2029ldap_init() acts just like ldap_open(), but does not open a connection to the LDAP server.  The actual connection open will occur when the first operation is attempted.\u2029\u2029ldap_initialize() acts like ldap_init(), but it returns an integer indicating either success or the failure reason, and it allows to specify details for the  connection  in  the\u2029schema  portion  of the URI.  The uri parameter may be a comma- or whitespace-separated list of URIs containing only the schema, the host, and the port fields.  Apart from ldap,\u2029other (non-standard) recognized values of the schema field are ldaps (LDAP over TLS), ldapi (LDAP over IPC), and cldap (connectionless LDAP).  If other fields are  present,  the\u2029behavior is undefined.\u2029\u2029At  this  time,  ldap_open() and ldap_init() are deprecated in favor of ldap_initialize(), essentially because the latter allows to specify a schema in the URI and it explicitly\u2029returns an error code.\u2029\u2029ldap_init_fd() allows an LDAP structure to be initialized using an  already-opened  connection.  The  proto  parameter  should  be  one  of  LDAP_PROTO_TCP,  LDAP_PROTO_UDP,  or\u2029LDAP_PROTO_IPC for a connection using TCP, UDP, or IPC, respectively. The value LDAP_PROTO_EXT may also be specified if user-supplied sockbuf handlers are going to be used. Note\u2029that support for UDP is not implemented unless libldap was built with LDAP_CONNECTIONLESS defined.  The uri parameter may optionally be provided for informational purposes.\u2029\u2029ldap_set_urllist_proc() allows to set a function proc of type LDAP_URLLIST_PROC that is called when a successful connection can be established.  This function receives the  list\u2029of  URIs  parsed  from the uri string originally passed to ldap_initialize(), and the one that successfully connected.  The function may manipulate the URI list; the typical use\u2029consists in moving the successful URI to the head of the list, so that subsequent attempts to connect to one of the URIs using the same LDAP handle will try it first.  If ld  is\u2029null,  proc  is  set  as  a  global  parameter  that  is inherited by all handlers within the process that are created after the call to ldap_set_urllist_proc().  By default, no\u2029LDAP_URLLIST_PROC is set.  In a multithreaded environment, ldap_set_urllist_proc() must be called before any concurrent operation using the LDAP handle is started.\u2029\u2029Note: the first call into the LDAP library also initializes the global options for the library. As such the first call should be single-threaded or otherwise protected to insure\u2029that  only one call is active. It is recommended that ldap_get_option() or ldap_set_option() be used in the program's main thread before any additional threads are created.  See\u2029ldap_get_option(3).\u2029\u2029ERRORS\u2029If an error occurs, ldap_open() and ldap_init() will return NULL and errno should be set appropriately.  ldap_initialize() and ldap_init_fd() will directly return the LDAP  code\u2029associated  to  the  error  (or LDAP_SUCCESS in case of success); errno should be set as well whenever appropriate.  ldap_set_urllist_proc() returns LDAP_OPT_ERROR on error, and\u2029LDAP_OPT_SUCCESS on success.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_bind(3), ldap_get_option(3), ldap_set_option(3), lber-sockbuf(3), errno(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 939, "position": [617134, 622686], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_init, ldap_initialize, ldap_open - Initialize the LDAP library and open a connection to an LDAP server\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029LDAP *ldap_open(host, port)\u2029char *host;\u2029int port;\u2029\u2029LDAP *ldap_init(host, port)\u2029char *host;\u2029int port;\u2029\u2029int ldap_initialize(ldp, uri)\u2029LDAP **ldp;\u2029char *uri;\u2029\u2029int ldap_set_urllist_proc(ld, proc, params)\u2029LDAP *ld;\u2029LDAP_URLLIST_PROC *proc;\u2029void *params;\u2029\u2029int (LDAP_URLLIST_PROC)(ld, urllist, url, params);\u2029LDAP *ld;\u2029LDAPURLDesc **urllist;\u2029LDAPURLDesc **url;\u2029void *params;\u2029\u2029#include &amp;lt;ldap_pvt.h&amp;gt;\u2029\u2029int ldap_init_fd(fd, proto, uri, ldp)\u2029ber_socket_t fd;\u2029int proto;\u2029char *uri;\u2029LDAP **ldp;\u2029\u2029DESCRIPTION\u2029ldap_open()  opens  a  connection  to  an  LDAP  server  and  allocates  an  LDAP  structure which is used to identify the connection and to maintain per-connection information.\u2029ldap_init() allocates an LDAP structure but does not open an initial connection.  ldap_initialize() allocates an  LDAP  structure  but  does  not  open  an  initial  connection.\u2029ldap_init_fd() allocates an LDAP structure using an existing connection on the provided socket.  One of these routines must be called before any operations are attempted.\u2029\u2029ldap_open()  takes  host,  the hostname on which the LDAP server is running, and port, the port number to which to connect.  If the default IANA-assigned port of 389 is desired,\u2029LDAP_PORT should be specified for port.  The host parameter may contain a blank-separated list of hosts to try to connect to, and  each  host  may  optionally  by  of  the  form\u2029host:port.   If  present,  the  :port  overrides the port parameter to ldap_open().  Upon successfully making a connection to an LDAP server, ldap_open() returns a pointer to an\u2029opaque LDAP structure, which should be passed to subsequent calls to ldap_bind(), ldap_search(), etc. Certain fields in the LDAP structure can be set  to  indicate  size  limit,\u2029time  limit,  and  how aliases are handled during operations; read and write access to those fields must occur by calling ldap_get_option(3) and ldap_set_option(3) respectively,\u2029whenever possible.\u2029\u2029ldap_init() acts just like ldap_open(), but does not open a connection to the LDAP server.  The actual connection open will occur when the first operation is attempted.\u2029\u2029ldap_initialize() acts like ldap_init(), but it returns an integer indicating either success or the failure reason, and it allows to specify details for the  connection  in  the\u2029schema  portion  of the URI.  The uri parameter may be a comma- or whitespace-separated list of URIs containing only the schema, the host, and the port fields.  Apart from ldap,\u2029other (non-standard) recognized values of the schema field are ldaps (LDAP over TLS), ldapi (LDAP over IPC), and cldap (connectionless LDAP).  If other fields are  present,  the\u2029behavior is undefined.\u2029\u2029At  this  time,  ldap_open() and ldap_init() are deprecated in favor of ldap_initialize(), essentially because the latter allows to specify a schema in the URI and it explicitly\u2029returns an error code.\u2029\u2029ldap_init_fd() allows an LDAP structure to be initialized using an  already-opened  connection.  The  proto  parameter  should  be  one  of  LDAP_PROTO_TCP,  LDAP_PROTO_UDP,  or\u2029LDAP_PROTO_IPC for a connection using TCP, UDP, or IPC, respectively. The value LDAP_PROTO_EXT may also be specified if user-supplied sockbuf handlers are going to be used. Note\u2029that support for UDP is not implemented unless libldap was built with LDAP_CONNECTIONLESS defined.  The uri parameter may optionally be provided for informational purposes.\u2029\u2029ldap_set_urllist_proc() allows to set a function proc of type LDAP_URLLIST_PROC that is called when a successful connection can be established.  This function receives the  list\u2029of  URIs  parsed  from the uri string originally passed to ldap_initialize(), and the one that successfully connected.  The function may manipulate the URI list; the typical use\u2029consists in moving the successful URI to the head of the list, so that subsequent attempts to connect to one of the URIs using the same LDAP handle will try it first.  If ld  is\u2029null,  proc  is  set  as  a  global  parameter  that  is inherited by all handlers within the process that are created after the call to ldap_set_urllist_proc().  By default, no\u2029LDAP_URLLIST_PROC is set.  In a multithreaded environment, ldap_set_urllist_proc() must be called before any concurrent operation using the LDAP handle is started.\u2029\u2029Note: the first call into the LDAP library also initializes the global options for the library. As such the first call should be single-threaded or otherwise protected to insure\u2029that  only one call is active. It is recommended that ldap_get_option() or ldap_set_option() be used in the program's main thread before any additional threads are created.  See\u2029ldap_get_option(3).\u2029\u2029ERRORS\u2029If an error occurs, ldap_open() and ldap_init() will return NULL and errno should be set appropriately.  ldap_initialize() and ldap_init_fd() will directly return the LDAP  code\u2029associated  to  the  error  (or LDAP_SUCCESS in case of success); errno should be set as well whenever appropriate.  ldap_set_urllist_proc() returns LDAP_OPT_ERROR on error, and\u2029LDAP_OPT_SUCCESS on success.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_bind(3), ldap_get_option(3), ldap_set_option(3), lber-sockbuf(3), errno(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 938, "position": [611209, 616761], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "59", "annotation": "LDAP_ERROR", "group_ids": [{"name2": "NAME\u2029ldap_perror, ld_errno, ldap_result2error, ldap_errlist, ldap_err2string - LDAP protocol error handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029char *ldap_err2string( int err );\u2029\u2029DESCRIPTION\u2029The  ldap_err2string()  routine  provides  short  description  of the various codes returned by routines in this library.  The returned string is a pointer to a static area that\u2029should not be modified.\u2029\u2029These codes are either negative, indicating an API error code; positive, indicating an LDAP resultCode other than 'success' (0), or - zero, indicating both successful use of the\u2029API and the LDAP resultCode 'success' (0).\u2029\u2029The   code  associated  with  an  LDAP  session  is  accessible  using  ldap_get_option(3)  and  ldap_set_option(3)  with  the  LDAP_OPT_RESULT_CODE  option  (previously  called\u2029LDAP_OPT_ERROR_NUMBER).\u2029\u2029PROTOCOL RESULT CODES\u2029This section provides a partial list of protocol codes recognized by the library.  As LDAP is extensible, additional values may be returned.  A complete  listing  of  registered\u2029LDAP result codes can be obtained from the Internet Assigned Numbers Authority &amp;lt;http://www.iana.org&amp;gt;.\u2029\u2029LDAP_SUCCESS        The request was successful.\u2029\u2029LDAP_OPERATIONS_ERROR\u2029An operations error occurred.\u2029\u2029LDAP_PROTOCOL_ERROR A protocol violation was detected.\u2029\u2029LDAP_TIMELIMIT_EXCEEDED\u2029An LDAP time limit was exceeded.\u2029\u2029LDAP_SIZELIMIT_EXCEEDED\u2029An LDAP size limit was exceeded.\u2029\u2029LDAP_COMPARE_FALSE  A compare operation returned false.\u2029\u2029LDAP_COMPARE_TRUE   A compare operation returned true.\u2029\u2029LDAP_STRONG_AUTH_NOT_SUPPORTED\u2029The LDAP server does not support strong authentication.\u2029\u2029LDAP_STRONG_AUTH_REQUIRED\u2029Strong authentication is required for the operation.\u2029\u2029LDAP_PARTIAL_RESULTS\u2029Partial results only returned.\u2029\u2029LDAP_NO_SUCH_ATTRIBUTE\u2029The attribute type specified does not exist in the entry.\u2029\u2029LDAP_UNDEFINED_TYPE The attribute type specified is invalid.\u2029\u2029LDAP_INAPPROPRIATE_MATCHING\u2029Filter type not supported for the specified attribute.\u2029\u2029LDAP_CONSTRAINT_VIOLATION\u2029An attribute value specified violates some constraint (e.g., a postalAddress has too many lines, or a line that is too long).\u2029\u2029LDAP_TYPE_OR_VALUE_EXISTS\u2029An attribute type or attribute value specified already exists in the entry.\u2029\u2029LDAP_INVALID_SYNTAX An invalid attribute value was specified.\u2029\u2029LDAP_NO_SUCH_OBJECT The specified object does not exist in The Directory.\u2029\u2029LDAP_ALIAS_PROBLEM  An alias in The Directory points to a nonexistent entry.\u2029\u2029LDAP_INVALID_DN_SYNTAX\u2029A syntactically invalid DN was specified.\u2029\u2029LDAP_IS_LEAF        The object specified is a leaf.\u2029\u2029LDAP_ALIAS_DEREF_PROBLEM\u2029A problem was encountered when dereferencing an alias.\u2029\u2029LDAP_INAPPROPRIATE_AUTH\u2029Inappropriate authentication was specified (e.g., LDAP_AUTH_SIMPLE was specified and the entry does not have a userPassword attribute).\u2029\u2029LDAP_INVALID_CREDENTIALS\u2029Invalid credentials were presented (e.g., the wrong password).\u2029\u2029LDAP_INSUFFICIENT_ACCESS\u2029The user has insufficient access to perform the operation.\u2029\u2029LDAP_BUSY           The DSA is busy.\u2029\u2029LDAP_UNAVAILABLE    The DSA is unavailable.\u2029\u2029LDAP_UNWILLING_TO_PERFORM\u2029The DSA is unwilling to perform the operation.\u2029\u2029LDAP_LOOP_DETECT    A loop was detected.\u2029\u2029LDAP_NAMING_VIOLATION\u2029A naming violation occurred.\u2029\u2029LDAP_OBJECT_CLASS_VIOLATION\u2029An object class violation occurred (e.g., a \"must\" attribute was missing from the entry).\u2029\u2029LDAP_NOT_ALLOWED_ON_NONLEAF\u2029The operation is not allowed on a nonleaf object.\u2029\u2029LDAP_NOT_ALLOWED_ON_RDN\u2029The operation is not allowed on an RDN.\u2029\u2029LDAP_ALREADY_EXISTS The entry already exists.\u2029\u2029LDAP_NO_OBJECT_CLASS_MODS\u2029Object class modifications are not allowed.\u2029\u2029LDAP_OTHER          An unknown error occurred.\u2029\u2029API ERROR CODES\u2029This  section  provides  a  complete list of API error codes recognized by the library.   Note that LDAP_SUCCESS indicates success of an API call in addition to representing the\u2029return of the LDAP 'success' resultCode.\u2029\u2029LDAP_SERVER_DOWN    The LDAP library can't contact the LDAP server.\u2029\u2029LDAP_LOCAL_ERROR    Some local error occurred.  This is usually a failed dynamic memory allocation.\u2029\u2029LDAP_ENCODING_ERROR An error was encountered encoding parameters to send to the LDAP server.\u2029\u2029LDAP_DECODING_ERROR An error was encountered decoding a result from the LDAP server.\u2029\u2029LDAP_TIMEOUT        A timelimit was exceeded while waiting for a result.\u2029\u2029LDAP_AUTH_UNKNOWN   The authentication method specified to ldap_bind() is not known.\u2029\u2029LDAP_FILTER_ERROR   An invalid filter was supplied to ldap_search() (e.g., unbalanced parentheses).\u2029\u2029LDAP_PARAM_ERROR    An ldap routine was called with a bad parameter.\u2029\u2029LDAP_NO_MEMORY      An memory allocation (e.g., malloc(3) or other dynamic memory allocator) call failed in an ldap library routine.\u2029\u2029LDAP_USER_CANCELED  Indicates the user cancelled the operation.\u2029\u2029LDAP_CONNECT_ERROR  Indicates a connection problem.\u2029\u2029LDAP_NOT_SUPPORTED  Indicates the routine was called in a manner not supported by the library.\u2029\u2029LDAP_CONTROL_NOT_FOUND\u2029Indicates the control provided is unknown to the client library.\u2029\u2029LDAP_NO_RESULTS_RETURNED\u2029Indicates no results returned.\u2029\u2029LDAP_MORE_RESULTS_TO_RETURN\u2029Indicates more results could be returned.\u2029\u2029LDAP_CLIENT_LOOP    Indicates the library has detected a loop in its processing.\u2029\u2029LDAP_REFERRAL_LIMIT_EXCEEDED\u2029Indicates the referral limit has been exceeded.\u2029\u2029DEPRECATED\u2029Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3),\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 948, "position": [789008, 795047], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_perror, ld_errno, ldap_result2error, ldap_errlist, ldap_err2string - LDAP protocol error handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029char *ldap_err2string( int err );\u2029\u2029DESCRIPTION\u2029The  ldap_err2string()  routine  provides  short  description  of the various codes returned by routines in this library.  The returned string is a pointer to a static area that\u2029should not be modified.\u2029\u2029These codes are either negative, indicating an API error code; positive, indicating an LDAP resultCode other than 'success' (0), or - zero, indicating both successful use of the\u2029API and the LDAP resultCode 'success' (0).\u2029\u2029The   code  associated  with  an  LDAP  session  is  accessible  using  ldap_get_option(3)  and  ldap_set_option(3)  with  the  LDAP_OPT_RESULT_CODE  option  (previously  called\u2029LDAP_OPT_ERROR_NUMBER).\u2029\u2029PROTOCOL RESULT CODES\u2029This section provides a partial list of protocol codes recognized by the library.  As LDAP is extensible, additional values may be returned.  A complete  listing  of  registered\u2029LDAP result codes can be obtained from the Internet Assigned Numbers Authority &amp;lt;http://www.iana.org&amp;gt;.\u2029\u2029LDAP_SUCCESS        The request was successful.\u2029\u2029LDAP_OPERATIONS_ERROR\u2029An operations error occurred.\u2029\u2029LDAP_PROTOCOL_ERROR A protocol violation was detected.\u2029\u2029LDAP_TIMELIMIT_EXCEEDED\u2029An LDAP time limit was exceeded.\u2029\u2029LDAP_SIZELIMIT_EXCEEDED\u2029An LDAP size limit was exceeded.\u2029\u2029LDAP_COMPARE_FALSE  A compare operation returned false.\u2029\u2029LDAP_COMPARE_TRUE   A compare operation returned true.\u2029\u2029LDAP_STRONG_AUTH_NOT_SUPPORTED\u2029The LDAP server does not support strong authentication.\u2029\u2029LDAP_STRONG_AUTH_REQUIRED\u2029Strong authentication is required for the operation.\u2029\u2029LDAP_PARTIAL_RESULTS\u2029Partial results only returned.\u2029\u2029LDAP_NO_SUCH_ATTRIBUTE\u2029The attribute type specified does not exist in the entry.\u2029\u2029LDAP_UNDEFINED_TYPE The attribute type specified is invalid.\u2029\u2029LDAP_INAPPROPRIATE_MATCHING\u2029Filter type not supported for the specified attribute.\u2029\u2029LDAP_CONSTRAINT_VIOLATION\u2029An attribute value specified violates some constraint (e.g., a postalAddress has too many lines, or a line that is too long).\u2029\u2029LDAP_TYPE_OR_VALUE_EXISTS\u2029An attribute type or attribute value specified already exists in the entry.\u2029\u2029LDAP_INVALID_SYNTAX An invalid attribute value was specified.\u2029\u2029LDAP_NO_SUCH_OBJECT The specified object does not exist in The Directory.\u2029\u2029LDAP_ALIAS_PROBLEM  An alias in The Directory points to a nonexistent entry.\u2029\u2029LDAP_INVALID_DN_SYNTAX\u2029A syntactically invalid DN was specified.\u2029\u2029LDAP_IS_LEAF        The object specified is a leaf.\u2029\u2029LDAP_ALIAS_DEREF_PROBLEM\u2029A problem was encountered when dereferencing an alias.\u2029\u2029LDAP_INAPPROPRIATE_AUTH\u2029Inappropriate authentication was specified (e.g., LDAP_AUTH_SIMPLE was specified and the entry does not have a userPassword attribute).\u2029\u2029LDAP_INVALID_CREDENTIALS\u2029Invalid credentials were presented (e.g., the wrong password).\u2029\u2029LDAP_INSUFFICIENT_ACCESS\u2029The user has insufficient access to perform the operation.\u2029\u2029LDAP_BUSY           The DSA is busy.\u2029\u2029LDAP_UNAVAILABLE    The DSA is unavailable.\u2029\u2029LDAP_UNWILLING_TO_PERFORM\u2029The DSA is unwilling to perform the operation.\u2029\u2029LDAP_LOOP_DETECT    A loop was detected.\u2029\u2029LDAP_NAMING_VIOLATION\u2029A naming violation occurred.\u2029\u2029LDAP_OBJECT_CLASS_VIOLATION\u2029An object class violation occurred (e.g., a \"must\" attribute was missing from the entry).\u2029\u2029LDAP_NOT_ALLOWED_ON_NONLEAF\u2029The operation is not allowed on a nonleaf object.\u2029\u2029LDAP_NOT_ALLOWED_ON_RDN\u2029The operation is not allowed on an RDN.\u2029\u2029LDAP_ALREADY_EXISTS The entry already exists.\u2029\u2029LDAP_NO_OBJECT_CLASS_MODS\u2029Object class modifications are not allowed.\u2029\u2029LDAP_OTHER          An unknown error occurred.\u2029\u2029API ERROR CODES\u2029This  section  provides  a  complete list of API error codes recognized by the library.   Note that LDAP_SUCCESS indicates success of an API call in addition to representing the\u2029return of the LDAP 'success' resultCode.\u2029\u2029LDAP_SERVER_DOWN    The LDAP library can't contact the LDAP server.\u2029\u2029LDAP_LOCAL_ERROR    Some local error occurred.  This is usually a failed dynamic memory allocation.\u2029\u2029LDAP_ENCODING_ERROR An error was encountered encoding parameters to send to the LDAP server.\u2029\u2029LDAP_DECODING_ERROR An error was encountered decoding a result from the LDAP server.\u2029\u2029LDAP_TIMEOUT        A timelimit was exceeded while waiting for a result.\u2029\u2029LDAP_AUTH_UNKNOWN   The authentication method specified to ldap_bind() is not known.\u2029\u2029LDAP_FILTER_ERROR   An invalid filter was supplied to ldap_search() (e.g., unbalanced parentheses).\u2029\u2029LDAP_PARAM_ERROR    An ldap routine was called with a bad parameter.\u2029\u2029LDAP_NO_MEMORY      An memory allocation (e.g., malloc(3) or other dynamic memory allocator) call failed in an ldap library routine.\u2029\u2029LDAP_USER_CANCELED  Indicates the user cancelled the operation.\u2029\u2029LDAP_CONNECT_ERROR  Indicates a connection problem.\u2029\u2029LDAP_NOT_SUPPORTED  Indicates the routine was called in a manner not supported by the library.\u2029\u2029LDAP_CONTROL_NOT_FOUND\u2029Indicates the control provided is unknown to the client library.\u2029\u2029LDAP_NO_RESULTS_RETURNED\u2029Indicates no results returned.\u2029\u2029LDAP_MORE_RESULTS_TO_RETURN\u2029Indicates more results could be returned.\u2029\u2029LDAP_CLIENT_LOOP    Indicates the library has detected a loop in its processing.\u2029\u2029LDAP_REFERRAL_LIMIT_EXCEEDED\u2029Indicates the referral limit has been exceeded.\u2029\u2029DEPRECATED\u2029Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3),\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 947, "position": [772751, 778790], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_perror, ld_errno, ldap_result2error, ldap_errlist, ldap_err2string - LDAP protocol error handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029char *ldap_err2string( int err );\u2029\u2029DESCRIPTION\u2029The  ldap_err2string()  routine  provides  short  description  of the various codes returned by routines in this library.  The returned string is a pointer to a static area that\u2029should not be modified.\u2029\u2029These codes are either negative, indicating an API error code; positive, indicating an LDAP resultCode other than 'success' (0), or - zero, indicating both successful use of the\u2029API and the LDAP resultCode 'success' (0).\u2029\u2029The   code  associated  with  an  LDAP  session  is  accessible  using  ldap_get_option(3)  and  ldap_set_option(3)  with  the  LDAP_OPT_RESULT_CODE  option  (previously  called\u2029LDAP_OPT_ERROR_NUMBER).\u2029\u2029PROTOCOL RESULT CODES\u2029This section provides a partial list of protocol codes recognized by the library.  As LDAP is extensible, additional values may be returned.  A complete  listing  of  registered\u2029LDAP result codes can be obtained from the Internet Assigned Numbers Authority &amp;lt;http://www.iana.org&amp;gt;.\u2029\u2029LDAP_SUCCESS        The request was successful.\u2029\u2029LDAP_OPERATIONS_ERROR\u2029An operations error occurred.\u2029\u2029LDAP_PROTOCOL_ERROR A protocol violation was detected.\u2029\u2029LDAP_TIMELIMIT_EXCEEDED\u2029An LDAP time limit was exceeded.\u2029\u2029LDAP_SIZELIMIT_EXCEEDED\u2029An LDAP size limit was exceeded.\u2029\u2029LDAP_COMPARE_FALSE  A compare operation returned false.\u2029\u2029LDAP_COMPARE_TRUE   A compare operation returned true.\u2029\u2029LDAP_STRONG_AUTH_NOT_SUPPORTED\u2029The LDAP server does not support strong authentication.\u2029\u2029LDAP_STRONG_AUTH_REQUIRED\u2029Strong authentication is required for the operation.\u2029\u2029LDAP_PARTIAL_RESULTS\u2029Partial results only returned.\u2029\u2029LDAP_NO_SUCH_ATTRIBUTE\u2029The attribute type specified does not exist in the entry.\u2029\u2029LDAP_UNDEFINED_TYPE The attribute type specified is invalid.\u2029\u2029LDAP_INAPPROPRIATE_MATCHING\u2029Filter type not supported for the specified attribute.\u2029\u2029LDAP_CONSTRAINT_VIOLATION\u2029An attribute value specified violates some constraint (e.g., a postalAddress has too many lines, or a line that is too long).\u2029\u2029LDAP_TYPE_OR_VALUE_EXISTS\u2029An attribute type or attribute value specified already exists in the entry.\u2029\u2029LDAP_INVALID_SYNTAX An invalid attribute value was specified.\u2029\u2029LDAP_NO_SUCH_OBJECT The specified object does not exist in The Directory.\u2029\u2029LDAP_ALIAS_PROBLEM  An alias in The Directory points to a nonexistent entry.\u2029\u2029LDAP_INVALID_DN_SYNTAX\u2029A syntactically invalid DN was specified.\u2029\u2029LDAP_IS_LEAF        The object specified is a leaf.\u2029\u2029LDAP_ALIAS_DEREF_PROBLEM\u2029A problem was encountered when dereferencing an alias.\u2029\u2029LDAP_INAPPROPRIATE_AUTH\u2029Inappropriate authentication was specified (e.g., LDAP_AUTH_SIMPLE was specified and the entry does not have a userPassword attribute).\u2029\u2029LDAP_INVALID_CREDENTIALS\u2029Invalid credentials were presented (e.g., the wrong password).\u2029\u2029LDAP_INSUFFICIENT_ACCESS\u2029The user has insufficient access to perform the operation.\u2029\u2029LDAP_BUSY           The DSA is busy.\u2029\u2029LDAP_UNAVAILABLE    The DSA is unavailable.\u2029\u2029LDAP_UNWILLING_TO_PERFORM\u2029The DSA is unwilling to perform the operation.\u2029\u2029LDAP_LOOP_DETECT    A loop was detected.\u2029\u2029LDAP_NAMING_VIOLATION\u2029A naming violation occurred.\u2029\u2029LDAP_OBJECT_CLASS_VIOLATION\u2029An object class violation occurred (e.g., a \"must\" attribute was missing from the entry).\u2029\u2029LDAP_NOT_ALLOWED_ON_NONLEAF\u2029The operation is not allowed on a nonleaf object.\u2029\u2029LDAP_NOT_ALLOWED_ON_RDN\u2029The operation is not allowed on an RDN.\u2029\u2029LDAP_ALREADY_EXISTS The entry already exists.\u2029\u2029LDAP_NO_OBJECT_CLASS_MODS\u2029Object class modifications are not allowed.\u2029\u2029LDAP_OTHER          An unknown error occurred.\u2029\u2029API ERROR CODES\u2029This  section  provides  a  complete list of API error codes recognized by the library.   Note that LDAP_SUCCESS indicates success of an API call in addition to representing the\u2029return of the LDAP 'success' resultCode.\u2029\u2029LDAP_SERVER_DOWN    The LDAP library can't contact the LDAP server.\u2029\u2029LDAP_LOCAL_ERROR    Some local error occurred.  This is usually a failed dynamic memory allocation.\u2029\u2029LDAP_ENCODING_ERROR An error was encountered encoding parameters to send to the LDAP server.\u2029\u2029LDAP_DECODING_ERROR An error was encountered decoding a result from the LDAP server.\u2029\u2029LDAP_TIMEOUT        A timelimit was exceeded while waiting for a result.\u2029\u2029LDAP_AUTH_UNKNOWN   The authentication method specified to ldap_bind() is not known.\u2029\u2029LDAP_FILTER_ERROR   An invalid filter was supplied to ldap_search() (e.g., unbalanced parentheses).\u2029\u2029LDAP_PARAM_ERROR    An ldap routine was called with a bad parameter.\u2029\u2029LDAP_NO_MEMORY      An memory allocation (e.g., malloc(3) or other dynamic memory allocator) call failed in an ldap library routine.\u2029\u2029LDAP_USER_CANCELED  Indicates the user cancelled the operation.\u2029\u2029LDAP_CONNECT_ERROR  Indicates a connection problem.\u2029\u2029LDAP_NOT_SUPPORTED  Indicates the routine was called in a manner not supported by the library.\u2029\u2029LDAP_CONTROL_NOT_FOUND\u2029Indicates the control provided is unknown to the client library.\u2029\u2029LDAP_NO_RESULTS_RETURNED\u2029Indicates no results returned.\u2029\u2029LDAP_MORE_RESULTS_TO_RETURN\u2029Indicates more results could be returned.\u2029\u2029LDAP_CLIENT_LOOP    Indicates the library has detected a loop in its processing.\u2029\u2029LDAP_REFERRAL_LIMIT_EXCEEDED\u2029Indicates the referral limit has been exceeded.\u2029\u2029DEPRECATED\u2029Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3),\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 946, "position": [545073, 551112], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_perror, ld_errno, ldap_result2error, ldap_errlist, ldap_err2string - LDAP protocol error handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029char *ldap_err2string( int err );\u2029\u2029DESCRIPTION\u2029The  ldap_err2string()  routine  provides  short  description  of the various codes returned by routines in this library.  The returned string is a pointer to a static area that\u2029should not be modified.\u2029\u2029These codes are either negative, indicating an API error code; positive, indicating an LDAP resultCode other than 'success' (0), or - zero, indicating both successful use of the\u2029API and the LDAP resultCode 'success' (0).\u2029\u2029The   code  associated  with  an  LDAP  session  is  accessible  using  ldap_get_option(3)  and  ldap_set_option(3)  with  the  LDAP_OPT_RESULT_CODE  option  (previously  called\u2029LDAP_OPT_ERROR_NUMBER).\u2029\u2029PROTOCOL RESULT CODES\u2029This section provides a partial list of protocol codes recognized by the library.  As LDAP is extensible, additional values may be returned.  A complete  listing  of  registered\u2029LDAP result codes can be obtained from the Internet Assigned Numbers Authority &amp;lt;http://www.iana.org&amp;gt;.\u2029\u2029LDAP_SUCCESS        The request was successful.\u2029\u2029LDAP_OPERATIONS_ERROR\u2029An operations error occurred.\u2029\u2029LDAP_PROTOCOL_ERROR A protocol violation was detected.\u2029\u2029LDAP_TIMELIMIT_EXCEEDED\u2029An LDAP time limit was exceeded.\u2029\u2029LDAP_SIZELIMIT_EXCEEDED\u2029An LDAP size limit was exceeded.\u2029\u2029LDAP_COMPARE_FALSE  A compare operation returned false.\u2029\u2029LDAP_COMPARE_TRUE   A compare operation returned true.\u2029\u2029LDAP_STRONG_AUTH_NOT_SUPPORTED\u2029The LDAP server does not support strong authentication.\u2029\u2029LDAP_STRONG_AUTH_REQUIRED\u2029Strong authentication is required for the operation.\u2029\u2029LDAP_PARTIAL_RESULTS\u2029Partial results only returned.\u2029\u2029LDAP_NO_SUCH_ATTRIBUTE\u2029The attribute type specified does not exist in the entry.\u2029\u2029LDAP_UNDEFINED_TYPE The attribute type specified is invalid.\u2029\u2029LDAP_INAPPROPRIATE_MATCHING\u2029Filter type not supported for the specified attribute.\u2029\u2029LDAP_CONSTRAINT_VIOLATION\u2029An attribute value specified violates some constraint (e.g., a postalAddress has too many lines, or a line that is too long).\u2029\u2029LDAP_TYPE_OR_VALUE_EXISTS\u2029An attribute type or attribute value specified already exists in the entry.\u2029\u2029LDAP_INVALID_SYNTAX An invalid attribute value was specified.\u2029\u2029LDAP_NO_SUCH_OBJECT The specified object does not exist in The Directory.\u2029\u2029LDAP_ALIAS_PROBLEM  An alias in The Directory points to a nonexistent entry.\u2029\u2029LDAP_INVALID_DN_SYNTAX\u2029A syntactically invalid DN was specified.\u2029\u2029LDAP_IS_LEAF        The object specified is a leaf.\u2029\u2029LDAP_ALIAS_DEREF_PROBLEM\u2029A problem was encountered when dereferencing an alias.\u2029\u2029LDAP_INAPPROPRIATE_AUTH\u2029Inappropriate authentication was specified (e.g., LDAP_AUTH_SIMPLE was specified and the entry does not have a userPassword attribute).\u2029\u2029LDAP_INVALID_CREDENTIALS\u2029Invalid credentials were presented (e.g., the wrong password).\u2029\u2029LDAP_INSUFFICIENT_ACCESS\u2029The user has insufficient access to perform the operation.\u2029\u2029LDAP_BUSY           The DSA is busy.\u2029\u2029LDAP_UNAVAILABLE    The DSA is unavailable.\u2029\u2029LDAP_UNWILLING_TO_PERFORM\u2029The DSA is unwilling to perform the operation.\u2029\u2029LDAP_LOOP_DETECT    A loop was detected.\u2029\u2029LDAP_NAMING_VIOLATION\u2029A naming violation occurred.\u2029\u2029LDAP_OBJECT_CLASS_VIOLATION\u2029An object class violation occurred (e.g., a \"must\" attribute was missing from the entry).\u2029\u2029LDAP_NOT_ALLOWED_ON_NONLEAF\u2029The operation is not allowed on a nonleaf object.\u2029\u2029LDAP_NOT_ALLOWED_ON_RDN\u2029The operation is not allowed on an RDN.\u2029\u2029LDAP_ALREADY_EXISTS The entry already exists.\u2029\u2029LDAP_NO_OBJECT_CLASS_MODS\u2029Object class modifications are not allowed.\u2029\u2029LDAP_OTHER          An unknown error occurred.\u2029\u2029API ERROR CODES\u2029This  section  provides  a  complete list of API error codes recognized by the library.   Note that LDAP_SUCCESS indicates success of an API call in addition to representing the\u2029return of the LDAP 'success' resultCode.\u2029\u2029LDAP_SERVER_DOWN    The LDAP library can't contact the LDAP server.\u2029\u2029LDAP_LOCAL_ERROR    Some local error occurred.  This is usually a failed dynamic memory allocation.\u2029\u2029LDAP_ENCODING_ERROR An error was encountered encoding parameters to send to the LDAP server.\u2029\u2029LDAP_DECODING_ERROR An error was encountered decoding a result from the LDAP server.\u2029\u2029LDAP_TIMEOUT        A timelimit was exceeded while waiting for a result.\u2029\u2029LDAP_AUTH_UNKNOWN   The authentication method specified to ldap_bind() is not known.\u2029\u2029LDAP_FILTER_ERROR   An invalid filter was supplied to ldap_search() (e.g., unbalanced parentheses).\u2029\u2029LDAP_PARAM_ERROR    An ldap routine was called with a bad parameter.\u2029\u2029LDAP_NO_MEMORY      An memory allocation (e.g., malloc(3) or other dynamic memory allocator) call failed in an ldap library routine.\u2029\u2029LDAP_USER_CANCELED  Indicates the user cancelled the operation.\u2029\u2029LDAP_CONNECT_ERROR  Indicates a connection problem.\u2029\u2029LDAP_NOT_SUPPORTED  Indicates the routine was called in a manner not supported by the library.\u2029\u2029LDAP_CONTROL_NOT_FOUND\u2029Indicates the control provided is unknown to the client library.\u2029\u2029LDAP_NO_RESULTS_RETURNED\u2029Indicates no results returned.\u2029\u2029LDAP_MORE_RESULTS_TO_RETURN\u2029Indicates more results could be returned.\u2029\u2029LDAP_CLIENT_LOOP    Indicates the library has detected a loop in its processing.\u2029\u2029LDAP_REFERRAL_LIMIT_EXCEEDED\u2029Indicates the referral limit has been exceeded.\u2029\u2029DEPRECATED\u2029Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3),\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 945, "position": [538661, 544700], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_perror, ld_errno, ldap_result2error, ldap_errlist, ldap_err2string - LDAP protocol error handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029char *ldap_err2string( int err );\u2029\u2029DESCRIPTION\u2029The  ldap_err2string()  routine  provides  short  description  of the various codes returned by routines in this library.  The returned string is a pointer to a static area that\u2029should not be modified.\u2029\u2029These codes are either negative, indicating an API error code; positive, indicating an LDAP resultCode other than 'success' (0), or - zero, indicating both successful use of the\u2029API and the LDAP resultCode 'success' (0).\u2029\u2029The   code  associated  with  an  LDAP  session  is  accessible  using  ldap_get_option(3)  and  ldap_set_option(3)  with  the  LDAP_OPT_RESULT_CODE  option  (previously  called\u2029LDAP_OPT_ERROR_NUMBER).\u2029\u2029PROTOCOL RESULT CODES\u2029This section provides a partial list of protocol codes recognized by the library.  As LDAP is extensible, additional values may be returned.  A complete  listing  of  registered\u2029LDAP result codes can be obtained from the Internet Assigned Numbers Authority &amp;lt;http://www.iana.org&amp;gt;.\u2029\u2029LDAP_SUCCESS        The request was successful.\u2029\u2029LDAP_OPERATIONS_ERROR\u2029An operations error occurred.\u2029\u2029LDAP_PROTOCOL_ERROR A protocol violation was detected.\u2029\u2029LDAP_TIMELIMIT_EXCEEDED\u2029An LDAP time limit was exceeded.\u2029\u2029LDAP_SIZELIMIT_EXCEEDED\u2029An LDAP size limit was exceeded.\u2029\u2029LDAP_COMPARE_FALSE  A compare operation returned false.\u2029\u2029LDAP_COMPARE_TRUE   A compare operation returned true.\u2029\u2029LDAP_STRONG_AUTH_NOT_SUPPORTED\u2029The LDAP server does not support strong authentication.\u2029\u2029LDAP_STRONG_AUTH_REQUIRED\u2029Strong authentication is required for the operation.\u2029\u2029LDAP_PARTIAL_RESULTS\u2029Partial results only returned.\u2029\u2029LDAP_NO_SUCH_ATTRIBUTE\u2029The attribute type specified does not exist in the entry.\u2029\u2029LDAP_UNDEFINED_TYPE The attribute type specified is invalid.\u2029\u2029LDAP_INAPPROPRIATE_MATCHING\u2029Filter type not supported for the specified attribute.\u2029\u2029LDAP_CONSTRAINT_VIOLATION\u2029An attribute value specified violates some constraint (e.g., a postalAddress has too many lines, or a line that is too long).\u2029\u2029LDAP_TYPE_OR_VALUE_EXISTS\u2029An attribute type or attribute value specified already exists in the entry.\u2029\u2029LDAP_INVALID_SYNTAX An invalid attribute value was specified.\u2029\u2029LDAP_NO_SUCH_OBJECT The specified object does not exist in The Directory.\u2029\u2029LDAP_ALIAS_PROBLEM  An alias in The Directory points to a nonexistent entry.\u2029\u2029LDAP_INVALID_DN_SYNTAX\u2029A syntactically invalid DN was specified.\u2029\u2029LDAP_IS_LEAF        The object specified is a leaf.\u2029\u2029LDAP_ALIAS_DEREF_PROBLEM\u2029A problem was encountered when dereferencing an alias.\u2029\u2029LDAP_INAPPROPRIATE_AUTH\u2029Inappropriate authentication was specified (e.g., LDAP_AUTH_SIMPLE was specified and the entry does not have a userPassword attribute).\u2029\u2029LDAP_INVALID_CREDENTIALS\u2029Invalid credentials were presented (e.g., the wrong password).\u2029\u2029LDAP_INSUFFICIENT_ACCESS\u2029The user has insufficient access to perform the operation.\u2029\u2029LDAP_BUSY           The DSA is busy.\u2029\u2029LDAP_UNAVAILABLE    The DSA is unavailable.\u2029\u2029LDAP_UNWILLING_TO_PERFORM\u2029The DSA is unwilling to perform the operation.\u2029\u2029LDAP_LOOP_DETECT    A loop was detected.\u2029\u2029LDAP_NAMING_VIOLATION\u2029A naming violation occurred.\u2029\u2029LDAP_OBJECT_CLASS_VIOLATION\u2029An object class violation occurred (e.g., a \"must\" attribute was missing from the entry).\u2029\u2029LDAP_NOT_ALLOWED_ON_NONLEAF\u2029The operation is not allowed on a nonleaf object.\u2029\u2029LDAP_NOT_ALLOWED_ON_RDN\u2029The operation is not allowed on an RDN.\u2029\u2029LDAP_ALREADY_EXISTS The entry already exists.\u2029\u2029LDAP_NO_OBJECT_CLASS_MODS\u2029Object class modifications are not allowed.\u2029\u2029LDAP_OTHER          An unknown error occurred.\u2029\u2029API ERROR CODES\u2029This  section  provides  a  complete list of API error codes recognized by the library.   Note that LDAP_SUCCESS indicates success of an API call in addition to representing the\u2029return of the LDAP 'success' resultCode.\u2029\u2029LDAP_SERVER_DOWN    The LDAP library can't contact the LDAP server.\u2029\u2029LDAP_LOCAL_ERROR    Some local error occurred.  This is usually a failed dynamic memory allocation.\u2029\u2029LDAP_ENCODING_ERROR An error was encountered encoding parameters to send to the LDAP server.\u2029\u2029LDAP_DECODING_ERROR An error was encountered decoding a result from the LDAP server.\u2029\u2029LDAP_TIMEOUT        A timelimit was exceeded while waiting for a result.\u2029\u2029LDAP_AUTH_UNKNOWN   The authentication method specified to ldap_bind() is not known.\u2029\u2029LDAP_FILTER_ERROR   An invalid filter was supplied to ldap_search() (e.g., unbalanced parentheses).\u2029\u2029LDAP_PARAM_ERROR    An ldap routine was called with a bad parameter.\u2029\u2029LDAP_NO_MEMORY      An memory allocation (e.g., malloc(3) or other dynamic memory allocator) call failed in an ldap library routine.\u2029\u2029LDAP_USER_CANCELED  Indicates the user cancelled the operation.\u2029\u2029LDAP_CONNECT_ERROR  Indicates a connection problem.\u2029\u2029LDAP_NOT_SUPPORTED  Indicates the routine was called in a manner not supported by the library.\u2029\u2029LDAP_CONTROL_NOT_FOUND\u2029Indicates the control provided is unknown to the client library.\u2029\u2029LDAP_NO_RESULTS_RETURNED\u2029Indicates no results returned.\u2029\u2029LDAP_MORE_RESULTS_TO_RETURN\u2029Indicates more results could be returned.\u2029\u2029LDAP_CLIENT_LOOP    Indicates the library has detected a loop in its processing.\u2029\u2029LDAP_REFERRAL_LIMIT_EXCEEDED\u2029Indicates the referral limit has been exceeded.\u2029\u2029DEPRECATED\u2029Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3),\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 944, "position": [532249, 538288], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_perror, ld_errno, ldap_result2error, ldap_errlist, ldap_err2string - LDAP protocol error handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029char *ldap_err2string( int err );\u2029\u2029DESCRIPTION\u2029The  ldap_err2string()  routine  provides  short  description  of the various codes returned by routines in this library.  The returned string is a pointer to a static area that\u2029should not be modified.\u2029\u2029These codes are either negative, indicating an API error code; positive, indicating an LDAP resultCode other than 'success' (0), or - zero, indicating both successful use of the\u2029API and the LDAP resultCode 'success' (0).\u2029\u2029The   code  associated  with  an  LDAP  session  is  accessible  using  ldap_get_option(3)  and  ldap_set_option(3)  with  the  LDAP_OPT_RESULT_CODE  option  (previously  called\u2029LDAP_OPT_ERROR_NUMBER).\u2029\u2029PROTOCOL RESULT CODES\u2029This section provides a partial list of protocol codes recognized by the library.  As LDAP is extensible, additional values may be returned.  A complete  listing  of  registered\u2029LDAP result codes can be obtained from the Internet Assigned Numbers Authority &amp;lt;http://www.iana.org&amp;gt;.\u2029\u2029LDAP_SUCCESS        The request was successful.\u2029\u2029LDAP_OPERATIONS_ERROR\u2029An operations error occurred.\u2029\u2029LDAP_PROTOCOL_ERROR A protocol violation was detected.\u2029\u2029LDAP_TIMELIMIT_EXCEEDED\u2029An LDAP time limit was exceeded.\u2029\u2029LDAP_SIZELIMIT_EXCEEDED\u2029An LDAP size limit was exceeded.\u2029\u2029LDAP_COMPARE_FALSE  A compare operation returned false.\u2029\u2029LDAP_COMPARE_TRUE   A compare operation returned true.\u2029\u2029LDAP_STRONG_AUTH_NOT_SUPPORTED\u2029The LDAP server does not support strong authentication.\u2029\u2029LDAP_STRONG_AUTH_REQUIRED\u2029Strong authentication is required for the operation.\u2029\u2029LDAP_PARTIAL_RESULTS\u2029Partial results only returned.\u2029\u2029LDAP_NO_SUCH_ATTRIBUTE\u2029The attribute type specified does not exist in the entry.\u2029\u2029LDAP_UNDEFINED_TYPE The attribute type specified is invalid.\u2029\u2029LDAP_INAPPROPRIATE_MATCHING\u2029Filter type not supported for the specified attribute.\u2029\u2029LDAP_CONSTRAINT_VIOLATION\u2029An attribute value specified violates some constraint (e.g., a postalAddress has too many lines, or a line that is too long).\u2029\u2029LDAP_TYPE_OR_VALUE_EXISTS\u2029An attribute type or attribute value specified already exists in the entry.\u2029\u2029LDAP_INVALID_SYNTAX An invalid attribute value was specified.\u2029\u2029LDAP_NO_SUCH_OBJECT The specified object does not exist in The Directory.\u2029\u2029LDAP_ALIAS_PROBLEM  An alias in The Directory points to a nonexistent entry.\u2029\u2029LDAP_INVALID_DN_SYNTAX\u2029A syntactically invalid DN was specified.\u2029\u2029LDAP_IS_LEAF        The object specified is a leaf.\u2029\u2029LDAP_ALIAS_DEREF_PROBLEM\u2029A problem was encountered when dereferencing an alias.\u2029\u2029LDAP_INAPPROPRIATE_AUTH\u2029Inappropriate authentication was specified (e.g., LDAP_AUTH_SIMPLE was specified and the entry does not have a userPassword attribute).\u2029\u2029LDAP_INVALID_CREDENTIALS\u2029Invalid credentials were presented (e.g., the wrong password).\u2029\u2029LDAP_INSUFFICIENT_ACCESS\u2029The user has insufficient access to perform the operation.\u2029\u2029LDAP_BUSY           The DSA is busy.\u2029\u2029LDAP_UNAVAILABLE    The DSA is unavailable.\u2029\u2029LDAP_UNWILLING_TO_PERFORM\u2029The DSA is unwilling to perform the operation.\u2029\u2029LDAP_LOOP_DETECT    A loop was detected.\u2029\u2029LDAP_NAMING_VIOLATION\u2029A naming violation occurred.\u2029\u2029LDAP_OBJECT_CLASS_VIOLATION\u2029An object class violation occurred (e.g., a \"must\" attribute was missing from the entry).\u2029\u2029LDAP_NOT_ALLOWED_ON_NONLEAF\u2029The operation is not allowed on a nonleaf object.\u2029\u2029LDAP_NOT_ALLOWED_ON_RDN\u2029The operation is not allowed on an RDN.\u2029\u2029LDAP_ALREADY_EXISTS The entry already exists.\u2029\u2029LDAP_NO_OBJECT_CLASS_MODS\u2029Object class modifications are not allowed.\u2029\u2029LDAP_OTHER          An unknown error occurred.\u2029\u2029API ERROR CODES\u2029This  section  provides  a  complete list of API error codes recognized by the library.   Note that LDAP_SUCCESS indicates success of an API call in addition to representing the\u2029return of the LDAP 'success' resultCode.\u2029\u2029LDAP_SERVER_DOWN    The LDAP library can't contact the LDAP server.\u2029\u2029LDAP_LOCAL_ERROR    Some local error occurred.  This is usually a failed dynamic memory allocation.\u2029\u2029LDAP_ENCODING_ERROR An error was encountered encoding parameters to send to the LDAP server.\u2029\u2029LDAP_DECODING_ERROR An error was encountered decoding a result from the LDAP server.\u2029\u2029LDAP_TIMEOUT        A timelimit was exceeded while waiting for a result.\u2029\u2029LDAP_AUTH_UNKNOWN   The authentication method specified to ldap_bind() is not known.\u2029\u2029LDAP_FILTER_ERROR   An invalid filter was supplied to ldap_search() (e.g., unbalanced parentheses).\u2029\u2029LDAP_PARAM_ERROR    An ldap routine was called with a bad parameter.\u2029\u2029LDAP_NO_MEMORY      An memory allocation (e.g., malloc(3) or other dynamic memory allocator) call failed in an ldap library routine.\u2029\u2029LDAP_USER_CANCELED  Indicates the user cancelled the operation.\u2029\u2029LDAP_CONNECT_ERROR  Indicates a connection problem.\u2029\u2029LDAP_NOT_SUPPORTED  Indicates the routine was called in a manner not supported by the library.\u2029\u2029LDAP_CONTROL_NOT_FOUND\u2029Indicates the control provided is unknown to the client library.\u2029\u2029LDAP_NO_RESULTS_RETURNED\u2029Indicates no results returned.\u2029\u2029LDAP_MORE_RESULTS_TO_RETURN\u2029Indicates more results could be returned.\u2029\u2029LDAP_CLIENT_LOOP    Indicates the library has detected a loop in its processing.\u2029\u2029LDAP_REFERRAL_LIMIT_EXCEEDED\u2029Indicates the referral limit has been exceeded.\u2029\u2029DEPRECATED\u2029Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3),\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 943, "position": [344852, 350891], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "60", "annotation": "LDAP_EXTENDED_OPERATION", "group_ids": [{"name2": "NAME\u2029ldap_extended_operation, ldap_extended_operation_s - Extends the LDAP operations to the LDAP server.\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_extended_operation(\u2029LDAP *ld,\u2029const char *requestoid,\u2029const struct berval *requestdata,\u2029LDAPControl **sctrls,\u2029LDAPControl **cctrls,\u2029int *msgidp );\u2029\u2029int ldap_extended_operation_s(\u2029LDAP *ld,\u2029const char *requestoid,\u2029const struct berval *requestdata,\u2029LDAPControl **sctrls,\u2029LDAPControl **cctrls,\u2029char **retoidp,\u2029struct berval **retdatap );\u2029\u2029DESCRIPTION\u2029The  ldap_extended_operation_s() routine is used to synchronously perform an LDAP extended operation.  It takes requestoid, which points to a dotted-decimal OID string identify\u2010\u2029ing the extended operation to perform. requestdata is the data required for the request, sctrls is an array of LDAPControl structures to use with this extended operation, cctrls\u2029is an array of LDAPControl structures that list the client controls to use with this extended operation.\u2029\u2029The output parameter retoidp points to a dotted-decimal OID string returned by the LDAP server.  The memory used by the string should be freed with the ldap_memfree(3) function.\u2029The output parameter retdatap points to a pointer to a berval structure that contains the returned data.  If no data is returned by the server, the pointer is set this to  NULL.\u2029The memory used by this structure should be freed with the ber_bvfree(3) function.\u2029\u2029The  ldap_extended_operation()  works  just  like  ldap_extended_operation_s(), but the operation is asynchronous.  It provides the message id of the request it initiated in the\u2029integer pointed to be msgidp.  The result of this operation can be obtained by calling ldap_result(3).\u2029\u2029SEE ALSO\u2029ber_bvfree(3), ldap_memfree(3), ldap_parse_extended_result(3), ldap_result(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 950, "position": [566815, 568838], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_extended_operation, ldap_extended_operation_s - Extends the LDAP operations to the LDAP server.\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_extended_operation(\u2029LDAP *ld,\u2029const char *requestoid,\u2029const struct berval *requestdata,\u2029LDAPControl **sctrls,\u2029LDAPControl **cctrls,\u2029int *msgidp );\u2029\u2029int ldap_extended_operation_s(\u2029LDAP *ld,\u2029const char *requestoid,\u2029const struct berval *requestdata,\u2029LDAPControl **sctrls,\u2029LDAPControl **cctrls,\u2029char **retoidp,\u2029struct berval **retdatap );\u2029\u2029DESCRIPTION\u2029The  ldap_extended_operation_s() routine is used to synchronously perform an LDAP extended operation.  It takes requestoid, which points to a dotted-decimal OID string identify\u2010\u2029ing the extended operation to perform. requestdata is the data required for the request, sctrls is an array of LDAPControl structures to use with this extended operation, cctrls\u2029is an array of LDAPControl structures that list the client controls to use with this extended operation.\u2029\u2029The output parameter retoidp points to a dotted-decimal OID string returned by the LDAP server.  The memory used by the string should be freed with the ldap_memfree(3) function.\u2029The output parameter retdatap points to a pointer to a berval structure that contains the returned data.  If no data is returned by the server, the pointer is set this to  NULL.\u2029The memory used by this structure should be freed with the ber_bvfree(3) function.\u2029\u2029The  ldap_extended_operation()  works  just  like  ldap_extended_operation_s(), but the operation is asynchronous.  It provides the message id of the request it initiated in the\u2029integer pointed to be msgidp.  The result of this operation can be obtained by calling ldap_result(3).\u2029\u2029SEE ALSO\u2029ber_bvfree(3), ldap_memfree(3), ldap_parse_extended_result(3), ldap_result(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 949, "position": [564419, 566442], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "61", "annotation": "LDAP_FIRST_ATTRIBUTE", "group_ids": [{"name2": "NAME\u2029ldap_first_attribute, ldap_next_attribute - step through LDAP entry attributes\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029char *ldap_first_attribute(\u2029LDAP *ld, LDAPMessage *entry, BerElement **berptr )\u2029\u2029char *ldap_next_attribute(\u2029LDAP *ld, LDAPMessage *entry, BerElement *ber )\u2029\u2029DESCRIPTION\u2029The  ldap_first_attribute()  and  ldap_next_attribute()  routines are used to step through the attributes in an LDAP entry.  ldap_first_attribute() takes an entry as returned by\u2029ldap_first_entry(3) or ldap_next_entry(3) and returns a pointer to character string containing the first attribute description in the entry.  ldap_next_attribute()  returns  the\u2029next attribute description in the entry.\u2029\u2029It  also  returns,  in  berptr,  a  pointer  to  a  BerElement  it  has  allocated  to  keep track of its current position.  This pointer should be passed to subsequent calls to\u2029ldap_next_attribute() and is used to effectively step through the entry's attributes.  The caller is solely responsible for freeing the BerElement pointed to by berptr  when  it\u2029is no longer needed by calling ber_free(3).  When calling ber_free(3) in this instance, be sure the second argument is 0.\u2029\u2029The attribute names returned are suitable for inclusion in a call to ldap_get_values(3) to retrieve the attribute's values.\u2029\u2029ERRORS\u2029If an error occurs, NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  See ldap_error(3) for a description of possible error codes.\u2029\u2029NOTES\u2029The ldap_first_attribute() and ldap_next_attribute() return dynamically allocated memory that must be freed by the caller via ldap_memfree(3).\u2029\u2029SEE ALSO\u2029ldap(3), ldap_first_entry(3), ldap_get_values(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 952, "position": [712890, 714837], "check": 1, "intersection": 1948, "FP_dupl": 7592, "FN_dupl": 0, "F": 0.33913649025069637, "Prec_Dupl": 0.20419287211740042, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_first_attribute, ldap_next_attribute - step through LDAP entry attributes\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029char *ldap_first_attribute(\u2029LDAP *ld, LDAPMessage *entry, BerElement **berptr )\u2029\u2029char *ldap_next_attribute(\u2029LDAP *ld, LDAPMessage *entry, BerElement *ber )\u2029\u2029DESCRIPTION\u2029The  ldap_first_attribute()  and  ldap_next_attribute()  routines are used to step through the attributes in an LDAP entry.  ldap_first_attribute() takes an entry as returned by\u2029ldap_first_entry(3) or ldap_next_entry(3) and returns a pointer to character string containing the first attribute description in the entry.  ldap_next_attribute()  returns  the\u2029next attribute description in the entry.\u2029\u2029It  also  returns,  in  berptr,  a  pointer  to  a  BerElement  it  has  allocated  to  keep track of its current position.  This pointer should be passed to subsequent calls to\u2029ldap_next_attribute() and is used to effectively step through the entry's attributes.  The caller is solely responsible for freeing the BerElement pointed to by berptr  when  it\u2029is no longer needed by calling ber_free(3).  When calling ber_free(3) in this instance, be sure the second argument is 0.\u2029\u2029The attribute names returned are suitable for inclusion in a call to ldap_get_values(3) to retrieve the attribute's values.\u2029\u2029ERRORS\u2029If an error occurs, NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  See ldap_error(3) for a description of possible error codes.\u2029\u2029NOTES\u2029The ldap_first_attribute() and ldap_next_attribute() return dynamically allocated memory that must be freed by the caller via ldap_memfree(3).\u2029\u2029SEE ALSO\u2029ldap(3), ldap_first_entry(3), ldap_get_values(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 951, "position": [569211, 571158], "check": 1, "intersection": 1948, "FP_dupl": 7592, "FN_dupl": 0, "F": 0.33913649025069637, "Prec_Dupl": 0.20419287211740042, "Recall_Dupl": 1.0}]}, {"name": "62", "annotation": "LDAP_URL", "group_ids": [{"name2": "NAME\u2029ldap_is_ldap_url, ldap_url_parse, ldap_free_urldesc - LDAP Uniform Resource Locator routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_is_ldap_url( const char *url )\u2029\u2029int ldap_url_parse( const char *url, LDAPURLDesc **ludpp )\u2029\u2029typedef struct ldap_url_desc {\u2029char *      lud_scheme;     /* URI scheme */\u2029char *      lud_host;       /* LDAP host to contact */\u2029int         lud_port;       /* port on host */\u2029char *      lud_dn;         /* base for search */\u2029char **     lud_attrs;      /* list of attributes */\u2029int         lud_scope;      /* a LDAP_SCOPE_... value */\u2029char *      lud_filter;     /* LDAP search filter */\u2029char **     lud_exts;       /* LDAP extensions */\u2029int         lud_crit_exts;  /* true if any extension is critical */\u2029/* may contain additional fields for internal use */\u2029} LDAPURLDesc;\u2029\u2029void ldap_free_urldesc( LDAPURLDesc *ludp );\u2029\u2029DESCRIPTION\u2029These routines support the use of LDAP URLs (Uniform Resource Locators) as detailed in RFC 4516.  LDAP URLs look like this:\u2029\u2029ldap://hostport/dn[?attrs[?scope[?filter[?exts]]]]\u2029\u2029where:\u2029hostport is a host name with an optional \":portnumber\"\u2029dn is the search base\u2029attrs is a comma separated list of attributes to request\u2029scope is one of these three strings:\u2029base one sub (default=base)\u2029filter is filter\u2029exts are recognized set of LDAP and/or API extensions.\u2029\u2029Example:\u2029ldap://ldap.example.net/dc=example,dc=net?cn,sn?sub?(cn=*)\u2029\u2029URLs  that are wrapped in angle-brackets and/or preceded by \"URL:\" are also tolerated.  Alternative LDAP schemes such as ldaps:// and ldapi:// may be parsed using the below rou\u2010\u2029tines as well.\u2029\u2029ldap_is_ldap_url() returns a non-zero value if url looks like an LDAP URL (as opposed to some other kind of URL).  It can be  used  as  a  quick  check  for  an  LDAP  URL;  the\u2029ldap_url_parse() routine should be used if a more thorough check is needed.\u2029\u2029ldap_url_parse() breaks down an LDAP URL passed in url into its component pieces.  If successful, zero is returned, an LDAP URL description is allocated, filled in, and ludpp is\u2029set to point to it.  If an error occurs, a non-zero URL error code is returned.\u2029\u2029ldap_free_urldesc() should be called to free an LDAP URL description that was obtained from a call to ldap_url_parse().\u2029\u2029SEE ALSO\u2029ldap(3)\u2029RFC 4516 &amp;lt;http://www.rfc-editor.org/rfc/rfc4516.txt&amp;gt;\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 956, "position": [1054913, 1057475], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_is_ldap_url, ldap_url_parse, ldap_free_urldesc - LDAP Uniform Resource Locator routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_is_ldap_url( const char *url )\u2029\u2029int ldap_url_parse( const char *url, LDAPURLDesc **ludpp )\u2029\u2029typedef struct ldap_url_desc {\u2029char *      lud_scheme;     /* URI scheme */\u2029char *      lud_host;       /* LDAP host to contact */\u2029int         lud_port;       /* port on host */\u2029char *      lud_dn;         /* base for search */\u2029char **     lud_attrs;      /* list of attributes */\u2029int         lud_scope;      /* a LDAP_SCOPE_... value */\u2029char *      lud_filter;     /* LDAP search filter */\u2029char **     lud_exts;       /* LDAP extensions */\u2029int         lud_crit_exts;  /* true if any extension is critical */\u2029/* may contain additional fields for internal use */\u2029} LDAPURLDesc;\u2029\u2029void ldap_free_urldesc( LDAPURLDesc *ludp );\u2029\u2029DESCRIPTION\u2029These routines support the use of LDAP URLs (Uniform Resource Locators) as detailed in RFC 4516.  LDAP URLs look like this:\u2029\u2029ldap://hostport/dn[?attrs[?scope[?filter[?exts]]]]\u2029\u2029where:\u2029hostport is a host name with an optional \":portnumber\"\u2029dn is the search base\u2029attrs is a comma separated list of attributes to request\u2029scope is one of these three strings:\u2029base one sub (default=base)\u2029filter is filter\u2029exts are recognized set of LDAP and/or API extensions.\u2029\u2029Example:\u2029ldap://ldap.example.net/dc=example,dc=net?cn,sn?sub?(cn=*)\u2029\u2029URLs  that are wrapped in angle-brackets and/or preceded by \"URL:\" are also tolerated.  Alternative LDAP schemes such as ldaps:// and ldapi:// may be parsed using the below rou\u2010\u2029tines as well.\u2029\u2029ldap_is_ldap_url() returns a non-zero value if url looks like an LDAP URL (as opposed to some other kind of URL).  It can be  used  as  a  quick  check  for  an  LDAP  URL;  the\u2029ldap_url_parse() routine should be used if a more thorough check is needed.\u2029\u2029ldap_url_parse() breaks down an LDAP URL passed in url into its component pieces.  If successful, zero is returned, an LDAP URL description is allocated, filled in, and ludpp is\u2029set to point to it.  If an error occurs, a non-zero URL error code is returned.\u2029\u2029ldap_free_urldesc() should be called to free an LDAP URL description that was obtained from a call to ldap_url_parse().\u2029\u2029SEE ALSO\u2029ldap(3)\u2029RFC 4516 &amp;lt;http://www.rfc-editor.org/rfc/rfc4516.txt&amp;gt;\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 955, "position": [1051978, 1054540], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_is_ldap_url, ldap_url_parse, ldap_free_urldesc - LDAP Uniform Resource Locator routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_is_ldap_url( const char *url )\u2029\u2029int ldap_url_parse( const char *url, LDAPURLDesc **ludpp )\u2029\u2029typedef struct ldap_url_desc {\u2029char *      lud_scheme;     /* URI scheme */\u2029char *      lud_host;       /* LDAP host to contact */\u2029int         lud_port;       /* port on host */\u2029char *      lud_dn;         /* base for search */\u2029char **     lud_attrs;      /* list of attributes */\u2029int         lud_scope;      /* a LDAP_SCOPE_... value */\u2029char *      lud_filter;     /* LDAP search filter */\u2029char **     lud_exts;       /* LDAP extensions */\u2029int         lud_crit_exts;  /* true if any extension is critical */\u2029/* may contain additional fields for internal use */\u2029} LDAPURLDesc;\u2029\u2029void ldap_free_urldesc( LDAPURLDesc *ludp );\u2029\u2029DESCRIPTION\u2029These routines support the use of LDAP URLs (Uniform Resource Locators) as detailed in RFC 4516.  LDAP URLs look like this:\u2029\u2029ldap://hostport/dn[?attrs[?scope[?filter[?exts]]]]\u2029\u2029where:\u2029hostport is a host name with an optional \":portnumber\"\u2029dn is the search base\u2029attrs is a comma separated list of attributes to request\u2029scope is one of these three strings:\u2029base one sub (default=base)\u2029filter is filter\u2029exts are recognized set of LDAP and/or API extensions.\u2029\u2029Example:\u2029ldap://ldap.example.net/dc=example,dc=net?cn,sn?sub?(cn=*)\u2029\u2029URLs  that are wrapped in angle-brackets and/or preceded by \"URL:\" are also tolerated.  Alternative LDAP schemes such as ldaps:// and ldapi:// may be parsed using the below rou\u2010\u2029tines as well.\u2029\u2029ldap_is_ldap_url() returns a non-zero value if url looks like an LDAP URL (as opposed to some other kind of URL).  It can be  used  as  a  quick  check  for  an  LDAP  URL;  the\u2029ldap_url_parse() routine should be used if a more thorough check is needed.\u2029\u2029ldap_url_parse() breaks down an LDAP URL passed in url into its component pieces.  If successful, zero is returned, an LDAP URL description is allocated, filled in, and ludpp is\u2029set to point to it.  If an error occurs, a non-zero URL error code is returned.\u2029\u2029ldap_free_urldesc() should be called to free an LDAP URL description that was obtained from a call to ldap_url_parse().\u2029\u2029SEE ALSO\u2029ldap(3)\u2029RFC 4516 &amp;lt;http://www.rfc-editor.org/rfc/rfc4516.txt&amp;gt;\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 954, "position": [630692, 633254], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_is_ldap_url, ldap_url_parse, ldap_free_urldesc - LDAP Uniform Resource Locator routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_is_ldap_url( const char *url )\u2029\u2029int ldap_url_parse( const char *url, LDAPURLDesc **ludpp )\u2029\u2029typedef struct ldap_url_desc {\u2029char *      lud_scheme;     /* URI scheme */\u2029char *      lud_host;       /* LDAP host to contact */\u2029int         lud_port;       /* port on host */\u2029char *      lud_dn;         /* base for search */\u2029char **     lud_attrs;      /* list of attributes */\u2029int         lud_scope;      /* a LDAP_SCOPE_... value */\u2029char *      lud_filter;     /* LDAP search filter */\u2029char **     lud_exts;       /* LDAP extensions */\u2029int         lud_crit_exts;  /* true if any extension is critical */\u2029/* may contain additional fields for internal use */\u2029} LDAPURLDesc;\u2029\u2029void ldap_free_urldesc( LDAPURLDesc *ludp );\u2029\u2029DESCRIPTION\u2029These routines support the use of LDAP URLs (Uniform Resource Locators) as detailed in RFC 4516.  LDAP URLs look like this:\u2029\u2029ldap://hostport/dn[?attrs[?scope[?filter[?exts]]]]\u2029\u2029where:\u2029hostport is a host name with an optional \":portnumber\"\u2029dn is the search base\u2029attrs is a comma separated list of attributes to request\u2029scope is one of these three strings:\u2029base one sub (default=base)\u2029filter is filter\u2029exts are recognized set of LDAP and/or API extensions.\u2029\u2029Example:\u2029ldap://ldap.example.net/dc=example,dc=net?cn,sn?sub?(cn=*)\u2029\u2029URLs  that are wrapped in angle-brackets and/or preceded by \"URL:\" are also tolerated.  Alternative LDAP schemes such as ldaps:// and ldapi:// may be parsed using the below rou\u2010\u2029tines as well.\u2029\u2029ldap_is_ldap_url() returns a non-zero value if url looks like an LDAP URL (as opposed to some other kind of URL).  It can be  used  as  a  quick  check  for  an  LDAP  URL;  the\u2029ldap_url_parse() routine should be used if a more thorough check is needed.\u2029\u2029ldap_url_parse() breaks down an LDAP URL passed in url into its component pieces.  If successful, zero is returned, an LDAP URL description is allocated, filled in, and ludpp is\u2029set to point to it.  If an error occurs, a non-zero URL error code is returned.\u2029\u2029ldap_free_urldesc() should be called to free an LDAP URL description that was obtained from a call to ldap_url_parse().\u2029\u2029SEE ALSO\u2029ldap(3)\u2029RFC 4516 &amp;lt;http://www.rfc-editor.org/rfc/rfc4516.txt&amp;gt;\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 953, "position": [578748, 581310], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "63", "annotation": "LDAP_GET_OPTION", "group_ids": [{"name2": "NAME\u2029ldap_get_option, ldap_set_option - LDAP option handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_get_option(LDAP *ld, int option, void *outvalue);\u2029\u2029int ldap_set_option(LDAP *ld, int option, const void *invalue);\u2029\u2029DESCRIPTION\u2029These  routines  provide  access  to  options stored either in a LDAP handle or as global options, where applicable.  They make use of a neutral interface, where the type of the\u2029value either retrieved by ldap_get_option(3) or set by ldap_set_option(3) is cast to void *.  The actual type is determined based on the value of the  option  argument.   Global\u2029options are set/retrieved by passing a NULL LDAP handle. LDAP handles inherit their default settings from the global options in effect at the time the handle is created.\u2029\u2029LDAP_OPT_API_FEATURE_INFO\u2029Fills-in  a  LDAPAPIFeatureInfo;  outvalue  must be a LDAPAPIFeatureInfo *, pointing to an already allocated struct.  The ldapaif_info_version field of the struct must be\u2029initialized to LDAP_FEATURE_INFO_VERSION before making the call. The ldapaif_name field must be set to the name of a feature to query.  This is a read-only option.\u2029\u2029LDAP_OPT_API_INFO\u2029Fills-in a LDAPAPIInfo; outvalue must be a LDAPAPIInfo *, pointing to an already allocated struct. The ldapai_info_version field of the  struct  must  be  initialized  to\u2029LDAP_API_INFO_VERSION  before  making  the  call.   If the version passed in does not match the current library version, the expected version number will be stored in the\u2029struct and the call will fail.  The caller is responsible for freeing the elements of the ldapai_extensions array and the array itself using ldap_memfree(3).  The  caller\u2029must also free the ldapi_vendor_name.  This is a read-only option.\u2029\u2029LDAP_OPT_CLIENT_CONTROLS\u2029Sets/gets the client-side controls to be used for all operations.  This is now deprecated as modern LDAP C API provides replacements for all main operations which accepts\u2029client-side controls as explicit arguments; see for example ldap_search_ext(3), ldap_add_ext(3), ldap_modify_ext(3) and so on.  outvalue must be LDAPControl ***, and  the\u2029caller  is  responsible of freeing the returned controls, if any, by calling ldap_controls_free(3), while invalue must be LDAPControl *const *; the library duplicates the\u2029controls passed via invalue.\u2029\u2029LDAP_OPT_CONNECT_ASYNC\u2029Sets/gets the status of the asynchronous connect flag.  invalue should either be LDAP_OPT_OFF or LDAP_OPT_ON; outvalue must be int *.  When set,  the  library  will  call\u2029connect(2)  and return, without waiting for response.  This leaves the handle in a connecting state.  Subsequent calls to library routines will poll for completion of the\u2029connect before performing further operations.  As a consequence, library calls that need to establish a connection with a DSA do not block even for  the  network  timeout\u2029(option LDAP_OPT_NETWORK_TIMEOUT).  This option is OpenLDAP specific.\u2029\u2029LDAP_OPT_CONNECT_CB\u2029This option allows to set a connect callback.  invalue must be a const struct ldap_conncb *.  Callbacks are executed in last in-first served order.  Handle-specific call\u2010\u2029backs are executed first, followed by global ones.  Right before freeing the callback  structure,  the  lc_del  callback  handler  is  passed  a  NULL  Sockbuf.   Calling\u2029ldap_get_option(3) for this option removes the callback whose pointer matches outvalue.  This option is OpenLDAP specific.\u2029\u2029LDAP_OPT_DEBUG_LEVEL\u2029Sets/gets  the  debug  level  of  the  client  library.  invalue must be a const int *; outvalue must be a int *.  Valid debug levels are LDAP_DEBUG_ANY, LDAP_DEBUG_ARGS,\u2029LDAP_DEBUG_BER, LDAP_DEBUG_CONNS, LDAP_DEBUG_NONE, LDAP_DEBUG_PACKETS, LDAP_DEBUG_PARSE, and LDAP_DEBUG_TRACE.  This option is OpenLDAP specific.\u2029\u2029LDAP_OPT_DEFBASE\u2029Sets/gets a string containing the DN to be used as default base for search operations.  outvalue must be a char **, and the caller is responsible of freeing the  returned\u2029string by calling ldap_memfree(3), while invalue must be a const char *; the library duplicates the corresponding string.  This option is OpenLDAP specific.\u2029\u2029LDAP_OPT_DEREF\u2029Sets/gets  the  value that defines when alias dereferencing must occur.  invalue must be const int *; outvalue must be int *.  They cannot be NULL.  The value of *invalue\u2029should be one of LDAP_DEREF_NEVER (the default), LDAP_DEREF_SEARCHING, LDAP_DEREF_FINDING, or LDAP_DEREF_ALWAYS.  Note that this has ever been the only means to determine\u2029alias dereferencing within search operations.\u2029\u2029LDAP_OPT_DESC\u2029Returns the file descriptor associated to the socket buffer of the LDAP handle passed in as ld; outvalue must be a int *.  This is a read-only, handle-specific option.\u2029\u2029LDAP_OPT_DIAGNOSTIC_MESSAGE\u2029Sets/gets  a  string containing the error string associated to the LDAP handle.  This option was formerly known as LDAP_OPT_ERROR_STRING.  outvalue must be a char **, and\u2029the caller is responsible of freeing the returned string by calling ldap_memfree(3), while invalue must be a char *; the library duplicates the corresponding string.\u2029\u2029LDAP_OPT_HOST_NAME\u2029Sets/gets a space-separated list of hosts to be contacted by the library when trying to establish a connection.  This is now deprecated in favor  of  LDAP_OPT_URI.   out\u2010\u2029value  must  be  a  char  **,  and the caller is responsible of freeing the resulting string by calling ldap_memfree(3), while invalue must be a const char *; the library\u2029duplicates the corresponding string.\u2029\u2029LDAP_OPT_MATCHED_DN\u2029Sets/gets a string containing the matched DN associated to the LDAP handle.  outvalue must be a char **, and the caller is responsible of freeing the returned  string  by\u2029calling ldap_memfree(3), while invalue must be a const char *; the library duplicates the corresponding string.\u2029\u2029LDAP_OPT_NETWORK_TIMEOUT\u2029Sets/gets the network timeout value after which poll(2)/select(2) following a connect(2) returns in case of no activity.  outvalue must be a struct timeval ** (the caller\u2029has to free *outvalue), and invalue must be a const struct timeval *.  They cannot be NULL. Using a struct with seconds set to -1 results in an infinite timeout, which is\u2029the default.  This option is OpenLDAP specific.\u2029\u2029LDAP_OPT_PROTOCOL_VERSION\u2029Sets/gets the protocol version.  outvalue and invalue must be int *.\u2029\u2029LDAP_OPT_REFERRAL_URLS\u2029Sets/gets  an array containing the referral URIs associated to the LDAP handle.  outvalue must be a char ***, and the caller is responsible of freeing the returned string\u2029by calling ldap_memvfree(3), while invalue must be a NULL-terminated char *const *; the library duplicates the corresponding string.  This option is OpenLDAP specific.\u2029\u2029LDAP_OPT_REFERRALS\u2029Determines whether the library should implicitly chase referrals or not.  invalue must be const int *; its value should either be LDAP_OPT_OFF or  LDAP_OPT_ON.   outvalue\u2029must be int *.\u2029\u2029LDAP_OPT_RESTART\u2029Determines  whether the library should implicitly restart connections (FIXME).  invalue must be const int *; its value should either be LDAP_OPT_OFF or LDAP_OPT_ON.  out\u2010\u2029value must be int *.\u2029\u2029LDAP_OPT_RESULT_CODE\u2029Sets/gets the LDAP result code associated to the handle.  This option was formerly known as LDAP_OPT_ERROR_NUMBER.  invalue must be a const int *.  outvalue must be a int\u2029*.\u2029\u2029LDAP_OPT_SERVER_CONTROLS\u2029Sets/gets the server-side controls to be used for all operations.  This is now deprecated as modern LDAP C API provides replacements for all main operations which accepts\u2029server-side controls as explicit arguments; see for example ldap_search_ext(3), ldap_add_ext(3), ldap_modify_ext(3) and so on.  outvalue must be LDAPControl ***, and  the\u2029caller  is  responsible of freeing the returned controls, if any, by calling ldap_controls_free(3), while invalue must be LDAPControl *const *; the library duplicates the\u2029controls passed via invalue.\u2029\u2029LDAP_OPT_SESSION_REFCNT\u2029Returns the reference count associated with the LDAP handle passed in as ld; outvalue must be a int *.  This is a  read-only,  handle-specific  option.   This  option  is\u2029OpenLDAP specific.\u2029\u2029LDAP_OPT_SIZELIMIT\u2029Sets/gets the value that defines the maximum number of entries to be returned by a search operation.  invalue must be const int *, while outvalue must be int *; They can\u2010\u2029not be NULL.\u2029\u2029LDAP_OPT_SOCKBUF\u2029Returns a pointer to the socket buffer of the LDAP handle passed in as ld; outvalue must be a Sockbuf **.  This is a read-only, handle-specific option.   This  option  is\u2029OpenLDAP specific.\u2029\u2029LDAP_OPT_TIMELIMIT\u2029Sets/gets  the  value  that defines the time limit after which a search operation should be terminated by the server.  invalue must be const int *, while outvalue must be\u2029int *, and they cannot be NULL.\u2029\u2029LDAP_OPT_TIMEOUT\u2029Sets/gets a timeout value for the synchronous API calls.  outvalue must be a struct timeval ** (the caller has to free *outvalue), and invalue must be a struct timeval *,\u2029and they cannot be NULL. Using a struct with seconds set to -1 results in an infinite timeout, which is the default.  This option is OpenLDAP specific.\u2029\u2029LDAP_OPT_URI\u2029Sets/gets  a  comma-  or space-separated list of URIs to be contacted by the library when trying to establish a connection.  outvalue must be a char **, and the caller is\u2029responsible of freeing the resulting string by calling ldap_memfree(3), while invalue must be a const char *; the library parses the string into  a  list  of  LDAPURLDesc\u2029structures,  so  the  invocation  of  ldap_set_option(3)  may fail if URL parsing fails.  URIs may only contain the schema, the host, and the port fields.  This option is\u2029OpenLDAP specific.\u2029\u2029SASL OPTIONS\u2029The SASL options are OpenLDAP specific.\u2029\u2029LDAP_OPT_X_SASL_AUTHCID\u2029Gets the SASL authentication identity; outvalue must be a char **, its content needs to be freed by the caller using ldap_memfree(3).\u2029\u2029LDAP_OPT_X_SASL_AUTHZID\u2029Gets the SASL authorization identity; outvalue must be a char **, its content needs to be freed by the caller using ldap_memfree(3).\u2029\u2029LDAP_OPT_X_SASL_MAXBUFSIZE\u2029Gets/sets SASL maximum buffer size; invalue must be const ber_len_t *, while outvalue must be ber_len_t *.  See also LDAP_OPT_X_SASL_SECPROPS.\u2029\u2029LDAP_OPT_X_SASL_MECH\u2029Gets the SASL mechanism; outvalue must be a char **, its content needs to be freed by the caller using ldap_memfree(3).\u2029\u2029LDAP_OPT_X_SASL_MECHLIST\u2029Gets the list of the available mechanisms, in form of a NULL-terminated array of strings; outvalue must be char ***.  The caller must not free or otherwise muck with it.\u2029\u2029LDAP_OPT_X_SASL_NOCANON\u2029Sets/gets the NOCANON flag.  When unset, the hostname is canonicalized.  invalue must be const int *; its value should either be LDAP_OPT_OFF  or  LDAP_OPT_ON.   outvalue\u2029must be int *.\u2029\u2029LDAP_OPT_X_SASL_REALM\u2029Gets the SASL realm; outvalue must be a char **, its content needs to be freed by the caller using ldap_memfree(3).\u2029\u2029LDAP_OPT_X_SASL_SECPROPS\u2029Sets  the SASL secprops; invalue must be a char *, containing a comma-separated list of properties.  Legal values are: none, nodict, noplain, noactive, passcred, forward\u2010\u2029sec, noanonymous, minssf=&amp;lt;minssf&amp;gt;, maxssf=&amp;lt;maxssf&amp;gt;, maxbufsize=&amp;lt;maxbufsize&amp;gt;.\u2029\u2029LDAP_OPT_X_SASL_SSF\u2029Gets the SASL SSF; outvalue must be a ber_len_t *.\u2029\u2029LDAP_OPT_X_SASL_SSF_EXTERNAL\u2029Sets the SASL SSF value related to an authentication performed using an EXTERNAL mechanism; invalue must be a const ber_len_t *.\u2029\u2029LDAP_OPT_X_SASL_SSF_MAX\u2029Gets/sets SASL maximum SSF; invalue must be const ber_len_t *, while outvalue must be ber_len_t *.  See also LDAP_OPT_X_SASL_SECPROPS.\u2029\u2029LDAP_OPT_X_SASL_SSF_MIN\u2029Gets/sets SASL minimum SSF; invalue must be const ber_len_t *, while outvalue must be ber_len_t *.  See also LDAP_OPT_X_SASL_SECPROPS.\u2029\u2029LDAP_OPT_X_SASL_USERNAME\u2029Gets the SASL username; outvalue must be a char **.  Its content needs to be freed by the caller using ldap_memfree(3).\u2029\u2029TCP OPTIONS\u2029The TCP options are OpenLDAP specific.  Mainly intended for use with Linux, they may not be portable.\u2029\u2029LDAP_OPT_X_KEEPALIVE_IDLE\u2029Sets/gets the number of seconds a connection needs to remain idle before TCP starts sending keepalive probes.  invalue must be const int *; outvalue must be int *.\u2029\u2029LDAP_OPT_X_KEEPALIVE_PROBES\u2029Sets/gets the maximum number of keepalive probes TCP should send before dropping the connection.  invalue must be const int *; outvalue must be int *.\u2029\u2029LDAP_OPT_X_KEEPALIVE_INTERVAL\u2029Sets/gets the interval in seconds between individual keepalive probes.  invalue must be const int *; outvalue must be int *.\u2029\u2029TLS OPTIONS\u2029The TLS options are OpenLDAP specific.\u2029\u2029LDAP_OPT_X_TLS_CACERTDIR\u2029Sets/gets the path of the directory containing CA certificates.  invalue must be const char *; outvalue must be char **, and its contents need to be freed by  the  caller\u2029using ldap_memfree(3).\u2029\u2029LDAP_OPT_X_TLS_CACERTFILE\u2029Sets/gets  the  full-path  of  the  CA  certificate  file.   invalue must be const char *; outvalue must be char **, and its contents need to be freed by the caller using\u2029ldap_memfree(3).\u2029\u2029LDAP_OPT_X_TLS_CERTFILE\u2029Sets/gets the full-path of the certificate file.  invalue must be const char *; outvalue must be char **, and its contents need to be freed by the caller using  ldap_mem\u2010\u2029free(3).\u2029\u2029LDAP_OPT_X_TLS_CIPHER_SUITE\u2029Sets/gets the allowed cipher suite.  invalue must be const char *; outvalue must be char **, and its contents need to be freed by the caller using ldap_memfree(3).\u2029\u2029LDAP_OPT_X_TLS_CONNECT_ARG\u2029Sets/gets the connection callback argument.  invalue must be const void *; outvalue must be void **.\u2029\u2029LDAP_OPT_X_TLS_CONNECT_CB\u2029Sets/gets the connection callback handle.  invalue must be const LDAP_TLS_CONNECT_CB *; outvalue must be LDAP_TLS_CONNECT_CB **.\u2029\u2029LDAP_OPT_X_TLS_CRLCHECK\u2029Sets/gets  the CRL evaluation strategy, one of LDAP_OPT_X_TLS_CRL_NONE, LDAP_OPT_X_TLS_CRL_PEER, or LDAP_OPT_X_TLS_CRL_ALL.  invalue must be const int *; outvalue must be\u2029int *.  Requires OpenSSL.\u2029\u2029LDAP_OPT_X_TLS_CRLFILE\u2029Sets/gets the full-path of the CRL file.  invalue must be const char *; outvalue must be char **, and its contents need to be freed by the caller  using  ldap_memfree(3).\u2029This option is only valid for GnuTLS.\u2029\u2029LDAP_OPT_X_TLS_CTX\u2029Sets/gets  the  TLS  library context. New TLS sessions will inherit their default settings from this library context.  invalue must be const void *; outvalue must be void\u2029**.  When using the OpenSSL library this is an SSL_CTX*. When using other crypto libraries this is a pointer to an OpenLDAP  private  structure.   Applications  generally\u2029should not use this option or attempt to manipulate this structure.\u2029\u2029LDAP_OPT_X_TLS_DHFILE\u2029Gets/sets  the full-path of the file containing the parameters for Diffie-Hellman ephemeral key exchange.  invalue must be const char *; outvalue must be char **, and its\u2029contents need to be freed by the caller using ldap_memfree(3).  Ignored by GnuTLS and Mozilla NSS.\u2029\u2029LDAP_OPT_X_TLS_KEYFILE\u2029Sets/gets the full-path of the certificate key file.  invalue must be const char *; outvalue must be char **, and its contents need  to  be  freed  by  the  caller  using\u2029ldap_memfree(3).\u2029\u2029LDAP_OPT_X_TLS_NEWCTX\u2029Instructs the library to create a new TLS library context.  invalue must be const int *.  A non-zero value pointed to by invalue tells the library to create a context for\u2029a server.\u2029\u2029LDAP_OPT_X_TLS_PROTOCOL_MIN\u2029Sets/gets the minimum protocol version.  invalue must be const int *; outvalue must be int *.\u2029\u2029LDAP_OPT_X_TLS_RANDOM_FILE\u2029Sets/gets the random file when /dev/random and /dev/urandom are not available.  invalue must be const char *; outvalue must be char **, and its contents need to be  freed\u2029by the caller using ldap_memfree(3).  Ignored by GnuTLS older than version 2.2.  Ignored by Mozilla NSS.\u2029\u2029LDAP_OPT_X_TLS_REQUIRE_CERT\u2029Sets/gets the peer certificate checking strategy, one of LDAP_OPT_X_TLS_NEVER, LDAP_OPT_X_TLS_HARD, LDAP_OPT_X_TLS_DEMAND, LDAP_OPT_X_TLS_ALLOW, LDAP_OPT_X_TLS_TRY.\u2029\u2029LDAP_OPT_X_TLS_SSL_CTX\u2029Gets  the  TLS  session context associated with this handle.  outvalue must be void **.  When using the OpenSSL library this is an SSL*. When using other crypto libraries\u2029this is a pointer to an OpenLDAP private structure.  Applications generally should not use this option.\u2029\u2029ERRORS\u2029On success, the functions return LDAP_OPT_SUCCESS, while they may return LDAP_OPT_ERROR to indicate a generic option handling error.  Occasionally, more specific errors  can  be\u2029returned, like LDAP_NO_MEMORY to indicate a failure in memory allocation.\u2029\u2029NOTES\u2029The  LDAP  libraries  with  the  LDAP_OPT_REFERRALS option set to LDAP_OPT_ON (default value) automatically follow referrals using an anonymous bind.  Application developers are\u2029encouraged to either implement consistent referral chasing features, or explicitly disable referral chasing by setting that option to LDAP_OPT_OFF.\u2029\u2029The protocol version used by the library defaults to LDAPv2 (now historic), which corresponds to the LDAP_VERSION2 macro.  Application developers are  encouraged  to  explicitly\u2029set LDAP_OPT_PROTOCOL_VERSION to LDAPv3, using the LDAP_VERSION3 macro, or to allow users to select the protocol version.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), RFC 4422 (http://www.rfc-editor.org),\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 958, "position": [860325, 877637], "check": 1, "intersection": 17313, "FP_dupl": 375, "FN_dupl": 0, "F": 0.9892860203994172, "Prec_Dupl": 0.9787991858887382, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_get_option, ldap_set_option - LDAP option handling routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_get_option(LDAP *ld, int option, void *outvalue);\u2029\u2029int ldap_set_option(LDAP *ld, int option, const void *invalue);\u2029\u2029DESCRIPTION\u2029These  routines  provide  access  to  options stored either in a LDAP handle or as global options, where applicable.  They make use of a neutral interface, where the type of the\u2029value either retrieved by ldap_get_option(3) or set by ldap_set_option(3) is cast to void *.  The actual type is determined based on the value of the  option  argument.   Global\u2029options are set/retrieved by passing a NULL LDAP handle. LDAP handles inherit their default settings from the global options in effect at the time the handle is created.\u2029\u2029LDAP_OPT_API_FEATURE_INFO\u2029Fills-in  a  LDAPAPIFeatureInfo;  outvalue  must be a LDAPAPIFeatureInfo *, pointing to an already allocated struct.  The ldapaif_info_version field of the struct must be\u2029initialized to LDAP_FEATURE_INFO_VERSION before making the call. The ldapaif_name field must be set to the name of a feature to query.  This is a read-only option.\u2029\u2029LDAP_OPT_API_INFO\u2029Fills-in a LDAPAPIInfo; outvalue must be a LDAPAPIInfo *, pointing to an already allocated struct. The ldapai_info_version field of the  struct  must  be  initialized  to\u2029LDAP_API_INFO_VERSION  before  making  the  call.   If the version passed in does not match the current library version, the expected version number will be stored in the\u2029struct and the call will fail.  The caller is responsible for freeing the elements of the ldapai_extensions array and the array itself using ldap_memfree(3).  The  caller\u2029must also free the ldapi_vendor_name.  This is a read-only option.\u2029\u2029LDAP_OPT_CLIENT_CONTROLS\u2029Sets/gets the client-side controls to be used for all operations.  This is now deprecated as modern LDAP C API provides replacements for all main operations which accepts\u2029client-side controls as explicit arguments; see for example ldap_search_ext(3), ldap_add_ext(3), ldap_modify_ext(3) and so on.  outvalue must be LDAPControl ***, and  the\u2029caller  is  responsible of freeing the returned controls, if any, by calling ldap_controls_free(3), while invalue must be LDAPControl *const *; the library duplicates the\u2029controls passed via invalue.\u2029\u2029LDAP_OPT_CONNECT_ASYNC\u2029Sets/gets the status of the asynchronous connect flag.  invalue should either be LDAP_OPT_OFF or LDAP_OPT_ON; outvalue must be int *.  When set,  the  library  will  call\u2029connect(2)  and return, without waiting for response.  This leaves the handle in a connecting state.  Subsequent calls to library routines will poll for completion of the\u2029connect before performing further operations.  As a consequence, library calls that need to establish a connection with a DSA do not block even for  the  network  timeout\u2029(option LDAP_OPT_NETWORK_TIMEOUT).  This option is OpenLDAP specific.\u2029\u2029LDAP_OPT_CONNECT_CB\u2029This option allows to set a connect callback.  invalue must be a const struct ldap_conncb *.  Callbacks are executed in last in-first served order.  Handle-specific call\u2010\u2029backs are executed first, followed by global ones.  Right before freeing the callback  structure,  the  lc_del  callback  handler  is  passed  a  NULL  Sockbuf.   Calling\u2029ldap_get_option(3) for this option removes the callback whose pointer matches outvalue.  This option is OpenLDAP specific.\u2029\u2029LDAP_OPT_DEBUG_LEVEL\u2029Sets/gets  the  debug  level  of  the  client  library.  invalue must be a const int *; outvalue must be a int *.  Valid debug levels are LDAP_DEBUG_ANY, LDAP_DEBUG_ARGS,\u2029LDAP_DEBUG_BER, LDAP_DEBUG_CONNS, LDAP_DEBUG_NONE, LDAP_DEBUG_PACKETS, LDAP_DEBUG_PARSE, and LDAP_DEBUG_TRACE.  This option is OpenLDAP specific.\u2029\u2029LDAP_OPT_DEFBASE\u2029Sets/gets a string containing the DN to be used as default base for search operations.  outvalue must be a char **, and the caller is responsible of freeing the  returned\u2029string by calling ldap_memfree(3), while invalue must be a const char *; the library duplicates the corresponding string.  This option is OpenLDAP specific.\u2029\u2029LDAP_OPT_DEREF\u2029Sets/gets  the  value that defines when alias dereferencing must occur.  invalue must be const int *; outvalue must be int *.  They cannot be NULL.  The value of *invalue\u2029should be one of LDAP_DEREF_NEVER (the default), LDAP_DEREF_SEARCHING, LDAP_DEREF_FINDING, or LDAP_DEREF_ALWAYS.  Note that this has ever been the only means to determine\u2029alias dereferencing within search operations.\u2029\u2029LDAP_OPT_DESC\u2029Returns the file descriptor associated to the socket buffer of the LDAP handle passed in as ld; outvalue must be a int *.  This is a read-only, handle-specific option.\u2029\u2029LDAP_OPT_DIAGNOSTIC_MESSAGE\u2029Sets/gets  a  string containing the error string associated to the LDAP handle.  This option was formerly known as LDAP_OPT_ERROR_STRING.  outvalue must be a char **, and\u2029the caller is responsible of freeing the returned string by calling ldap_memfree(3), while invalue must be a char *; the library duplicates the corresponding string.\u2029\u2029LDAP_OPT_HOST_NAME\u2029Sets/gets a space-separated list of hosts to be contacted by the library when trying to establish a connection.  This is now deprecated in favor  of  LDAP_OPT_URI.   out\u2010\u2029value  must  be  a  char  **,  and the caller is responsible of freeing the resulting string by calling ldap_memfree(3), while invalue must be a const char *; the library\u2029duplicates the corresponding string.\u2029\u2029LDAP_OPT_MATCHED_DN\u2029Sets/gets a string containing the matched DN associated to the LDAP handle.  outvalue must be a char **, and the caller is responsible of freeing the returned  string  by\u2029calling ldap_memfree(3), while invalue must be a const char *; the library duplicates the corresponding string.\u2029\u2029LDAP_OPT_NETWORK_TIMEOUT\u2029Sets/gets the network timeout value after which poll(2)/select(2) following a connect(2) returns in case of no activity.  outvalue must be a struct timeval ** (the caller\u2029has to free *outvalue), and invalue must be a const struct timeval *.  They cannot be NULL. Using a struct with seconds set to -1 results in an infinite timeout, which is\u2029the default.  This option is OpenLDAP specific.\u2029\u2029LDAP_OPT_PROTOCOL_VERSION\u2029Sets/gets the protocol version.  outvalue and invalue must be int *.\u2029\u2029LDAP_OPT_REFERRAL_URLS\u2029Sets/gets  an array containing the referral URIs associated to the LDAP handle.  outvalue must be a char ***, and the caller is responsible of freeing the returned string\u2029by calling ldap_memvfree(3), while invalue must be a NULL-terminated char *const *; the library duplicates the corresponding string.  This option is OpenLDAP specific.\u2029\u2029LDAP_OPT_REFERRALS\u2029Determines whether the library should implicitly chase referrals or not.  invalue must be const int *; its value should either be LDAP_OPT_OFF or  LDAP_OPT_ON.   outvalue\u2029must be int *.\u2029\u2029LDAP_OPT_RESTART\u2029Determines  whether the library should implicitly restart connections (FIXME).  invalue must be const int *; its value should either be LDAP_OPT_OFF or LDAP_OPT_ON.  out\u2010\u2029value must be int *.\u2029\u2029LDAP_OPT_RESULT_CODE\u2029Sets/gets the LDAP result code associated to the handle.  This option was formerly known as LDAP_OPT_ERROR_NUMBER.  invalue must be a const int *.  outvalue must be a int\u2029*.\u2029\u2029LDAP_OPT_SERVER_CONTROLS\u2029Sets/gets the server-side controls to be used for all operations.  This is now deprecated as modern LDAP C API provides replacements for all main operations which accepts\u2029server-side controls as explicit arguments; see for example ldap_search_ext(3), ldap_add_ext(3), ldap_modify_ext(3) and so on.  outvalue must be LDAPControl ***, and  the\u2029caller  is  responsible of freeing the returned controls, if any, by calling ldap_controls_free(3), while invalue must be LDAPControl *const *; the library duplicates the\u2029controls passed via invalue.\u2029\u2029LDAP_OPT_SESSION_REFCNT\u2029Returns the reference count associated with the LDAP handle passed in as ld; outvalue must be a int *.  This is a  read-only,  handle-specific  option.   This  option  is\u2029OpenLDAP specific.\u2029\u2029LDAP_OPT_SIZELIMIT\u2029Sets/gets the value that defines the maximum number of entries to be returned by a search operation.  invalue must be const int *, while outvalue must be int *; They can\u2010\u2029not be NULL.\u2029\u2029LDAP_OPT_SOCKBUF\u2029Returns a pointer to the socket buffer of the LDAP handle passed in as ld; outvalue must be a Sockbuf **.  This is a read-only, handle-specific option.   This  option  is\u2029OpenLDAP specific.\u2029\u2029LDAP_OPT_TIMELIMIT\u2029Sets/gets  the  value  that defines the time limit after which a search operation should be terminated by the server.  invalue must be const int *, while outvalue must be\u2029int *, and they cannot be NULL.\u2029\u2029LDAP_OPT_TIMEOUT\u2029Sets/gets a timeout value for the synchronous API calls.  outvalue must be a struct timeval ** (the caller has to free *outvalue), and invalue must be a struct timeval *,\u2029and they cannot be NULL. Using a struct with seconds set to -1 results in an infinite timeout, which is the default.  This option is OpenLDAP specific.\u2029\u2029LDAP_OPT_URI\u2029Sets/gets  a  comma-  or space-separated list of URIs to be contacted by the library when trying to establish a connection.  outvalue must be a char **, and the caller is\u2029responsible of freeing the resulting string by calling ldap_memfree(3), while invalue must be a const char *; the library parses the string into  a  list  of  LDAPURLDesc\u2029structures,  so  the  invocation  of  ldap_set_option(3)  may fail if URL parsing fails.  URIs may only contain the schema, the host, and the port fields.  This option is\u2029OpenLDAP specific.\u2029\u2029SASL OPTIONS\u2029The SASL options are OpenLDAP specific.\u2029\u2029LDAP_OPT_X_SASL_AUTHCID\u2029Gets the SASL authentication identity; outvalue must be a char **, its content needs to be freed by the caller using ldap_memfree(3).\u2029\u2029LDAP_OPT_X_SASL_AUTHZID\u2029Gets the SASL authorization identity; outvalue must be a char **, its content needs to be freed by the caller using ldap_memfree(3).\u2029\u2029LDAP_OPT_X_SASL_MAXBUFSIZE\u2029Gets/sets SASL maximum buffer size; invalue must be const ber_len_t *, while outvalue must be ber_len_t *.  See also LDAP_OPT_X_SASL_SECPROPS.\u2029\u2029LDAP_OPT_X_SASL_MECH\u2029Gets the SASL mechanism; outvalue must be a char **, its content needs to be freed by the caller using ldap_memfree(3).\u2029\u2029LDAP_OPT_X_SASL_MECHLIST\u2029Gets the list of the available mechanisms, in form of a NULL-terminated array of strings; outvalue must be char ***.  The caller must not free or otherwise muck with it.\u2029\u2029LDAP_OPT_X_SASL_NOCANON\u2029Sets/gets the NOCANON flag.  When unset, the hostname is canonicalized.  invalue must be const int *; its value should either be LDAP_OPT_OFF  or  LDAP_OPT_ON.   outvalue\u2029must be int *.\u2029\u2029LDAP_OPT_X_SASL_REALM\u2029Gets the SASL realm; outvalue must be a char **, its content needs to be freed by the caller using ldap_memfree(3).\u2029\u2029LDAP_OPT_X_SASL_SECPROPS\u2029Sets  the SASL secprops; invalue must be a char *, containing a comma-separated list of properties.  Legal values are: none, nodict, noplain, noactive, passcred, forward\u2010\u2029sec, noanonymous, minssf=&amp;lt;minssf&amp;gt;, maxssf=&amp;lt;maxssf&amp;gt;, maxbufsize=&amp;lt;maxbufsize&amp;gt;.\u2029\u2029LDAP_OPT_X_SASL_SSF\u2029Gets the SASL SSF; outvalue must be a ber_len_t *.\u2029\u2029LDAP_OPT_X_SASL_SSF_EXTERNAL\u2029Sets the SASL SSF value related to an authentication performed using an EXTERNAL mechanism; invalue must be a const ber_len_t *.\u2029\u2029LDAP_OPT_X_SASL_SSF_MAX\u2029Gets/sets SASL maximum SSF; invalue must be const ber_len_t *, while outvalue must be ber_len_t *.  See also LDAP_OPT_X_SASL_SECPROPS.\u2029\u2029LDAP_OPT_X_SASL_SSF_MIN\u2029Gets/sets SASL minimum SSF; invalue must be const ber_len_t *, while outvalue must be ber_len_t *.  See also LDAP_OPT_X_SASL_SECPROPS.\u2029\u2029LDAP_OPT_X_SASL_USERNAME\u2029Gets the SASL username; outvalue must be a char **.  Its content needs to be freed by the caller using ldap_memfree(3).\u2029\u2029TCP OPTIONS\u2029The TCP options are OpenLDAP specific.  Mainly intended for use with Linux, they may not be portable.\u2029\u2029LDAP_OPT_X_KEEPALIVE_IDLE\u2029Sets/gets the number of seconds a connection needs to remain idle before TCP starts sending keepalive probes.  invalue must be const int *; outvalue must be int *.\u2029\u2029LDAP_OPT_X_KEEPALIVE_PROBES\u2029Sets/gets the maximum number of keepalive probes TCP should send before dropping the connection.  invalue must be const int *; outvalue must be int *.\u2029\u2029LDAP_OPT_X_KEEPALIVE_INTERVAL\u2029Sets/gets the interval in seconds between individual keepalive probes.  invalue must be const int *; outvalue must be int *.\u2029\u2029TLS OPTIONS\u2029The TLS options are OpenLDAP specific.\u2029\u2029LDAP_OPT_X_TLS_CACERTDIR\u2029Sets/gets the path of the directory containing CA certificates.  invalue must be const char *; outvalue must be char **, and its contents need to be freed by  the  caller\u2029using ldap_memfree(3).\u2029\u2029LDAP_OPT_X_TLS_CACERTFILE\u2029Sets/gets  the  full-path  of  the  CA  certificate  file.   invalue must be const char *; outvalue must be char **, and its contents need to be freed by the caller using\u2029ldap_memfree(3).\u2029\u2029LDAP_OPT_X_TLS_CERTFILE\u2029Sets/gets the full-path of the certificate file.  invalue must be const char *; outvalue must be char **, and its contents need to be freed by the caller using  ldap_mem\u2010\u2029free(3).\u2029\u2029LDAP_OPT_X_TLS_CIPHER_SUITE\u2029Sets/gets the allowed cipher suite.  invalue must be const char *; outvalue must be char **, and its contents need to be freed by the caller using ldap_memfree(3).\u2029\u2029LDAP_OPT_X_TLS_CONNECT_ARG\u2029Sets/gets the connection callback argument.  invalue must be const void *; outvalue must be void **.\u2029\u2029LDAP_OPT_X_TLS_CONNECT_CB\u2029Sets/gets the connection callback handle.  invalue must be const LDAP_TLS_CONNECT_CB *; outvalue must be LDAP_TLS_CONNECT_CB **.\u2029\u2029LDAP_OPT_X_TLS_CRLCHECK\u2029Sets/gets  the CRL evaluation strategy, one of LDAP_OPT_X_TLS_CRL_NONE, LDAP_OPT_X_TLS_CRL_PEER, or LDAP_OPT_X_TLS_CRL_ALL.  invalue must be const int *; outvalue must be\u2029int *.  Requires OpenSSL.\u2029\u2029LDAP_OPT_X_TLS_CRLFILE\u2029Sets/gets the full-path of the CRL file.  invalue must be const char *; outvalue must be char **, and its contents need to be freed by the caller  using  ldap_memfree(3).\u2029This option is only valid for GnuTLS.\u2029\u2029LDAP_OPT_X_TLS_CTX\u2029Sets/gets  the  TLS  library context. New TLS sessions will inherit their default settings from this library context.  invalue must be const void *; outvalue must be void\u2029**.  When using the OpenSSL library this is an SSL_CTX*. When using other crypto libraries this is a pointer to an OpenLDAP  private  structure.   Applications  generally\u2029should not use this option or attempt to manipulate this structure.\u2029\u2029LDAP_OPT_X_TLS_DHFILE\u2029Gets/sets  the full-path of the file containing the parameters for Diffie-Hellman ephemeral key exchange.  invalue must be const char *; outvalue must be char **, and its\u2029contents need to be freed by the caller using ldap_memfree(3).  Ignored by GnuTLS and Mozilla NSS.\u2029\u2029LDAP_OPT_X_TLS_KEYFILE\u2029Sets/gets the full-path of the certificate key file.  invalue must be const char *; outvalue must be char **, and its contents need  to  be  freed  by  the  caller  using\u2029ldap_memfree(3).\u2029\u2029LDAP_OPT_X_TLS_NEWCTX\u2029Instructs the library to create a new TLS library context.  invalue must be const int *.  A non-zero value pointed to by invalue tells the library to create a context for\u2029a server.\u2029\u2029LDAP_OPT_X_TLS_PROTOCOL_MIN\u2029Sets/gets the minimum protocol version.  invalue must be const int *; outvalue must be int *.\u2029\u2029LDAP_OPT_X_TLS_RANDOM_FILE\u2029Sets/gets the random file when /dev/random and /dev/urandom are not available.  invalue must be const char *; outvalue must be char **, and its contents need to be  freed\u2029by the caller using ldap_memfree(3).  Ignored by GnuTLS older than version 2.2.  Ignored by Mozilla NSS.\u2029\u2029LDAP_OPT_X_TLS_REQUIRE_CERT\u2029Sets/gets the peer certificate checking strategy, one of LDAP_OPT_X_TLS_NEVER, LDAP_OPT_X_TLS_HARD, LDAP_OPT_X_TLS_DEMAND, LDAP_OPT_X_TLS_ALLOW, LDAP_OPT_X_TLS_TRY.\u2029\u2029LDAP_OPT_X_TLS_SSL_CTX\u2029Gets  the  TLS  session context associated with this handle.  outvalue must be void **.  When using the OpenSSL library this is an SSL*. When using other crypto libraries\u2029this is a pointer to an OpenLDAP private structure.  Applications generally should not use this option.\u2029\u2029ERRORS\u2029On success, the functions return LDAP_OPT_SUCCESS, while they may return LDAP_OPT_ERROR to indicate a generic option handling error.  Occasionally, more specific errors  can  be\u2029returned, like LDAP_NO_MEMORY to indicate a failure in memory allocation.\u2029\u2029NOTES\u2029The  LDAP  libraries  with  the  LDAP_OPT_REFERRALS option set to LDAP_OPT_ON (default value) automatically follow referrals using an anonymous bind.  Application developers are\u2029encouraged to either implement consistent referral chasing features, or explicitly disable referral chasing by setting that option to LDAP_OPT_OFF.\u2029\u2029The protocol version used by the library defaults to LDAPv2 (now historic), which corresponds to the LDAP_VERSION2 macro.  Application developers are  encouraged  to  explicitly\u2029set LDAP_OPT_PROTOCOL_VERSION to LDAPv3, using the LDAP_VERSION3 macro, or to allow users to select the protocol version.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3), RFC 4422 (http://www.rfc-editor.org),\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 957, "position": [588150, 605462], "check": 1, "intersection": 17313, "FP_dupl": 375, "FN_dupl": 0, "F": 0.9892860203994172, "Prec_Dupl": 0.9787991858887382, "Recall_Dupl": 1.0}]}, {"name": "64", "annotation": "LDAP_TLS", "group_ids": [{"name2": "NAME\u2029ldap_start_tls, ldap_start_tls_s, ldap_tls_inplace, ldap_install_tls - LDAP TLS initialization routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_start_tls(LDAP *ld);\u2029\u2029int ldap_start_tls_s(LDAP *ld, LDAPControl **serverctrls, LDAPControl **clientctrls);\u2029\u2029int ldap_tls_inplace(LDAP *ld);\u2029\u2029int ldap_install_tls(LDAP *ld);\u2029\u2029DESCRIPTION\u2029These  routines are used to initiate TLS processing on an LDAP session.  ldap_start_tls_s() sends a StartTLS request to a server, waits for the reply, and then installs TLS han\u2010\u2029dlers on the session if the request succeeded. The routine returns LDAP_SUCCESS if everything succeeded, otherwise it returns an  LDAP  error  code.   ldap_start_tls()  sends  a\u2029StartTLS  request  to  a  server  and  does  nothing  else. It returns LDAP_SUCCESS if the request was sent successfully.  ldap_tls_inplace() returns 1 if TLS handlers have been\u2029installed on the specified session, 0 otherwise.  ldap_install_tls() installs the TLS handlers on the given session. It returns LDAP_LOCAL_ERROR if TLS is already installed.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 963, "position": [1006050, 1007385], "check": 1, "intersection": 1336, "FP_dupl": 2083, "FN_dupl": 0, "F": 0.5619348054679285, "Prec_Dupl": 0.3907575314419421, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_start_tls, ldap_start_tls_s, ldap_tls_inplace, ldap_install_tls - LDAP TLS initialization routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_start_tls(LDAP *ld);\u2029\u2029int ldap_start_tls_s(LDAP *ld, LDAPControl **serverctrls, LDAPControl **clientctrls);\u2029\u2029int ldap_tls_inplace(LDAP *ld);\u2029\u2029int ldap_install_tls(LDAP *ld);\u2029\u2029DESCRIPTION\u2029These  routines are used to initiate TLS processing on an LDAP session.  ldap_start_tls_s() sends a StartTLS request to a server, waits for the reply, and then installs TLS han\u2010\u2029dlers on the session if the request succeeded. The routine returns LDAP_SUCCESS if everything succeeded, otherwise it returns an  LDAP  error  code.   ldap_start_tls()  sends  a\u2029StartTLS  request  to  a  server  and  does  nothing  else. It returns LDAP_SUCCESS if the request was sent successfully.  ldap_tls_inplace() returns 1 if TLS handlers have been\u2029installed on the specified session, 0 otherwise.  ldap_install_tls() installs the TLS handlers on the given session. It returns LDAP_LOCAL_ERROR if TLS is already installed.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 962, "position": [1004342, 1005677], "check": 1, "intersection": 1336, "FP_dupl": 2083, "FN_dupl": 0, "F": 0.5619348054679285, "Prec_Dupl": 0.3907575314419421, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_start_tls, ldap_start_tls_s, ldap_tls_inplace, ldap_install_tls - LDAP TLS initialization routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_start_tls(LDAP *ld);\u2029\u2029int ldap_start_tls_s(LDAP *ld, LDAPControl **serverctrls, LDAPControl **clientctrls);\u2029\u2029int ldap_tls_inplace(LDAP *ld);\u2029\u2029int ldap_install_tls(LDAP *ld);\u2029\u2029DESCRIPTION\u2029These  routines are used to initiate TLS processing on an LDAP session.  ldap_start_tls_s() sends a StartTLS request to a server, waits for the reply, and then installs TLS han\u2010\u2029dlers on the session if the request succeeded. The routine returns LDAP_SUCCESS if everything succeeded, otherwise it returns an  LDAP  error  code.   ldap_start_tls()  sends  a\u2029StartTLS  request  to  a  server  and  does  nothing  else. It returns LDAP_SUCCESS if the request was sent successfully.  ldap_tls_inplace() returns 1 if TLS handlers have been\u2029installed on the specified session, 0 otherwise.  ldap_install_tls() installs the TLS handlers on the given session. It returns LDAP_LOCAL_ERROR if TLS is already installed.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 961, "position": [923948, 925283], "check": 1, "intersection": 1336, "FP_dupl": 2083, "FN_dupl": 0, "F": 0.5619348054679285, "Prec_Dupl": 0.3907575314419421, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_start_tls, ldap_start_tls_s, ldap_tls_inplace, ldap_install_tls - LDAP TLS initialization routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_start_tls(LDAP *ld);\u2029\u2029int ldap_start_tls_s(LDAP *ld, LDAPControl **serverctrls, LDAPControl **clientctrls);\u2029\u2029int ldap_tls_inplace(LDAP *ld);\u2029\u2029int ldap_install_tls(LDAP *ld);\u2029\u2029DESCRIPTION\u2029These  routines are used to initiate TLS processing on an LDAP session.  ldap_start_tls_s() sends a StartTLS request to a server, waits for the reply, and then installs TLS han\u2010\u2029dlers on the session if the request succeeded. The routine returns LDAP_SUCCESS if everything succeeded, otherwise it returns an  LDAP  error  code.   ldap_start_tls()  sends  a\u2029StartTLS  request  to  a  server  and  does  nothing  else. It returns LDAP_SUCCESS if the request was sent successfully.  ldap_tls_inplace() returns 1 if TLS handlers have been\u2029installed on the specified session, 0 otherwise.  ldap_install_tls() installs the TLS handlers on the given session. It returns LDAP_LOCAL_ERROR if TLS is already installed.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 960, "position": [922240, 923575], "check": 1, "intersection": 1336, "FP_dupl": 2083, "FN_dupl": 0, "F": 0.5619348054679285, "Prec_Dupl": 0.3907575314419421, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_start_tls, ldap_start_tls_s, ldap_tls_inplace, ldap_install_tls - LDAP TLS initialization routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_start_tls(LDAP *ld);\u2029\u2029int ldap_start_tls_s(LDAP *ld, LDAPControl **serverctrls, LDAPControl **clientctrls);\u2029\u2029int ldap_tls_inplace(LDAP *ld);\u2029\u2029int ldap_install_tls(LDAP *ld);\u2029\u2029DESCRIPTION\u2029These  routines are used to initiate TLS processing on an LDAP session.  ldap_start_tls_s() sends a StartTLS request to a server, waits for the reply, and then installs TLS han\u2010\u2029dlers on the session if the request succeeded. The routine returns LDAP_SUCCESS if everything succeeded, otherwise it returns an  LDAP  error  code.   ldap_start_tls()  sends  a\u2029StartTLS  request  to  a  server  and  does  nothing  else. It returns LDAP_SUCCESS if the request was sent successfully.  ldap_tls_inplace() returns 1 if TLS handlers have been\u2029installed on the specified session, 0 otherwise.  ldap_install_tls() installs the TLS handlers on the given session. It returns LDAP_LOCAL_ERROR if TLS is already installed.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 959, "position": [628984, 630319], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "65", "annotation": "LDAP_MEMORY", "group_ids": [{"name2": "NAME\u2029ldap_memfree, ldap_memvfree, ldap_memalloc, ldap_memcalloc, ldap_memrealloc, ldap_strdup - LDAP memory allocation routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029void ldap_memfree(void *p);\u2029\u2029void ldap_memvfree(void **v);\u2029\u2029void *ldap_memalloc(ber_len_t s);\u2029\u2029void *ldap_memcalloc(ber_len_t n, ber_len_t s);\u2029\u2029void *ldap_memrealloc(void *p, ber_len_t s);\u2029\u2029char *ldap_strdup(LDAP_CONST char *p);\u2029\u2029DESCRIPTION\u2029These  routines  are  used  to  allocate/deallocate  memory used/returned by the LDAP library.  ldap_memalloc(), ldap_memcalloc(), ldap_memrealloc(), and ldap_memfree() are used\u2029exactly like the standard malloc(3), calloc(3), realloc(3), and free(3) routines, respectively.  The ldap_memvfree() routine is used to free a  dynamically  allocated  array  of\u2029pointers to arbitrary dynamically allocated objects.  The ldap_strdup() routine is used exactly like the standard strdup(3) routine.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 970, "position": [967243, 968409], "check": 1, "intersection": 1167, "FP_dupl": 26715, "FN_dupl": 0, "F": 0.08034699989672624, "Prec_Dupl": 0.04185496018936949, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_memfree, ldap_memvfree, ldap_memalloc, ldap_memcalloc, ldap_memrealloc, ldap_strdup - LDAP memory allocation routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029void ldap_memfree(void *p);\u2029\u2029void ldap_memvfree(void **v);\u2029\u2029void *ldap_memalloc(ber_len_t s);\u2029\u2029void *ldap_memcalloc(ber_len_t n, ber_len_t s);\u2029\u2029void *ldap_memrealloc(void *p, ber_len_t s);\u2029\u2029char *ldap_strdup(LDAP_CONST char *p);\u2029\u2029DESCRIPTION\u2029These  routines  are  used  to  allocate/deallocate  memory used/returned by the LDAP library.  ldap_memalloc(), ldap_memcalloc(), ldap_memrealloc(), and ldap_memfree() are used\u2029exactly like the standard malloc(3), calloc(3), realloc(3), and free(3) routines, respectively.  The ldap_memvfree() routine is used to free a  dynamically  allocated  array  of\u2029pointers to arbitrary dynamically allocated objects.  The ldap_strdup() routine is used exactly like the standard strdup(3) routine.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 969, "position": [667662, 668828], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_memfree, ldap_memvfree, ldap_memalloc, ldap_memcalloc, ldap_memrealloc, ldap_strdup - LDAP memory allocation routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029void ldap_memfree(void *p);\u2029\u2029void ldap_memvfree(void **v);\u2029\u2029void *ldap_memalloc(ber_len_t s);\u2029\u2029void *ldap_memcalloc(ber_len_t n, ber_len_t s);\u2029\u2029void *ldap_memrealloc(void *p, ber_len_t s);\u2029\u2029char *ldap_strdup(LDAP_CONST char *p);\u2029\u2029DESCRIPTION\u2029These  routines  are  used  to  allocate/deallocate  memory used/returned by the LDAP library.  ldap_memalloc(), ldap_memcalloc(), ldap_memrealloc(), and ldap_memfree() are used\u2029exactly like the standard malloc(3), calloc(3), realloc(3), and free(3) routines, respectively.  The ldap_memvfree() routine is used to free a  dynamically  allocated  array  of\u2029pointers to arbitrary dynamically allocated objects.  The ldap_strdup() routine is used exactly like the standard strdup(3) routine.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 968, "position": [666123, 667289], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_memfree, ldap_memvfree, ldap_memalloc, ldap_memcalloc, ldap_memrealloc, ldap_strdup - LDAP memory allocation routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029void ldap_memfree(void *p);\u2029\u2029void ldap_memvfree(void **v);\u2029\u2029void *ldap_memalloc(ber_len_t s);\u2029\u2029void *ldap_memcalloc(ber_len_t n, ber_len_t s);\u2029\u2029void *ldap_memrealloc(void *p, ber_len_t s);\u2029\u2029char *ldap_strdup(LDAP_CONST char *p);\u2029\u2029DESCRIPTION\u2029These  routines  are  used  to  allocate/deallocate  memory used/returned by the LDAP library.  ldap_memalloc(), ldap_memcalloc(), ldap_memrealloc(), and ldap_memfree() are used\u2029exactly like the standard malloc(3), calloc(3), realloc(3), and free(3) routines, respectively.  The ldap_memvfree() routine is used to free a  dynamically  allocated  array  of\u2029pointers to arbitrary dynamically allocated objects.  The ldap_strdup() routine is used exactly like the standard strdup(3) routine.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 967, "position": [664584, 665750], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_memfree, ldap_memvfree, ldap_memalloc, ldap_memcalloc, ldap_memrealloc, ldap_strdup - LDAP memory allocation routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029void ldap_memfree(void *p);\u2029\u2029void ldap_memvfree(void **v);\u2029\u2029void *ldap_memalloc(ber_len_t s);\u2029\u2029void *ldap_memcalloc(ber_len_t n, ber_len_t s);\u2029\u2029void *ldap_memrealloc(void *p, ber_len_t s);\u2029\u2029char *ldap_strdup(LDAP_CONST char *p);\u2029\u2029DESCRIPTION\u2029These  routines  are  used  to  allocate/deallocate  memory used/returned by the LDAP library.  ldap_memalloc(), ldap_memcalloc(), ldap_memrealloc(), and ldap_memfree() are used\u2029exactly like the standard malloc(3), calloc(3), realloc(3), and free(3) routines, respectively.  The ldap_memvfree() routine is used to free a  dynamically  allocated  array  of\u2029pointers to arbitrary dynamically allocated objects.  The ldap_strdup() routine is used exactly like the standard strdup(3) routine.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 966, "position": [663045, 664211], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_memfree, ldap_memvfree, ldap_memalloc, ldap_memcalloc, ldap_memrealloc, ldap_strdup - LDAP memory allocation routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029void ldap_memfree(void *p);\u2029\u2029void ldap_memvfree(void **v);\u2029\u2029void *ldap_memalloc(ber_len_t s);\u2029\u2029void *ldap_memcalloc(ber_len_t n, ber_len_t s);\u2029\u2029void *ldap_memrealloc(void *p, ber_len_t s);\u2029\u2029char *ldap_strdup(LDAP_CONST char *p);\u2029\u2029DESCRIPTION\u2029These  routines  are  used  to  allocate/deallocate  memory used/returned by the LDAP library.  ldap_memalloc(), ldap_memcalloc(), ldap_memrealloc(), and ldap_memfree() are used\u2029exactly like the standard malloc(3), calloc(3), realloc(3), and free(3) routines, respectively.  The ldap_memvfree() routine is used to free a  dynamically  allocated  array  of\u2029pointers to arbitrary dynamically allocated objects.  The ldap_strdup() routine is used exactly like the standard strdup(3) routine.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 965, "position": [661506, 662672], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_memfree, ldap_memvfree, ldap_memalloc, ldap_memcalloc, ldap_memrealloc, ldap_strdup - LDAP memory allocation routines\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029void ldap_memfree(void *p);\u2029\u2029void ldap_memvfree(void **v);\u2029\u2029void *ldap_memalloc(ber_len_t s);\u2029\u2029void *ldap_memcalloc(ber_len_t n, ber_len_t s);\u2029\u2029void *ldap_memrealloc(void *p, ber_len_t s);\u2029\u2029char *ldap_strdup(LDAP_CONST char *p);\u2029\u2029DESCRIPTION\u2029These  routines  are  used  to  allocate/deallocate  memory used/returned by the LDAP library.  ldap_memalloc(), ldap_memcalloc(), ldap_memrealloc(), and ldap_memfree() are used\u2029exactly like the standard malloc(3), calloc(3), realloc(3), and free(3) routines, respectively.  The ldap_memvfree() routine is used to free a  dynamically  allocated  array  of\u2029pointers to arbitrary dynamically allocated objects.  The ldap_strdup() routine is used exactly like the standard strdup(3) routine.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 964, "position": [659967, 661133], "check": 1, "intersection": 1167, "FP_dupl": 26715, "FN_dupl": 0, "F": 0.08034699989672624, "Prec_Dupl": 0.04185496018936949, "Recall_Dupl": 1.0}]}, {"name": "66", "annotation": "LDAP_MODIFY", "group_ids": [{"name2": "NAME\u2029ldap_modify_ext, ldap_modify_ext_s - Perform an LDAP modify operation\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_modify_ext(\u2029LDAP *ld,\u2029char *dn,\u2029LDAPMod *mods[],\u2029LDAPControl **sctrls,\u2029LDAPControl **cctrls,\u2029int *msgidp );\u2029\u2029int ldap_modify_ext_s(\u2029LDAP *ld,\u2029char *dn,\u2029LDAPMod *mods[],\u2029LDAPControl **sctrls,\u2029LDAPControl **cctrls );\u2029\u2029void ldap_mods_free(\u2029LDAPMod **mods,\u2029int freemods );\u2029\u2029DESCRIPTION\u2029The  routine  ldap_modify_ext_s() is used to perform an LDAP modify operation.  dn is the DN of the entry to modify, and mods is a null-terminated array of modifications to make\u2029to the entry.  Each element of the mods array is a pointer to an LDAPMod structure, which is defined below.\u2029\u2029typedef struct ldapmod {\u2029int mod_op;\u2029char *mod_type;\u2029union {\u2029char **modv_strvals;\u2029struct berval **modv_bvals;\u2029} mod_vals;\u2029struct ldapmod *mod_next;\u2029} LDAPMod;\u2029#define mod_values mod_vals.modv_strvals\u2029#define mod_bvalues mod_vals.modv_bvals\u2029\u2029The mod_op field is used to specify the type of modification to perform and should be one of LDAP_MOD_ADD, LDAP_MOD_DELETE, or LDAP_MOD_REPLACE.   The  mod_type  and  mod_values\u2029fields  specify  the  attribute type to modify and a null-terminated array of values to add, delete, or replace respectively.  The mod_next field is used only by the LDAP server\u2029and may be ignored by the client.\u2029\u2029If you need to specify a non-string value (e.g., to add a photo or audio attribute value),  you  should  set  mod_op  to  the  logical  OR  of  the  operation  as  above  (e.g.,\u2029LDAP_MOD_REPLACE)  and  the  constant LDAP_MOD_BVALUES.  In this case, mod_bvalues should be used instead of mod_values, and it should point to a null-terminated array of struct\u2029bervals, as defined in &amp;lt;lber.h&amp;gt;.\u2029\u2029For LDAP_MOD_ADD modifications, the given values are added to the entry, creating the attribute if necessary.  For LDAP_MOD_DELETE modifications, the given  values  are  deleted\u2029from  the entry, removing the attribute if no values remain.  If the entire attribute is to be deleted, the mod_values field should be set to NULL.  For LDAP_MOD_REPLACE modifi\u2010\u2029cations, the attribute will have the listed values after the modification, having been created if necessary.  All modifications are performed in the  order  in  which  they  are\u2029listed.\u2029\u2029ldap_mods_free() can be used to free each element of a NULL-terminated array of mod structures.  If freemods is non-zero, the mods pointer itself is freed as well.\u2029\u2029ldap_modify_ext_s() returns a code indicating success or, in the case of failure, indicating the nature of the failure.  See ldap_error(3) for details\u2029\u2029The ldap_modify_ext() operation works the same way as ldap_modify_ext_s(), except that it is asynchronous. The integer that msgidp points to is set to the message id of the mod\u2010\u2029ify request.  The result of the operation can be obtained by calling ldap_result(3).\u2029\u2029Both ldap_modify_ext() and ldap_modify_ext_s() allows server and client controls to be passed in via the sctrls and cctrls parameters, respectively.\u2029\u2029DEPRECATED INTERFACES\u2029The ldap_modify() and ldap_modify_s() routines are deprecated in favor of the ldap_modify_ext() and ldap_modify_ext_s() routines, respectively.\u2029\u2029Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3),\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 975, "position": [695301, 699200], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_modify_ext, ldap_modify_ext_s - Perform an LDAP modify operation\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_modify_ext(\u2029LDAP *ld,\u2029char *dn,\u2029LDAPMod *mods[],\u2029LDAPControl **sctrls,\u2029LDAPControl **cctrls,\u2029int *msgidp );\u2029\u2029int ldap_modify_ext_s(\u2029LDAP *ld,\u2029char *dn,\u2029LDAPMod *mods[],\u2029LDAPControl **sctrls,\u2029LDAPControl **cctrls );\u2029\u2029void ldap_mods_free(\u2029LDAPMod **mods,\u2029int freemods );\u2029\u2029DESCRIPTION\u2029The  routine  ldap_modify_ext_s() is used to perform an LDAP modify operation.  dn is the DN of the entry to modify, and mods is a null-terminated array of modifications to make\u2029to the entry.  Each element of the mods array is a pointer to an LDAPMod structure, which is defined below.\u2029\u2029typedef struct ldapmod {\u2029int mod_op;\u2029char *mod_type;\u2029union {\u2029char **modv_strvals;\u2029struct berval **modv_bvals;\u2029} mod_vals;\u2029struct ldapmod *mod_next;\u2029} LDAPMod;\u2029#define mod_values mod_vals.modv_strvals\u2029#define mod_bvalues mod_vals.modv_bvals\u2029\u2029The mod_op field is used to specify the type of modification to perform and should be one of LDAP_MOD_ADD, LDAP_MOD_DELETE, or LDAP_MOD_REPLACE.   The  mod_type  and  mod_values\u2029fields  specify  the  attribute type to modify and a null-terminated array of values to add, delete, or replace respectively.  The mod_next field is used only by the LDAP server\u2029and may be ignored by the client.\u2029\u2029If you need to specify a non-string value (e.g., to add a photo or audio attribute value),  you  should  set  mod_op  to  the  logical  OR  of  the  operation  as  above  (e.g.,\u2029LDAP_MOD_REPLACE)  and  the  constant LDAP_MOD_BVALUES.  In this case, mod_bvalues should be used instead of mod_values, and it should point to a null-terminated array of struct\u2029bervals, as defined in &amp;lt;lber.h&amp;gt;.\u2029\u2029For LDAP_MOD_ADD modifications, the given values are added to the entry, creating the attribute if necessary.  For LDAP_MOD_DELETE modifications, the given  values  are  deleted\u2029from  the entry, removing the attribute if no values remain.  If the entire attribute is to be deleted, the mod_values field should be set to NULL.  For LDAP_MOD_REPLACE modifi\u2010\u2029cations, the attribute will have the listed values after the modification, having been created if necessary.  All modifications are performed in the  order  in  which  they  are\u2029listed.\u2029\u2029ldap_mods_free() can be used to free each element of a NULL-terminated array of mod structures.  If freemods is non-zero, the mods pointer itself is freed as well.\u2029\u2029ldap_modify_ext_s() returns a code indicating success or, in the case of failure, indicating the nature of the failure.  See ldap_error(3) for details\u2029\u2029The ldap_modify_ext() operation works the same way as ldap_modify_ext_s(), except that it is asynchronous. The integer that msgidp points to is set to the message id of the mod\u2010\u2029ify request.  The result of the operation can be obtained by calling ldap_result(3).\u2029\u2029Both ldap_modify_ext() and ldap_modify_ext_s() allows server and client controls to be passed in via the sctrls and cctrls parameters, respectively.\u2029\u2029DEPRECATED INTERFACES\u2029The ldap_modify() and ldap_modify_s() routines are deprecated in favor of the ldap_modify_ext() and ldap_modify_ext_s() routines, respectively.\u2029\u2029Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3),\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 974, "position": [682017, 685916], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_modify_ext, ldap_modify_ext_s - Perform an LDAP modify operation\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_modify_ext(\u2029LDAP *ld,\u2029char *dn,\u2029LDAPMod *mods[],\u2029LDAPControl **sctrls,\u2029LDAPControl **cctrls,\u2029int *msgidp );\u2029\u2029int ldap_modify_ext_s(\u2029LDAP *ld,\u2029char *dn,\u2029LDAPMod *mods[],\u2029LDAPControl **sctrls,\u2029LDAPControl **cctrls );\u2029\u2029void ldap_mods_free(\u2029LDAPMod **mods,\u2029int freemods );\u2029\u2029DESCRIPTION\u2029The  routine  ldap_modify_ext_s() is used to perform an LDAP modify operation.  dn is the DN of the entry to modify, and mods is a null-terminated array of modifications to make\u2029to the entry.  Each element of the mods array is a pointer to an LDAPMod structure, which is defined below.\u2029\u2029typedef struct ldapmod {\u2029int mod_op;\u2029char *mod_type;\u2029union {\u2029char **modv_strvals;\u2029struct berval **modv_bvals;\u2029} mod_vals;\u2029struct ldapmod *mod_next;\u2029} LDAPMod;\u2029#define mod_values mod_vals.modv_strvals\u2029#define mod_bvalues mod_vals.modv_bvals\u2029\u2029The mod_op field is used to specify the type of modification to perform and should be one of LDAP_MOD_ADD, LDAP_MOD_DELETE, or LDAP_MOD_REPLACE.   The  mod_type  and  mod_values\u2029fields  specify  the  attribute type to modify and a null-terminated array of values to add, delete, or replace respectively.  The mod_next field is used only by the LDAP server\u2029and may be ignored by the client.\u2029\u2029If you need to specify a non-string value (e.g., to add a photo or audio attribute value),  you  should  set  mod_op  to  the  logical  OR  of  the  operation  as  above  (e.g.,\u2029LDAP_MOD_REPLACE)  and  the  constant LDAP_MOD_BVALUES.  In this case, mod_bvalues should be used instead of mod_values, and it should point to a null-terminated array of struct\u2029bervals, as defined in &amp;lt;lber.h&amp;gt;.\u2029\u2029For LDAP_MOD_ADD modifications, the given values are added to the entry, creating the attribute if necessary.  For LDAP_MOD_DELETE modifications, the given  values  are  deleted\u2029from  the entry, removing the attribute if no values remain.  If the entire attribute is to be deleted, the mod_values field should be set to NULL.  For LDAP_MOD_REPLACE modifi\u2010\u2029cations, the attribute will have the listed values after the modification, having been created if necessary.  All modifications are performed in the  order  in  which  they  are\u2029listed.\u2029\u2029ldap_mods_free() can be used to free each element of a NULL-terminated array of mod structures.  If freemods is non-zero, the mods pointer itself is freed as well.\u2029\u2029ldap_modify_ext_s() returns a code indicating success or, in the case of failure, indicating the nature of the failure.  See ldap_error(3) for details\u2029\u2029The ldap_modify_ext() operation works the same way as ldap_modify_ext_s(), except that it is asynchronous. The integer that msgidp points to is set to the message id of the mod\u2010\u2029ify request.  The result of the operation can be obtained by calling ldap_result(3).\u2029\u2029Both ldap_modify_ext() and ldap_modify_ext_s() allows server and client controls to be passed in via the sctrls and cctrls parameters, respectively.\u2029\u2029DEPRECATED INTERFACES\u2029The ldap_modify() and ldap_modify_s() routines are deprecated in favor of the ldap_modify_ext() and ldap_modify_ext_s() routines, respectively.\u2029\u2029Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3),\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 973, "position": [677745, 681644], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_modify_ext, ldap_modify_ext_s - Perform an LDAP modify operation\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_modify_ext(\u2029LDAP *ld,\u2029char *dn,\u2029LDAPMod *mods[],\u2029LDAPControl **sctrls,\u2029LDAPControl **cctrls,\u2029int *msgidp );\u2029\u2029int ldap_modify_ext_s(\u2029LDAP *ld,\u2029char *dn,\u2029LDAPMod *mods[],\u2029LDAPControl **sctrls,\u2029LDAPControl **cctrls );\u2029\u2029void ldap_mods_free(\u2029LDAPMod **mods,\u2029int freemods );\u2029\u2029DESCRIPTION\u2029The  routine  ldap_modify_ext_s() is used to perform an LDAP modify operation.  dn is the DN of the entry to modify, and mods is a null-terminated array of modifications to make\u2029to the entry.  Each element of the mods array is a pointer to an LDAPMod structure, which is defined below.\u2029\u2029typedef struct ldapmod {\u2029int mod_op;\u2029char *mod_type;\u2029union {\u2029char **modv_strvals;\u2029struct berval **modv_bvals;\u2029} mod_vals;\u2029struct ldapmod *mod_next;\u2029} LDAPMod;\u2029#define mod_values mod_vals.modv_strvals\u2029#define mod_bvalues mod_vals.modv_bvals\u2029\u2029The mod_op field is used to specify the type of modification to perform and should be one of LDAP_MOD_ADD, LDAP_MOD_DELETE, or LDAP_MOD_REPLACE.   The  mod_type  and  mod_values\u2029fields  specify  the  attribute type to modify and a null-terminated array of values to add, delete, or replace respectively.  The mod_next field is used only by the LDAP server\u2029and may be ignored by the client.\u2029\u2029If you need to specify a non-string value (e.g., to add a photo or audio attribute value),  you  should  set  mod_op  to  the  logical  OR  of  the  operation  as  above  (e.g.,\u2029LDAP_MOD_REPLACE)  and  the  constant LDAP_MOD_BVALUES.  In this case, mod_bvalues should be used instead of mod_values, and it should point to a null-terminated array of struct\u2029bervals, as defined in &amp;lt;lber.h&amp;gt;.\u2029\u2029For LDAP_MOD_ADD modifications, the given values are added to the entry, creating the attribute if necessary.  For LDAP_MOD_DELETE modifications, the given  values  are  deleted\u2029from  the entry, removing the attribute if no values remain.  If the entire attribute is to be deleted, the mod_values field should be set to NULL.  For LDAP_MOD_REPLACE modifi\u2010\u2029cations, the attribute will have the listed values after the modification, having been created if necessary.  All modifications are performed in the  order  in  which  they  are\u2029listed.\u2029\u2029ldap_mods_free() can be used to free each element of a NULL-terminated array of mod structures.  If freemods is non-zero, the mods pointer itself is freed as well.\u2029\u2029ldap_modify_ext_s() returns a code indicating success or, in the case of failure, indicating the nature of the failure.  See ldap_error(3) for details\u2029\u2029The ldap_modify_ext() operation works the same way as ldap_modify_ext_s(), except that it is asynchronous. The integer that msgidp points to is set to the message id of the mod\u2010\u2029ify request.  The result of the operation can be obtained by calling ldap_result(3).\u2029\u2029Both ldap_modify_ext() and ldap_modify_ext_s() allows server and client controls to be passed in via the sctrls and cctrls parameters, respectively.\u2029\u2029DEPRECATED INTERFACES\u2029The ldap_modify() and ldap_modify_s() routines are deprecated in favor of the ldap_modify_ext() and ldap_modify_ext_s() routines, respectively.\u2029\u2029Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3),\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 972, "position": [673473, 677372], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_modify_ext, ldap_modify_ext_s - Perform an LDAP modify operation\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_modify_ext(\u2029LDAP *ld,\u2029char *dn,\u2029LDAPMod *mods[],\u2029LDAPControl **sctrls,\u2029LDAPControl **cctrls,\u2029int *msgidp );\u2029\u2029int ldap_modify_ext_s(\u2029LDAP *ld,\u2029char *dn,\u2029LDAPMod *mods[],\u2029LDAPControl **sctrls,\u2029LDAPControl **cctrls );\u2029\u2029void ldap_mods_free(\u2029LDAPMod **mods,\u2029int freemods );\u2029\u2029DESCRIPTION\u2029The  routine  ldap_modify_ext_s() is used to perform an LDAP modify operation.  dn is the DN of the entry to modify, and mods is a null-terminated array of modifications to make\u2029to the entry.  Each element of the mods array is a pointer to an LDAPMod structure, which is defined below.\u2029\u2029typedef struct ldapmod {\u2029int mod_op;\u2029char *mod_type;\u2029union {\u2029char **modv_strvals;\u2029struct berval **modv_bvals;\u2029} mod_vals;\u2029struct ldapmod *mod_next;\u2029} LDAPMod;\u2029#define mod_values mod_vals.modv_strvals\u2029#define mod_bvalues mod_vals.modv_bvals\u2029\u2029The mod_op field is used to specify the type of modification to perform and should be one of LDAP_MOD_ADD, LDAP_MOD_DELETE, or LDAP_MOD_REPLACE.   The  mod_type  and  mod_values\u2029fields  specify  the  attribute type to modify and a null-terminated array of values to add, delete, or replace respectively.  The mod_next field is used only by the LDAP server\u2029and may be ignored by the client.\u2029\u2029If you need to specify a non-string value (e.g., to add a photo or audio attribute value),  you  should  set  mod_op  to  the  logical  OR  of  the  operation  as  above  (e.g.,\u2029LDAP_MOD_REPLACE)  and  the  constant LDAP_MOD_BVALUES.  In this case, mod_bvalues should be used instead of mod_values, and it should point to a null-terminated array of struct\u2029bervals, as defined in &amp;lt;lber.h&amp;gt;.\u2029\u2029For LDAP_MOD_ADD modifications, the given values are added to the entry, creating the attribute if necessary.  For LDAP_MOD_DELETE modifications, the given  values  are  deleted\u2029from  the entry, removing the attribute if no values remain.  If the entire attribute is to be deleted, the mod_values field should be set to NULL.  For LDAP_MOD_REPLACE modifi\u2010\u2029cations, the attribute will have the listed values after the modification, having been created if necessary.  All modifications are performed in the  order  in  which  they  are\u2029listed.\u2029\u2029ldap_mods_free() can be used to free each element of a NULL-terminated array of mod structures.  If freemods is non-zero, the mods pointer itself is freed as well.\u2029\u2029ldap_modify_ext_s() returns a code indicating success or, in the case of failure, indicating the nature of the failure.  See ldap_error(3) for details\u2029\u2029The ldap_modify_ext() operation works the same way as ldap_modify_ext_s(), except that it is asynchronous. The integer that msgidp points to is set to the message id of the mod\u2010\u2029ify request.  The result of the operation can be obtained by calling ldap_result(3).\u2029\u2029Both ldap_modify_ext() and ldap_modify_ext_s() allows server and client controls to be passed in via the sctrls and cctrls parameters, respectively.\u2029\u2029DEPRECATED INTERFACES\u2029The ldap_modify() and ldap_modify_s() routines are deprecated in favor of the ldap_modify_ext() and ldap_modify_ext_s() routines, respectively.\u2029\u2029Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed\u2029to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3),\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 971, "position": [669201, 673100], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "67", "annotation": "LDAP_MODRDN", "group_ids": [{"name2": "NAME\u2029ldap_modrdn, ldap_modrdn_s, ldap_modrdn2, ldap_modrdn2_s - Perform an LDAP modify RDN operation\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_modrdn(ld, dn, newrdn)\u2029LDAP \u2217ld;\u2029char \u2217dn, \u2217newrdn;\u2029\u2029int ldap_modrdn_s(ld, dn, newrdn)\u2029LDAP \u2217ld;\u2029char \u2217dn, \u2217newrdn;\u2029\u2029int ldap_modrdn2(ld, dn, newrdn, deleteoldrdn)\u2029LDAP \u2217ld;\u2029char \u2217dn, \u2217newrdn;\u2029int deleteoldrdn;\u2029\u2029int ldap_modrdn2_s(ld, dn, newrdn, deleteoldrdn)\u2029LDAP \u2217ld;\u2029char \u2217dn, \u2217newrdn;\u2029int deleteoldrdn;\u2029\u2029DESCRIPTION\u2029The  ldap_modrdn() and ldap_modrdn_s() routines perform an LDAP modify RDN operation.  They both take dn, the DN of the entry whose RDN is to be changed, and newrdn, the new RDN\u2029to give the entry.  The old RDN of the entry is never kept as an attribute of the entry.  ldap_modrdn() is asynchronous, returning the message id of the operation it  initiates.\u2029ldap_modrdn_s()  is  synchronous,  returning  the  LDAP  error  code  indicating the success or failure of the operation.  Use of these routines is deprecated.  Use the versions\u2029described below instead.\u2029\u2029The ldap_modrdn2() and ldap_modrdn2_s() routines also perform an LDAP modify RDN operation, taking the same parameters as above.  In addition, they both  take  the  deleteoldrdn\u2029parameter which is used as a boolean value to indicate whether the old RDN values should be deleted from the entry or not.\u2029\u2029ERRORS\u2029The  synchronous (_s) versions of these routines return an LDAP error code, either LDAP_SUCCESS or an error if there was trouble.  The asynchronous versions return -1 in case of\u2029trouble, setting the ld_errno field of ld.  See ldap_error(3) for more details.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 979, "position": [693048, 694928], "check": 1, "intersection": 1881, "FP_dupl": 375, "FN_dupl": 0, "F": 0.9093546047860769, "Prec_Dupl": 0.8337765957446809, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_modrdn, ldap_modrdn_s, ldap_modrdn2, ldap_modrdn2_s - Perform an LDAP modify RDN operation\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_modrdn(ld, dn, newrdn)\u2029LDAP \u2217ld;\u2029char \u2217dn, \u2217newrdn;\u2029\u2029int ldap_modrdn_s(ld, dn, newrdn)\u2029LDAP \u2217ld;\u2029char \u2217dn, \u2217newrdn;\u2029\u2029int ldap_modrdn2(ld, dn, newrdn, deleteoldrdn)\u2029LDAP \u2217ld;\u2029char \u2217dn, \u2217newrdn;\u2029int deleteoldrdn;\u2029\u2029int ldap_modrdn2_s(ld, dn, newrdn, deleteoldrdn)\u2029LDAP \u2217ld;\u2029char \u2217dn, \u2217newrdn;\u2029int deleteoldrdn;\u2029\u2029DESCRIPTION\u2029The  ldap_modrdn() and ldap_modrdn_s() routines perform an LDAP modify RDN operation.  They both take dn, the DN of the entry whose RDN is to be changed, and newrdn, the new RDN\u2029to give the entry.  The old RDN of the entry is never kept as an attribute of the entry.  ldap_modrdn() is asynchronous, returning the message id of the operation it  initiates.\u2029ldap_modrdn_s()  is  synchronous,  returning  the  LDAP  error  code  indicating the success or failure of the operation.  Use of these routines is deprecated.  Use the versions\u2029described below instead.\u2029\u2029The ldap_modrdn2() and ldap_modrdn2_s() routines also perform an LDAP modify RDN operation, taking the same parameters as above.  In addition, they both  take  the  deleteoldrdn\u2029parameter which is used as a boolean value to indicate whether the old RDN values should be deleted from the entry or not.\u2029\u2029ERRORS\u2029The  synchronous (_s) versions of these routines return an LDAP error code, either LDAP_SUCCESS or an error if there was trouble.  The asynchronous versions return -1 in case of\u2029trouble, setting the ld_errno field of ld.  See ldap_error(3) for more details.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 978, "position": [690795, 692675], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_modrdn, ldap_modrdn_s, ldap_modrdn2, ldap_modrdn2_s - Perform an LDAP modify RDN operation\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_modrdn(ld, dn, newrdn)\u2029LDAP \u2217ld;\u2029char \u2217dn, \u2217newrdn;\u2029\u2029int ldap_modrdn_s(ld, dn, newrdn)\u2029LDAP \u2217ld;\u2029char \u2217dn, \u2217newrdn;\u2029\u2029int ldap_modrdn2(ld, dn, newrdn, deleteoldrdn)\u2029LDAP \u2217ld;\u2029char \u2217dn, \u2217newrdn;\u2029int deleteoldrdn;\u2029\u2029int ldap_modrdn2_s(ld, dn, newrdn, deleteoldrdn)\u2029LDAP \u2217ld;\u2029char \u2217dn, \u2217newrdn;\u2029int deleteoldrdn;\u2029\u2029DESCRIPTION\u2029The  ldap_modrdn() and ldap_modrdn_s() routines perform an LDAP modify RDN operation.  They both take dn, the DN of the entry whose RDN is to be changed, and newrdn, the new RDN\u2029to give the entry.  The old RDN of the entry is never kept as an attribute of the entry.  ldap_modrdn() is asynchronous, returning the message id of the operation it  initiates.\u2029ldap_modrdn_s()  is  synchronous,  returning  the  LDAP  error  code  indicating the success or failure of the operation.  Use of these routines is deprecated.  Use the versions\u2029described below instead.\u2029\u2029The ldap_modrdn2() and ldap_modrdn2_s() routines also perform an LDAP modify RDN operation, taking the same parameters as above.  In addition, they both  take  the  deleteoldrdn\u2029parameter which is used as a boolean value to indicate whether the old RDN values should be deleted from the entry or not.\u2029\u2029ERRORS\u2029The  synchronous (_s) versions of these routines return an LDAP error code, either LDAP_SUCCESS or an error if there was trouble.  The asynchronous versions return -1 in case of\u2029trouble, setting the ld_errno field of ld.  See ldap_error(3) for more details.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 977, "position": [688542, 690422], "check": 1, "intersection": 1881, "FP_dupl": 375, "FN_dupl": 0, "F": 0.9093546047860769, "Prec_Dupl": 0.8337765957446809, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_modrdn, ldap_modrdn_s, ldap_modrdn2, ldap_modrdn2_s - Perform an LDAP modify RDN operation\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_modrdn(ld, dn, newrdn)\u2029LDAP \u2217ld;\u2029char \u2217dn, \u2217newrdn;\u2029\u2029int ldap_modrdn_s(ld, dn, newrdn)\u2029LDAP \u2217ld;\u2029char \u2217dn, \u2217newrdn;\u2029\u2029int ldap_modrdn2(ld, dn, newrdn, deleteoldrdn)\u2029LDAP \u2217ld;\u2029char \u2217dn, \u2217newrdn;\u2029int deleteoldrdn;\u2029\u2029int ldap_modrdn2_s(ld, dn, newrdn, deleteoldrdn)\u2029LDAP \u2217ld;\u2029char \u2217dn, \u2217newrdn;\u2029int deleteoldrdn;\u2029\u2029DESCRIPTION\u2029The  ldap_modrdn() and ldap_modrdn_s() routines perform an LDAP modify RDN operation.  They both take dn, the DN of the entry whose RDN is to be changed, and newrdn, the new RDN\u2029to give the entry.  The old RDN of the entry is never kept as an attribute of the entry.  ldap_modrdn() is asynchronous, returning the message id of the operation it  initiates.\u2029ldap_modrdn_s()  is  synchronous,  returning  the  LDAP  error  code  indicating the success or failure of the operation.  Use of these routines is deprecated.  Use the versions\u2029described below instead.\u2029\u2029The ldap_modrdn2() and ldap_modrdn2_s() routines also perform an LDAP modify RDN operation, taking the same parameters as above.  In addition, they both  take  the  deleteoldrdn\u2029parameter which is used as a boolean value to indicate whether the old RDN values should be deleted from the entry or not.\u2029\u2029ERRORS\u2029The  synchronous (_s) versions of these routines return an LDAP error code, either LDAP_SUCCESS or an error if there was trouble.  The asynchronous versions return -1 in case of\u2029trouble, setting the ld_errno field of ld.  See ldap_error(3) for more details.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 976, "position": [686289, 688169], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "68", "annotation": "LDAP_RESULT", "group_ids": [{"name2": "NAME\u2029ldap_result - Wait for the result of an LDAP operation\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_result( LDAP *ld, int msgid, int all,\u2029struct timeval *timeout, LDAPMessage **result );\u2029\u2029int ldap_msgfree( LDAPMessage *msg );\u2029\u2029int ldap_msgtype( LDAPMessage *msg );\u2029\u2029int ldap_msgid( LDAPMessage *msg );\u2029\u2029DESCRIPTION\u2029The  ldap_result()  routine  is  used  to  wait  for  and  return  the  result  of  an  operation  previously initiated by one of the LDAP asynchronous operation routines (e.g.,\u2029ldap_search_ext(3), ldap_modify_ext(3), etc.).  Those routines all return -1 in case of error, and an invocation identifier upon successful  initiation  of  the  operation.  The\u2029invocation  identifier  is  picked  by  the  library  and  is guaranteed to be unique across the LDAP session.  It can be used to request the result of a specific operation from\u2029ldap_result() through the msgid parameter.\u2029\u2029The ldap_result() routine will block or not, depending upon the setting of the timeout parameter.  If timeout is not a NULL pointer,  it  specifies  a  maximum interval  to wait\u2029for  the  selection  to  complete.   If  timeout  is a NULL  pointer, the LDAP_OPT_TIMEOUT value set by ldap_set_option(3) is used. With the default setting, the  select  blocks\u2029indefinitely.   To effect  a  poll,  the  timeout argument should be a non-NULL pointer, pointing to a zero-valued timeval structure.  To obtain the behavior of the default set\u2010\u2029ting, bypassing any value set by ldap_set_option(3), set to -1 the tv_sec field of the timeout parameter.  See select(2) for further details.\u2029\u2029If  the  result  of  a  specific  operation  is  required,  msgid should be set to the invocation identifier returned when the operation was initiated, otherwise LDAP_RES_ANY or\u2029LDAP_RES_UNSOLICITED should be supplied to wait for any or unsolicited response.\u2029\u2029The all parameter, if non-zero, causes ldap_result() to return all responses with msgid, otherwise only the next response is returned.  This is commonly used to obtain  all  the\u2029responses of a search operation.\u2029\u2029A  search response is made up of zero or more search entries, zero or more search references, and zero or more extended partial responses followed by a search result.  If all is\u2029set to 0, search entries will be returned one at a time as they come in, via separate calls to ldap_result().  If it's set to 1, the search response will only be returned in its\u2029entirety, i.e., after all entries, all references, all extended partial responses, and the final search result have been received.\u2029\u2029RETURN VALUE\u2029Upon  success, the type of the result received is returned and the result parameter will contain the result of the operation; otherwise, the result parameter is undefined.  This\u2029result should be passed to the LDAP parsing routines, ldap_first_message(3) and friends, for interpretation.\u2029\u2029The possible result types returned are:\u2029\u2029LDAP_RES_BIND (0x61)\u2029LDAP_RES_SEARCH_ENTRY (0x64)\u2029LDAP_RES_SEARCH_REFERENCE (0x73)\u2029LDAP_RES_SEARCH_RESULT (0x65)\u2029LDAP_RES_MODIFY (0x67)\u2029LDAP_RES_ADD (0x69)\u2029LDAP_RES_DELETE (0x6b)\u2029LDAP_RES_MODDN (0x6d)\u2029LDAP_RES_COMPARE (0x6f)\u2029LDAP_RES_EXTENDED (0x78)\u2029LDAP_RES_INTERMEDIATE (0x79)\u2029\u2029The ldap_msgfree() routine is used to free the memory allocated for result(s) by ldap_result() or ldap_search_ext_s(3) and friends.  It takes a pointer to the result  or  result\u2029chain to be freed and returns the type of the last message in the chain.  If the parameter is NULL, the function does nothing and returns zero.\u2029\u2029The ldap_msgtype() routine returns the type of a message.\u2029\u2029The ldap_msgid() routine returns the message id of a message.\u2029\u2029ERRORS\u2029ldap_result() returns -1 if something bad happens, and zero if the timeout specified was exceeded.  ldap_msgtype() and ldap_msgid() return -1 on error.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_first_message(3), select(2)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 983, "position": [784569, 788635], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_result - Wait for the result of an LDAP operation\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_result( LDAP *ld, int msgid, int all,\u2029struct timeval *timeout, LDAPMessage **result );\u2029\u2029int ldap_msgfree( LDAPMessage *msg );\u2029\u2029int ldap_msgtype( LDAPMessage *msg );\u2029\u2029int ldap_msgid( LDAPMessage *msg );\u2029\u2029DESCRIPTION\u2029The  ldap_result()  routine  is  used  to  wait  for  and  return  the  result  of  an  operation  previously initiated by one of the LDAP asynchronous operation routines (e.g.,\u2029ldap_search_ext(3), ldap_modify_ext(3), etc.).  Those routines all return -1 in case of error, and an invocation identifier upon successful  initiation  of  the  operation.  The\u2029invocation  identifier  is  picked  by  the  library  and  is guaranteed to be unique across the LDAP session.  It can be used to request the result of a specific operation from\u2029ldap_result() through the msgid parameter.\u2029\u2029The ldap_result() routine will block or not, depending upon the setting of the timeout parameter.  If timeout is not a NULL pointer,  it  specifies  a  maximum interval  to wait\u2029for  the  selection  to  complete.   If  timeout  is a NULL  pointer, the LDAP_OPT_TIMEOUT value set by ldap_set_option(3) is used. With the default setting, the  select  blocks\u2029indefinitely.   To effect  a  poll,  the  timeout argument should be a non-NULL pointer, pointing to a zero-valued timeval structure.  To obtain the behavior of the default set\u2010\u2029ting, bypassing any value set by ldap_set_option(3), set to -1 the tv_sec field of the timeout parameter.  See select(2) for further details.\u2029\u2029If  the  result  of  a  specific  operation  is  required,  msgid should be set to the invocation identifier returned when the operation was initiated, otherwise LDAP_RES_ANY or\u2029LDAP_RES_UNSOLICITED should be supplied to wait for any or unsolicited response.\u2029\u2029The all parameter, if non-zero, causes ldap_result() to return all responses with msgid, otherwise only the next response is returned.  This is commonly used to obtain  all  the\u2029responses of a search operation.\u2029\u2029A  search response is made up of zero or more search entries, zero or more search references, and zero or more extended partial responses followed by a search result.  If all is\u2029set to 0, search entries will be returned one at a time as they come in, via separate calls to ldap_result().  If it's set to 1, the search response will only be returned in its\u2029entirety, i.e., after all entries, all references, all extended partial responses, and the final search result have been received.\u2029\u2029RETURN VALUE\u2029Upon  success, the type of the result received is returned and the result parameter will contain the result of the operation; otherwise, the result parameter is undefined.  This\u2029result should be passed to the LDAP parsing routines, ldap_first_message(3) and friends, for interpretation.\u2029\u2029The possible result types returned are:\u2029\u2029LDAP_RES_BIND (0x61)\u2029LDAP_RES_SEARCH_ENTRY (0x64)\u2029LDAP_RES_SEARCH_REFERENCE (0x73)\u2029LDAP_RES_SEARCH_RESULT (0x65)\u2029LDAP_RES_MODIFY (0x67)\u2029LDAP_RES_ADD (0x69)\u2029LDAP_RES_DELETE (0x6b)\u2029LDAP_RES_MODDN (0x6d)\u2029LDAP_RES_COMPARE (0x6f)\u2029LDAP_RES_EXTENDED (0x78)\u2029LDAP_RES_INTERMEDIATE (0x79)\u2029\u2029The ldap_msgfree() routine is used to free the memory allocated for result(s) by ldap_result() or ldap_search_ext_s(3) and friends.  It takes a pointer to the result  or  result\u2029chain to be freed and returns the type of the last message in the chain.  If the parameter is NULL, the function does nothing and returns zero.\u2029\u2029The ldap_msgtype() routine returns the type of a message.\u2029\u2029The ldap_msgid() routine returns the message id of a message.\u2029\u2029ERRORS\u2029ldap_result() returns -1 if something bad happens, and zero if the timeout specified was exceeded.  ldap_msgtype() and ldap_msgid() return -1 on error.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_first_message(3), select(2)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 982, "position": [708451, 712517], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_result - Wait for the result of an LDAP operation\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_result( LDAP *ld, int msgid, int all,\u2029struct timeval *timeout, LDAPMessage **result );\u2029\u2029int ldap_msgfree( LDAPMessage *msg );\u2029\u2029int ldap_msgtype( LDAPMessage *msg );\u2029\u2029int ldap_msgid( LDAPMessage *msg );\u2029\u2029DESCRIPTION\u2029The  ldap_result()  routine  is  used  to  wait  for  and  return  the  result  of  an  operation  previously initiated by one of the LDAP asynchronous operation routines (e.g.,\u2029ldap_search_ext(3), ldap_modify_ext(3), etc.).  Those routines all return -1 in case of error, and an invocation identifier upon successful  initiation  of  the  operation.  The\u2029invocation  identifier  is  picked  by  the  library  and  is guaranteed to be unique across the LDAP session.  It can be used to request the result of a specific operation from\u2029ldap_result() through the msgid parameter.\u2029\u2029The ldap_result() routine will block or not, depending upon the setting of the timeout parameter.  If timeout is not a NULL pointer,  it  specifies  a  maximum interval  to wait\u2029for  the  selection  to  complete.   If  timeout  is a NULL  pointer, the LDAP_OPT_TIMEOUT value set by ldap_set_option(3) is used. With the default setting, the  select  blocks\u2029indefinitely.   To effect  a  poll,  the  timeout argument should be a non-NULL pointer, pointing to a zero-valued timeval structure.  To obtain the behavior of the default set\u2010\u2029ting, bypassing any value set by ldap_set_option(3), set to -1 the tv_sec field of the timeout parameter.  See select(2) for further details.\u2029\u2029If  the  result  of  a  specific  operation  is  required,  msgid should be set to the invocation identifier returned when the operation was initiated, otherwise LDAP_RES_ANY or\u2029LDAP_RES_UNSOLICITED should be supplied to wait for any or unsolicited response.\u2029\u2029The all parameter, if non-zero, causes ldap_result() to return all responses with msgid, otherwise only the next response is returned.  This is commonly used to obtain  all  the\u2029responses of a search operation.\u2029\u2029A  search response is made up of zero or more search entries, zero or more search references, and zero or more extended partial responses followed by a search result.  If all is\u2029set to 0, search entries will be returned one at a time as they come in, via separate calls to ldap_result().  If it's set to 1, the search response will only be returned in its\u2029entirety, i.e., after all entries, all references, all extended partial responses, and the final search result have been received.\u2029\u2029RETURN VALUE\u2029Upon  success, the type of the result received is returned and the result parameter will contain the result of the operation; otherwise, the result parameter is undefined.  This\u2029result should be passed to the LDAP parsing routines, ldap_first_message(3) and friends, for interpretation.\u2029\u2029The possible result types returned are:\u2029\u2029LDAP_RES_BIND (0x61)\u2029LDAP_RES_SEARCH_ENTRY (0x64)\u2029LDAP_RES_SEARCH_REFERENCE (0x73)\u2029LDAP_RES_SEARCH_RESULT (0x65)\u2029LDAP_RES_MODIFY (0x67)\u2029LDAP_RES_ADD (0x69)\u2029LDAP_RES_DELETE (0x6b)\u2029LDAP_RES_MODDN (0x6d)\u2029LDAP_RES_COMPARE (0x6f)\u2029LDAP_RES_EXTENDED (0x78)\u2029LDAP_RES_INTERMEDIATE (0x79)\u2029\u2029The ldap_msgfree() routine is used to free the memory allocated for result(s) by ldap_result() or ldap_search_ext_s(3) and friends.  It takes a pointer to the result  or  result\u2029chain to be freed and returns the type of the last message in the chain.  If the parameter is NULL, the function does nothing and returns zero.\u2029\u2029The ldap_msgtype() routine returns the type of a message.\u2029\u2029The ldap_msgid() routine returns the message id of a message.\u2029\u2029ERRORS\u2029ldap_result() returns -1 if something bad happens, and zero if the timeout specified was exceeded.  ldap_msgtype() and ldap_msgid() return -1 on error.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_first_message(3), select(2)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 981, "position": [704012, 708078], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_result - Wait for the result of an LDAP operation\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_result( LDAP *ld, int msgid, int all,\u2029struct timeval *timeout, LDAPMessage **result );\u2029\u2029int ldap_msgfree( LDAPMessage *msg );\u2029\u2029int ldap_msgtype( LDAPMessage *msg );\u2029\u2029int ldap_msgid( LDAPMessage *msg );\u2029\u2029DESCRIPTION\u2029The  ldap_result()  routine  is  used  to  wait  for  and  return  the  result  of  an  operation  previously initiated by one of the LDAP asynchronous operation routines (e.g.,\u2029ldap_search_ext(3), ldap_modify_ext(3), etc.).  Those routines all return -1 in case of error, and an invocation identifier upon successful  initiation  of  the  operation.  The\u2029invocation  identifier  is  picked  by  the  library  and  is guaranteed to be unique across the LDAP session.  It can be used to request the result of a specific operation from\u2029ldap_result() through the msgid parameter.\u2029\u2029The ldap_result() routine will block or not, depending upon the setting of the timeout parameter.  If timeout is not a NULL pointer,  it  specifies  a  maximum interval  to wait\u2029for  the  selection  to  complete.   If  timeout  is a NULL  pointer, the LDAP_OPT_TIMEOUT value set by ldap_set_option(3) is used. With the default setting, the  select  blocks\u2029indefinitely.   To effect  a  poll,  the  timeout argument should be a non-NULL pointer, pointing to a zero-valued timeval structure.  To obtain the behavior of the default set\u2010\u2029ting, bypassing any value set by ldap_set_option(3), set to -1 the tv_sec field of the timeout parameter.  See select(2) for further details.\u2029\u2029If  the  result  of  a  specific  operation  is  required,  msgid should be set to the invocation identifier returned when the operation was initiated, otherwise LDAP_RES_ANY or\u2029LDAP_RES_UNSOLICITED should be supplied to wait for any or unsolicited response.\u2029\u2029The all parameter, if non-zero, causes ldap_result() to return all responses with msgid, otherwise only the next response is returned.  This is commonly used to obtain  all  the\u2029responses of a search operation.\u2029\u2029A  search response is made up of zero or more search entries, zero or more search references, and zero or more extended partial responses followed by a search result.  If all is\u2029set to 0, search entries will be returned one at a time as they come in, via separate calls to ldap_result().  If it's set to 1, the search response will only be returned in its\u2029entirety, i.e., after all entries, all references, all extended partial responses, and the final search result have been received.\u2029\u2029RETURN VALUE\u2029Upon  success, the type of the result received is returned and the result parameter will contain the result of the operation; otherwise, the result parameter is undefined.  This\u2029result should be passed to the LDAP parsing routines, ldap_first_message(3) and friends, for interpretation.\u2029\u2029The possible result types returned are:\u2029\u2029LDAP_RES_BIND (0x61)\u2029LDAP_RES_SEARCH_ENTRY (0x64)\u2029LDAP_RES_SEARCH_REFERENCE (0x73)\u2029LDAP_RES_SEARCH_RESULT (0x65)\u2029LDAP_RES_MODIFY (0x67)\u2029LDAP_RES_ADD (0x69)\u2029LDAP_RES_DELETE (0x6b)\u2029LDAP_RES_MODDN (0x6d)\u2029LDAP_RES_COMPARE (0x6f)\u2029LDAP_RES_EXTENDED (0x78)\u2029LDAP_RES_INTERMEDIATE (0x79)\u2029\u2029The ldap_msgfree() routine is used to free the memory allocated for result(s) by ldap_result() or ldap_search_ext_s(3) and friends.  It takes a pointer to the result  or  result\u2029chain to be freed and returns the type of the last message in the chain.  If the parameter is NULL, the function does nothing and returns zero.\u2029\u2029The ldap_msgtype() routine returns the type of a message.\u2029\u2029The ldap_msgid() routine returns the message id of a message.\u2029\u2029ERRORS\u2029ldap_result() returns -1 if something bad happens, and zero if the timeout specified was exceeded.  ldap_msgtype() and ldap_msgid() return -1 on error.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_first_message(3), select(2)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 980, "position": [699573, 703639], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "69", "annotation": "LDAP_PARSE_RESULT", "group_ids": [{"name2": "NAME\u2029ldap_parse_result - Parsing results\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_parse_result( LDAP *ld, LDAPMessage *result,\u2029int *errcodep, char **matcheddnp, char **errmsgp,\u2029char ***referralsp, LDAPControl ***serverctrlsp,\u2029int freeit )\u2029\u2029int ldap_parse_sasl_bind_result( LDAP *ld, LDAPMessage *result,\u2029struct berval **servercredp, int freeit )\u2029\u2029int ldap_parse_extended_result( LDAP *ld, LDAPMessage *result,\u2029char **retoidp, struct berval **retdatap, int freeit )\u2029\u2029DESCRIPTION\u2029These  routines  are  used to extract information from a result message.  They will operate on the first result message in a chain of search results (skipping past other message\u2029types). They  take  the  result  as  returned  by  a  call  to  ldap_result(3),  ldap_search_s(3)  or  ldap_search_st(3).   In  addition  to  ldap_parse_result(),  the  routines\u2029ldap_parse_sasl_bind_result() and ldap_parse_extended_result() are used to get all the result information from SASL bind and extended operations.\u2029\u2029The errcodep parameter will be filled in with the result code from the result message.\u2029\u2029The server might supply a matched DN string in the message indicating how much of a name in a request was recognized. The matcheddnp parameter will be filled in with this string\u2029if supplied, else it will be NULL. If a string is returned, it should be freed using ldap_memfree(3).\u2029\u2029The errmsgp parameter will be filled in with the error message field from the parsed message. This string should be freed using ldap_memfree(3).\u2029\u2029The referralsp parameter will be filled in with an allocated array of referral strings from the parsed message. This array should be freed using ldap_memvfree(3).  If no  refer\u2010\u2029rals were returned, *referralsp is set to NULL.\u2029\u2029The  serverctrlsp  parameter  will be filled in with an allocated array of controls copied from the parsed message. The array should be freed using ldap_controls_free(3).  If no\u2029controls were returned, *serverctrlsp is set to NULL.\u2029\u2029The freeit parameter determines whether the parsed message is freed or not after the extraction. Any non-zero value will make it free the message.  The  ldap_msgfree(3)  routine\u2029can also be used to free the message later.\u2029\u2029For SASL bind results, the servercredp parameter will be filled in with an allocated berval structure containing the credentials from the server if present. The structure should\u2029be freed using ber_bvfree(3).\u2029\u2029For extended results, the retoidp parameter will be filled in with the dotted-OID text representation of the name of the extended operation response. The string should be  freed\u2029using ldap_memfree(3).  If no OID was returned, *retoidp is set to NULL.\u2029\u2029For  extended  results,  the  retdatap  parameter  will be filled in with a pointer to a berval structure containing the data from the extended operation response. The structure\u2029should be freed using ber_bvfree(3).  If no data were returned, *retdatap is set to NULL.\u2029\u2029For all the above result parameters, NULL values can be used in calls in order to ignore certain fields.\u2029\u2029ERRORS\u2029Upon success LDAP_SUCCESS is returned. Otherwise the values of the result parameters are undefined.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_result(3), ldap_search(3), ldap_memfree(3), ldap_memvfree(3), ldap_get_values(3), ldap_controls_free(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 986, "position": [764756, 768278], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_parse_result - Parsing results\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_parse_result( LDAP *ld, LDAPMessage *result,\u2029int *errcodep, char **matcheddnp, char **errmsgp,\u2029char ***referralsp, LDAPControl ***serverctrlsp,\u2029int freeit )\u2029\u2029int ldap_parse_sasl_bind_result( LDAP *ld, LDAPMessage *result,\u2029struct berval **servercredp, int freeit )\u2029\u2029int ldap_parse_extended_result( LDAP *ld, LDAPMessage *result,\u2029char **retoidp, struct berval **retdatap, int freeit )\u2029\u2029DESCRIPTION\u2029These  routines  are  used to extract information from a result message.  They will operate on the first result message in a chain of search results (skipping past other message\u2029types). They  take  the  result  as  returned  by  a  call  to  ldap_result(3),  ldap_search_s(3)  or  ldap_search_st(3).   In  addition  to  ldap_parse_result(),  the  routines\u2029ldap_parse_sasl_bind_result() and ldap_parse_extended_result() are used to get all the result information from SASL bind and extended operations.\u2029\u2029The errcodep parameter will be filled in with the result code from the result message.\u2029\u2029The server might supply a matched DN string in the message indicating how much of a name in a request was recognized. The matcheddnp parameter will be filled in with this string\u2029if supplied, else it will be NULL. If a string is returned, it should be freed using ldap_memfree(3).\u2029\u2029The errmsgp parameter will be filled in with the error message field from the parsed message. This string should be freed using ldap_memfree(3).\u2029\u2029The referralsp parameter will be filled in with an allocated array of referral strings from the parsed message. This array should be freed using ldap_memvfree(3).  If no  refer\u2010\u2029rals were returned, *referralsp is set to NULL.\u2029\u2029The  serverctrlsp  parameter  will be filled in with an allocated array of controls copied from the parsed message. The array should be freed using ldap_controls_free(3).  If no\u2029controls were returned, *serverctrlsp is set to NULL.\u2029\u2029The freeit parameter determines whether the parsed message is freed or not after the extraction. Any non-zero value will make it free the message.  The  ldap_msgfree(3)  routine\u2029can also be used to free the message later.\u2029\u2029For SASL bind results, the servercredp parameter will be filled in with an allocated berval structure containing the credentials from the server if present. The structure should\u2029be freed using ber_bvfree(3).\u2029\u2029For extended results, the retoidp parameter will be filled in with the dotted-OID text representation of the name of the extended operation response. The string should be  freed\u2029using ldap_memfree(3).  If no OID was returned, *retoidp is set to NULL.\u2029\u2029For  extended  results,  the  retdatap  parameter  will be filled in with a pointer to a berval structure containing the data from the extended operation response. The structure\u2029should be freed using ber_bvfree(3).  If no data were returned, *retdatap is set to NULL.\u2029\u2029For all the above result parameters, NULL values can be used in calls in order to ignore certain fields.\u2029\u2029ERRORS\u2029Upon success LDAP_SUCCESS is returned. Otherwise the values of the result parameters are undefined.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_result(3), ldap_search(3), ldap_memfree(3), ldap_memvfree(3), ldap_get_values(3), ldap_controls_free(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 985, "position": [760861, 764383], "check": 1, "intersection": 3523, "FP_dupl": 375, "FN_dupl": 0, "F": 0.9494677267214662, "Prec_Dupl": 0.9037968188814777, "Recall_Dupl": 1.0}, {"name2": "NAME\u2029ldap_parse_result - Parsing results\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_parse_result( LDAP *ld, LDAPMessage *result,\u2029int *errcodep, char **matcheddnp, char **errmsgp,\u2029char ***referralsp, LDAPControl ***serverctrlsp,\u2029int freeit )\u2029\u2029int ldap_parse_sasl_bind_result( LDAP *ld, LDAPMessage *result,\u2029struct berval **servercredp, int freeit )\u2029\u2029int ldap_parse_extended_result( LDAP *ld, LDAPMessage *result,\u2029char **retoidp, struct berval **retdatap, int freeit )\u2029\u2029DESCRIPTION\u2029These  routines  are  used to extract information from a result message.  They will operate on the first result message in a chain of search results (skipping past other message\u2029types). They  take  the  result  as  returned  by  a  call  to  ldap_result(3),  ldap_search_s(3)  or  ldap_search_st(3).   In  addition  to  ldap_parse_result(),  the  routines\u2029ldap_parse_sasl_bind_result() and ldap_parse_extended_result() are used to get all the result information from SASL bind and extended operations.\u2029\u2029The errcodep parameter will be filled in with the result code from the result message.\u2029\u2029The server might supply a matched DN string in the message indicating how much of a name in a request was recognized. The matcheddnp parameter will be filled in with this string\u2029if supplied, else it will be NULL. If a string is returned, it should be freed using ldap_memfree(3).\u2029\u2029The errmsgp parameter will be filled in with the error message field from the parsed message. This string should be freed using ldap_memfree(3).\u2029\u2029The referralsp parameter will be filled in with an allocated array of referral strings from the parsed message. This array should be freed using ldap_memvfree(3).  If no  refer\u2010\u2029rals were returned, *referralsp is set to NULL.\u2029\u2029The  serverctrlsp  parameter  will be filled in with an allocated array of controls copied from the parsed message. The array should be freed using ldap_controls_free(3).  If no\u2029controls were returned, *serverctrlsp is set to NULL.\u2029\u2029The freeit parameter determines whether the parsed message is freed or not after the extraction. Any non-zero value will make it free the message.  The  ldap_msgfree(3)  routine\u2029can also be used to free the message later.\u2029\u2029For SASL bind results, the servercredp parameter will be filled in with an allocated berval structure containing the credentials from the server if present. The structure should\u2029be freed using ber_bvfree(3).\u2029\u2029For extended results, the retoidp parameter will be filled in with the dotted-OID text representation of the name of the extended operation response. The string should be  freed\u2029using ldap_memfree(3).  If no OID was returned, *retoidp is set to NULL.\u2029\u2029For  extended  results,  the  retdatap  parameter  will be filled in with a pointer to a berval structure containing the data from the extended operation response. The structure\u2029should be freed using ber_bvfree(3).  If no data were returned, *retdatap is set to NULL.\u2029\u2029For all the above result parameters, NULL values can be used in calls in order to ignore certain fields.\u2029\u2029ERRORS\u2029Upon success LDAP_SUCCESS is returned. Otherwise the values of the result parameters are undefined.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_result(3), ldap_search(3), ldap_memfree(3), ldap_memvfree(3), ldap_get_values(3), ldap_controls_free(3), lber-types(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 984, "position": [754692, 758214], "check": 1, "intersection": 3523, "FP_dupl": 375, "FN_dupl": 0, "F": 0.9494677267214662, "Prec_Dupl": 0.9037968188814777, "Recall_Dupl": 1.0}]}, {"name": "70", "annotation": "LDAP_RENAME", "group_ids": [{"name2": "NAME\u2029ldap_rename, ldap_rename_s - Renames the specified entry.\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_rename( ld, dn, newrdn, newparent, deleteoldrdn, sctrls[], cctrls[], msgidp );\u2029LDAP *ld;\u2029const char *dn, *newrdn, *newparent;\u2029int deleteoldrdn;\u2029LDAPControl *sctrls[], *cctrls[];\u2029int *msgidp);\u2029\u2029int ldap_rename_s( ld, dn, newrdn, newparent, deleteoldrdn, sctrls[], cctrls[] );\u2029LDAP *ld;\u2029const char *dn, *newrdn, *newparent;\u2029int deleteoldrdn;\u2029LDAPControl *sctrls[], *cctrls[];\u2029\u2029DESCRIPTION\u2029These  routines  are  used to perform a LDAP rename operation.  The function changes the leaf component of an entry's distinguished name and  optionally moves the entry to a new\u2029parent container. The ldap_rename_s performs a rename operation synchronously.  The method takes dn, which points to the distinguished name of the entry whose attribute is being\u2029compared,  newparent,the  distinguished  name  of  the entry's new parent. If this parameter is NULL, only the RDN is changed.  The root DN is specified by passing a zero length\u2029string, \"\".  deleteoldrdn specifies whether the old RDN should be retained or deleted.  Zero indicates that the old RDN should be  retained.  If  you  choose  this  option,  the\u2029attribute  will  contain both names (the old and the new).  Non-zero indicates that the old RDN should be deleted.  serverctrls points to an array of LDAPControl structures that\u2029list the client controls to use with this extended operation. Use NULL to specify no client controls. clientctrls points to an array of  LDAPControl  structures  that  list  the\u2029client controls to use with the search.\u2029\u2029ldap_rename works just like ldap_rename_s, but the operation is asynchronous. It returns the message id of the request it initiated. The result of this operation can be obtained\u2029by calling ldap_result(3).\u2029\u2029ERRORS\u2029ldap_rename() returns -1 in case of error initiating the request, and will set the ld_errno field in the ld parameter to indicate the error.  ldap_rename_s()  returns  the  LDAP\u2029error code resulting from the rename operation.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_modify(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 988, "position": [781866, 784196], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_rename, ldap_rename_s - Renames the specified entry.\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_rename( ld, dn, newrdn, newparent, deleteoldrdn, sctrls[], cctrls[], msgidp );\u2029LDAP *ld;\u2029const char *dn, *newrdn, *newparent;\u2029int deleteoldrdn;\u2029LDAPControl *sctrls[], *cctrls[];\u2029int *msgidp);\u2029\u2029int ldap_rename_s( ld, dn, newrdn, newparent, deleteoldrdn, sctrls[], cctrls[] );\u2029LDAP *ld;\u2029const char *dn, *newrdn, *newparent;\u2029int deleteoldrdn;\u2029LDAPControl *sctrls[], *cctrls[];\u2029\u2029DESCRIPTION\u2029These  routines  are  used to perform a LDAP rename operation.  The function changes the leaf component of an entry's distinguished name and  optionally moves the entry to a new\u2029parent container. The ldap_rename_s performs a rename operation synchronously.  The method takes dn, which points to the distinguished name of the entry whose attribute is being\u2029compared,  newparent,the  distinguished  name  of  the entry's new parent. If this parameter is NULL, only the RDN is changed.  The root DN is specified by passing a zero length\u2029string, \"\".  deleteoldrdn specifies whether the old RDN should be retained or deleted.  Zero indicates that the old RDN should be  retained.  If  you  choose  this  option,  the\u2029attribute  will  contain both names (the old and the new).  Non-zero indicates that the old RDN should be deleted.  serverctrls points to an array of LDAPControl structures that\u2029list the client controls to use with this extended operation. Use NULL to specify no client controls. clientctrls points to an array of  LDAPControl  structures  that  list  the\u2029client controls to use with the search.\u2029\u2029ldap_rename works just like ldap_rename_s, but the operation is asynchronous. It returns the message id of the request it initiated. The result of this operation can be obtained\u2029by calling ldap_result(3).\u2029\u2029ERRORS\u2029ldap_rename() returns -1 in case of error initiating the request, and will set the ld_errno field in the ld parameter to indicate the error.  ldap_rename_s()  returns  the  LDAP\u2029error code resulting from the rename operation.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_modify(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 987, "position": [779163, 781493], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "71", "annotation": "LDAP_SEARCH", "group_ids": [{"name2": "NAME\u2029ldap_search, ldap_search_s, ldap_search_st, ldap_search_ext, ldap_search_ext_s - Perform an LDAP search operation\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;sys/types.h&amp;gt;\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_search_ext(\u2029LDAP *ld,\u2029char *base,\u2029int scope,\u2029char *filter,\u2029char *attrs[],\u2029int attrsonly,\u2029LDAPControl **serverctrls,\u2029LDAPControl **clientctrls,\u2029struct timeval *timeout,\u2029int sizelimit,\u2029int *msgidp );\u2029\u2029int ldap_search_ext_s(\u2029LDAP *ld,\u2029char *base,\u2029int scope,\u2029char *filter,\u2029char *attrs[],\u2029int attrsonly,\u2029LDAPControl **serverctrls,\u2029LDAPControl **clientctrls,\u2029struct timeval *timeout,\u2029int sizelimit,\u2029LDAPMessage **res );\u2029\u2029DESCRIPTION\u2029These  routines  are  used to perform LDAP search operations.  The ldap_search_ext_s() routine does the search synchronously (i.e., not returning until the operation completes),\u2029providing a pointer to the resulting LDAP messages at the location pointed to by the res parameter.\u2029\u2029The ldap_search_ext() routine is the asynchronous version, initiating the search and returning the message id of the operation it initiated in the  integer  pointed  to  by  the\u2029msgidp parameter.\u2029\u2029The base parameter is the DN of the entry at which to start the search.\u2029\u2029The scope parameter is the scope of the search and should be one of LDAP_SCOPE_BASE, to search the object itself, LDAP_SCOPE_ONELEVEL, to search the object's immediate children,\u2029LDAP_SCOPE_SUBTREE, to search the object and all its descendants, or LDAP_SCOPE_CHILDREN, to search all of the descendants.   Note that the latter requires  the  server  support\u2029the LDAP Subordinates Search Scope extension.\u2029\u2029The  filter  is  a  string  representation  of  the  filter  to apply in the search.  The string should conform to the format specified in RFC 4515 as extended by RFC 4526.  For\u2029instance, \"(cn=Jane Doe)\".  Note that use of the extension requires the server to support the LDAP Absolute True/False Filter extension.  NULL may be specified to  indicate  the\u2029library should send the filter (objectClass=*).\u2029\u2029The  attrs parameter is a null-terminated array of attribute descriptions to return from matching entries.  If NULL is specified, the return of all user attributes is requested.\u2029The description \"*\" (LDAP_ALL_USER_ATTRIBUTES) may be used to request all user attributes to be returned.  The description \"+\"(LDAP_ALL_OPERATIONAL_ATTRIBUTES) may  be  used  to\u2029request  all  operational  attributes to be returned.  Note that this requires the server to support the LDAP All Operational Attribute extension.  To request no attributes, the\u2029description \"1.1\" (LDAP_NO_ATTRS) should be listed by itself.\u2029\u2029The attrsonly parameter should be set to a non-zero value if only attribute descriptions are wanted.  It should be set to zero (0) if both attributes descriptions and  attribute\u2029values are wanted.\u2029\u2029The serverctrls and clientctrls parameters may be used to specify server and client controls, respectively.\u2029\u2029The ldap_search_ext_s() routine is the synchronous version of ldap_search_ext().\u2029\u2029It also returns a code indicating success or, in the case of failure, indicating the nature of the failure of the operation.  See ldap_error(3) for details.\u2029\u2029NOTES\u2029Note  that  both  read  and  list  functionality  are  subsumed  by  these routines, by using a filter like \"(objectclass=*)\" and a scope of LDAP_SCOPE_BASE (to emulate read) or\u2029LDAP_SCOPE_ONELEVEL (to emulate list).\u2029\u2029These routines may dynamically allocate memory. The caller is responsible for freeing such memory using supplied deallocation routines. Return values are contained in &amp;lt;ldap.h&amp;gt;.\u2029\u2029Note that res parameter of ldap_search_ext_s() and ldap_search_s() should be freed with ldap_msgfree() regardless of return value of these functions.\u2029\u2029DEPRECATED INTERFACES\u2029The ldap_search() routine is deprecated in favor of the  ldap_search_ext()  routine.   The  ldap_search_s()  and  ldap_search_st()  routines  are  deprecated  in  favor  of  the\u2029ldap_search_ext_s() routine.\u2029\u2029Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed\u2029to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_result(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 993, "position": [855278, 859952], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_search, ldap_search_s, ldap_search_st, ldap_search_ext, ldap_search_ext_s - Perform an LDAP search operation\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;sys/types.h&amp;gt;\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_search_ext(\u2029LDAP *ld,\u2029char *base,\u2029int scope,\u2029char *filter,\u2029char *attrs[],\u2029int attrsonly,\u2029LDAPControl **serverctrls,\u2029LDAPControl **clientctrls,\u2029struct timeval *timeout,\u2029int sizelimit,\u2029int *msgidp );\u2029\u2029int ldap_search_ext_s(\u2029LDAP *ld,\u2029char *base,\u2029int scope,\u2029char *filter,\u2029char *attrs[],\u2029int attrsonly,\u2029LDAPControl **serverctrls,\u2029LDAPControl **clientctrls,\u2029struct timeval *timeout,\u2029int sizelimit,\u2029LDAPMessage **res );\u2029\u2029DESCRIPTION\u2029These  routines  are  used to perform LDAP search operations.  The ldap_search_ext_s() routine does the search synchronously (i.e., not returning until the operation completes),\u2029providing a pointer to the resulting LDAP messages at the location pointed to by the res parameter.\u2029\u2029The ldap_search_ext() routine is the asynchronous version, initiating the search and returning the message id of the operation it initiated in the  integer  pointed  to  by  the\u2029msgidp parameter.\u2029\u2029The base parameter is the DN of the entry at which to start the search.\u2029\u2029The scope parameter is the scope of the search and should be one of LDAP_SCOPE_BASE, to search the object itself, LDAP_SCOPE_ONELEVEL, to search the object's immediate children,\u2029LDAP_SCOPE_SUBTREE, to search the object and all its descendants, or LDAP_SCOPE_CHILDREN, to search all of the descendants.   Note that the latter requires  the  server  support\u2029the LDAP Subordinates Search Scope extension.\u2029\u2029The  filter  is  a  string  representation  of  the  filter  to apply in the search.  The string should conform to the format specified in RFC 4515 as extended by RFC 4526.  For\u2029instance, \"(cn=Jane Doe)\".  Note that use of the extension requires the server to support the LDAP Absolute True/False Filter extension.  NULL may be specified to  indicate  the\u2029library should send the filter (objectClass=*).\u2029\u2029The  attrs parameter is a null-terminated array of attribute descriptions to return from matching entries.  If NULL is specified, the return of all user attributes is requested.\u2029The description \"*\" (LDAP_ALL_USER_ATTRIBUTES) may be used to request all user attributes to be returned.  The description \"+\"(LDAP_ALL_OPERATIONAL_ATTRIBUTES) may  be  used  to\u2029request  all  operational  attributes to be returned.  Note that this requires the server to support the LDAP All Operational Attribute extension.  To request no attributes, the\u2029description \"1.1\" (LDAP_NO_ATTRS) should be listed by itself.\u2029\u2029The attrsonly parameter should be set to a non-zero value if only attribute descriptions are wanted.  It should be set to zero (0) if both attributes descriptions and  attribute\u2029values are wanted.\u2029\u2029The serverctrls and clientctrls parameters may be used to specify server and client controls, respectively.\u2029\u2029The ldap_search_ext_s() routine is the synchronous version of ldap_search_ext().\u2029\u2029It also returns a code indicating success or, in the case of failure, indicating the nature of the failure of the operation.  See ldap_error(3) for details.\u2029\u2029NOTES\u2029Note  that  both  read  and  list  functionality  are  subsumed  by  these routines, by using a filter like \"(objectclass=*)\" and a scope of LDAP_SCOPE_BASE (to emulate read) or\u2029LDAP_SCOPE_ONELEVEL (to emulate list).\u2029\u2029These routines may dynamically allocate memory. The caller is responsible for freeing such memory using supplied deallocation routines. Return values are contained in &amp;lt;ldap.h&amp;gt;.\u2029\u2029Note that res parameter of ldap_search_ext_s() and ldap_search_s() should be freed with ldap_msgfree() regardless of return value of these functions.\u2029\u2029DEPRECATED INTERFACES\u2029The ldap_search() routine is deprecated in favor of the  ldap_search_ext()  routine.   The  ldap_search_s()  and  ldap_search_st()  routines  are  deprecated  in  favor  of  the\u2029ldap_search_ext_s() routine.\u2029\u2029Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed\u2029to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_result(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 992, "position": [850231, 854905], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_search, ldap_search_s, ldap_search_st, ldap_search_ext, ldap_search_ext_s - Perform an LDAP search operation\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;sys/types.h&amp;gt;\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_search_ext(\u2029LDAP *ld,\u2029char *base,\u2029int scope,\u2029char *filter,\u2029char *attrs[],\u2029int attrsonly,\u2029LDAPControl **serverctrls,\u2029LDAPControl **clientctrls,\u2029struct timeval *timeout,\u2029int sizelimit,\u2029int *msgidp );\u2029\u2029int ldap_search_ext_s(\u2029LDAP *ld,\u2029char *base,\u2029int scope,\u2029char *filter,\u2029char *attrs[],\u2029int attrsonly,\u2029LDAPControl **serverctrls,\u2029LDAPControl **clientctrls,\u2029struct timeval *timeout,\u2029int sizelimit,\u2029LDAPMessage **res );\u2029\u2029DESCRIPTION\u2029These  routines  are  used to perform LDAP search operations.  The ldap_search_ext_s() routine does the search synchronously (i.e., not returning until the operation completes),\u2029providing a pointer to the resulting LDAP messages at the location pointed to by the res parameter.\u2029\u2029The ldap_search_ext() routine is the asynchronous version, initiating the search and returning the message id of the operation it initiated in the  integer  pointed  to  by  the\u2029msgidp parameter.\u2029\u2029The base parameter is the DN of the entry at which to start the search.\u2029\u2029The scope parameter is the scope of the search and should be one of LDAP_SCOPE_BASE, to search the object itself, LDAP_SCOPE_ONELEVEL, to search the object's immediate children,\u2029LDAP_SCOPE_SUBTREE, to search the object and all its descendants, or LDAP_SCOPE_CHILDREN, to search all of the descendants.   Note that the latter requires  the  server  support\u2029the LDAP Subordinates Search Scope extension.\u2029\u2029The  filter  is  a  string  representation  of  the  filter  to apply in the search.  The string should conform to the format specified in RFC 4515 as extended by RFC 4526.  For\u2029instance, \"(cn=Jane Doe)\".  Note that use of the extension requires the server to support the LDAP Absolute True/False Filter extension.  NULL may be specified to  indicate  the\u2029library should send the filter (objectClass=*).\u2029\u2029The  attrs parameter is a null-terminated array of attribute descriptions to return from matching entries.  If NULL is specified, the return of all user attributes is requested.\u2029The description \"*\" (LDAP_ALL_USER_ATTRIBUTES) may be used to request all user attributes to be returned.  The description \"+\"(LDAP_ALL_OPERATIONAL_ATTRIBUTES) may  be  used  to\u2029request  all  operational  attributes to be returned.  Note that this requires the server to support the LDAP All Operational Attribute extension.  To request no attributes, the\u2029description \"1.1\" (LDAP_NO_ATTRS) should be listed by itself.\u2029\u2029The attrsonly parameter should be set to a non-zero value if only attribute descriptions are wanted.  It should be set to zero (0) if both attributes descriptions and  attribute\u2029values are wanted.\u2029\u2029The serverctrls and clientctrls parameters may be used to specify server and client controls, respectively.\u2029\u2029The ldap_search_ext_s() routine is the synchronous version of ldap_search_ext().\u2029\u2029It also returns a code indicating success or, in the case of failure, indicating the nature of the failure of the operation.  See ldap_error(3) for details.\u2029\u2029NOTES\u2029Note  that  both  read  and  list  functionality  are  subsumed  by  these routines, by using a filter like \"(objectclass=*)\" and a scope of LDAP_SCOPE_BASE (to emulate read) or\u2029LDAP_SCOPE_ONELEVEL (to emulate list).\u2029\u2029These routines may dynamically allocate memory. The caller is responsible for freeing such memory using supplied deallocation routines. Return values are contained in &amp;lt;ldap.h&amp;gt;.\u2029\u2029Note that res parameter of ldap_search_ext_s() and ldap_search_s() should be freed with ldap_msgfree() regardless of return value of these functions.\u2029\u2029DEPRECATED INTERFACES\u2029The ldap_search() routine is deprecated in favor of the  ldap_search_ext()  routine.   The  ldap_search_s()  and  ldap_search_st()  routines  are  deprecated  in  favor  of  the\u2029ldap_search_ext_s() routine.\u2029\u2029Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed\u2029to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_result(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 991, "position": [845184, 849858], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_search, ldap_search_s, ldap_search_st, ldap_search_ext, ldap_search_ext_s - Perform an LDAP search operation\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;sys/types.h&amp;gt;\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_search_ext(\u2029LDAP *ld,\u2029char *base,\u2029int scope,\u2029char *filter,\u2029char *attrs[],\u2029int attrsonly,\u2029LDAPControl **serverctrls,\u2029LDAPControl **clientctrls,\u2029struct timeval *timeout,\u2029int sizelimit,\u2029int *msgidp );\u2029\u2029int ldap_search_ext_s(\u2029LDAP *ld,\u2029char *base,\u2029int scope,\u2029char *filter,\u2029char *attrs[],\u2029int attrsonly,\u2029LDAPControl **serverctrls,\u2029LDAPControl **clientctrls,\u2029struct timeval *timeout,\u2029int sizelimit,\u2029LDAPMessage **res );\u2029\u2029DESCRIPTION\u2029These  routines  are  used to perform LDAP search operations.  The ldap_search_ext_s() routine does the search synchronously (i.e., not returning until the operation completes),\u2029providing a pointer to the resulting LDAP messages at the location pointed to by the res parameter.\u2029\u2029The ldap_search_ext() routine is the asynchronous version, initiating the search and returning the message id of the operation it initiated in the  integer  pointed  to  by  the\u2029msgidp parameter.\u2029\u2029The base parameter is the DN of the entry at which to start the search.\u2029\u2029The scope parameter is the scope of the search and should be one of LDAP_SCOPE_BASE, to search the object itself, LDAP_SCOPE_ONELEVEL, to search the object's immediate children,\u2029LDAP_SCOPE_SUBTREE, to search the object and all its descendants, or LDAP_SCOPE_CHILDREN, to search all of the descendants.   Note that the latter requires  the  server  support\u2029the LDAP Subordinates Search Scope extension.\u2029\u2029The  filter  is  a  string  representation  of  the  filter  to apply in the search.  The string should conform to the format specified in RFC 4515 as extended by RFC 4526.  For\u2029instance, \"(cn=Jane Doe)\".  Note that use of the extension requires the server to support the LDAP Absolute True/False Filter extension.  NULL may be specified to  indicate  the\u2029library should send the filter (objectClass=*).\u2029\u2029The  attrs parameter is a null-terminated array of attribute descriptions to return from matching entries.  If NULL is specified, the return of all user attributes is requested.\u2029The description \"*\" (LDAP_ALL_USER_ATTRIBUTES) may be used to request all user attributes to be returned.  The description \"+\"(LDAP_ALL_OPERATIONAL_ATTRIBUTES) may  be  used  to\u2029request  all  operational  attributes to be returned.  Note that this requires the server to support the LDAP All Operational Attribute extension.  To request no attributes, the\u2029description \"1.1\" (LDAP_NO_ATTRS) should be listed by itself.\u2029\u2029The attrsonly parameter should be set to a non-zero value if only attribute descriptions are wanted.  It should be set to zero (0) if both attributes descriptions and  attribute\u2029values are wanted.\u2029\u2029The serverctrls and clientctrls parameters may be used to specify server and client controls, respectively.\u2029\u2029The ldap_search_ext_s() routine is the synchronous version of ldap_search_ext().\u2029\u2029It also returns a code indicating success or, in the case of failure, indicating the nature of the failure of the operation.  See ldap_error(3) for details.\u2029\u2029NOTES\u2029Note  that  both  read  and  list  functionality  are  subsumed  by  these routines, by using a filter like \"(objectclass=*)\" and a scope of LDAP_SCOPE_BASE (to emulate read) or\u2029LDAP_SCOPE_ONELEVEL (to emulate list).\u2029\u2029These routines may dynamically allocate memory. The caller is responsible for freeing such memory using supplied deallocation routines. Return values are contained in &amp;lt;ldap.h&amp;gt;.\u2029\u2029Note that res parameter of ldap_search_ext_s() and ldap_search_s() should be freed with ldap_msgfree() regardless of return value of these functions.\u2029\u2029DEPRECATED INTERFACES\u2029The ldap_search() routine is deprecated in favor of the  ldap_search_ext()  routine.   The  ldap_search_s()  and  ldap_search_st()  routines  are  deprecated  in  favor  of  the\u2029ldap_search_ext_s() routine.\u2029\u2029Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed\u2029to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_result(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 990, "position": [840137, 844811], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_search, ldap_search_s, ldap_search_st, ldap_search_ext, ldap_search_ext_s - Perform an LDAP search operation\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029SYNOPSIS\u2029#include &amp;lt;sys/types.h&amp;gt;\u2029#include &amp;lt;ldap.h&amp;gt;\u2029\u2029int ldap_search_ext(\u2029LDAP *ld,\u2029char *base,\u2029int scope,\u2029char *filter,\u2029char *attrs[],\u2029int attrsonly,\u2029LDAPControl **serverctrls,\u2029LDAPControl **clientctrls,\u2029struct timeval *timeout,\u2029int sizelimit,\u2029int *msgidp );\u2029\u2029int ldap_search_ext_s(\u2029LDAP *ld,\u2029char *base,\u2029int scope,\u2029char *filter,\u2029char *attrs[],\u2029int attrsonly,\u2029LDAPControl **serverctrls,\u2029LDAPControl **clientctrls,\u2029struct timeval *timeout,\u2029int sizelimit,\u2029LDAPMessage **res );\u2029\u2029DESCRIPTION\u2029These  routines  are  used to perform LDAP search operations.  The ldap_search_ext_s() routine does the search synchronously (i.e., not returning until the operation completes),\u2029providing a pointer to the resulting LDAP messages at the location pointed to by the res parameter.\u2029\u2029The ldap_search_ext() routine is the asynchronous version, initiating the search and returning the message id of the operation it initiated in the  integer  pointed  to  by  the\u2029msgidp parameter.\u2029\u2029The base parameter is the DN of the entry at which to start the search.\u2029\u2029The scope parameter is the scope of the search and should be one of LDAP_SCOPE_BASE, to search the object itself, LDAP_SCOPE_ONELEVEL, to search the object's immediate children,\u2029LDAP_SCOPE_SUBTREE, to search the object and all its descendants, or LDAP_SCOPE_CHILDREN, to search all of the descendants.   Note that the latter requires  the  server  support\u2029the LDAP Subordinates Search Scope extension.\u2029\u2029The  filter  is  a  string  representation  of  the  filter  to apply in the search.  The string should conform to the format specified in RFC 4515 as extended by RFC 4526.  For\u2029instance, \"(cn=Jane Doe)\".  Note that use of the extension requires the server to support the LDAP Absolute True/False Filter extension.  NULL may be specified to  indicate  the\u2029library should send the filter (objectClass=*).\u2029\u2029The  attrs parameter is a null-terminated array of attribute descriptions to return from matching entries.  If NULL is specified, the return of all user attributes is requested.\u2029The description \"*\" (LDAP_ALL_USER_ATTRIBUTES) may be used to request all user attributes to be returned.  The description \"+\"(LDAP_ALL_OPERATIONAL_ATTRIBUTES) may  be  used  to\u2029request  all  operational  attributes to be returned.  Note that this requires the server to support the LDAP All Operational Attribute extension.  To request no attributes, the\u2029description \"1.1\" (LDAP_NO_ATTRS) should be listed by itself.\u2029\u2029The attrsonly parameter should be set to a non-zero value if only attribute descriptions are wanted.  It should be set to zero (0) if both attributes descriptions and  attribute\u2029values are wanted.\u2029\u2029The serverctrls and clientctrls parameters may be used to specify server and client controls, respectively.\u2029\u2029The ldap_search_ext_s() routine is the synchronous version of ldap_search_ext().\u2029\u2029It also returns a code indicating success or, in the case of failure, indicating the nature of the failure of the operation.  See ldap_error(3) for details.\u2029\u2029NOTES\u2029Note  that  both  read  and  list  functionality  are  subsumed  by  these routines, by using a filter like \"(objectclass=*)\" and a scope of LDAP_SCOPE_BASE (to emulate read) or\u2029LDAP_SCOPE_ONELEVEL (to emulate list).\u2029\u2029These routines may dynamically allocate memory. The caller is responsible for freeing such memory using supplied deallocation routines. Return values are contained in &amp;lt;ldap.h&amp;gt;.\u2029\u2029Note that res parameter of ldap_search_ext_s() and ldap_search_s() should be freed with ldap_msgfree() regardless of return value of these functions.\u2029\u2029DEPRECATED INTERFACES\u2029The ldap_search() routine is deprecated in favor of the  ldap_search_ext()  routine.   The  ldap_search_s()  and  ldap_search_st()  routines  are  deprecated  in  favor  of  the\u2029ldap_search_ext_s() routine.\u2029\u2029Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed\u2029to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3), ldap_result(3), ldap_error(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 989, "position": [835090, 839764], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "72", "annotation": "LDAP_SORT", "group_ids": [{"name2": "NAME\u2029ldap_sort_entries, ldap_sort_values, ldap_sort_strcasecmp - LDAP sorting routines (deprecated)\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029DESCRIPTION\u2029The ldap_sort_entries(), ldap_sort_values(), and ldap_sort_strcasecmp() are deprecated.\u2029\u2029Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed\u2029to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 997, "position": [920955, 921867], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_sort_entries, ldap_sort_values, ldap_sort_strcasecmp - LDAP sorting routines (deprecated)\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029DESCRIPTION\u2029The ldap_sort_entries(), ldap_sort_values(), and ldap_sort_strcasecmp() are deprecated.\u2029\u2029Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed\u2029to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 996, "position": [919670, 920582], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_sort_entries, ldap_sort_values, ldap_sort_strcasecmp - LDAP sorting routines (deprecated)\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029DESCRIPTION\u2029The ldap_sort_entries(), ldap_sort_values(), and ldap_sort_strcasecmp() are deprecated.\u2029\u2029Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed\u2029to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 995, "position": [918385, 919297], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}, {"name2": "NAME\u2029ldap_sort_entries, ldap_sort_values, ldap_sort_strcasecmp - LDAP sorting routines (deprecated)\u2029\u2029LIBRARY\u2029OpenLDAP LDAP (libldap, -lldap)\u2029\u2029DESCRIPTION\u2029The ldap_sort_entries(), ldap_sort_values(), and ldap_sort_strcasecmp() are deprecated.\u2029\u2029Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed\u2029to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected\u2029that documentation (and, eventually, support) for deprecated interfaces to be eliminated.\u2029\u2029SEE ALSO\u2029ldap(3)\u2029\u2029ACKNOWLEDGEMENTS\u2029OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.", "id_dupl": 994, "position": [917100, 918012], "check": 0, "intersection": 0, "FP_dupl": 1000000, "FN_dupl": 1000000, "F": 0, "Prec_Dupl": 0, "Recall_Dupl": 0}]}, {"name": "73", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 TLS_CRLCHECK \u0438 TLS_CRLFILE", "group_ids": [{"name2": "Specifies  the  file containing a Certificate Revocation List to be used to verify if the server certificates have not been revoked. This parameter is only supported with\u2029GnuTLS and Mozilla NSS.", "id_dupl": 999, "position": [1078507, 1078701], "check": 1, "intersection": 73, "FP_dupl": 0, "FN_dupl": 122, "F": 0.5447761194029851, "Prec_Dupl": 1.0, "Recall_Dupl": 0.37435897435897436}, {"name2": "Specifies if the Certificate Revocation List (CRL) of the CA should be used to verify if the server certificates have not been revoked. This requires TLS_CACERTDIR param\u2010\u2029eter to be set. This parameter is ignored with GnuTLS and Mozilla NSS. ", "id_dupl": 998, "position": [1078019, 1078261], "check": 1, "intersection": 73, "FP_dupl": 0, "FN_dupl": 170, "F": 0.4620253164556962, "Prec_Dupl": 1.0, "Recall_Dupl": 0.3004115226337449}]}, {"name": "74", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043a\u043e\u043c\u0430\u043d\u0434 \u043f\u0430\u043a\u0435\u0442\u0430 ldap \u0434\u043b\u044f \u043f\u043e\u0438\u0441\u043a\u0430(\u043a\u0430\u0442\u0430\u043b\u043e\u0433\u043e\u0432)", "group_ids": [{"name2": "This command initiates a LDAP search below the baseObject tree using a complex LDAP search expression filterString.  The search  gets  the  specified  attributes  of  all\u2029matching  objects  (DNs).   The  command itself just starts the search, to retrieve the actual results, use ::ldap::searchNext.  A search can be terminated at any time by\u2029::ldap::searchEnd. This informs the server that no further results should be sent by sending and ABANDON message and cleans up the internal state of the search.  Only one\u2029::ldap::search  can  be  active at a given time, this includes the introspection commands ::ldap::info saslmechanisms, ldap::info control and ldap::info extensions, which\u2029invoke a search internally.  Error responses from the server due to wrong arguments or similar things are returned with the first ::ldap::searchNext call  and  should  be\u2029checked  and  dealed with there.  If the list of requested attributes is empty all attributes will be returned.", "id_dupl": 1001, "position": [357392, 358358], "check": 1, "intersection": 197, "FP_dupl": 50, "FN_dupl": 770, "F": 0.3245469522240527, "Prec_Dupl": 0.7975708502024291, "Recall_Dupl": 0.20372285418821096}, {"name2": "This  command  performs  a  LDAP search below the baseObject tree using a complex LDAP search expression filterString and returns the specified attributes of all matching\u2029objects (DNs). If the list of attributes was empty all attributes are returned. The command blocks until it has received all results.  The valid options are identical  to\u2029the options listed for ::ldap::searchInit.", "id_dupl": 1000, "position": [356575, 356959], "check": 1, "intersection": 186, "FP_dupl": 50, "FN_dupl": 199, "F": 0.5990338164251208, "Prec_Dupl": 0.788135593220339, "Recall_Dupl": 0.4831168831168831}]}, {"name": "75", "annotation": "\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043a\u043e\u043c\u0430\u043d\u0434 \u0438 \u0438\u0445 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432 \u043f\u0430\u043a\u0435\u0442\u0430 ldap:  ::ldap::modify \u0438 ::ldap::modifyMulti (\u0438\u0437\u043c\u0435\u043d\u044f\u044e\u0449\u0438\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043e\u0431\u044a\u0435\u043a\u0442\u0430 dn)", "group_ids": [{"name2": "This command modifies the object dn on the ldap server we are connected to via handle. It replaces attributes with new values, deletes attributes, and adds new attributes\u2029with new values.  All arguments are lists with the format:\u2029\u2029attr1 {val11 val12 ...} attr2 {val21...} ...\u2029\u2029where each value list may be empty for deleting all attributes.  The optional arguments default to empty lists of attributes to delete and to add.", "id_dupl": 1003, "position": [362021, 362444], "check": 1, "intersection": 207, "FP_dupl": 15, "FN_dupl": 217, "F": 0.6408668730650154, "Prec_Dupl": 0.9324324324324325, "Recall_Dupl": 0.4882075471698113}, {"name2": "This command modifies the object dn on the ldap server we are connected to via handle. It replaces attributes with new values, deletes attributes, and adds new attributes\u2029with new values.  All arguments are dictionaries mapping attribute names to values. The optional arguments default to the empty dictionary, which means that no attributes\u2029will be deleted nor added.", "id_dupl": 1002, "position": [360791, 361159], "check": 1, "intersection": 207, "FP_dupl": 15, "FN_dupl": 162, "F": 0.700507614213198, "Prec_Dupl": 0.9324324324324325, "Recall_Dupl": 0.5609756097560976}]}]}