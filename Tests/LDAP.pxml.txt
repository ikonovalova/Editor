<?xml version="1.0" encoding="utf-8" ?>
<plainxml>LBER_ENCODE(3)                                                                  Library Functions Manual                                                                  LBER_ENCODE(3)

NAME
ber_alloc_t,  ber_flush,  ber_flush2,  ber_printf,  ber_put_int,  ber_put_enum, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean, ber_put_bitstring, ber_start_seq,
ber_start_set, ber_put_seq, ber_put_set - OpenLDAP LBER simplified Basic Encoding Rules library routines for encoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

BerElement *ber_alloc_t(int options);

int ber_flush(Sockbuf *sb, BerElement *ber, int freeit);

int ber_flush2(Sockbuf *sb, BerElement *ber, int freeit);

int ber_printf(BerElement *ber, const char *fmt, ...);

int ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);

int ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);

int ber_put_ostring(BerElement *ber, const char *str, ber_len_t len, ber_tag_t tag);

int ber_put_string(BerElement *ber, const char *str, ber_tag_t tag);

int ber_put_null(BerElement *ber, ber_tag_t tag);

int ber_put_boolean(BerElement *ber, ber_int_t bool, ber_tag_t tag);

int ber_put_bitstring(BerElement *ber, const char *str, ber_len_t blen, ber_tag_t tag);

int ber_start_seq(BerElement *ber, ber_tag_t tag);

int ber_start_set(BerElement *ber, ber_tag_t tag);

int ber_put_seq(BerElement *ber);

int ber_put_set(BerElement *ber);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and
ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou‐
tines return the length of the element encoded, or -1 if an error occurred.

The ber_alloc_t() routine is used to allocate a new BER element.  It should be called with an argument of LBER_USE_DER.

The ber_flush2() routine is used to actually write the element to a socket (or file) descriptor, once it has been fully encoded (using ber_printf() and friends).  See lber-sock‐
buf(3) for more details on the Sockbuf implementation of the sb parameter.  If the freeit parameter is non-zero, the supplied ber will be freed.   If  LBER_FLUSH_FREE_ON_SUCCESS
is used, the ber is only freed when successfully flushed, otherwise it is left intact; if LBER_FLUSH_FREE_ON_ERROR is used, the ber is only freed when an error occurs, otherwise
it is left intact; if LBER_FLUSH_FREE_ALWAYS is used, the ber is freed anyway.  This function differs from the original ber_flush(3) function, whose behavior corresponds to that
indicated  for LBER_FLUSH_FREE_ON_SUCCESS.  Note that in the future, the behavior of ber_flush(3) with freeit non-zero might change into that of ber_flush2(3) with freeit set to
LBER_FLUSH_FREE_ALWAYS.

The ber_printf() routine is used to encode a BER element in much the same way that sprintf(3) works.  One important difference, though, is that some state  information  is  kept
with  the ber parameter so that multiple calls can be made to ber_printf() to append things to the end of the BER element.  Ber_printf() writes to ber, a pointer to a BerElement
such as returned by ber_alloc_t().  It interprets and formats its arguments according to the format string fmt.  The format string can contain the following characters:

b  Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.

e  Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.

i  Integer.  An ber_int_t parameter should be supplied.  An integer element is output.

B  Bitstring.  A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.  A bitstring element is output.

n  Null.  No parameter is required.  A null element is output.

o  Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.

O  Octet string.  A struct berval * is supplied.  An octet string element is output.

s  Octet string.  A null-terminated string is supplied.  An octet string element is output, not including the trailing NULL octet.

t  Tag.  A ber_tag_t specifying the tag to give the next element is provided.  This works across calls.

v  Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.

V  Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet
strings.

W  Several  octet  strings.  An array of struct berval's is supplied.  The array is terminated by a struct berval with a NULL bv_val.  Note that a construct like '{W}' is
required to get an actual SEQUENCE OF octet strings.

{  Begin sequence.  No parameter is required.

}  End sequence.  No parameter is required.

[  Begin set.  No parameter is required.

]  End set.  No parameter is required.

The ber_put_int() routine writes the integer element num to the BER element ber.

The ber_put_enum() routine writes the enumeration element num to the BER element ber.

The ber_put_boolean() routine writes the boolean value given by bool to the BER element.

The ber_put_bitstring() routine writes blen bits starting at str as a bitstring value to the given BER element.  Note that blen is the length in bits of the bitstring.

The ber_put_ostring() routine writes len bytes starting at str to the BER element as an octet string.

The ber_put_string() routine writes the null-terminated string (minus the terminating ' ') to the BER element as an octet string.

The ber_put_null() routine writes a NULL element to the BER element.

The ber_start_seq() routine is used to start a sequence in the BER element.  The ber_start_set() routine works similarly.  The end of the sequence or set is marked by the  near‐
est matching call to ber_put_seq() or ber_put_set(), respectively.

EXAMPLES
Assuming the following variable declarations, and that the variables have been assigned appropriately, an lber encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

can be achieved like so:

int rc;
ber_int_t    scope, ali, size, time, attrsonly;
char   *dn, **attrs;
BerElement *ber;

/* ... fill in values ... */

ber = ber_alloc_t( LBER_USE_DER );

if ( ber == NULL ) {
/* error */
}

rc = ber_printf( ber, "{siiiib{v}}", dn, scope, ali,
size, time, attrsonly, attrs );

if( rc == -1 ) {
/* error */
} else {
/* success */
}

ERRORS
If an error occurs during encoding, generally these routines return -1.

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.

SEE ALSO
lber-decode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_ENCODE(3)
LBER_TYPES(3)                                                                   Library Functions Manual                                                                   LBER_TYPES(3)

NAME
ber_int_t,  ber_uint_t,  ber_len_t,  ber_slen_t,  ber_tag_t,  struct  berval, BerValue, BerVarray, BerElement, ber_bvfree, ber_bvecfree, ber_bvecadd, ber_bvarray_free, ber_bvar‐
ray_add, ber_bvdup, ber_dupbv, ber_bvstr, ber_bvstrdup, ber_str2bv, ber_alloc_t, ber_init, ber_init2, ber_free - OpenLDAP LBER types and allocation functions

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

typedef impl_tag_t ber_tag_t;
typedef impl_int_t ber_int_t;
typedef impl_uint_t ber_uint_t;
typedef impl_len_t ber_len_t;
typedef impl_slen_t ber_slen_t;

typedef struct berval {
ber_len_t bv_len;
char *bv_val;
} BerValue, *BerVarray;

typedef struct berelement BerElement;

void ber_bvfree(struct berval *bv);

void ber_bvecfree(struct berval **bvec);

void ber_bvecadd(struct berval ***bvec, struct berval *bv);

void ber_bvarray_free(struct berval *bvarray);

void ber_bvarray_add(BerVarray *bvarray, BerValue *bv);

struct berval *ber_bvdup(const struct berval *bv);

struct berval *ber_dupbv(const struct berval *dst, struct berval *src);

struct berval *ber_bvstr(const char *str);

struct berval *ber_bvstrdup(const char *str);

struct berval *ber_str2bv(const char *str, ber_len_t len, int dup, struct berval *bv);

BerElement *ber_alloc_t(int options);

BerElement *ber_init(struct berval *bv);

void ber_init2(BerElement *ber, struct berval *bv, int options);

void ber_free(BerElement *ber, int freebuf);

DESCRIPTION
The following are the basic types and structures defined for use with the Lightweight BER library.

ber_int_t is a signed integer of at least 32 bits.  It is commonly equivalent to int.  ber_uint_t is the unsigned variant of ber_int_t.

ber_len_t is an unsigned integer of at least 32 bits used to represent a length.  It is commonly equivalent to a size_t.  ber_slen_t is the signed variant to ber_len_t.

ber_tag_t is an unsigned integer of at least 32 bits used to represent a BER tag.  It is commonly equivalent to a unsigned long.

The actual definitions of the integral impl_TYPE_t types are platform specific.

BerValue, commonly used as struct berval, is used to hold an arbitrary sequence of octets.  bv_val points to bv_len octets.  bv_val is  not  necessarily  terminated  by  a  NULL
(zero) octet.  ber_bvfree() frees a BerValue, pointed to by bv, returned from this API.  If bv is NULL, the routine does nothing.

ber_bvecfree() frees an array of BerValues (and the array), pointed to by bvec, returned from this API.  If bvec is NULL, the routine does nothing.  ber_bvecadd() appends the bv
pointer to the bvec array.  Space for the array is allocated as needed.  The end of the array is marked by a NULL pointer.

ber_bvarray_free() frees an array of BerValues (and the array), pointed to by bvarray, returned from this API.  If bvarray is NULL, the routine does nothing.   ber_bvarray_add()
appends the contents of the BerValue pointed to by bv to the bvarray array.  Space for the new element is allocated as needed.  The end of the array is marked by a BerValue with
a NULL bv_val field.

ber_bvdup() returns a copy of a BerValue.  The routine returns NULL upon error (e.g. out of memory).  The caller should use ber_bvfree() to deallocate  the  resulting  BerValue.
ber_dupbv()  copies  a  BerValue from src to dst.  If dst is NULL a new BerValue will be allocated to hold the copy.  The routine returns NULL upon error, otherwise it returns a
pointer to the copy.  If dst is NULL the caller should use ber_bvfree() to deallocate  the  resulting  BerValue,  otherwise  ber_memfree()  should  be  used  to  deallocate  the
dst-&amp;gt;bv_val.   (The  ber_bvdup()  function  is internally implemented as ber_dupbv(NULL, bv).  ber_bvdup() is provided only for compatibility with an expired draft of the LDAP C
API; ber_dupbv() is the preferred interface.)

ber_bvstr() returns a BerValue containing the string pointed to by str.  ber_bvstrdup() returns a BerValue containing a copy of the  string  pointed  to  by  str.   ber_str2bv()
returns  a  BerValue  containing the string pointed to by str, whose length may be optionally specified in len.  If dup is non-zero, the BerValue will contain a copy of str.  If
len is zero, the number of bytes to copy will be determined by strlen(3), otherwise len bytes will be copied.  If bv is  non-NULL,  the  result  will  be  stored  in  the  given
BerValue, otherwise a new BerValue will be allocated to store the result.  NOTE: Both ber_bvstr() and ber_bvstrdup() are implemented as macros using ber_str2bv() in this version
of the library.

BerElement is an opaque structure used to maintain state information used in encoding and  decoding.   ber_alloc_t()  is  used  to  create  an  empty  BerElement  structure.  If
LBER_USE_DER is specified for the options parameter then data lengths for data written to the BerElement will be encoded in the minimal number of octets required, otherwise they
will always be written as four byte values.  ber_init() creates a BerElement structure that is initialized with a copy of the data in its bv parameter.  ber_init2()  initializes
an  existing  BerElement ber using the data in the bv parameter. The data is referenced directly, not copied. The options parameter is the same as for ber_alloc_t().  ber_free()
frees a BerElement pointed to by ber.  If ber is NULL, the routine does nothing.  If freebuf is zero, the internal buffer is not freed.

SEE ALSO
lber-encode(3), lber-decode(3), lber-memory(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                          LBER_TYPES(3)
LBER_TYPES(3)                                                                   Library Functions Manual                                                                   LBER_TYPES(3)

NAME
ber_int_t,  ber_uint_t,  ber_len_t,  ber_slen_t,  ber_tag_t,  struct  berval, BerValue, BerVarray, BerElement, ber_bvfree, ber_bvecfree, ber_bvecadd, ber_bvarray_free, ber_bvar‐
ray_add, ber_bvdup, ber_dupbv, ber_bvstr, ber_bvstrdup, ber_str2bv, ber_alloc_t, ber_init, ber_init2, ber_free - OpenLDAP LBER types and allocation functions

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

typedef impl_tag_t ber_tag_t;
typedef impl_int_t ber_int_t;
typedef impl_uint_t ber_uint_t;
typedef impl_len_t ber_len_t;
typedef impl_slen_t ber_slen_t;

typedef struct berval {
ber_len_t bv_len;
char *bv_val;
} BerValue, *BerVarray;

typedef struct berelement BerElement;

void ber_bvfree(struct berval *bv);

void ber_bvecfree(struct berval **bvec);

void ber_bvecadd(struct berval ***bvec, struct berval *bv);

void ber_bvarray_free(struct berval *bvarray);

void ber_bvarray_add(BerVarray *bvarray, BerValue *bv);

struct berval *ber_bvdup(const struct berval *bv);

struct berval *ber_dupbv(const struct berval *dst, struct berval *src);

struct berval *ber_bvstr(const char *str);

struct berval *ber_bvstrdup(const char *str);

struct berval *ber_str2bv(const char *str, ber_len_t len, int dup, struct berval *bv);

BerElement *ber_alloc_t(int options);

BerElement *ber_init(struct berval *bv);

void ber_init2(BerElement *ber, struct berval *bv, int options);

void ber_free(BerElement *ber, int freebuf);

DESCRIPTION
The following are the basic types and structures defined for use with the Lightweight BER library.

ber_int_t is a signed integer of at least 32 bits.  It is commonly equivalent to int.  ber_uint_t is the unsigned variant of ber_int_t.

ber_len_t is an unsigned integer of at least 32 bits used to represent a length.  It is commonly equivalent to a size_t.  ber_slen_t is the signed variant to ber_len_t.

ber_tag_t is an unsigned integer of at least 32 bits used to represent a BER tag.  It is commonly equivalent to a unsigned long.

The actual definitions of the integral impl_TYPE_t types are platform specific.

BerValue, commonly used as struct berval, is used to hold an arbitrary sequence of octets.  bv_val points to bv_len octets.  bv_val is  not  necessarily  terminated  by  a  NULL
(zero) octet.  ber_bvfree() frees a BerValue, pointed to by bv, returned from this API.  If bv is NULL, the routine does nothing.

ber_bvecfree() frees an array of BerValues (and the array), pointed to by bvec, returned from this API.  If bvec is NULL, the routine does nothing.  ber_bvecadd() appends the bv
pointer to the bvec array.  Space for the array is allocated as needed.  The end of the array is marked by a NULL pointer.

ber_bvarray_free() frees an array of BerValues (and the array), pointed to by bvarray, returned from this API.  If bvarray is NULL, the routine does nothing.   ber_bvarray_add()
appends the contents of the BerValue pointed to by bv to the bvarray array.  Space for the new element is allocated as needed.  The end of the array is marked by a BerValue with
a NULL bv_val field.

ber_bvdup() returns a copy of a BerValue.  The routine returns NULL upon error (e.g. out of memory).  The caller should use ber_bvfree() to deallocate  the  resulting  BerValue.
ber_dupbv()  copies  a  BerValue from src to dst.  If dst is NULL a new BerValue will be allocated to hold the copy.  The routine returns NULL upon error, otherwise it returns a
pointer to the copy.  If dst is NULL the caller should use ber_bvfree() to deallocate  the  resulting  BerValue,  otherwise  ber_memfree()  should  be  used  to  deallocate  the
dst-&amp;gt;bv_val.   (The  ber_bvdup()  function  is internally implemented as ber_dupbv(NULL, bv).  ber_bvdup() is provided only for compatibility with an expired draft of the LDAP C
API; ber_dupbv() is the preferred interface.)

ber_bvstr() returns a BerValue containing the string pointed to by str.  ber_bvstrdup() returns a BerValue containing a copy of the  string  pointed  to  by  str.   ber_str2bv()
returns  a  BerValue  containing the string pointed to by str, whose length may be optionally specified in len.  If dup is non-zero, the BerValue will contain a copy of str.  If
len is zero, the number of bytes to copy will be determined by strlen(3), otherwise len bytes will be copied.  If bv is  non-NULL,  the  result  will  be  stored  in  the  given
BerValue, otherwise a new BerValue will be allocated to store the result.  NOTE: Both ber_bvstr() and ber_bvstrdup() are implemented as macros using ber_str2bv() in this version
of the library.

BerElement is an opaque structure used to maintain state information used in encoding and  decoding.   ber_alloc_t()  is  used  to  create  an  empty  BerElement  structure.  If
LBER_USE_DER is specified for the options parameter then data lengths for data written to the BerElement will be encoded in the minimal number of octets required, otherwise they
will always be written as four byte values.  ber_init() creates a BerElement structure that is initialized with a copy of the data in its bv parameter.  ber_init2()  initializes
an  existing  BerElement ber using the data in the bv parameter. The data is referenced directly, not copied. The options parameter is the same as for ber_alloc_t().  ber_free()
frees a BerElement pointed to by ber.  If ber is NULL, the routine does nothing.  If freebuf is zero, the internal buffer is not freed.

SEE ALSO
lber-encode(3), lber-decode(3), lber-memory(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                          LBER_TYPES(3)
LBER_TYPES(3)                                                                   Library Functions Manual                                                                   LBER_TYPES(3)

NAME
ber_int_t,  ber_uint_t,  ber_len_t,  ber_slen_t,  ber_tag_t,  struct  berval, BerValue, BerVarray, BerElement, ber_bvfree, ber_bvecfree, ber_bvecadd, ber_bvarray_free, ber_bvar‐
ray_add, ber_bvdup, ber_dupbv, ber_bvstr, ber_bvstrdup, ber_str2bv, ber_alloc_t, ber_init, ber_init2, ber_free - OpenLDAP LBER types and allocation functions

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

typedef impl_tag_t ber_tag_t;
typedef impl_int_t ber_int_t;
typedef impl_uint_t ber_uint_t;
typedef impl_len_t ber_len_t;
typedef impl_slen_t ber_slen_t;

typedef struct berval {
ber_len_t bv_len;
char *bv_val;
} BerValue, *BerVarray;

typedef struct berelement BerElement;

void ber_bvfree(struct berval *bv);

void ber_bvecfree(struct berval **bvec);

void ber_bvecadd(struct berval ***bvec, struct berval *bv);

void ber_bvarray_free(struct berval *bvarray);

void ber_bvarray_add(BerVarray *bvarray, BerValue *bv);

struct berval *ber_bvdup(const struct berval *bv);

struct berval *ber_dupbv(const struct berval *dst, struct berval *src);

struct berval *ber_bvstr(const char *str);

struct berval *ber_bvstrdup(const char *str);

struct berval *ber_str2bv(const char *str, ber_len_t len, int dup, struct berval *bv);

BerElement *ber_alloc_t(int options);

BerElement *ber_init(struct berval *bv);

void ber_init2(BerElement *ber, struct berval *bv, int options);

void ber_free(BerElement *ber, int freebuf);

DESCRIPTION
The following are the basic types and structures defined for use with the Lightweight BER library.

ber_int_t is a signed integer of at least 32 bits.  It is commonly equivalent to int.  ber_uint_t is the unsigned variant of ber_int_t.

ber_len_t is an unsigned integer of at least 32 bits used to represent a length.  It is commonly equivalent to a size_t.  ber_slen_t is the signed variant to ber_len_t.

ber_tag_t is an unsigned integer of at least 32 bits used to represent a BER tag.  It is commonly equivalent to a unsigned long.

The actual definitions of the integral impl_TYPE_t types are platform specific.

BerValue, commonly used as struct berval, is used to hold an arbitrary sequence of octets.  bv_val points to bv_len octets.  bv_val is  not  necessarily  terminated  by  a  NULL
(zero) octet.  ber_bvfree() frees a BerValue, pointed to by bv, returned from this API.  If bv is NULL, the routine does nothing.

ber_bvecfree() frees an array of BerValues (and the array), pointed to by bvec, returned from this API.  If bvec is NULL, the routine does nothing.  ber_bvecadd() appends the bv
pointer to the bvec array.  Space for the array is allocated as needed.  The end of the array is marked by a NULL pointer.

ber_bvarray_free() frees an array of BerValues (and the array), pointed to by bvarray, returned from this API.  If bvarray is NULL, the routine does nothing.   ber_bvarray_add()
appends the contents of the BerValue pointed to by bv to the bvarray array.  Space for the new element is allocated as needed.  The end of the array is marked by a BerValue with
a NULL bv_val field.

ber_bvdup() returns a copy of a BerValue.  The routine returns NULL upon error (e.g. out of memory).  The caller should use ber_bvfree() to deallocate  the  resulting  BerValue.
ber_dupbv()  copies  a  BerValue from src to dst.  If dst is NULL a new BerValue will be allocated to hold the copy.  The routine returns NULL upon error, otherwise it returns a
pointer to the copy.  If dst is NULL the caller should use ber_bvfree() to deallocate  the  resulting  BerValue,  otherwise  ber_memfree()  should  be  used  to  deallocate  the
dst-&amp;gt;bv_val.   (The  ber_bvdup()  function  is internally implemented as ber_dupbv(NULL, bv).  ber_bvdup() is provided only for compatibility with an expired draft of the LDAP C
API; ber_dupbv() is the preferred interface.)

ber_bvstr() returns a BerValue containing the string pointed to by str.  ber_bvstrdup() returns a BerValue containing a copy of the  string  pointed  to  by  str.   ber_str2bv()
returns  a  BerValue  containing the string pointed to by str, whose length may be optionally specified in len.  If dup is non-zero, the BerValue will contain a copy of str.  If
len is zero, the number of bytes to copy will be determined by strlen(3), otherwise len bytes will be copied.  If bv is  non-NULL,  the  result  will  be  stored  in  the  given
BerValue, otherwise a new BerValue will be allocated to store the result.  NOTE: Both ber_bvstr() and ber_bvstrdup() are implemented as macros using ber_str2bv() in this version
of the library.

BerElement is an opaque structure used to maintain state information used in encoding and  decoding.   ber_alloc_t()  is  used  to  create  an  empty  BerElement  structure.  If
LBER_USE_DER is specified for the options parameter then data lengths for data written to the BerElement will be encoded in the minimal number of octets required, otherwise they
will always be written as four byte values.  ber_init() creates a BerElement structure that is initialized with a copy of the data in its bv parameter.  ber_init2()  initializes
an  existing  BerElement ber using the data in the bv parameter. The data is referenced directly, not copied. The options parameter is the same as for ber_alloc_t().  ber_free()
frees a BerElement pointed to by ber.  If ber is NULL, the routine does nothing.  If freebuf is zero, the internal buffer is not freed.

SEE ALSO
lber-encode(3), lber-decode(3), lber-memory(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                          LBER_TYPES(3)
LBER_TYPES(3)                                                                   Library Functions Manual                                                                   LBER_TYPES(3)

NAME
ber_int_t,  ber_uint_t,  ber_len_t,  ber_slen_t,  ber_tag_t,  struct  berval, BerValue, BerVarray, BerElement, ber_bvfree, ber_bvecfree, ber_bvecadd, ber_bvarray_free, ber_bvar‐
ray_add, ber_bvdup, ber_dupbv, ber_bvstr, ber_bvstrdup, ber_str2bv, ber_alloc_t, ber_init, ber_init2, ber_free - OpenLDAP LBER types and allocation functions

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

typedef impl_tag_t ber_tag_t;
typedef impl_int_t ber_int_t;
typedef impl_uint_t ber_uint_t;
typedef impl_len_t ber_len_t;
typedef impl_slen_t ber_slen_t;

typedef struct berval {
ber_len_t bv_len;
char *bv_val;
} BerValue, *BerVarray;

typedef struct berelement BerElement;

void ber_bvfree(struct berval *bv);

void ber_bvecfree(struct berval **bvec);

void ber_bvecadd(struct berval ***bvec, struct berval *bv);

void ber_bvarray_free(struct berval *bvarray);

void ber_bvarray_add(BerVarray *bvarray, BerValue *bv);

struct berval *ber_bvdup(const struct berval *bv);

struct berval *ber_dupbv(const struct berval *dst, struct berval *src);

struct berval *ber_bvstr(const char *str);

struct berval *ber_bvstrdup(const char *str);

struct berval *ber_str2bv(const char *str, ber_len_t len, int dup, struct berval *bv);

BerElement *ber_alloc_t(int options);

BerElement *ber_init(struct berval *bv);

void ber_init2(BerElement *ber, struct berval *bv, int options);

void ber_free(BerElement *ber, int freebuf);

DESCRIPTION
The following are the basic types and structures defined for use with the Lightweight BER library.

ber_int_t is a signed integer of at least 32 bits.  It is commonly equivalent to int.  ber_uint_t is the unsigned variant of ber_int_t.

ber_len_t is an unsigned integer of at least 32 bits used to represent a length.  It is commonly equivalent to a size_t.  ber_slen_t is the signed variant to ber_len_t.

ber_tag_t is an unsigned integer of at least 32 bits used to represent a BER tag.  It is commonly equivalent to a unsigned long.

The actual definitions of the integral impl_TYPE_t types are platform specific.

BerValue, commonly used as struct berval, is used to hold an arbitrary sequence of octets.  bv_val points to bv_len octets.  bv_val is  not  necessarily  terminated  by  a  NULL
(zero) octet.  ber_bvfree() frees a BerValue, pointed to by bv, returned from this API.  If bv is NULL, the routine does nothing.

ber_bvecfree() frees an array of BerValues (and the array), pointed to by bvec, returned from this API.  If bvec is NULL, the routine does nothing.  ber_bvecadd() appends the bv
pointer to the bvec array.  Space for the array is allocated as needed.  The end of the array is marked by a NULL pointer.

ber_bvarray_free() frees an array of BerValues (and the array), pointed to by bvarray, returned from this API.  If bvarray is NULL, the routine does nothing.   ber_bvarray_add()
appends the contents of the BerValue pointed to by bv to the bvarray array.  Space for the new element is allocated as needed.  The end of the array is marked by a BerValue with
a NULL bv_val field.

ber_bvdup() returns a copy of a BerValue.  The routine returns NULL upon error (e.g. out of memory).  The caller should use ber_bvfree() to deallocate  the  resulting  BerValue.
ber_dupbv()  copies  a  BerValue from src to dst.  If dst is NULL a new BerValue will be allocated to hold the copy.  The routine returns NULL upon error, otherwise it returns a
pointer to the copy.  If dst is NULL the caller should use ber_bvfree() to deallocate  the  resulting  BerValue,  otherwise  ber_memfree()  should  be  used  to  deallocate  the
dst-&amp;gt;bv_val.   (The  ber_bvdup()  function  is internally implemented as ber_dupbv(NULL, bv).  ber_bvdup() is provided only for compatibility with an expired draft of the LDAP C
API; ber_dupbv() is the preferred interface.)

ber_bvstr() returns a BerValue containing the string pointed to by str.  ber_bvstrdup() returns a BerValue containing a copy of the  string  pointed  to  by  str.   ber_str2bv()
returns  a  BerValue  containing the string pointed to by str, whose length may be optionally specified in len.  If dup is non-zero, the BerValue will contain a copy of str.  If
len is zero, the number of bytes to copy will be determined by strlen(3), otherwise len bytes will be copied.  If bv is  non-NULL,  the  result  will  be  stored  in  the  given
BerValue, otherwise a new BerValue will be allocated to store the result.  NOTE: Both ber_bvstr() and ber_bvstrdup() are implemented as macros using ber_str2bv() in this version
of the library.

BerElement is an opaque structure used to maintain state information used in encoding and  decoding.   ber_alloc_t()  is  used  to  create  an  empty  BerElement  structure.  If
LBER_USE_DER is specified for the options parameter then data lengths for data written to the BerElement will be encoded in the minimal number of octets required, otherwise they
will always be written as four byte values.  ber_init() creates a BerElement structure that is initialized with a copy of the data in its bv parameter.  ber_init2()  initializes
an  existing  BerElement ber using the data in the bv parameter. The data is referenced directly, not copied. The options parameter is the same as for ber_alloc_t().  ber_free()
frees a BerElement pointed to by ber.  If ber is NULL, the routine does nothing.  If freebuf is zero, the internal buffer is not freed.

SEE ALSO
lber-encode(3), lber-decode(3), lber-memory(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                          LBER_TYPES(3)
LBER_TYPES(3)                                                                   Library Functions Manual                                                                   LBER_TYPES(3)

NAME
ber_int_t,  ber_uint_t,  ber_len_t,  ber_slen_t,  ber_tag_t,  struct  berval, BerValue, BerVarray, BerElement, ber_bvfree, ber_bvecfree, ber_bvecadd, ber_bvarray_free, ber_bvar‐
ray_add, ber_bvdup, ber_dupbv, ber_bvstr, ber_bvstrdup, ber_str2bv, ber_alloc_t, ber_init, ber_init2, ber_free - OpenLDAP LBER types and allocation functions

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

typedef impl_tag_t ber_tag_t;
typedef impl_int_t ber_int_t;
typedef impl_uint_t ber_uint_t;
typedef impl_len_t ber_len_t;
typedef impl_slen_t ber_slen_t;

typedef struct berval {
ber_len_t bv_len;
char *bv_val;
} BerValue, *BerVarray;

typedef struct berelement BerElement;

void ber_bvfree(struct berval *bv);

void ber_bvecfree(struct berval **bvec);

void ber_bvecadd(struct berval ***bvec, struct berval *bv);

void ber_bvarray_free(struct berval *bvarray);

void ber_bvarray_add(BerVarray *bvarray, BerValue *bv);

struct berval *ber_bvdup(const struct berval *bv);

struct berval *ber_dupbv(const struct berval *dst, struct berval *src);

struct berval *ber_bvstr(const char *str);

struct berval *ber_bvstrdup(const char *str);

struct berval *ber_str2bv(const char *str, ber_len_t len, int dup, struct berval *bv);

BerElement *ber_alloc_t(int options);

BerElement *ber_init(struct berval *bv);

void ber_init2(BerElement *ber, struct berval *bv, int options);

void ber_free(BerElement *ber, int freebuf);

DESCRIPTION
The following are the basic types and structures defined for use with the Lightweight BER library.

ber_int_t is a signed integer of at least 32 bits.  It is commonly equivalent to int.  ber_uint_t is the unsigned variant of ber_int_t.

ber_len_t is an unsigned integer of at least 32 bits used to represent a length.  It is commonly equivalent to a size_t.  ber_slen_t is the signed variant to ber_len_t.

ber_tag_t is an unsigned integer of at least 32 bits used to represent a BER tag.  It is commonly equivalent to a unsigned long.

The actual definitions of the integral impl_TYPE_t types are platform specific.

BerValue, commonly used as struct berval, is used to hold an arbitrary sequence of octets.  bv_val points to bv_len octets.  bv_val is  not  necessarily  terminated  by  a  NULL
(zero) octet.  ber_bvfree() frees a BerValue, pointed to by bv, returned from this API.  If bv is NULL, the routine does nothing.

ber_bvecfree() frees an array of BerValues (and the array), pointed to by bvec, returned from this API.  If bvec is NULL, the routine does nothing.  ber_bvecadd() appends the bv
pointer to the bvec array.  Space for the array is allocated as needed.  The end of the array is marked by a NULL pointer.

ber_bvarray_free() frees an array of BerValues (and the array), pointed to by bvarray, returned from this API.  If bvarray is NULL, the routine does nothing.   ber_bvarray_add()
appends the contents of the BerValue pointed to by bv to the bvarray array.  Space for the new element is allocated as needed.  The end of the array is marked by a BerValue with
a NULL bv_val field.

ber_bvdup() returns a copy of a BerValue.  The routine returns NULL upon error (e.g. out of memory).  The caller should use ber_bvfree() to deallocate  the  resulting  BerValue.
ber_dupbv()  copies  a  BerValue from src to dst.  If dst is NULL a new BerValue will be allocated to hold the copy.  The routine returns NULL upon error, otherwise it returns a
pointer to the copy.  If dst is NULL the caller should use ber_bvfree() to deallocate  the  resulting  BerValue,  otherwise  ber_memfree()  should  be  used  to  deallocate  the
dst-&amp;gt;bv_val.   (The  ber_bvdup()  function  is internally implemented as ber_dupbv(NULL, bv).  ber_bvdup() is provided only for compatibility with an expired draft of the LDAP C
API; ber_dupbv() is the preferred interface.)

ber_bvstr() returns a BerValue containing the string pointed to by str.  ber_bvstrdup() returns a BerValue containing a copy of the  string  pointed  to  by  str.   ber_str2bv()
returns  a  BerValue  containing the string pointed to by str, whose length may be optionally specified in len.  If dup is non-zero, the BerValue will contain a copy of str.  If
len is zero, the number of bytes to copy will be determined by strlen(3), otherwise len bytes will be copied.  If bv is  non-NULL,  the  result  will  be  stored  in  the  given
BerValue, otherwise a new BerValue will be allocated to store the result.  NOTE: Both ber_bvstr() and ber_bvstrdup() are implemented as macros using ber_str2bv() in this version
of the library.

BerElement is an opaque structure used to maintain state information used in encoding and  decoding.   ber_alloc_t()  is  used  to  create  an  empty  BerElement  structure.  If
LBER_USE_DER is specified for the options parameter then data lengths for data written to the BerElement will be encoded in the minimal number of octets required, otherwise they
will always be written as four byte values.  ber_init() creates a BerElement structure that is initialized with a copy of the data in its bv parameter.  ber_init2()  initializes
an  existing  BerElement ber using the data in the bv parameter. The data is referenced directly, not copied. The options parameter is the same as for ber_alloc_t().  ber_free()
frees a BerElement pointed to by ber.  If ber is NULL, the routine does nothing.  If freebuf is zero, the internal buffer is not freed.

SEE ALSO
lber-encode(3), lber-decode(3), lber-memory(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                          LBER_TYPES(3)
LBER_TYPES(3)                                                                   Library Functions Manual                                                                   LBER_TYPES(3)

NAME
ber_int_t,  ber_uint_t,  ber_len_t,  ber_slen_t,  ber_tag_t,  struct  berval, BerValue, BerVarray, BerElement, ber_bvfree, ber_bvecfree, ber_bvecadd, ber_bvarray_free, ber_bvar‐
ray_add, ber_bvdup, ber_dupbv, ber_bvstr, ber_bvstrdup, ber_str2bv, ber_alloc_t, ber_init, ber_init2, ber_free - OpenLDAP LBER types and allocation functions

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

typedef impl_tag_t ber_tag_t;
typedef impl_int_t ber_int_t;
typedef impl_uint_t ber_uint_t;
typedef impl_len_t ber_len_t;
typedef impl_slen_t ber_slen_t;

typedef struct berval {
ber_len_t bv_len;
char *bv_val;
} BerValue, *BerVarray;

typedef struct berelement BerElement;

void ber_bvfree(struct berval *bv);

void ber_bvecfree(struct berval **bvec);

void ber_bvecadd(struct berval ***bvec, struct berval *bv);

void ber_bvarray_free(struct berval *bvarray);

void ber_bvarray_add(BerVarray *bvarray, BerValue *bv);

struct berval *ber_bvdup(const struct berval *bv);

struct berval *ber_dupbv(const struct berval *dst, struct berval *src);

struct berval *ber_bvstr(const char *str);

struct berval *ber_bvstrdup(const char *str);

struct berval *ber_str2bv(const char *str, ber_len_t len, int dup, struct berval *bv);

BerElement *ber_alloc_t(int options);

BerElement *ber_init(struct berval *bv);

void ber_init2(BerElement *ber, struct berval *bv, int options);

void ber_free(BerElement *ber, int freebuf);

DESCRIPTION
The following are the basic types and structures defined for use with the Lightweight BER library.

ber_int_t is a signed integer of at least 32 bits.  It is commonly equivalent to int.  ber_uint_t is the unsigned variant of ber_int_t.

ber_len_t is an unsigned integer of at least 32 bits used to represent a length.  It is commonly equivalent to a size_t.  ber_slen_t is the signed variant to ber_len_t.

ber_tag_t is an unsigned integer of at least 32 bits used to represent a BER tag.  It is commonly equivalent to a unsigned long.

The actual definitions of the integral impl_TYPE_t types are platform specific.

BerValue, commonly used as struct berval, is used to hold an arbitrary sequence of octets.  bv_val points to bv_len octets.  bv_val is  not  necessarily  terminated  by  a  NULL
(zero) octet.  ber_bvfree() frees a BerValue, pointed to by bv, returned from this API.  If bv is NULL, the routine does nothing.

ber_bvecfree() frees an array of BerValues (and the array), pointed to by bvec, returned from this API.  If bvec is NULL, the routine does nothing.  ber_bvecadd() appends the bv
pointer to the bvec array.  Space for the array is allocated as needed.  The end of the array is marked by a NULL pointer.

ber_bvarray_free() frees an array of BerValues (and the array), pointed to by bvarray, returned from this API.  If bvarray is NULL, the routine does nothing.   ber_bvarray_add()
appends the contents of the BerValue pointed to by bv to the bvarray array.  Space for the new element is allocated as needed.  The end of the array is marked by a BerValue with
a NULL bv_val field.

ber_bvdup() returns a copy of a BerValue.  The routine returns NULL upon error (e.g. out of memory).  The caller should use ber_bvfree() to deallocate  the  resulting  BerValue.
ber_dupbv()  copies  a  BerValue from src to dst.  If dst is NULL a new BerValue will be allocated to hold the copy.  The routine returns NULL upon error, otherwise it returns a
pointer to the copy.  If dst is NULL the caller should use ber_bvfree() to deallocate  the  resulting  BerValue,  otherwise  ber_memfree()  should  be  used  to  deallocate  the
dst-&amp;gt;bv_val.   (The  ber_bvdup()  function  is internally implemented as ber_dupbv(NULL, bv).  ber_bvdup() is provided only for compatibility with an expired draft of the LDAP C
API; ber_dupbv() is the preferred interface.)

ber_bvstr() returns a BerValue containing the string pointed to by str.  ber_bvstrdup() returns a BerValue containing a copy of the  string  pointed  to  by  str.   ber_str2bv()
returns  a  BerValue  containing the string pointed to by str, whose length may be optionally specified in len.  If dup is non-zero, the BerValue will contain a copy of str.  If
len is zero, the number of bytes to copy will be determined by strlen(3), otherwise len bytes will be copied.  If bv is  non-NULL,  the  result  will  be  stored  in  the  given
BerValue, otherwise a new BerValue will be allocated to store the result.  NOTE: Both ber_bvstr() and ber_bvstrdup() are implemented as macros using ber_str2bv() in this version
of the library.

BerElement is an opaque structure used to maintain state information used in encoding and  decoding.   ber_alloc_t()  is  used  to  create  an  empty  BerElement  structure.  If
LBER_USE_DER is specified for the options parameter then data lengths for data written to the BerElement will be encoded in the minimal number of octets required, otherwise they
will always be written as four byte values.  ber_init() creates a BerElement structure that is initialized with a copy of the data in its bv parameter.  ber_init2()  initializes
an  existing  BerElement ber using the data in the bv parameter. The data is referenced directly, not copied. The options parameter is the same as for ber_alloc_t().  ber_free()
frees a BerElement pointed to by ber.  If ber is NULL, the routine does nothing.  If freebuf is zero, the internal buffer is not freed.

SEE ALSO
lber-encode(3), lber-decode(3), lber-memory(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                          LBER_TYPES(3)
LBER_TYPES(3)                                                                   Library Functions Manual                                                                   LBER_TYPES(3)

NAME
ber_int_t,  ber_uint_t,  ber_len_t,  ber_slen_t,  ber_tag_t,  struct  berval, BerValue, BerVarray, BerElement, ber_bvfree, ber_bvecfree, ber_bvecadd, ber_bvarray_free, ber_bvar‐
ray_add, ber_bvdup, ber_dupbv, ber_bvstr, ber_bvstrdup, ber_str2bv, ber_alloc_t, ber_init, ber_init2, ber_free - OpenLDAP LBER types and allocation functions

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

typedef impl_tag_t ber_tag_t;
typedef impl_int_t ber_int_t;
typedef impl_uint_t ber_uint_t;
typedef impl_len_t ber_len_t;
typedef impl_slen_t ber_slen_t;

typedef struct berval {
ber_len_t bv_len;
char *bv_val;
} BerValue, *BerVarray;

typedef struct berelement BerElement;

void ber_bvfree(struct berval *bv);

void ber_bvecfree(struct berval **bvec);

void ber_bvecadd(struct berval ***bvec, struct berval *bv);

void ber_bvarray_free(struct berval *bvarray);

void ber_bvarray_add(BerVarray *bvarray, BerValue *bv);

struct berval *ber_bvdup(const struct berval *bv);

struct berval *ber_dupbv(const struct berval *dst, struct berval *src);

struct berval *ber_bvstr(const char *str);

struct berval *ber_bvstrdup(const char *str);

struct berval *ber_str2bv(const char *str, ber_len_t len, int dup, struct berval *bv);

BerElement *ber_alloc_t(int options);

BerElement *ber_init(struct berval *bv);

void ber_init2(BerElement *ber, struct berval *bv, int options);

void ber_free(BerElement *ber, int freebuf);

DESCRIPTION
The following are the basic types and structures defined for use with the Lightweight BER library.

ber_int_t is a signed integer of at least 32 bits.  It is commonly equivalent to int.  ber_uint_t is the unsigned variant of ber_int_t.

ber_len_t is an unsigned integer of at least 32 bits used to represent a length.  It is commonly equivalent to a size_t.  ber_slen_t is the signed variant to ber_len_t.

ber_tag_t is an unsigned integer of at least 32 bits used to represent a BER tag.  It is commonly equivalent to a unsigned long.

The actual definitions of the integral impl_TYPE_t types are platform specific.

BerValue, commonly used as struct berval, is used to hold an arbitrary sequence of octets.  bv_val points to bv_len octets.  bv_val is  not  necessarily  terminated  by  a  NULL
(zero) octet.  ber_bvfree() frees a BerValue, pointed to by bv, returned from this API.  If bv is NULL, the routine does nothing.

ber_bvecfree() frees an array of BerValues (and the array), pointed to by bvec, returned from this API.  If bvec is NULL, the routine does nothing.  ber_bvecadd() appends the bv
pointer to the bvec array.  Space for the array is allocated as needed.  The end of the array is marked by a NULL pointer.

ber_bvarray_free() frees an array of BerValues (and the array), pointed to by bvarray, returned from this API.  If bvarray is NULL, the routine does nothing.   ber_bvarray_add()
appends the contents of the BerValue pointed to by bv to the bvarray array.  Space for the new element is allocated as needed.  The end of the array is marked by a BerValue with
a NULL bv_val field.

ber_bvdup() returns a copy of a BerValue.  The routine returns NULL upon error (e.g. out of memory).  The caller should use ber_bvfree() to deallocate  the  resulting  BerValue.
ber_dupbv()  copies  a  BerValue from src to dst.  If dst is NULL a new BerValue will be allocated to hold the copy.  The routine returns NULL upon error, otherwise it returns a
pointer to the copy.  If dst is NULL the caller should use ber_bvfree() to deallocate  the  resulting  BerValue,  otherwise  ber_memfree()  should  be  used  to  deallocate  the
dst-&amp;gt;bv_val.   (The  ber_bvdup()  function  is internally implemented as ber_dupbv(NULL, bv).  ber_bvdup() is provided only for compatibility with an expired draft of the LDAP C
API; ber_dupbv() is the preferred interface.)

ber_bvstr() returns a BerValue containing the string pointed to by str.  ber_bvstrdup() returns a BerValue containing a copy of the  string  pointed  to  by  str.   ber_str2bv()
returns  a  BerValue  containing the string pointed to by str, whose length may be optionally specified in len.  If dup is non-zero, the BerValue will contain a copy of str.  If
len is zero, the number of bytes to copy will be determined by strlen(3), otherwise len bytes will be copied.  If bv is  non-NULL,  the  result  will  be  stored  in  the  given
BerValue, otherwise a new BerValue will be allocated to store the result.  NOTE: Both ber_bvstr() and ber_bvstrdup() are implemented as macros using ber_str2bv() in this version
of the library.

BerElement is an opaque structure used to maintain state information used in encoding and  decoding.   ber_alloc_t()  is  used  to  create  an  empty  BerElement  structure.  If
LBER_USE_DER is specified for the options parameter then data lengths for data written to the BerElement will be encoded in the minimal number of octets required, otherwise they
will always be written as four byte values.  ber_init() creates a BerElement structure that is initialized with a copy of the data in its bv parameter.  ber_init2()  initializes
an  existing  BerElement ber using the data in the bv parameter. The data is referenced directly, not copied. The options parameter is the same as for ber_alloc_t().  ber_free()
frees a BerElement pointed to by ber.  If ber is NULL, the routine does nothing.  If freebuf is zero, the internal buffer is not freed.

SEE ALSO
lber-encode(3), lber-decode(3), lber-memory(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                          LBER_TYPES(3)
LBER_TYPES(3)                                                                   Library Functions Manual                                                                   LBER_TYPES(3)

NAME
ber_int_t,  ber_uint_t,  ber_len_t,  ber_slen_t,  ber_tag_t,  struct  berval, BerValue, BerVarray, BerElement, ber_bvfree, ber_bvecfree, ber_bvecadd, ber_bvarray_free, ber_bvar‐
ray_add, ber_bvdup, ber_dupbv, ber_bvstr, ber_bvstrdup, ber_str2bv, ber_alloc_t, ber_init, ber_init2, ber_free - OpenLDAP LBER types and allocation functions

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

typedef impl_tag_t ber_tag_t;
typedef impl_int_t ber_int_t;
typedef impl_uint_t ber_uint_t;
typedef impl_len_t ber_len_t;
typedef impl_slen_t ber_slen_t;

typedef struct berval {
ber_len_t bv_len;
char *bv_val;
} BerValue, *BerVarray;

typedef struct berelement BerElement;

void ber_bvfree(struct berval *bv);

void ber_bvecfree(struct berval **bvec);

void ber_bvecadd(struct berval ***bvec, struct berval *bv);

void ber_bvarray_free(struct berval *bvarray);

void ber_bvarray_add(BerVarray *bvarray, BerValue *bv);

struct berval *ber_bvdup(const struct berval *bv);

struct berval *ber_dupbv(const struct berval *dst, struct berval *src);

struct berval *ber_bvstr(const char *str);

struct berval *ber_bvstrdup(const char *str);

struct berval *ber_str2bv(const char *str, ber_len_t len, int dup, struct berval *bv);

BerElement *ber_alloc_t(int options);

BerElement *ber_init(struct berval *bv);

void ber_init2(BerElement *ber, struct berval *bv, int options);

void ber_free(BerElement *ber, int freebuf);

DESCRIPTION
The following are the basic types and structures defined for use with the Lightweight BER library.

ber_int_t is a signed integer of at least 32 bits.  It is commonly equivalent to int.  ber_uint_t is the unsigned variant of ber_int_t.

ber_len_t is an unsigned integer of at least 32 bits used to represent a length.  It is commonly equivalent to a size_t.  ber_slen_t is the signed variant to ber_len_t.

ber_tag_t is an unsigned integer of at least 32 bits used to represent a BER tag.  It is commonly equivalent to a unsigned long.

The actual definitions of the integral impl_TYPE_t types are platform specific.

BerValue, commonly used as struct berval, is used to hold an arbitrary sequence of octets.  bv_val points to bv_len octets.  bv_val is  not  necessarily  terminated  by  a  NULL
(zero) octet.  ber_bvfree() frees a BerValue, pointed to by bv, returned from this API.  If bv is NULL, the routine does nothing.

ber_bvecfree() frees an array of BerValues (and the array), pointed to by bvec, returned from this API.  If bvec is NULL, the routine does nothing.  ber_bvecadd() appends the bv
pointer to the bvec array.  Space for the array is allocated as needed.  The end of the array is marked by a NULL pointer.

ber_bvarray_free() frees an array of BerValues (and the array), pointed to by bvarray, returned from this API.  If bvarray is NULL, the routine does nothing.   ber_bvarray_add()
appends the contents of the BerValue pointed to by bv to the bvarray array.  Space for the new element is allocated as needed.  The end of the array is marked by a BerValue with
a NULL bv_val field.

ber_bvdup() returns a copy of a BerValue.  The routine returns NULL upon error (e.g. out of memory).  The caller should use ber_bvfree() to deallocate  the  resulting  BerValue.
ber_dupbv()  copies  a  BerValue from src to dst.  If dst is NULL a new BerValue will be allocated to hold the copy.  The routine returns NULL upon error, otherwise it returns a
pointer to the copy.  If dst is NULL the caller should use ber_bvfree() to deallocate  the  resulting  BerValue,  otherwise  ber_memfree()  should  be  used  to  deallocate  the
dst-&amp;gt;bv_val.   (The  ber_bvdup()  function  is internally implemented as ber_dupbv(NULL, bv).  ber_bvdup() is provided only for compatibility with an expired draft of the LDAP C
API; ber_dupbv() is the preferred interface.)

ber_bvstr() returns a BerValue containing the string pointed to by str.  ber_bvstrdup() returns a BerValue containing a copy of the  string  pointed  to  by  str.   ber_str2bv()
returns  a  BerValue  containing the string pointed to by str, whose length may be optionally specified in len.  If dup is non-zero, the BerValue will contain a copy of str.  If
len is zero, the number of bytes to copy will be determined by strlen(3), otherwise len bytes will be copied.  If bv is  non-NULL,  the  result  will  be  stored  in  the  given
BerValue, otherwise a new BerValue will be allocated to store the result.  NOTE: Both ber_bvstr() and ber_bvstrdup() are implemented as macros using ber_str2bv() in this version
of the library.

BerElement is an opaque structure used to maintain state information used in encoding and  decoding.   ber_alloc_t()  is  used  to  create  an  empty  BerElement  structure.  If
LBER_USE_DER is specified for the options parameter then data lengths for data written to the BerElement will be encoded in the minimal number of octets required, otherwise they
will always be written as four byte values.  ber_init() creates a BerElement structure that is initialized with a copy of the data in its bv parameter.  ber_init2()  initializes
an  existing  BerElement ber using the data in the bv parameter. The data is referenced directly, not copied. The options parameter is the same as for ber_alloc_t().  ber_free()
frees a BerElement pointed to by ber.  If ber is NULL, the routine does nothing.  If freebuf is zero, the internal buffer is not freed.

SEE ALSO
lber-encode(3), lber-decode(3), lber-memory(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                          LBER_TYPES(3)
LBER_TYPES(3)                                                                   Library Functions Manual                                                                   LBER_TYPES(3)

NAME
ber_int_t,  ber_uint_t,  ber_len_t,  ber_slen_t,  ber_tag_t,  struct  berval, BerValue, BerVarray, BerElement, ber_bvfree, ber_bvecfree, ber_bvecadd, ber_bvarray_free, ber_bvar‐
ray_add, ber_bvdup, ber_dupbv, ber_bvstr, ber_bvstrdup, ber_str2bv, ber_alloc_t, ber_init, ber_init2, ber_free - OpenLDAP LBER types and allocation functions

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

typedef impl_tag_t ber_tag_t;
typedef impl_int_t ber_int_t;
typedef impl_uint_t ber_uint_t;
typedef impl_len_t ber_len_t;
typedef impl_slen_t ber_slen_t;

typedef struct berval {
ber_len_t bv_len;
char *bv_val;
} BerValue, *BerVarray;

typedef struct berelement BerElement;

void ber_bvfree(struct berval *bv);

void ber_bvecfree(struct berval **bvec);

void ber_bvecadd(struct berval ***bvec, struct berval *bv);

void ber_bvarray_free(struct berval *bvarray);

void ber_bvarray_add(BerVarray *bvarray, BerValue *bv);

struct berval *ber_bvdup(const struct berval *bv);

struct berval *ber_dupbv(const struct berval *dst, struct berval *src);

struct berval *ber_bvstr(const char *str);

struct berval *ber_bvstrdup(const char *str);

struct berval *ber_str2bv(const char *str, ber_len_t len, int dup, struct berval *bv);

BerElement *ber_alloc_t(int options);

BerElement *ber_init(struct berval *bv);

void ber_init2(BerElement *ber, struct berval *bv, int options);

void ber_free(BerElement *ber, int freebuf);

DESCRIPTION
The following are the basic types and structures defined for use with the Lightweight BER library.

ber_int_t is a signed integer of at least 32 bits.  It is commonly equivalent to int.  ber_uint_t is the unsigned variant of ber_int_t.

ber_len_t is an unsigned integer of at least 32 bits used to represent a length.  It is commonly equivalent to a size_t.  ber_slen_t is the signed variant to ber_len_t.

ber_tag_t is an unsigned integer of at least 32 bits used to represent a BER tag.  It is commonly equivalent to a unsigned long.

The actual definitions of the integral impl_TYPE_t types are platform specific.

BerValue, commonly used as struct berval, is used to hold an arbitrary sequence of octets.  bv_val points to bv_len octets.  bv_val is  not  necessarily  terminated  by  a  NULL
(zero) octet.  ber_bvfree() frees a BerValue, pointed to by bv, returned from this API.  If bv is NULL, the routine does nothing.

ber_bvecfree() frees an array of BerValues (and the array), pointed to by bvec, returned from this API.  If bvec is NULL, the routine does nothing.  ber_bvecadd() appends the bv
pointer to the bvec array.  Space for the array is allocated as needed.  The end of the array is marked by a NULL pointer.

ber_bvarray_free() frees an array of BerValues (and the array), pointed to by bvarray, returned from this API.  If bvarray is NULL, the routine does nothing.   ber_bvarray_add()
appends the contents of the BerValue pointed to by bv to the bvarray array.  Space for the new element is allocated as needed.  The end of the array is marked by a BerValue with
a NULL bv_val field.

ber_bvdup() returns a copy of a BerValue.  The routine returns NULL upon error (e.g. out of memory).  The caller should use ber_bvfree() to deallocate  the  resulting  BerValue.
ber_dupbv()  copies  a  BerValue from src to dst.  If dst is NULL a new BerValue will be allocated to hold the copy.  The routine returns NULL upon error, otherwise it returns a
pointer to the copy.  If dst is NULL the caller should use ber_bvfree() to deallocate  the  resulting  BerValue,  otherwise  ber_memfree()  should  be  used  to  deallocate  the
dst-&amp;gt;bv_val.   (The  ber_bvdup()  function  is internally implemented as ber_dupbv(NULL, bv).  ber_bvdup() is provided only for compatibility with an expired draft of the LDAP C
API; ber_dupbv() is the preferred interface.)

ber_bvstr() returns a BerValue containing the string pointed to by str.  ber_bvstrdup() returns a BerValue containing a copy of the  string  pointed  to  by  str.   ber_str2bv()
returns  a  BerValue  containing the string pointed to by str, whose length may be optionally specified in len.  If dup is non-zero, the BerValue will contain a copy of str.  If
len is zero, the number of bytes to copy will be determined by strlen(3), otherwise len bytes will be copied.  If bv is  non-NULL,  the  result  will  be  stored  in  the  given
BerValue, otherwise a new BerValue will be allocated to store the result.  NOTE: Both ber_bvstr() and ber_bvstrdup() are implemented as macros using ber_str2bv() in this version
of the library.

BerElement is an opaque structure used to maintain state information used in encoding and  decoding.   ber_alloc_t()  is  used  to  create  an  empty  BerElement  structure.  If
LBER_USE_DER is specified for the options parameter then data lengths for data written to the BerElement will be encoded in the minimal number of octets required, otherwise they
will always be written as four byte values.  ber_init() creates a BerElement structure that is initialized with a copy of the data in its bv parameter.  ber_init2()  initializes
an  existing  BerElement ber using the data in the bv parameter. The data is referenced directly, not copied. The options parameter is the same as for ber_alloc_t().  ber_free()
frees a BerElement pointed to by ber.  If ber is NULL, the routine does nothing.  If freebuf is zero, the internal buffer is not freed.

SEE ALSO
lber-encode(3), lber-decode(3), lber-memory(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                          LBER_TYPES(3)
LBER_DECODE(3)                                                                  Library Functions Manual                                                                  LBER_DECODE(3)

NAME
ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool‐
ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);

ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);

ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);

ber_tag_t ber_get_stringa(BerElement *ber, char **buf);

ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);

ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);

ber_tag_t ber_get_null(BerElement *ber);

ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);

ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);

ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);

ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,
ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,
these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.

The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the
entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb
parameter.

The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by
ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica‐
tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.

a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The
caller should free the returned string using ber_memfree().

A  Octet string.  A variant of "a".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in
the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().

s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet
string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.

O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.
The caller should free the returned structure using ber_bvfree().

o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the
returned octet string using ber_memfree().

m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle‐
ment, and must not be freed by the caller.

b  Boolean.  A pointer to a ber_int_t should be supplied.

e  Enumeration.  A pointer to a ber_int_t should be supplied.

i  Integer.  A pointer to a ber_int_t should be supplied.

B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the
bitstring returned.

n  Null.  No parameter is required.  The element is simply skipped if it is recognized.

v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet
strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().

V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct
berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using
ber_bvecfree().

W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the
octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller
should free the returned structures using ber_bvarray_free().

M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)
and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting
at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter‐
minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)
on return.  The caller should free the returned array using ber_memfree().

l  Length of the next element.  A pointer to a ber_len_t should be supplied.

t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.

T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.

x  Skip element.  The next element is skipped.

{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.

}  End sequence.  No parameter is required and no action is taken.

[  Begin set.  No parameter is required.  The initial set tag and length are skipped.

]  End set.  No parameter is required and no action is taken.

The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)
on failure.

The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain
the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.

The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().

The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in
this parameter.  The caller should free the returned structure using ber_bvfree().

The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory
assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be
returned using ber_memfree().

The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.

The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.

The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.

The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will
point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().

The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should
be passed to subsequent calls to ber_next_element(), which returns similar information.

EXAMPLES
Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

The element can be decoded using ber_scanf() as follows.

ber_int_t    scope, deref, size, time, attrsonly;
char   *dn, **attrs;
ber_tag_t tag;

tag = ber_scanf( ber, "{aeeiib{v}}",
&amp;dn, &amp;scope, &amp;deref,
&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );

if( tag == LBER_ERROR ) {
/* error */
} else {
/* success */
}

ber_memfree( dn );
ber_memvfree( attrs );

ERRORS
If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using
supplied deallocation routines.

SEE ALSO
lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_DECODE(3)
LBER_ENCODE(3)                                                                  Library Functions Manual                                                                  LBER_ENCODE(3)

NAME
ber_alloc_t,  ber_flush,  ber_flush2,  ber_printf,  ber_put_int,  ber_put_enum, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean, ber_put_bitstring, ber_start_seq,
ber_start_set, ber_put_seq, ber_put_set - OpenLDAP LBER simplified Basic Encoding Rules library routines for encoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

BerElement *ber_alloc_t(int options);

int ber_flush(Sockbuf *sb, BerElement *ber, int freeit);

int ber_flush2(Sockbuf *sb, BerElement *ber, int freeit);

int ber_printf(BerElement *ber, const char *fmt, ...);

int ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);

int ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);

int ber_put_ostring(BerElement *ber, const char *str, ber_len_t len, ber_tag_t tag);

int ber_put_string(BerElement *ber, const char *str, ber_tag_t tag);

int ber_put_null(BerElement *ber, ber_tag_t tag);

int ber_put_boolean(BerElement *ber, ber_int_t bool, ber_tag_t tag);

int ber_put_bitstring(BerElement *ber, const char *str, ber_len_t blen, ber_tag_t tag);

int ber_start_seq(BerElement *ber, ber_tag_t tag);

int ber_start_set(BerElement *ber, ber_tag_t tag);

int ber_put_seq(BerElement *ber);

int ber_put_set(BerElement *ber);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and
ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou‐
tines return the length of the element encoded, or -1 if an error occurred.

The ber_alloc_t() routine is used to allocate a new BER element.  It should be called with an argument of LBER_USE_DER.

The ber_flush2() routine is used to actually write the element to a socket (or file) descriptor, once it has been fully encoded (using ber_printf() and friends).  See lber-sock‐
buf(3) for more details on the Sockbuf implementation of the sb parameter.  If the freeit parameter is non-zero, the supplied ber will be freed.   If  LBER_FLUSH_FREE_ON_SUCCESS
is used, the ber is only freed when successfully flushed, otherwise it is left intact; if LBER_FLUSH_FREE_ON_ERROR is used, the ber is only freed when an error occurs, otherwise
it is left intact; if LBER_FLUSH_FREE_ALWAYS is used, the ber is freed anyway.  This function differs from the original ber_flush(3) function, whose behavior corresponds to that
indicated  for LBER_FLUSH_FREE_ON_SUCCESS.  Note that in the future, the behavior of ber_flush(3) with freeit non-zero might change into that of ber_flush2(3) with freeit set to
LBER_FLUSH_FREE_ALWAYS.

The ber_printf() routine is used to encode a BER element in much the same way that sprintf(3) works.  One important difference, though, is that some state  information  is  kept
with  the ber parameter so that multiple calls can be made to ber_printf() to append things to the end of the BER element.  Ber_printf() writes to ber, a pointer to a BerElement
such as returned by ber_alloc_t().  It interprets and formats its arguments according to the format string fmt.  The format string can contain the following characters:

b  Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.

e  Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.

i  Integer.  An ber_int_t parameter should be supplied.  An integer element is output.

B  Bitstring.  A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.  A bitstring element is output.

n  Null.  No parameter is required.  A null element is output.

o  Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.

O  Octet string.  A struct berval * is supplied.  An octet string element is output.

s  Octet string.  A null-terminated string is supplied.  An octet string element is output, not including the trailing NULL octet.

t  Tag.  A ber_tag_t specifying the tag to give the next element is provided.  This works across calls.

v  Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.

V  Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet
strings.

W  Several  octet  strings.  An array of struct berval's is supplied.  The array is terminated by a struct berval with a NULL bv_val.  Note that a construct like '{W}' is
required to get an actual SEQUENCE OF octet strings.

{  Begin sequence.  No parameter is required.

}  End sequence.  No parameter is required.

[  Begin set.  No parameter is required.

]  End set.  No parameter is required.

The ber_put_int() routine writes the integer element num to the BER element ber.

The ber_put_enum() routine writes the enumeration element num to the BER element ber.

The ber_put_boolean() routine writes the boolean value given by bool to the BER element.

The ber_put_bitstring() routine writes blen bits starting at str as a bitstring value to the given BER element.  Note that blen is the length in bits of the bitstring.

The ber_put_ostring() routine writes len bytes starting at str to the BER element as an octet string.

The ber_put_string() routine writes the null-terminated string (minus the terminating ' ') to the BER element as an octet string.

The ber_put_null() routine writes a NULL element to the BER element.

The ber_start_seq() routine is used to start a sequence in the BER element.  The ber_start_set() routine works similarly.  The end of the sequence or set is marked by the  near‐
est matching call to ber_put_seq() or ber_put_set(), respectively.

EXAMPLES
Assuming the following variable declarations, and that the variables have been assigned appropriately, an lber encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

can be achieved like so:

int rc;
ber_int_t    scope, ali, size, time, attrsonly;
char   *dn, **attrs;
BerElement *ber;

/* ... fill in values ... */

ber = ber_alloc_t( LBER_USE_DER );

if ( ber == NULL ) {
/* error */
}

rc = ber_printf( ber, "{siiiib{v}}", dn, scope, ali,
size, time, attrsonly, attrs );

if( rc == -1 ) {
/* error */
} else {
/* success */
}

ERRORS
If an error occurs during encoding, generally these routines return -1.

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.

SEE ALSO
lber-decode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_ENCODE(3)
LBER_TYPES(3)                                                                   Library Functions Manual                                                                   LBER_TYPES(3)

NAME
ber_int_t,  ber_uint_t,  ber_len_t,  ber_slen_t,  ber_tag_t,  struct  berval, BerValue, BerVarray, BerElement, ber_bvfree, ber_bvecfree, ber_bvecadd, ber_bvarray_free, ber_bvar‐
ray_add, ber_bvdup, ber_dupbv, ber_bvstr, ber_bvstrdup, ber_str2bv, ber_alloc_t, ber_init, ber_init2, ber_free - OpenLDAP LBER types and allocation functions

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

typedef impl_tag_t ber_tag_t;
typedef impl_int_t ber_int_t;
typedef impl_uint_t ber_uint_t;
typedef impl_len_t ber_len_t;
typedef impl_slen_t ber_slen_t;

typedef struct berval {
ber_len_t bv_len;
char *bv_val;
} BerValue, *BerVarray;

typedef struct berelement BerElement;

void ber_bvfree(struct berval *bv);

void ber_bvecfree(struct berval **bvec);

void ber_bvecadd(struct berval ***bvec, struct berval *bv);

void ber_bvarray_free(struct berval *bvarray);

void ber_bvarray_add(BerVarray *bvarray, BerValue *bv);

struct berval *ber_bvdup(const struct berval *bv);

struct berval *ber_dupbv(const struct berval *dst, struct berval *src);

struct berval *ber_bvstr(const char *str);

struct berval *ber_bvstrdup(const char *str);

struct berval *ber_str2bv(const char *str, ber_len_t len, int dup, struct berval *bv);

BerElement *ber_alloc_t(int options);

BerElement *ber_init(struct berval *bv);

void ber_init2(BerElement *ber, struct berval *bv, int options);

void ber_free(BerElement *ber, int freebuf);

DESCRIPTION
The following are the basic types and structures defined for use with the Lightweight BER library.

ber_int_t is a signed integer of at least 32 bits.  It is commonly equivalent to int.  ber_uint_t is the unsigned variant of ber_int_t.

ber_len_t is an unsigned integer of at least 32 bits used to represent a length.  It is commonly equivalent to a size_t.  ber_slen_t is the signed variant to ber_len_t.

ber_tag_t is an unsigned integer of at least 32 bits used to represent a BER tag.  It is commonly equivalent to a unsigned long.

The actual definitions of the integral impl_TYPE_t types are platform specific.

BerValue, commonly used as struct berval, is used to hold an arbitrary sequence of octets.  bv_val points to bv_len octets.  bv_val is  not  necessarily  terminated  by  a  NULL
(zero) octet.  ber_bvfree() frees a BerValue, pointed to by bv, returned from this API.  If bv is NULL, the routine does nothing.

ber_bvecfree() frees an array of BerValues (and the array), pointed to by bvec, returned from this API.  If bvec is NULL, the routine does nothing.  ber_bvecadd() appends the bv
pointer to the bvec array.  Space for the array is allocated as needed.  The end of the array is marked by a NULL pointer.

ber_bvarray_free() frees an array of BerValues (and the array), pointed to by bvarray, returned from this API.  If bvarray is NULL, the routine does nothing.   ber_bvarray_add()
appends the contents of the BerValue pointed to by bv to the bvarray array.  Space for the new element is allocated as needed.  The end of the array is marked by a BerValue with
a NULL bv_val field.

ber_bvdup() returns a copy of a BerValue.  The routine returns NULL upon error (e.g. out of memory).  The caller should use ber_bvfree() to deallocate  the  resulting  BerValue.
ber_dupbv()  copies  a  BerValue from src to dst.  If dst is NULL a new BerValue will be allocated to hold the copy.  The routine returns NULL upon error, otherwise it returns a
pointer to the copy.  If dst is NULL the caller should use ber_bvfree() to deallocate  the  resulting  BerValue,  otherwise  ber_memfree()  should  be  used  to  deallocate  the
dst-&amp;gt;bv_val.   (The  ber_bvdup()  function  is internally implemented as ber_dupbv(NULL, bv).  ber_bvdup() is provided only for compatibility with an expired draft of the LDAP C
API; ber_dupbv() is the preferred interface.)

ber_bvstr() returns a BerValue containing the string pointed to by str.  ber_bvstrdup() returns a BerValue containing a copy of the  string  pointed  to  by  str.   ber_str2bv()
returns  a  BerValue  containing the string pointed to by str, whose length may be optionally specified in len.  If dup is non-zero, the BerValue will contain a copy of str.  If
len is zero, the number of bytes to copy will be determined by strlen(3), otherwise len bytes will be copied.  If bv is  non-NULL,  the  result  will  be  stored  in  the  given
BerValue, otherwise a new BerValue will be allocated to store the result.  NOTE: Both ber_bvstr() and ber_bvstrdup() are implemented as macros using ber_str2bv() in this version
of the library.

BerElement is an opaque structure used to maintain state information used in encoding and  decoding.   ber_alloc_t()  is  used  to  create  an  empty  BerElement  structure.  If
LBER_USE_DER is specified for the options parameter then data lengths for data written to the BerElement will be encoded in the minimal number of octets required, otherwise they
will always be written as four byte values.  ber_init() creates a BerElement structure that is initialized with a copy of the data in its bv parameter.  ber_init2()  initializes
an  existing  BerElement ber using the data in the bv parameter. The data is referenced directly, not copied. The options parameter is the same as for ber_alloc_t().  ber_free()
frees a BerElement pointed to by ber.  If ber is NULL, the routine does nothing.  If freebuf is zero, the internal buffer is not freed.

SEE ALSO
lber-encode(3), lber-decode(3), lber-memory(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                          LBER_TYPES(3)
LBER_DECODE(3)                                                                  Library Functions Manual                                                                  LBER_DECODE(3)

NAME
ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool‐
ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);

ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);

ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);

ber_tag_t ber_get_stringa(BerElement *ber, char **buf);

ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);

ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);

ber_tag_t ber_get_null(BerElement *ber);

ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);

ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);

ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);

ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,
ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,
these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.

The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the
entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb
parameter.

The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by
ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica‐
tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.

a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The
caller should free the returned string using ber_memfree().

A  Octet string.  A variant of "a".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in
the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().

s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet
string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.

O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.
The caller should free the returned structure using ber_bvfree().

o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the
returned octet string using ber_memfree().

m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle‐
ment, and must not be freed by the caller.

b  Boolean.  A pointer to a ber_int_t should be supplied.

e  Enumeration.  A pointer to a ber_int_t should be supplied.

i  Integer.  A pointer to a ber_int_t should be supplied.

B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the
bitstring returned.

n  Null.  No parameter is required.  The element is simply skipped if it is recognized.

v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet
strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().

V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct
berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using
ber_bvecfree().

W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the
octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller
should free the returned structures using ber_bvarray_free().

M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)
and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting
at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter‐
minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)
on return.  The caller should free the returned array using ber_memfree().

l  Length of the next element.  A pointer to a ber_len_t should be supplied.

t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.

T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.

x  Skip element.  The next element is skipped.

{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.

}  End sequence.  No parameter is required and no action is taken.

[  Begin set.  No parameter is required.  The initial set tag and length are skipped.

]  End set.  No parameter is required and no action is taken.

The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)
on failure.

The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain
the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.

The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().

The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in
this parameter.  The caller should free the returned structure using ber_bvfree().

The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory
assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be
returned using ber_memfree().

The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.

The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.

The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.

The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will
point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().

The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should
be passed to subsequent calls to ber_next_element(), which returns similar information.

EXAMPLES
Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

The element can be decoded using ber_scanf() as follows.

ber_int_t    scope, deref, size, time, attrsonly;
char   *dn, **attrs;
ber_tag_t tag;

tag = ber_scanf( ber, "{aeeiib{v}}",
&amp;dn, &amp;scope, &amp;deref,
&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );

if( tag == LBER_ERROR ) {
/* error */
} else {
/* success */
}

ber_memfree( dn );
ber_memvfree( attrs );

ERRORS
If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using
supplied deallocation routines.

SEE ALSO
lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_DECODE(3)
LBER_DECODE(3)                                                                  Library Functions Manual                                                                  LBER_DECODE(3)

NAME
ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool‐
ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);

ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);

ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);

ber_tag_t ber_get_stringa(BerElement *ber, char **buf);

ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);

ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);

ber_tag_t ber_get_null(BerElement *ber);

ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);

ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);

ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);

ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,
ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,
these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.

The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the
entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb
parameter.

The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by
ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica‐
tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.

a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The
caller should free the returned string using ber_memfree().

A  Octet string.  A variant of "a".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in
the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().

s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet
string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.

O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.
The caller should free the returned structure using ber_bvfree().

o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the
returned octet string using ber_memfree().

m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle‐
ment, and must not be freed by the caller.

b  Boolean.  A pointer to a ber_int_t should be supplied.

e  Enumeration.  A pointer to a ber_int_t should be supplied.

i  Integer.  A pointer to a ber_int_t should be supplied.

B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the
bitstring returned.

n  Null.  No parameter is required.  The element is simply skipped if it is recognized.

v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet
strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().

V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct
berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using
ber_bvecfree().

W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the
octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller
should free the returned structures using ber_bvarray_free().

M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)
and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting
at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter‐
minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)
on return.  The caller should free the returned array using ber_memfree().

l  Length of the next element.  A pointer to a ber_len_t should be supplied.

t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.

T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.

x  Skip element.  The next element is skipped.

{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.

}  End sequence.  No parameter is required and no action is taken.

[  Begin set.  No parameter is required.  The initial set tag and length are skipped.

]  End set.  No parameter is required and no action is taken.

The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)
on failure.

The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain
the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.

The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().

The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in
this parameter.  The caller should free the returned structure using ber_bvfree().

The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory
assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be
returned using ber_memfree().

The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.

The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.

The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.

The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will
point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().

The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should
be passed to subsequent calls to ber_next_element(), which returns similar information.

EXAMPLES
Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

The element can be decoded using ber_scanf() as follows.

ber_int_t    scope, deref, size, time, attrsonly;
char   *dn, **attrs;
ber_tag_t tag;

tag = ber_scanf( ber, "{aeeiib{v}}",
&amp;dn, &amp;scope, &amp;deref,
&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );

if( tag == LBER_ERROR ) {
/* error */
} else {
/* success */
}

ber_memfree( dn );
ber_memvfree( attrs );

ERRORS
If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using
supplied deallocation routines.

SEE ALSO
lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_DECODE(3)
LBER_DECODE(3)                                                                  Library Functions Manual                                                                  LBER_DECODE(3)

NAME
ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool‐
ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);

ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);

ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);

ber_tag_t ber_get_stringa(BerElement *ber, char **buf);

ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);

ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);

ber_tag_t ber_get_null(BerElement *ber);

ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);

ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);

ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);

ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,
ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,
these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.

The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the
entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb
parameter.

The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by
ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica‐
tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.

a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The
caller should free the returned string using ber_memfree().

A  Octet string.  A variant of "a".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in
the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().

s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet
string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.

O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.
The caller should free the returned structure using ber_bvfree().

o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the
returned octet string using ber_memfree().

m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle‐
ment, and must not be freed by the caller.

b  Boolean.  A pointer to a ber_int_t should be supplied.

e  Enumeration.  A pointer to a ber_int_t should be supplied.

i  Integer.  A pointer to a ber_int_t should be supplied.

B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the
bitstring returned.

n  Null.  No parameter is required.  The element is simply skipped if it is recognized.

v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet
strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().

V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct
berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using
ber_bvecfree().

W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the
octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller
should free the returned structures using ber_bvarray_free().

M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)
and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting
at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter‐
minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)
on return.  The caller should free the returned array using ber_memfree().

l  Length of the next element.  A pointer to a ber_len_t should be supplied.

t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.

T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.

x  Skip element.  The next element is skipped.

{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.

}  End sequence.  No parameter is required and no action is taken.

[  Begin set.  No parameter is required.  The initial set tag and length are skipped.

]  End set.  No parameter is required and no action is taken.

The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)
on failure.

The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain
the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.

The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().

The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in
this parameter.  The caller should free the returned structure using ber_bvfree().

The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory
assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be
returned using ber_memfree().

The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.

The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.

The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.

The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will
point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().

The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should
be passed to subsequent calls to ber_next_element(), which returns similar information.

EXAMPLES
Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

The element can be decoded using ber_scanf() as follows.

ber_int_t    scope, deref, size, time, attrsonly;
char   *dn, **attrs;
ber_tag_t tag;

tag = ber_scanf( ber, "{aeeiib{v}}",
&amp;dn, &amp;scope, &amp;deref,
&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );

if( tag == LBER_ERROR ) {
/* error */
} else {
/* success */
}

ber_memfree( dn );
ber_memvfree( attrs );

ERRORS
If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using
supplied deallocation routines.

SEE ALSO
lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_DECODE(3)
LBER_DECODE(3)                                                                  Library Functions Manual                                                                  LBER_DECODE(3)

NAME
ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool‐
ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);

ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);

ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);

ber_tag_t ber_get_stringa(BerElement *ber, char **buf);

ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);

ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);

ber_tag_t ber_get_null(BerElement *ber);

ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);

ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);

ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);

ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,
ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,
these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.

The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the
entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb
parameter.

The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by
ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica‐
tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.

a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The
caller should free the returned string using ber_memfree().

A  Octet string.  A variant of "a".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in
the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().

s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet
string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.

O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.
The caller should free the returned structure using ber_bvfree().

o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the
returned octet string using ber_memfree().

m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle‐
ment, and must not be freed by the caller.

b  Boolean.  A pointer to a ber_int_t should be supplied.

e  Enumeration.  A pointer to a ber_int_t should be supplied.

i  Integer.  A pointer to a ber_int_t should be supplied.

B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the
bitstring returned.

n  Null.  No parameter is required.  The element is simply skipped if it is recognized.

v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet
strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().

V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct
berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using
ber_bvecfree().

W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the
octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller
should free the returned structures using ber_bvarray_free().

M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)
and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting
at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter‐
minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)
on return.  The caller should free the returned array using ber_memfree().

l  Length of the next element.  A pointer to a ber_len_t should be supplied.

t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.

T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.

x  Skip element.  The next element is skipped.

{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.

}  End sequence.  No parameter is required and no action is taken.

[  Begin set.  No parameter is required.  The initial set tag and length are skipped.

]  End set.  No parameter is required and no action is taken.

The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)
on failure.

The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain
the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.

The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().

The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in
this parameter.  The caller should free the returned structure using ber_bvfree().

The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory
assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be
returned using ber_memfree().

The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.

The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.

The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.

The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will
point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().

The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should
be passed to subsequent calls to ber_next_element(), which returns similar information.

EXAMPLES
Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

The element can be decoded using ber_scanf() as follows.

ber_int_t    scope, deref, size, time, attrsonly;
char   *dn, **attrs;
ber_tag_t tag;

tag = ber_scanf( ber, "{aeeiib{v}}",
&amp;dn, &amp;scope, &amp;deref,
&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );

if( tag == LBER_ERROR ) {
/* error */
} else {
/* success */
}

ber_memfree( dn );
ber_memvfree( attrs );

ERRORS
If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using
supplied deallocation routines.

SEE ALSO
lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_DECODE(3)
LBER_DECODE(3)                                                                  Library Functions Manual                                                                  LBER_DECODE(3)

NAME
ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool‐
ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);

ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);

ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);

ber_tag_t ber_get_stringa(BerElement *ber, char **buf);

ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);

ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);

ber_tag_t ber_get_null(BerElement *ber);

ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);

ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);

ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);

ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,
ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,
these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.

The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the
entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb
parameter.

The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by
ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica‐
tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.

a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The
caller should free the returned string using ber_memfree().

A  Octet string.  A variant of "a".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in
the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().

s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet
string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.

O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.
The caller should free the returned structure using ber_bvfree().

o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the
returned octet string using ber_memfree().

m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle‐
ment, and must not be freed by the caller.

b  Boolean.  A pointer to a ber_int_t should be supplied.

e  Enumeration.  A pointer to a ber_int_t should be supplied.

i  Integer.  A pointer to a ber_int_t should be supplied.

B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the
bitstring returned.

n  Null.  No parameter is required.  The element is simply skipped if it is recognized.

v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet
strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().

V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct
berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using
ber_bvecfree().

W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the
octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller
should free the returned structures using ber_bvarray_free().

M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)
and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting
at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter‐
minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)
on return.  The caller should free the returned array using ber_memfree().

l  Length of the next element.  A pointer to a ber_len_t should be supplied.

t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.

T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.

x  Skip element.  The next element is skipped.

{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.

}  End sequence.  No parameter is required and no action is taken.

[  Begin set.  No parameter is required.  The initial set tag and length are skipped.

]  End set.  No parameter is required and no action is taken.

The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)
on failure.

The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain
the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.

The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().

The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in
this parameter.  The caller should free the returned structure using ber_bvfree().

The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory
assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be
returned using ber_memfree().

The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.

The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.

The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.

The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will
point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().

The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should
be passed to subsequent calls to ber_next_element(), which returns similar information.

EXAMPLES
Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

The element can be decoded using ber_scanf() as follows.

ber_int_t    scope, deref, size, time, attrsonly;
char   *dn, **attrs;
ber_tag_t tag;

tag = ber_scanf( ber, "{aeeiib{v}}",
&amp;dn, &amp;scope, &amp;deref,
&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );

if( tag == LBER_ERROR ) {
/* error */
} else {
/* success */
}

ber_memfree( dn );
ber_memvfree( attrs );

ERRORS
If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using
supplied deallocation routines.

SEE ALSO
lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_DECODE(3)
LBER_DECODE(3)                                                                  Library Functions Manual                                                                  LBER_DECODE(3)

NAME
ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool‐
ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);

ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);

ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);

ber_tag_t ber_get_stringa(BerElement *ber, char **buf);

ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);

ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);

ber_tag_t ber_get_null(BerElement *ber);

ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);

ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);

ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);

ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,
ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,
these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.

The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the
entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb
parameter.

The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by
ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica‐
tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.

a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The
caller should free the returned string using ber_memfree().

A  Octet string.  A variant of "a".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in
the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().

s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet
string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.

O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.
The caller should free the returned structure using ber_bvfree().

o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the
returned octet string using ber_memfree().

m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle‐
ment, and must not be freed by the caller.

b  Boolean.  A pointer to a ber_int_t should be supplied.

e  Enumeration.  A pointer to a ber_int_t should be supplied.

i  Integer.  A pointer to a ber_int_t should be supplied.

B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the
bitstring returned.

n  Null.  No parameter is required.  The element is simply skipped if it is recognized.

v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet
strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().

V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct
berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using
ber_bvecfree().

W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the
octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller
should free the returned structures using ber_bvarray_free().

M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)
and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting
at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter‐
minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)
on return.  The caller should free the returned array using ber_memfree().

l  Length of the next element.  A pointer to a ber_len_t should be supplied.

t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.

T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.

x  Skip element.  The next element is skipped.

{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.

}  End sequence.  No parameter is required and no action is taken.

[  Begin set.  No parameter is required.  The initial set tag and length are skipped.

]  End set.  No parameter is required and no action is taken.

The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)
on failure.

The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain
the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.

The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().

The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in
this parameter.  The caller should free the returned structure using ber_bvfree().

The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory
assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be
returned using ber_memfree().

The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.

The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.

The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.

The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will
point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().

The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should
be passed to subsequent calls to ber_next_element(), which returns similar information.

EXAMPLES
Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

The element can be decoded using ber_scanf() as follows.

ber_int_t    scope, deref, size, time, attrsonly;
char   *dn, **attrs;
ber_tag_t tag;

tag = ber_scanf( ber, "{aeeiib{v}}",
&amp;dn, &amp;scope, &amp;deref,
&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );

if( tag == LBER_ERROR ) {
/* error */
} else {
/* success */
}

ber_memfree( dn );
ber_memvfree( attrs );

ERRORS
If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using
supplied deallocation routines.

SEE ALSO
lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_DECODE(3)
LBER_DECODE(3)                                                                  Library Functions Manual                                                                  LBER_DECODE(3)

NAME
ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool‐
ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);

ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);

ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);

ber_tag_t ber_get_stringa(BerElement *ber, char **buf);

ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);

ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);

ber_tag_t ber_get_null(BerElement *ber);

ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);

ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);

ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);

ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,
ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,
these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.

The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the
entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb
parameter.

The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by
ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica‐
tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.

a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The
caller should free the returned string using ber_memfree().

A  Octet string.  A variant of "a".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in
the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().

s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet
string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.

O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.
The caller should free the returned structure using ber_bvfree().

o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the
returned octet string using ber_memfree().

m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle‐
ment, and must not be freed by the caller.

b  Boolean.  A pointer to a ber_int_t should be supplied.

e  Enumeration.  A pointer to a ber_int_t should be supplied.

i  Integer.  A pointer to a ber_int_t should be supplied.

B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the
bitstring returned.

n  Null.  No parameter is required.  The element is simply skipped if it is recognized.

v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet
strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().

V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct
berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using
ber_bvecfree().

W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the
octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller
should free the returned structures using ber_bvarray_free().

M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)
and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting
at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter‐
minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)
on return.  The caller should free the returned array using ber_memfree().

l  Length of the next element.  A pointer to a ber_len_t should be supplied.

t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.

T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.

x  Skip element.  The next element is skipped.

{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.

}  End sequence.  No parameter is required and no action is taken.

[  Begin set.  No parameter is required.  The initial set tag and length are skipped.

]  End set.  No parameter is required and no action is taken.

The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)
on failure.

The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain
the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.

The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().

The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in
this parameter.  The caller should free the returned structure using ber_bvfree().

The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory
assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be
returned using ber_memfree().

The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.

The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.

The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.

The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will
point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().

The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should
be passed to subsequent calls to ber_next_element(), which returns similar information.

EXAMPLES
Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

The element can be decoded using ber_scanf() as follows.

ber_int_t    scope, deref, size, time, attrsonly;
char   *dn, **attrs;
ber_tag_t tag;

tag = ber_scanf( ber, "{aeeiib{v}}",
&amp;dn, &amp;scope, &amp;deref,
&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );

if( tag == LBER_ERROR ) {
/* error */
} else {
/* success */
}

ber_memfree( dn );
ber_memvfree( attrs );

ERRORS
If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using
supplied deallocation routines.

SEE ALSO
lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_DECODE(3)
LBER_DECODE(3)                                                                  Library Functions Manual                                                                  LBER_DECODE(3)

NAME
ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool‐
ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);

ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);

ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);

ber_tag_t ber_get_stringa(BerElement *ber, char **buf);

ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);

ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);

ber_tag_t ber_get_null(BerElement *ber);

ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);

ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);

ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);

ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,
ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,
these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.

The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the
entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb
parameter.

The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by
ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica‐
tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.

a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The
caller should free the returned string using ber_memfree().

A  Octet string.  A variant of "a".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in
the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().

s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet
string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.

O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.
The caller should free the returned structure using ber_bvfree().

o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the
returned octet string using ber_memfree().

m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle‐
ment, and must not be freed by the caller.

b  Boolean.  A pointer to a ber_int_t should be supplied.

e  Enumeration.  A pointer to a ber_int_t should be supplied.

i  Integer.  A pointer to a ber_int_t should be supplied.

B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the
bitstring returned.

n  Null.  No parameter is required.  The element is simply skipped if it is recognized.

v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet
strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().

V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct
berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using
ber_bvecfree().

W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the
octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller
should free the returned structures using ber_bvarray_free().

M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)
and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting
at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter‐
minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)
on return.  The caller should free the returned array using ber_memfree().

l  Length of the next element.  A pointer to a ber_len_t should be supplied.

t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.

T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.

x  Skip element.  The next element is skipped.

{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.

}  End sequence.  No parameter is required and no action is taken.

[  Begin set.  No parameter is required.  The initial set tag and length are skipped.

]  End set.  No parameter is required and no action is taken.

The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)
on failure.

The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain
the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.

The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().

The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in
this parameter.  The caller should free the returned structure using ber_bvfree().

The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory
assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be
returned using ber_memfree().

The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.

The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.

The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.

The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will
point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().

The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should
be passed to subsequent calls to ber_next_element(), which returns similar information.

EXAMPLES
Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

The element can be decoded using ber_scanf() as follows.

ber_int_t    scope, deref, size, time, attrsonly;
char   *dn, **attrs;
ber_tag_t tag;

tag = ber_scanf( ber, "{aeeiib{v}}",
&amp;dn, &amp;scope, &amp;deref,
&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );

if( tag == LBER_ERROR ) {
/* error */
} else {
/* success */
}

ber_memfree( dn );
ber_memvfree( attrs );

ERRORS
If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using
supplied deallocation routines.

SEE ALSO
lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_DECODE(3)
LBER_DECODE(3)                                                                  Library Functions Manual                                                                  LBER_DECODE(3)

NAME
ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool‐
ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);

ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);

ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);

ber_tag_t ber_get_stringa(BerElement *ber, char **buf);

ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);

ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);

ber_tag_t ber_get_null(BerElement *ber);

ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);

ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);

ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);

ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,
ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,
these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.

The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the
entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb
parameter.

The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by
ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica‐
tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.

a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The
caller should free the returned string using ber_memfree().

A  Octet string.  A variant of "a".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in
the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().

s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet
string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.

O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.
The caller should free the returned structure using ber_bvfree().

o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the
returned octet string using ber_memfree().

m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle‐
ment, and must not be freed by the caller.

b  Boolean.  A pointer to a ber_int_t should be supplied.

e  Enumeration.  A pointer to a ber_int_t should be supplied.

i  Integer.  A pointer to a ber_int_t should be supplied.

B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the
bitstring returned.

n  Null.  No parameter is required.  The element is simply skipped if it is recognized.

v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet
strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().

V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct
berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using
ber_bvecfree().

W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the
octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller
should free the returned structures using ber_bvarray_free().

M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)
and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting
at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter‐
minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)
on return.  The caller should free the returned array using ber_memfree().

l  Length of the next element.  A pointer to a ber_len_t should be supplied.

t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.

T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.

x  Skip element.  The next element is skipped.

{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.

}  End sequence.  No parameter is required and no action is taken.

[  Begin set.  No parameter is required.  The initial set tag and length are skipped.

]  End set.  No parameter is required and no action is taken.

The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)
on failure.

The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain
the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.

The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().

The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in
this parameter.  The caller should free the returned structure using ber_bvfree().

The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory
assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be
returned using ber_memfree().

The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.

The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.

The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.

The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will
point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().

The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should
be passed to subsequent calls to ber_next_element(), which returns similar information.

EXAMPLES
Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

The element can be decoded using ber_scanf() as follows.

ber_int_t    scope, deref, size, time, attrsonly;
char   *dn, **attrs;
ber_tag_t tag;

tag = ber_scanf( ber, "{aeeiib{v}}",
&amp;dn, &amp;scope, &amp;deref,
&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );

if( tag == LBER_ERROR ) {
/* error */
} else {
/* success */
}

ber_memfree( dn );
ber_memvfree( attrs );

ERRORS
If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using
supplied deallocation routines.

SEE ALSO
lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_DECODE(3)
LBER_DECODE(3)                                                                  Library Functions Manual                                                                  LBER_DECODE(3)

NAME
ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool‐
ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);

ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);

ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);

ber_tag_t ber_get_stringa(BerElement *ber, char **buf);

ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);

ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);

ber_tag_t ber_get_null(BerElement *ber);

ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);

ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);

ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);

ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,
ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,
these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.

The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the
entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb
parameter.

The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by
ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica‐
tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.

a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The
caller should free the returned string using ber_memfree().

A  Octet string.  A variant of "a".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in
the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().

s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet
string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.

O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.
The caller should free the returned structure using ber_bvfree().

o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the
returned octet string using ber_memfree().

m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle‐
ment, and must not be freed by the caller.

b  Boolean.  A pointer to a ber_int_t should be supplied.

e  Enumeration.  A pointer to a ber_int_t should be supplied.

i  Integer.  A pointer to a ber_int_t should be supplied.

B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the
bitstring returned.

n  Null.  No parameter is required.  The element is simply skipped if it is recognized.

v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet
strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().

V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct
berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using
ber_bvecfree().

W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the
octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller
should free the returned structures using ber_bvarray_free().

M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)
and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting
at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter‐
minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)
on return.  The caller should free the returned array using ber_memfree().

l  Length of the next element.  A pointer to a ber_len_t should be supplied.

t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.

T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.

x  Skip element.  The next element is skipped.

{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.

}  End sequence.  No parameter is required and no action is taken.

[  Begin set.  No parameter is required.  The initial set tag and length are skipped.

]  End set.  No parameter is required and no action is taken.

The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)
on failure.

The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain
the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.

The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().

The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in
this parameter.  The caller should free the returned structure using ber_bvfree().

The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory
assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be
returned using ber_memfree().

The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.

The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.

The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.

The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will
point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().

The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should
be passed to subsequent calls to ber_next_element(), which returns similar information.

EXAMPLES
Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

The element can be decoded using ber_scanf() as follows.

ber_int_t    scope, deref, size, time, attrsonly;
char   *dn, **attrs;
ber_tag_t tag;

tag = ber_scanf( ber, "{aeeiib{v}}",
&amp;dn, &amp;scope, &amp;deref,
&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );

if( tag == LBER_ERROR ) {
/* error */
} else {
/* success */
}

ber_memfree( dn );
ber_memvfree( attrs );

ERRORS
If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using
supplied deallocation routines.

SEE ALSO
lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_DECODE(3)
LBER_ENCODE(3)                                                                  Library Functions Manual                                                                  LBER_ENCODE(3)

NAME
ber_alloc_t,  ber_flush,  ber_flush2,  ber_printf,  ber_put_int,  ber_put_enum, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean, ber_put_bitstring, ber_start_seq,
ber_start_set, ber_put_seq, ber_put_set - OpenLDAP LBER simplified Basic Encoding Rules library routines for encoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

BerElement *ber_alloc_t(int options);

int ber_flush(Sockbuf *sb, BerElement *ber, int freeit);

int ber_flush2(Sockbuf *sb, BerElement *ber, int freeit);

int ber_printf(BerElement *ber, const char *fmt, ...);

int ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);

int ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);

int ber_put_ostring(BerElement *ber, const char *str, ber_len_t len, ber_tag_t tag);

int ber_put_string(BerElement *ber, const char *str, ber_tag_t tag);

int ber_put_null(BerElement *ber, ber_tag_t tag);

int ber_put_boolean(BerElement *ber, ber_int_t bool, ber_tag_t tag);

int ber_put_bitstring(BerElement *ber, const char *str, ber_len_t blen, ber_tag_t tag);

int ber_start_seq(BerElement *ber, ber_tag_t tag);

int ber_start_set(BerElement *ber, ber_tag_t tag);

int ber_put_seq(BerElement *ber);

int ber_put_set(BerElement *ber);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and
ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou‐
tines return the length of the element encoded, or -1 if an error occurred.

The ber_alloc_t() routine is used to allocate a new BER element.  It should be called with an argument of LBER_USE_DER.

The ber_flush2() routine is used to actually write the element to a socket (or file) descriptor, once it has been fully encoded (using ber_printf() and friends).  See lber-sock‐
buf(3) for more details on the Sockbuf implementation of the sb parameter.  If the freeit parameter is non-zero, the supplied ber will be freed.   If  LBER_FLUSH_FREE_ON_SUCCESS
is used, the ber is only freed when successfully flushed, otherwise it is left intact; if LBER_FLUSH_FREE_ON_ERROR is used, the ber is only freed when an error occurs, otherwise
it is left intact; if LBER_FLUSH_FREE_ALWAYS is used, the ber is freed anyway.  This function differs from the original ber_flush(3) function, whose behavior corresponds to that
indicated  for LBER_FLUSH_FREE_ON_SUCCESS.  Note that in the future, the behavior of ber_flush(3) with freeit non-zero might change into that of ber_flush2(3) with freeit set to
LBER_FLUSH_FREE_ALWAYS.

The ber_printf() routine is used to encode a BER element in much the same way that sprintf(3) works.  One important difference, though, is that some state  information  is  kept
with  the ber parameter so that multiple calls can be made to ber_printf() to append things to the end of the BER element.  Ber_printf() writes to ber, a pointer to a BerElement
such as returned by ber_alloc_t().  It interprets and formats its arguments according to the format string fmt.  The format string can contain the following characters:

b  Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.

e  Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.

i  Integer.  An ber_int_t parameter should be supplied.  An integer element is output.

B  Bitstring.  A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.  A bitstring element is output.

n  Null.  No parameter is required.  A null element is output.

o  Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.

O  Octet string.  A struct berval * is supplied.  An octet string element is output.

s  Octet string.  A null-terminated string is supplied.  An octet string element is output, not including the trailing NULL octet.

t  Tag.  A ber_tag_t specifying the tag to give the next element is provided.  This works across calls.

v  Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.

V  Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet
strings.

W  Several  octet  strings.  An array of struct berval's is supplied.  The array is terminated by a struct berval with a NULL bv_val.  Note that a construct like '{W}' is
required to get an actual SEQUENCE OF octet strings.

{  Begin sequence.  No parameter is required.

}  End sequence.  No parameter is required.

[  Begin set.  No parameter is required.

]  End set.  No parameter is required.

The ber_put_int() routine writes the integer element num to the BER element ber.

The ber_put_enum() routine writes the enumeration element num to the BER element ber.

The ber_put_boolean() routine writes the boolean value given by bool to the BER element.

The ber_put_bitstring() routine writes blen bits starting at str as a bitstring value to the given BER element.  Note that blen is the length in bits of the bitstring.

The ber_put_ostring() routine writes len bytes starting at str to the BER element as an octet string.

The ber_put_string() routine writes the null-terminated string (minus the terminating ' ') to the BER element as an octet string.

The ber_put_null() routine writes a NULL element to the BER element.

The ber_start_seq() routine is used to start a sequence in the BER element.  The ber_start_set() routine works similarly.  The end of the sequence or set is marked by the  near‐
est matching call to ber_put_seq() or ber_put_set(), respectively.

EXAMPLES
Assuming the following variable declarations, and that the variables have been assigned appropriately, an lber encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

can be achieved like so:

int rc;
ber_int_t    scope, ali, size, time, attrsonly;
char   *dn, **attrs;
BerElement *ber;

/* ... fill in values ... */

ber = ber_alloc_t( LBER_USE_DER );

if ( ber == NULL ) {
/* error */
}

rc = ber_printf( ber, "{siiiib{v}}", dn, scope, ali,
size, time, attrsonly, attrs );

if( rc == -1 ) {
/* error */
} else {
/* success */
}

ERRORS
If an error occurs during encoding, generally these routines return -1.

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.

SEE ALSO
lber-decode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_ENCODE(3)
LBER_ENCODE(3)                                                                  Library Functions Manual                                                                  LBER_ENCODE(3)

NAME
ber_alloc_t,  ber_flush,  ber_flush2,  ber_printf,  ber_put_int,  ber_put_enum, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean, ber_put_bitstring, ber_start_seq,
ber_start_set, ber_put_seq, ber_put_set - OpenLDAP LBER simplified Basic Encoding Rules library routines for encoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

BerElement *ber_alloc_t(int options);

int ber_flush(Sockbuf *sb, BerElement *ber, int freeit);

int ber_flush2(Sockbuf *sb, BerElement *ber, int freeit);

int ber_printf(BerElement *ber, const char *fmt, ...);

int ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);

int ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);

int ber_put_ostring(BerElement *ber, const char *str, ber_len_t len, ber_tag_t tag);

int ber_put_string(BerElement *ber, const char *str, ber_tag_t tag);

int ber_put_null(BerElement *ber, ber_tag_t tag);

int ber_put_boolean(BerElement *ber, ber_int_t bool, ber_tag_t tag);

int ber_put_bitstring(BerElement *ber, const char *str, ber_len_t blen, ber_tag_t tag);

int ber_start_seq(BerElement *ber, ber_tag_t tag);

int ber_start_set(BerElement *ber, ber_tag_t tag);

int ber_put_seq(BerElement *ber);

int ber_put_set(BerElement *ber);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and
ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou‐
tines return the length of the element encoded, or -1 if an error occurred.

The ber_alloc_t() routine is used to allocate a new BER element.  It should be called with an argument of LBER_USE_DER.

The ber_flush2() routine is used to actually write the element to a socket (or file) descriptor, once it has been fully encoded (using ber_printf() and friends).  See lber-sock‐
buf(3) for more details on the Sockbuf implementation of the sb parameter.  If the freeit parameter is non-zero, the supplied ber will be freed.   If  LBER_FLUSH_FREE_ON_SUCCESS
is used, the ber is only freed when successfully flushed, otherwise it is left intact; if LBER_FLUSH_FREE_ON_ERROR is used, the ber is only freed when an error occurs, otherwise
it is left intact; if LBER_FLUSH_FREE_ALWAYS is used, the ber is freed anyway.  This function differs from the original ber_flush(3) function, whose behavior corresponds to that
indicated  for LBER_FLUSH_FREE_ON_SUCCESS.  Note that in the future, the behavior of ber_flush(3) with freeit non-zero might change into that of ber_flush2(3) with freeit set to
LBER_FLUSH_FREE_ALWAYS.

The ber_printf() routine is used to encode a BER element in much the same way that sprintf(3) works.  One important difference, though, is that some state  information  is  kept
with  the ber parameter so that multiple calls can be made to ber_printf() to append things to the end of the BER element.  Ber_printf() writes to ber, a pointer to a BerElement
such as returned by ber_alloc_t().  It interprets and formats its arguments according to the format string fmt.  The format string can contain the following characters:

b  Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.

e  Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.

i  Integer.  An ber_int_t parameter should be supplied.  An integer element is output.

B  Bitstring.  A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.  A bitstring element is output.

n  Null.  No parameter is required.  A null element is output.

o  Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.

O  Octet string.  A struct berval * is supplied.  An octet string element is output.

s  Octet string.  A null-terminated string is supplied.  An octet string element is output, not including the trailing NULL octet.

t  Tag.  A ber_tag_t specifying the tag to give the next element is provided.  This works across calls.

v  Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.

V  Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet
strings.

W  Several  octet  strings.  An array of struct berval's is supplied.  The array is terminated by a struct berval with a NULL bv_val.  Note that a construct like '{W}' is
required to get an actual SEQUENCE OF octet strings.

{  Begin sequence.  No parameter is required.

}  End sequence.  No parameter is required.

[  Begin set.  No parameter is required.

]  End set.  No parameter is required.

The ber_put_int() routine writes the integer element num to the BER element ber.

The ber_put_enum() routine writes the enumeration element num to the BER element ber.

The ber_put_boolean() routine writes the boolean value given by bool to the BER element.

The ber_put_bitstring() routine writes blen bits starting at str as a bitstring value to the given BER element.  Note that blen is the length in bits of the bitstring.

The ber_put_ostring() routine writes len bytes starting at str to the BER element as an octet string.

The ber_put_string() routine writes the null-terminated string (minus the terminating ' ') to the BER element as an octet string.

The ber_put_null() routine writes a NULL element to the BER element.

The ber_start_seq() routine is used to start a sequence in the BER element.  The ber_start_set() routine works similarly.  The end of the sequence or set is marked by the  near‐
est matching call to ber_put_seq() or ber_put_set(), respectively.

EXAMPLES
Assuming the following variable declarations, and that the variables have been assigned appropriately, an lber encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

can be achieved like so:

int rc;
ber_int_t    scope, ali, size, time, attrsonly;
char   *dn, **attrs;
BerElement *ber;

/* ... fill in values ... */

ber = ber_alloc_t( LBER_USE_DER );

if ( ber == NULL ) {
/* error */
}

rc = ber_printf( ber, "{siiiib{v}}", dn, scope, ali,
size, time, attrsonly, attrs );

if( rc == -1 ) {
/* error */
} else {
/* success */
}

ERRORS
If an error occurs during encoding, generally these routines return -1.

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.

SEE ALSO
lber-decode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_ENCODE(3)
LBER_ENCODE(3)                                                                  Library Functions Manual                                                                  LBER_ENCODE(3)

NAME
ber_alloc_t,  ber_flush,  ber_flush2,  ber_printf,  ber_put_int,  ber_put_enum, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean, ber_put_bitstring, ber_start_seq,
ber_start_set, ber_put_seq, ber_put_set - OpenLDAP LBER simplified Basic Encoding Rules library routines for encoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

BerElement *ber_alloc_t(int options);

int ber_flush(Sockbuf *sb, BerElement *ber, int freeit);

int ber_flush2(Sockbuf *sb, BerElement *ber, int freeit);

int ber_printf(BerElement *ber, const char *fmt, ...);

int ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);

int ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);

int ber_put_ostring(BerElement *ber, const char *str, ber_len_t len, ber_tag_t tag);

int ber_put_string(BerElement *ber, const char *str, ber_tag_t tag);

int ber_put_null(BerElement *ber, ber_tag_t tag);

int ber_put_boolean(BerElement *ber, ber_int_t bool, ber_tag_t tag);

int ber_put_bitstring(BerElement *ber, const char *str, ber_len_t blen, ber_tag_t tag);

int ber_start_seq(BerElement *ber, ber_tag_t tag);

int ber_start_set(BerElement *ber, ber_tag_t tag);

int ber_put_seq(BerElement *ber);

int ber_put_set(BerElement *ber);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and
ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou‐
tines return the length of the element encoded, or -1 if an error occurred.

The ber_alloc_t() routine is used to allocate a new BER element.  It should be called with an argument of LBER_USE_DER.

The ber_flush2() routine is used to actually write the element to a socket (or file) descriptor, once it has been fully encoded (using ber_printf() and friends).  See lber-sock‐
buf(3) for more details on the Sockbuf implementation of the sb parameter.  If the freeit parameter is non-zero, the supplied ber will be freed.   If  LBER_FLUSH_FREE_ON_SUCCESS
is used, the ber is only freed when successfully flushed, otherwise it is left intact; if LBER_FLUSH_FREE_ON_ERROR is used, the ber is only freed when an error occurs, otherwise
it is left intact; if LBER_FLUSH_FREE_ALWAYS is used, the ber is freed anyway.  This function differs from the original ber_flush(3) function, whose behavior corresponds to that
indicated  for LBER_FLUSH_FREE_ON_SUCCESS.  Note that in the future, the behavior of ber_flush(3) with freeit non-zero might change into that of ber_flush2(3) with freeit set to
LBER_FLUSH_FREE_ALWAYS.

The ber_printf() routine is used to encode a BER element in much the same way that sprintf(3) works.  One important difference, though, is that some state  information  is  kept
with  the ber parameter so that multiple calls can be made to ber_printf() to append things to the end of the BER element.  Ber_printf() writes to ber, a pointer to a BerElement
such as returned by ber_alloc_t().  It interprets and formats its arguments according to the format string fmt.  The format string can contain the following characters:

b  Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.

e  Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.

i  Integer.  An ber_int_t parameter should be supplied.  An integer element is output.

B  Bitstring.  A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.  A bitstring element is output.

n  Null.  No parameter is required.  A null element is output.

o  Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.

O  Octet string.  A struct berval * is supplied.  An octet string element is output.

s  Octet string.  A null-terminated string is supplied.  An octet string element is output, not including the trailing NULL octet.

t  Tag.  A ber_tag_t specifying the tag to give the next element is provided.  This works across calls.

v  Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.

V  Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet
strings.

W  Several  octet  strings.  An array of struct berval's is supplied.  The array is terminated by a struct berval with a NULL bv_val.  Note that a construct like '{W}' is
required to get an actual SEQUENCE OF octet strings.

{  Begin sequence.  No parameter is required.

}  End sequence.  No parameter is required.

[  Begin set.  No parameter is required.

]  End set.  No parameter is required.

The ber_put_int() routine writes the integer element num to the BER element ber.

The ber_put_enum() routine writes the enumeration element num to the BER element ber.

The ber_put_boolean() routine writes the boolean value given by bool to the BER element.

The ber_put_bitstring() routine writes blen bits starting at str as a bitstring value to the given BER element.  Note that blen is the length in bits of the bitstring.

The ber_put_ostring() routine writes len bytes starting at str to the BER element as an octet string.

The ber_put_string() routine writes the null-terminated string (minus the terminating ' ') to the BER element as an octet string.

The ber_put_null() routine writes a NULL element to the BER element.

The ber_start_seq() routine is used to start a sequence in the BER element.  The ber_start_set() routine works similarly.  The end of the sequence or set is marked by the  near‐
est matching call to ber_put_seq() or ber_put_set(), respectively.

EXAMPLES
Assuming the following variable declarations, and that the variables have been assigned appropriately, an lber encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

can be achieved like so:

int rc;
ber_int_t    scope, ali, size, time, attrsonly;
char   *dn, **attrs;
BerElement *ber;

/* ... fill in values ... */

ber = ber_alloc_t( LBER_USE_DER );

if ( ber == NULL ) {
/* error */
}

rc = ber_printf( ber, "{siiiib{v}}", dn, scope, ali,
size, time, attrsonly, attrs );

if( rc == -1 ) {
/* error */
} else {
/* success */
}

ERRORS
If an error occurs during encoding, generally these routines return -1.

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.

SEE ALSO
lber-decode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_ENCODE(3)
LBER_ENCODE(3)                                                                  Library Functions Manual                                                                  LBER_ENCODE(3)

NAME
ber_alloc_t,  ber_flush,  ber_flush2,  ber_printf,  ber_put_int,  ber_put_enum, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean, ber_put_bitstring, ber_start_seq,
ber_start_set, ber_put_seq, ber_put_set - OpenLDAP LBER simplified Basic Encoding Rules library routines for encoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

BerElement *ber_alloc_t(int options);

int ber_flush(Sockbuf *sb, BerElement *ber, int freeit);

int ber_flush2(Sockbuf *sb, BerElement *ber, int freeit);

int ber_printf(BerElement *ber, const char *fmt, ...);

int ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);

int ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);

int ber_put_ostring(BerElement *ber, const char *str, ber_len_t len, ber_tag_t tag);

int ber_put_string(BerElement *ber, const char *str, ber_tag_t tag);

int ber_put_null(BerElement *ber, ber_tag_t tag);

int ber_put_boolean(BerElement *ber, ber_int_t bool, ber_tag_t tag);

int ber_put_bitstring(BerElement *ber, const char *str, ber_len_t blen, ber_tag_t tag);

int ber_start_seq(BerElement *ber, ber_tag_t tag);

int ber_start_set(BerElement *ber, ber_tag_t tag);

int ber_put_seq(BerElement *ber);

int ber_put_set(BerElement *ber);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and
ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou‐
tines return the length of the element encoded, or -1 if an error occurred.

The ber_alloc_t() routine is used to allocate a new BER element.  It should be called with an argument of LBER_USE_DER.

The ber_flush2() routine is used to actually write the element to a socket (or file) descriptor, once it has been fully encoded (using ber_printf() and friends).  See lber-sock‐
buf(3) for more details on the Sockbuf implementation of the sb parameter.  If the freeit parameter is non-zero, the supplied ber will be freed.   If  LBER_FLUSH_FREE_ON_SUCCESS
is used, the ber is only freed when successfully flushed, otherwise it is left intact; if LBER_FLUSH_FREE_ON_ERROR is used, the ber is only freed when an error occurs, otherwise
it is left intact; if LBER_FLUSH_FREE_ALWAYS is used, the ber is freed anyway.  This function differs from the original ber_flush(3) function, whose behavior corresponds to that
indicated  for LBER_FLUSH_FREE_ON_SUCCESS.  Note that in the future, the behavior of ber_flush(3) with freeit non-zero might change into that of ber_flush2(3) with freeit set to
LBER_FLUSH_FREE_ALWAYS.

The ber_printf() routine is used to encode a BER element in much the same way that sprintf(3) works.  One important difference, though, is that some state  information  is  kept
with  the ber parameter so that multiple calls can be made to ber_printf() to append things to the end of the BER element.  Ber_printf() writes to ber, a pointer to a BerElement
such as returned by ber_alloc_t().  It interprets and formats its arguments according to the format string fmt.  The format string can contain the following characters:

b  Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.

e  Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.

i  Integer.  An ber_int_t parameter should be supplied.  An integer element is output.

B  Bitstring.  A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.  A bitstring element is output.

n  Null.  No parameter is required.  A null element is output.

o  Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.

O  Octet string.  A struct berval * is supplied.  An octet string element is output.

s  Octet string.  A null-terminated string is supplied.  An octet string element is output, not including the trailing NULL octet.

t  Tag.  A ber_tag_t specifying the tag to give the next element is provided.  This works across calls.

v  Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.

V  Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet
strings.

W  Several  octet  strings.  An array of struct berval's is supplied.  The array is terminated by a struct berval with a NULL bv_val.  Note that a construct like '{W}' is
required to get an actual SEQUENCE OF octet strings.

{  Begin sequence.  No parameter is required.

}  End sequence.  No parameter is required.

[  Begin set.  No parameter is required.

]  End set.  No parameter is required.

The ber_put_int() routine writes the integer element num to the BER element ber.

The ber_put_enum() routine writes the enumeration element num to the BER element ber.

The ber_put_boolean() routine writes the boolean value given by bool to the BER element.

The ber_put_bitstring() routine writes blen bits starting at str as a bitstring value to the given BER element.  Note that blen is the length in bits of the bitstring.

The ber_put_ostring() routine writes len bytes starting at str to the BER element as an octet string.

The ber_put_string() routine writes the null-terminated string (minus the terminating ' ') to the BER element as an octet string.

The ber_put_null() routine writes a NULL element to the BER element.

The ber_start_seq() routine is used to start a sequence in the BER element.  The ber_start_set() routine works similarly.  The end of the sequence or set is marked by the  near‐
est matching call to ber_put_seq() or ber_put_set(), respectively.

EXAMPLES
Assuming the following variable declarations, and that the variables have been assigned appropriately, an lber encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

can be achieved like so:

int rc;
ber_int_t    scope, ali, size, time, attrsonly;
char   *dn, **attrs;
BerElement *ber;

/* ... fill in values ... */

ber = ber_alloc_t( LBER_USE_DER );

if ( ber == NULL ) {
/* error */
}

rc = ber_printf( ber, "{siiiib{v}}", dn, scope, ali,
size, time, attrsonly, attrs );

if( rc == -1 ) {
/* error */
} else {
/* success */
}

ERRORS
If an error occurs during encoding, generally these routines return -1.

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.

SEE ALSO
lber-decode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_ENCODE(3)
LBER_ENCODE(3)                                                                  Library Functions Manual                                                                  LBER_ENCODE(3)

NAME
ber_alloc_t,  ber_flush,  ber_flush2,  ber_printf,  ber_put_int,  ber_put_enum, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean, ber_put_bitstring, ber_start_seq,
ber_start_set, ber_put_seq, ber_put_set - OpenLDAP LBER simplified Basic Encoding Rules library routines for encoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

BerElement *ber_alloc_t(int options);

int ber_flush(Sockbuf *sb, BerElement *ber, int freeit);

int ber_flush2(Sockbuf *sb, BerElement *ber, int freeit);

int ber_printf(BerElement *ber, const char *fmt, ...);

int ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);

int ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);

int ber_put_ostring(BerElement *ber, const char *str, ber_len_t len, ber_tag_t tag);

int ber_put_string(BerElement *ber, const char *str, ber_tag_t tag);

int ber_put_null(BerElement *ber, ber_tag_t tag);

int ber_put_boolean(BerElement *ber, ber_int_t bool, ber_tag_t tag);

int ber_put_bitstring(BerElement *ber, const char *str, ber_len_t blen, ber_tag_t tag);

int ber_start_seq(BerElement *ber, ber_tag_t tag);

int ber_start_set(BerElement *ber, ber_tag_t tag);

int ber_put_seq(BerElement *ber);

int ber_put_set(BerElement *ber);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and
ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou‐
tines return the length of the element encoded, or -1 if an error occurred.

The ber_alloc_t() routine is used to allocate a new BER element.  It should be called with an argument of LBER_USE_DER.

The ber_flush2() routine is used to actually write the element to a socket (or file) descriptor, once it has been fully encoded (using ber_printf() and friends).  See lber-sock‐
buf(3) for more details on the Sockbuf implementation of the sb parameter.  If the freeit parameter is non-zero, the supplied ber will be freed.   If  LBER_FLUSH_FREE_ON_SUCCESS
is used, the ber is only freed when successfully flushed, otherwise it is left intact; if LBER_FLUSH_FREE_ON_ERROR is used, the ber is only freed when an error occurs, otherwise
it is left intact; if LBER_FLUSH_FREE_ALWAYS is used, the ber is freed anyway.  This function differs from the original ber_flush(3) function, whose behavior corresponds to that
indicated  for LBER_FLUSH_FREE_ON_SUCCESS.  Note that in the future, the behavior of ber_flush(3) with freeit non-zero might change into that of ber_flush2(3) with freeit set to
LBER_FLUSH_FREE_ALWAYS.

The ber_printf() routine is used to encode a BER element in much the same way that sprintf(3) works.  One important difference, though, is that some state  information  is  kept
with  the ber parameter so that multiple calls can be made to ber_printf() to append things to the end of the BER element.  Ber_printf() writes to ber, a pointer to a BerElement
such as returned by ber_alloc_t().  It interprets and formats its arguments according to the format string fmt.  The format string can contain the following characters:

b  Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.

e  Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.

i  Integer.  An ber_int_t parameter should be supplied.  An integer element is output.

B  Bitstring.  A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.  A bitstring element is output.

n  Null.  No parameter is required.  A null element is output.

o  Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.

O  Octet string.  A struct berval * is supplied.  An octet string element is output.

s  Octet string.  A null-terminated string is supplied.  An octet string element is output, not including the trailing NULL octet.

t  Tag.  A ber_tag_t specifying the tag to give the next element is provided.  This works across calls.

v  Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.

V  Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet
strings.

W  Several  octet  strings.  An array of struct berval's is supplied.  The array is terminated by a struct berval with a NULL bv_val.  Note that a construct like '{W}' is
required to get an actual SEQUENCE OF octet strings.

{  Begin sequence.  No parameter is required.

}  End sequence.  No parameter is required.

[  Begin set.  No parameter is required.

]  End set.  No parameter is required.

The ber_put_int() routine writes the integer element num to the BER element ber.

The ber_put_enum() routine writes the enumeration element num to the BER element ber.

The ber_put_boolean() routine writes the boolean value given by bool to the BER element.

The ber_put_bitstring() routine writes blen bits starting at str as a bitstring value to the given BER element.  Note that blen is the length in bits of the bitstring.

The ber_put_ostring() routine writes len bytes starting at str to the BER element as an octet string.

The ber_put_string() routine writes the null-terminated string (minus the terminating ' ') to the BER element as an octet string.

The ber_put_null() routine writes a NULL element to the BER element.

The ber_start_seq() routine is used to start a sequence in the BER element.  The ber_start_set() routine works similarly.  The end of the sequence or set is marked by the  near‐
est matching call to ber_put_seq() or ber_put_set(), respectively.

EXAMPLES
Assuming the following variable declarations, and that the variables have been assigned appropriately, an lber encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

can be achieved like so:

int rc;
ber_int_t    scope, ali, size, time, attrsonly;
char   *dn, **attrs;
BerElement *ber;

/* ... fill in values ... */

ber = ber_alloc_t( LBER_USE_DER );

if ( ber == NULL ) {
/* error */
}

rc = ber_printf( ber, "{siiiib{v}}", dn, scope, ali,
size, time, attrsonly, attrs );

if( rc == -1 ) {
/* error */
} else {
/* success */
}

ERRORS
If an error occurs during encoding, generally these routines return -1.

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.

SEE ALSO
lber-decode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_ENCODE(3)
LBER_ENCODE(3)                                                                  Library Functions Manual                                                                  LBER_ENCODE(3)

NAME
ber_alloc_t,  ber_flush,  ber_flush2,  ber_printf,  ber_put_int,  ber_put_enum, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean, ber_put_bitstring, ber_start_seq,
ber_start_set, ber_put_seq, ber_put_set - OpenLDAP LBER simplified Basic Encoding Rules library routines for encoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

BerElement *ber_alloc_t(int options);

int ber_flush(Sockbuf *sb, BerElement *ber, int freeit);

int ber_flush2(Sockbuf *sb, BerElement *ber, int freeit);

int ber_printf(BerElement *ber, const char *fmt, ...);

int ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);

int ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);

int ber_put_ostring(BerElement *ber, const char *str, ber_len_t len, ber_tag_t tag);

int ber_put_string(BerElement *ber, const char *str, ber_tag_t tag);

int ber_put_null(BerElement *ber, ber_tag_t tag);

int ber_put_boolean(BerElement *ber, ber_int_t bool, ber_tag_t tag);

int ber_put_bitstring(BerElement *ber, const char *str, ber_len_t blen, ber_tag_t tag);

int ber_start_seq(BerElement *ber, ber_tag_t tag);

int ber_start_set(BerElement *ber, ber_tag_t tag);

int ber_put_seq(BerElement *ber);

int ber_put_set(BerElement *ber);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and
ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou‐
tines return the length of the element encoded, or -1 if an error occurred.

The ber_alloc_t() routine is used to allocate a new BER element.  It should be called with an argument of LBER_USE_DER.

The ber_flush2() routine is used to actually write the element to a socket (or file) descriptor, once it has been fully encoded (using ber_printf() and friends).  See lber-sock‐
buf(3) for more details on the Sockbuf implementation of the sb parameter.  If the freeit parameter is non-zero, the supplied ber will be freed.   If  LBER_FLUSH_FREE_ON_SUCCESS
is used, the ber is only freed when successfully flushed, otherwise it is left intact; if LBER_FLUSH_FREE_ON_ERROR is used, the ber is only freed when an error occurs, otherwise
it is left intact; if LBER_FLUSH_FREE_ALWAYS is used, the ber is freed anyway.  This function differs from the original ber_flush(3) function, whose behavior corresponds to that
indicated  for LBER_FLUSH_FREE_ON_SUCCESS.  Note that in the future, the behavior of ber_flush(3) with freeit non-zero might change into that of ber_flush2(3) with freeit set to
LBER_FLUSH_FREE_ALWAYS.

The ber_printf() routine is used to encode a BER element in much the same way that sprintf(3) works.  One important difference, though, is that some state  information  is  kept
with  the ber parameter so that multiple calls can be made to ber_printf() to append things to the end of the BER element.  Ber_printf() writes to ber, a pointer to a BerElement
such as returned by ber_alloc_t().  It interprets and formats its arguments according to the format string fmt.  The format string can contain the following characters:

b  Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.

e  Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.

i  Integer.  An ber_int_t parameter should be supplied.  An integer element is output.

B  Bitstring.  A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.  A bitstring element is output.

n  Null.  No parameter is required.  A null element is output.

o  Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.

O  Octet string.  A struct berval * is supplied.  An octet string element is output.

s  Octet string.  A null-terminated string is supplied.  An octet string element is output, not including the trailing NULL octet.

t  Tag.  A ber_tag_t specifying the tag to give the next element is provided.  This works across calls.

v  Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.

V  Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet
strings.

W  Several  octet  strings.  An array of struct berval's is supplied.  The array is terminated by a struct berval with a NULL bv_val.  Note that a construct like '{W}' is
required to get an actual SEQUENCE OF octet strings.

{  Begin sequence.  No parameter is required.

}  End sequence.  No parameter is required.

[  Begin set.  No parameter is required.

]  End set.  No parameter is required.

The ber_put_int() routine writes the integer element num to the BER element ber.

The ber_put_enum() routine writes the enumeration element num to the BER element ber.

The ber_put_boolean() routine writes the boolean value given by bool to the BER element.

The ber_put_bitstring() routine writes blen bits starting at str as a bitstring value to the given BER element.  Note that blen is the length in bits of the bitstring.

The ber_put_ostring() routine writes len bytes starting at str to the BER element as an octet string.

The ber_put_string() routine writes the null-terminated string (minus the terminating ' ') to the BER element as an octet string.

The ber_put_null() routine writes a NULL element to the BER element.

The ber_start_seq() routine is used to start a sequence in the BER element.  The ber_start_set() routine works similarly.  The end of the sequence or set is marked by the  near‐
est matching call to ber_put_seq() or ber_put_set(), respectively.

EXAMPLES
Assuming the following variable declarations, and that the variables have been assigned appropriately, an lber encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

can be achieved like so:

int rc;
ber_int_t    scope, ali, size, time, attrsonly;
char   *dn, **attrs;
BerElement *ber;

/* ... fill in values ... */

ber = ber_alloc_t( LBER_USE_DER );

if ( ber == NULL ) {
/* error */
}

rc = ber_printf( ber, "{siiiib{v}}", dn, scope, ali,
size, time, attrsonly, attrs );

if( rc == -1 ) {
/* error */
} else {
/* success */
}

ERRORS
If an error occurs during encoding, generally these routines return -1.

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.

SEE ALSO
lber-decode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_ENCODE(3)
LBER_ENCODE(3)                                                                  Library Functions Manual                                                                  LBER_ENCODE(3)

NAME
ber_alloc_t,  ber_flush,  ber_flush2,  ber_printf,  ber_put_int,  ber_put_enum, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean, ber_put_bitstring, ber_start_seq,
ber_start_set, ber_put_seq, ber_put_set - OpenLDAP LBER simplified Basic Encoding Rules library routines for encoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

BerElement *ber_alloc_t(int options);

int ber_flush(Sockbuf *sb, BerElement *ber, int freeit);

int ber_flush2(Sockbuf *sb, BerElement *ber, int freeit);

int ber_printf(BerElement *ber, const char *fmt, ...);

int ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);

int ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);

int ber_put_ostring(BerElement *ber, const char *str, ber_len_t len, ber_tag_t tag);

int ber_put_string(BerElement *ber, const char *str, ber_tag_t tag);

int ber_put_null(BerElement *ber, ber_tag_t tag);

int ber_put_boolean(BerElement *ber, ber_int_t bool, ber_tag_t tag);

int ber_put_bitstring(BerElement *ber, const char *str, ber_len_t blen, ber_tag_t tag);

int ber_start_seq(BerElement *ber, ber_tag_t tag);

int ber_start_set(BerElement *ber, ber_tag_t tag);

int ber_put_seq(BerElement *ber);

int ber_put_set(BerElement *ber);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and
ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou‐
tines return the length of the element encoded, or -1 if an error occurred.

The ber_alloc_t() routine is used to allocate a new BER element.  It should be called with an argument of LBER_USE_DER.

The ber_flush2() routine is used to actually write the element to a socket (or file) descriptor, once it has been fully encoded (using ber_printf() and friends).  See lber-sock‐
buf(3) for more details on the Sockbuf implementation of the sb parameter.  If the freeit parameter is non-zero, the supplied ber will be freed.   If  LBER_FLUSH_FREE_ON_SUCCESS
is used, the ber is only freed when successfully flushed, otherwise it is left intact; if LBER_FLUSH_FREE_ON_ERROR is used, the ber is only freed when an error occurs, otherwise
it is left intact; if LBER_FLUSH_FREE_ALWAYS is used, the ber is freed anyway.  This function differs from the original ber_flush(3) function, whose behavior corresponds to that
indicated  for LBER_FLUSH_FREE_ON_SUCCESS.  Note that in the future, the behavior of ber_flush(3) with freeit non-zero might change into that of ber_flush2(3) with freeit set to
LBER_FLUSH_FREE_ALWAYS.

The ber_printf() routine is used to encode a BER element in much the same way that sprintf(3) works.  One important difference, though, is that some state  information  is  kept
with  the ber parameter so that multiple calls can be made to ber_printf() to append things to the end of the BER element.  Ber_printf() writes to ber, a pointer to a BerElement
such as returned by ber_alloc_t().  It interprets and formats its arguments according to the format string fmt.  The format string can contain the following characters:

b  Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.

e  Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.

i  Integer.  An ber_int_t parameter should be supplied.  An integer element is output.

B  Bitstring.  A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.  A bitstring element is output.

n  Null.  No parameter is required.  A null element is output.

o  Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.

O  Octet string.  A struct berval * is supplied.  An octet string element is output.

s  Octet string.  A null-terminated string is supplied.  An octet string element is output, not including the trailing NULL octet.

t  Tag.  A ber_tag_t specifying the tag to give the next element is provided.  This works across calls.

v  Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.

V  Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet
strings.

W  Several  octet  strings.  An array of struct berval's is supplied.  The array is terminated by a struct berval with a NULL bv_val.  Note that a construct like '{W}' is
required to get an actual SEQUENCE OF octet strings.

{  Begin sequence.  No parameter is required.

}  End sequence.  No parameter is required.

[  Begin set.  No parameter is required.

]  End set.  No parameter is required.

The ber_put_int() routine writes the integer element num to the BER element ber.

The ber_put_enum() routine writes the enumeration element num to the BER element ber.

The ber_put_boolean() routine writes the boolean value given by bool to the BER element.

The ber_put_bitstring() routine writes blen bits starting at str as a bitstring value to the given BER element.  Note that blen is the length in bits of the bitstring.

The ber_put_ostring() routine writes len bytes starting at str to the BER element as an octet string.

The ber_put_string() routine writes the null-terminated string (minus the terminating ' ') to the BER element as an octet string.

The ber_put_null() routine writes a NULL element to the BER element.

The ber_start_seq() routine is used to start a sequence in the BER element.  The ber_start_set() routine works similarly.  The end of the sequence or set is marked by the  near‐
est matching call to ber_put_seq() or ber_put_set(), respectively.

EXAMPLES
Assuming the following variable declarations, and that the variables have been assigned appropriately, an lber encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

can be achieved like so:

int rc;
ber_int_t    scope, ali, size, time, attrsonly;
char   *dn, **attrs;
BerElement *ber;

/* ... fill in values ... */

ber = ber_alloc_t( LBER_USE_DER );

if ( ber == NULL ) {
/* error */
}

rc = ber_printf( ber, "{siiiib{v}}", dn, scope, ali,
size, time, attrsonly, attrs );

if( rc == -1 ) {
/* error */
} else {
/* success */
}

ERRORS
If an error occurs during encoding, generally these routines return -1.

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.

SEE ALSO
lber-decode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_ENCODE(3)
LBER_ENCODE(3)                                                                  Library Functions Manual                                                                  LBER_ENCODE(3)

NAME
ber_alloc_t,  ber_flush,  ber_flush2,  ber_printf,  ber_put_int,  ber_put_enum, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean, ber_put_bitstring, ber_start_seq,
ber_start_set, ber_put_seq, ber_put_set - OpenLDAP LBER simplified Basic Encoding Rules library routines for encoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

BerElement *ber_alloc_t(int options);

int ber_flush(Sockbuf *sb, BerElement *ber, int freeit);

int ber_flush2(Sockbuf *sb, BerElement *ber, int freeit);

int ber_printf(BerElement *ber, const char *fmt, ...);

int ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);

int ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);

int ber_put_ostring(BerElement *ber, const char *str, ber_len_t len, ber_tag_t tag);

int ber_put_string(BerElement *ber, const char *str, ber_tag_t tag);

int ber_put_null(BerElement *ber, ber_tag_t tag);

int ber_put_boolean(BerElement *ber, ber_int_t bool, ber_tag_t tag);

int ber_put_bitstring(BerElement *ber, const char *str, ber_len_t blen, ber_tag_t tag);

int ber_start_seq(BerElement *ber, ber_tag_t tag);

int ber_start_set(BerElement *ber, ber_tag_t tag);

int ber_put_seq(BerElement *ber);

int ber_put_set(BerElement *ber);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and
ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou‐
tines return the length of the element encoded, or -1 if an error occurred.

The ber_alloc_t() routine is used to allocate a new BER element.  It should be called with an argument of LBER_USE_DER.

The ber_flush2() routine is used to actually write the element to a socket (or file) descriptor, once it has been fully encoded (using ber_printf() and friends).  See lber-sock‐
buf(3) for more details on the Sockbuf implementation of the sb parameter.  If the freeit parameter is non-zero, the supplied ber will be freed.   If  LBER_FLUSH_FREE_ON_SUCCESS
is used, the ber is only freed when successfully flushed, otherwise it is left intact; if LBER_FLUSH_FREE_ON_ERROR is used, the ber is only freed when an error occurs, otherwise
it is left intact; if LBER_FLUSH_FREE_ALWAYS is used, the ber is freed anyway.  This function differs from the original ber_flush(3) function, whose behavior corresponds to that
indicated  for LBER_FLUSH_FREE_ON_SUCCESS.  Note that in the future, the behavior of ber_flush(3) with freeit non-zero might change into that of ber_flush2(3) with freeit set to
LBER_FLUSH_FREE_ALWAYS.

The ber_printf() routine is used to encode a BER element in much the same way that sprintf(3) works.  One important difference, though, is that some state  information  is  kept
with  the ber parameter so that multiple calls can be made to ber_printf() to append things to the end of the BER element.  Ber_printf() writes to ber, a pointer to a BerElement
such as returned by ber_alloc_t().  It interprets and formats its arguments according to the format string fmt.  The format string can contain the following characters:

b  Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.

e  Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.

i  Integer.  An ber_int_t parameter should be supplied.  An integer element is output.

B  Bitstring.  A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.  A bitstring element is output.

n  Null.  No parameter is required.  A null element is output.

o  Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.

O  Octet string.  A struct berval * is supplied.  An octet string element is output.

s  Octet string.  A null-terminated string is supplied.  An octet string element is output, not including the trailing NULL octet.

t  Tag.  A ber_tag_t specifying the tag to give the next element is provided.  This works across calls.

v  Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.

V  Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet
strings.

W  Several  octet  strings.  An array of struct berval's is supplied.  The array is terminated by a struct berval with a NULL bv_val.  Note that a construct like '{W}' is
required to get an actual SEQUENCE OF octet strings.

{  Begin sequence.  No parameter is required.

}  End sequence.  No parameter is required.

[  Begin set.  No parameter is required.

]  End set.  No parameter is required.

The ber_put_int() routine writes the integer element num to the BER element ber.

The ber_put_enum() routine writes the enumeration element num to the BER element ber.

The ber_put_boolean() routine writes the boolean value given by bool to the BER element.

The ber_put_bitstring() routine writes blen bits starting at str as a bitstring value to the given BER element.  Note that blen is the length in bits of the bitstring.

The ber_put_ostring() routine writes len bytes starting at str to the BER element as an octet string.

The ber_put_string() routine writes the null-terminated string (minus the terminating ' ') to the BER element as an octet string.

The ber_put_null() routine writes a NULL element to the BER element.

The ber_start_seq() routine is used to start a sequence in the BER element.  The ber_start_set() routine works similarly.  The end of the sequence or set is marked by the  near‐
est matching call to ber_put_seq() or ber_put_set(), respectively.

EXAMPLES
Assuming the following variable declarations, and that the variables have been assigned appropriately, an lber encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

can be achieved like so:

int rc;
ber_int_t    scope, ali, size, time, attrsonly;
char   *dn, **attrs;
BerElement *ber;

/* ... fill in values ... */

ber = ber_alloc_t( LBER_USE_DER );

if ( ber == NULL ) {
/* error */
}

rc = ber_printf( ber, "{siiiib{v}}", dn, scope, ali,
size, time, attrsonly, attrs );

if( rc == -1 ) {
/* error */
} else {
/* success */
}

ERRORS
If an error occurs during encoding, generally these routines return -1.

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.

SEE ALSO
lber-decode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_ENCODE(3)
LBER_DECODE(3)                                                                  Library Functions Manual                                                                  LBER_DECODE(3)

NAME
ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool‐
ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);

ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);

ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);

ber_tag_t ber_get_stringa(BerElement *ber, char **buf);

ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);

ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);

ber_tag_t ber_get_null(BerElement *ber);

ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);

ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);

ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);

ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,
ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,
these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.

The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the
entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb
parameter.

The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by
ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica‐
tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.

a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The
caller should free the returned string using ber_memfree().

A  Octet string.  A variant of "a".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in
the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().

s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet
string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.

O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.
The caller should free the returned structure using ber_bvfree().

o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the
returned octet string using ber_memfree().

m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle‐
ment, and must not be freed by the caller.

b  Boolean.  A pointer to a ber_int_t should be supplied.

e  Enumeration.  A pointer to a ber_int_t should be supplied.

i  Integer.  A pointer to a ber_int_t should be supplied.

B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the
bitstring returned.

n  Null.  No parameter is required.  The element is simply skipped if it is recognized.

v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet
strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().

V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct
berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using
ber_bvecfree().

W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the
octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller
should free the returned structures using ber_bvarray_free().

M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)
and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting
at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter‐
minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)
on return.  The caller should free the returned array using ber_memfree().

l  Length of the next element.  A pointer to a ber_len_t should be supplied.

t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.

T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.

x  Skip element.  The next element is skipped.

{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.

}  End sequence.  No parameter is required and no action is taken.

[  Begin set.  No parameter is required.  The initial set tag and length are skipped.

]  End set.  No parameter is required and no action is taken.

The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)
on failure.

The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain
the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.

The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().

The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in
this parameter.  The caller should free the returned structure using ber_bvfree().

The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory
assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be
returned using ber_memfree().

The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.

The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.

The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.

The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will
point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().

The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should
be passed to subsequent calls to ber_next_element(), which returns similar information.

EXAMPLES
Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

The element can be decoded using ber_scanf() as follows.

ber_int_t    scope, deref, size, time, attrsonly;
char   *dn, **attrs;
ber_tag_t tag;

tag = ber_scanf( ber, "{aeeiib{v}}",
&amp;dn, &amp;scope, &amp;deref,
&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );

if( tag == LBER_ERROR ) {
/* error */
} else {
/* success */
}

ber_memfree( dn );
ber_memvfree( attrs );

ERRORS
If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using
supplied deallocation routines.

SEE ALSO
lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_DECODE(3)
LBER_DECODE(3)                                                                  Library Functions Manual                                                                  LBER_DECODE(3)

NAME
ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool‐
ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);

ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);

ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);

ber_tag_t ber_get_stringa(BerElement *ber, char **buf);

ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);

ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);

ber_tag_t ber_get_null(BerElement *ber);

ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);

ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);

ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);

ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,
ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,
these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.

The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the
entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb
parameter.

The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by
ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica‐
tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.

a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The
caller should free the returned string using ber_memfree().

A  Octet string.  A variant of "a".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in
the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().

s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet
string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.

O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.
The caller should free the returned structure using ber_bvfree().

o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the
returned octet string using ber_memfree().

m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle‐
ment, and must not be freed by the caller.

b  Boolean.  A pointer to a ber_int_t should be supplied.

e  Enumeration.  A pointer to a ber_int_t should be supplied.

i  Integer.  A pointer to a ber_int_t should be supplied.

B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the
bitstring returned.

n  Null.  No parameter is required.  The element is simply skipped if it is recognized.

v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet
strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().

V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct
berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using
ber_bvecfree().

W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the
octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller
should free the returned structures using ber_bvarray_free().

M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)
and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting
at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter‐
minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)
on return.  The caller should free the returned array using ber_memfree().

l  Length of the next element.  A pointer to a ber_len_t should be supplied.

t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.

T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.

x  Skip element.  The next element is skipped.

{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.

}  End sequence.  No parameter is required and no action is taken.

[  Begin set.  No parameter is required.  The initial set tag and length are skipped.

]  End set.  No parameter is required and no action is taken.

The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)
on failure.

The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain
the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.

The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().

The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in
this parameter.  The caller should free the returned structure using ber_bvfree().

The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory
assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be
returned using ber_memfree().

The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.

The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.

The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.

The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will
point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().

The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should
be passed to subsequent calls to ber_next_element(), which returns similar information.

EXAMPLES
Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

The element can be decoded using ber_scanf() as follows.

ber_int_t    scope, deref, size, time, attrsonly;
char   *dn, **attrs;
ber_tag_t tag;

tag = ber_scanf( ber, "{aeeiib{v}}",
&amp;dn, &amp;scope, &amp;deref,
&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );

if( tag == LBER_ERROR ) {
/* error */
} else {
/* success */
}

ber_memfree( dn );
ber_memvfree( attrs );

ERRORS
If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using
supplied deallocation routines.

SEE ALSO
lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_DECODE(3)
LBER_ENCODE(3)                                                                  Library Functions Manual                                                                  LBER_ENCODE(3)

NAME
ber_alloc_t,  ber_flush,  ber_flush2,  ber_printf,  ber_put_int,  ber_put_enum, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean, ber_put_bitstring, ber_start_seq,
ber_start_set, ber_put_seq, ber_put_set - OpenLDAP LBER simplified Basic Encoding Rules library routines for encoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

BerElement *ber_alloc_t(int options);

int ber_flush(Sockbuf *sb, BerElement *ber, int freeit);

int ber_flush2(Sockbuf *sb, BerElement *ber, int freeit);

int ber_printf(BerElement *ber, const char *fmt, ...);

int ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);

int ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);

int ber_put_ostring(BerElement *ber, const char *str, ber_len_t len, ber_tag_t tag);

int ber_put_string(BerElement *ber, const char *str, ber_tag_t tag);

int ber_put_null(BerElement *ber, ber_tag_t tag);

int ber_put_boolean(BerElement *ber, ber_int_t bool, ber_tag_t tag);

int ber_put_bitstring(BerElement *ber, const char *str, ber_len_t blen, ber_tag_t tag);

int ber_start_seq(BerElement *ber, ber_tag_t tag);

int ber_start_set(BerElement *ber, ber_tag_t tag);

int ber_put_seq(BerElement *ber);

int ber_put_set(BerElement *ber);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and
ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou‐
tines return the length of the element encoded, or -1 if an error occurred.

The ber_alloc_t() routine is used to allocate a new BER element.  It should be called with an argument of LBER_USE_DER.

The ber_flush2() routine is used to actually write the element to a socket (or file) descriptor, once it has been fully encoded (using ber_printf() and friends).  See lber-sock‐
buf(3) for more details on the Sockbuf implementation of the sb parameter.  If the freeit parameter is non-zero, the supplied ber will be freed.   If  LBER_FLUSH_FREE_ON_SUCCESS
is used, the ber is only freed when successfully flushed, otherwise it is left intact; if LBER_FLUSH_FREE_ON_ERROR is used, the ber is only freed when an error occurs, otherwise
it is left intact; if LBER_FLUSH_FREE_ALWAYS is used, the ber is freed anyway.  This function differs from the original ber_flush(3) function, whose behavior corresponds to that
indicated  for LBER_FLUSH_FREE_ON_SUCCESS.  Note that in the future, the behavior of ber_flush(3) with freeit non-zero might change into that of ber_flush2(3) with freeit set to
LBER_FLUSH_FREE_ALWAYS.

The ber_printf() routine is used to encode a BER element in much the same way that sprintf(3) works.  One important difference, though, is that some state  information  is  kept
with  the ber parameter so that multiple calls can be made to ber_printf() to append things to the end of the BER element.  Ber_printf() writes to ber, a pointer to a BerElement
such as returned by ber_alloc_t().  It interprets and formats its arguments according to the format string fmt.  The format string can contain the following characters:

b  Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.

e  Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.

i  Integer.  An ber_int_t parameter should be supplied.  An integer element is output.

B  Bitstring.  A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.  A bitstring element is output.

n  Null.  No parameter is required.  A null element is output.

o  Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.

O  Octet string.  A struct berval * is supplied.  An octet string element is output.

s  Octet string.  A null-terminated string is supplied.  An octet string element is output, not including the trailing NULL octet.

t  Tag.  A ber_tag_t specifying the tag to give the next element is provided.  This works across calls.

v  Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.

V  Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet
strings.

W  Several  octet  strings.  An array of struct berval's is supplied.  The array is terminated by a struct berval with a NULL bv_val.  Note that a construct like '{W}' is
required to get an actual SEQUENCE OF octet strings.

{  Begin sequence.  No parameter is required.

}  End sequence.  No parameter is required.

[  Begin set.  No parameter is required.

]  End set.  No parameter is required.

The ber_put_int() routine writes the integer element num to the BER element ber.

The ber_put_enum() routine writes the enumeration element num to the BER element ber.

The ber_put_boolean() routine writes the boolean value given by bool to the BER element.

The ber_put_bitstring() routine writes blen bits starting at str as a bitstring value to the given BER element.  Note that blen is the length in bits of the bitstring.

The ber_put_ostring() routine writes len bytes starting at str to the BER element as an octet string.

The ber_put_string() routine writes the null-terminated string (minus the terminating ' ') to the BER element as an octet string.

The ber_put_null() routine writes a NULL element to the BER element.

The ber_start_seq() routine is used to start a sequence in the BER element.  The ber_start_set() routine works similarly.  The end of the sequence or set is marked by the  near‐
est matching call to ber_put_seq() or ber_put_set(), respectively.

EXAMPLES
Assuming the following variable declarations, and that the variables have been assigned appropriately, an lber encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

can be achieved like so:

int rc;
ber_int_t    scope, ali, size, time, attrsonly;
char   *dn, **attrs;
BerElement *ber;

/* ... fill in values ... */

ber = ber_alloc_t( LBER_USE_DER );

if ( ber == NULL ) {
/* error */
}

rc = ber_printf( ber, "{siiiib{v}}", dn, scope, ali,
size, time, attrsonly, attrs );

if( rc == -1 ) {
/* error */
} else {
/* success */
}

ERRORS
If an error occurs during encoding, generally these routines return -1.

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.

SEE ALSO
lber-decode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_ENCODE(3)
LBER_TYPES(3)                                                                   Library Functions Manual                                                                   LBER_TYPES(3)

NAME
ber_int_t,  ber_uint_t,  ber_len_t,  ber_slen_t,  ber_tag_t,  struct  berval, BerValue, BerVarray, BerElement, ber_bvfree, ber_bvecfree, ber_bvecadd, ber_bvarray_free, ber_bvar‐
ray_add, ber_bvdup, ber_dupbv, ber_bvstr, ber_bvstrdup, ber_str2bv, ber_alloc_t, ber_init, ber_init2, ber_free - OpenLDAP LBER types and allocation functions

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

typedef impl_tag_t ber_tag_t;
typedef impl_int_t ber_int_t;
typedef impl_uint_t ber_uint_t;
typedef impl_len_t ber_len_t;
typedef impl_slen_t ber_slen_t;

typedef struct berval {
ber_len_t bv_len;
char *bv_val;
} BerValue, *BerVarray;

typedef struct berelement BerElement;

void ber_bvfree(struct berval *bv);

void ber_bvecfree(struct berval **bvec);

void ber_bvecadd(struct berval ***bvec, struct berval *bv);

void ber_bvarray_free(struct berval *bvarray);

void ber_bvarray_add(BerVarray *bvarray, BerValue *bv);

struct berval *ber_bvdup(const struct berval *bv);

struct berval *ber_dupbv(const struct berval *dst, struct berval *src);

struct berval *ber_bvstr(const char *str);

struct berval *ber_bvstrdup(const char *str);

struct berval *ber_str2bv(const char *str, ber_len_t len, int dup, struct berval *bv);

BerElement *ber_alloc_t(int options);

BerElement *ber_init(struct berval *bv);

void ber_init2(BerElement *ber, struct berval *bv, int options);

void ber_free(BerElement *ber, int freebuf);

DESCRIPTION
The following are the basic types and structures defined for use with the Lightweight BER library.

ber_int_t is a signed integer of at least 32 bits.  It is commonly equivalent to int.  ber_uint_t is the unsigned variant of ber_int_t.

ber_len_t is an unsigned integer of at least 32 bits used to represent a length.  It is commonly equivalent to a size_t.  ber_slen_t is the signed variant to ber_len_t.

ber_tag_t is an unsigned integer of at least 32 bits used to represent a BER tag.  It is commonly equivalent to a unsigned long.

The actual definitions of the integral impl_TYPE_t types are platform specific.

BerValue, commonly used as struct berval, is used to hold an arbitrary sequence of octets.  bv_val points to bv_len octets.  bv_val is  not  necessarily  terminated  by  a  NULL
(zero) octet.  ber_bvfree() frees a BerValue, pointed to by bv, returned from this API.  If bv is NULL, the routine does nothing.

ber_bvecfree() frees an array of BerValues (and the array), pointed to by bvec, returned from this API.  If bvec is NULL, the routine does nothing.  ber_bvecadd() appends the bv
pointer to the bvec array.  Space for the array is allocated as needed.  The end of the array is marked by a NULL pointer.

ber_bvarray_free() frees an array of BerValues (and the array), pointed to by bvarray, returned from this API.  If bvarray is NULL, the routine does nothing.   ber_bvarray_add()
appends the contents of the BerValue pointed to by bv to the bvarray array.  Space for the new element is allocated as needed.  The end of the array is marked by a BerValue with
a NULL bv_val field.

ber_bvdup() returns a copy of a BerValue.  The routine returns NULL upon error (e.g. out of memory).  The caller should use ber_bvfree() to deallocate  the  resulting  BerValue.
ber_dupbv()  copies  a  BerValue from src to dst.  If dst is NULL a new BerValue will be allocated to hold the copy.  The routine returns NULL upon error, otherwise it returns a
pointer to the copy.  If dst is NULL the caller should use ber_bvfree() to deallocate  the  resulting  BerValue,  otherwise  ber_memfree()  should  be  used  to  deallocate  the
dst-&amp;gt;bv_val.   (The  ber_bvdup()  function  is internally implemented as ber_dupbv(NULL, bv).  ber_bvdup() is provided only for compatibility with an expired draft of the LDAP C
API; ber_dupbv() is the preferred interface.)

ber_bvstr() returns a BerValue containing the string pointed to by str.  ber_bvstrdup() returns a BerValue containing a copy of the  string  pointed  to  by  str.   ber_str2bv()
returns  a  BerValue  containing the string pointed to by str, whose length may be optionally specified in len.  If dup is non-zero, the BerValue will contain a copy of str.  If
len is zero, the number of bytes to copy will be determined by strlen(3), otherwise len bytes will be copied.  If bv is  non-NULL,  the  result  will  be  stored  in  the  given
BerValue, otherwise a new BerValue will be allocated to store the result.  NOTE: Both ber_bvstr() and ber_bvstrdup() are implemented as macros using ber_str2bv() in this version
of the library.

BerElement is an opaque structure used to maintain state information used in encoding and  decoding.   ber_alloc_t()  is  used  to  create  an  empty  BerElement  structure.  If
LBER_USE_DER is specified for the options parameter then data lengths for data written to the BerElement will be encoded in the minimal number of octets required, otherwise they
will always be written as four byte values.  ber_init() creates a BerElement structure that is initialized with a copy of the data in its bv parameter.  ber_init2()  initializes
an  existing  BerElement ber using the data in the bv parameter. The data is referenced directly, not copied. The options parameter is the same as for ber_alloc_t().  ber_free()
frees a BerElement pointed to by ber.  If ber is NULL, the routine does nothing.  If freebuf is zero, the internal buffer is not freed.

SEE ALSO
lber-encode(3), lber-decode(3), lber-memory(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                          LBER_TYPES(3)
LBER_DECODE(3)                                                                  Library Functions Manual                                                                  LBER_DECODE(3)

NAME
ber_get_next, ber_skip_tag, ber_peek_tag, ber_scanf, ber_get_int, ber_get_enum, ber_get_stringb, ber_get_stringa, ber_get_stringal, ber_get_stringbv, ber_get_null, ber_get_bool‐
ean, ber_get_bitstring, ber_first_element, ber_next_element - OpenLDAP LBER simplified Basic Encoding Rules library routines for decoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

ber_tag_t ber_get_next(Sockbuf *sb, ber_len_t *len, BerElement *ber);

ber_tag_t ber_skip_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_peek_tag(BerElement *ber, ber_len_t *len);

ber_tag_t ber_scanf(BerElement *ber, const char *fmt, ...);

ber_tag_t ber_get_int(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_enum(BerElement *ber, ber_int_t *num);

ber_tag_t ber_get_stringb(BerElement *ber, char *buf, ber_len_t *len);

ber_tag_t ber_get_stringa(BerElement *ber, char **buf);

ber_tag_t ber_get_stringal(BerElement *ber, struct berval **bv);

ber_tag_t ber_get_stringbv(BerElement *ber, struct berval *bv, int alloc);

ber_tag_t ber_get_null(BerElement *ber);

ber_tag_t ber_get_boolean(BerElement *ber, ber_int_t *bool);

ber_tag_t ber_get_bitstringa(BerElement *ber, char **buf, ber_len_t *blen);

ber_tag_t ber_first_element(BerElement *ber, ber_len_t *len, char **cookie);

ber_tag_t ber_next_element(BerElement *ber, ber_len_t *len, const char *cookie);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the decoding routines in the lber library.  See lber-encode(3) for details on the corresponding  encoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines that need to be called by an application are ber_get_next() to get the next BER element and ber_scanf() to do the actual decoding.  In some cases,
ber_peek_tag() may also need to be called in normal usage.  The other routines are provided for those applications that need more control than ber_scanf() provides.  In general,
these routines return the tag of the element decoded, or LBER_ERROR if an error occurred.

The  ber_get_next() routine is used to read the next BER element from the given Sockbuf, sb.  It strips off and returns the leading tag, strips off and returns the length of the
entire element in len, and sets up ber for subsequent calls to ber_scanf() et al to decode the element. See lber-sockbuf(3) for details of the Sockbuf implementation of  the  sb
parameter.

The  ber_scanf()  routine  is  used  to  decode  a  BER  element  in  much  the  same  way that scanf(3) works.  It reads from ber, a pointer to a BerElement such as returned by
ber_get_next(), interprets the bytes according to the format string fmt, and stores the results in its additional arguments.  The format string  contains  conversion  specifica‐
tions which are used to direct the interpretation of the BER element.  The format string can contain the following characters.

a  Octet  string.   A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated, and returned in the parameter.  The
caller should free the returned string using ber_memfree().

A  Octet string.  A variant of "a".  A char ** should be supplied.  Memory is allocated, filled with the contents of the octet string, null-terminated,  and  returned  in
the parameter, unless a zero-length string would result; in that case, the arg is set to NULL.  The caller should free the returned string using ber_memfree().

s  Octet  string.  A char * buffer should be supplied, followed by a pointer to a ber_len_t initialized to the size of the buffer.  Upon return, the null-terminated octet
string is put into the buffer, and the ber_len_t is set to the actual size of the octet string.

O  Octet string.  A struct ber_val ** should be supplied, which upon return points to a dynamically allocated struct berval containing the octet string  and  its  length.
The caller should free the returned structure using ber_bvfree().

o  Octet  string.   A  struct  ber_val * should be supplied, which upon return contains the dynamically allocated octet string and its length.  The caller should free the
returned octet string using ber_memfree().

m  Octet string.  A struct ber_val * should be supplied, which upon return contains the octet string and its length.  The string resides in memory assigned to the BerEle‐
ment, and must not be freed by the caller.

b  Boolean.  A pointer to a ber_int_t should be supplied.

e  Enumeration.  A pointer to a ber_int_t should be supplied.

i  Integer.  A pointer to a ber_int_t should be supplied.

B  Bitstring.  A char ** should be supplied which will point to the dynamically allocated bits, followed by a ber_len_t *, which will point to the length (in bits) of the
bitstring returned.

n  Null.  No parameter is required.  The element is simply skipped if it is recognized.

v  Sequence of octet strings.  A char *** should be supplied, which upon return points to a dynamically allocated null-terminated array of char *'s containing  the  octet
strings.  NULL is returned if the sequence is empty.  The caller should free the returned array and octet strings using ber_memvfree().

V  Sequence  of  octet  strings with lengths.  A struct berval *** should be supplied, which upon return points to a dynamically allocated null-terminated array of struct
berval *'s containing the octet strings and their lengths.  NULL is returned if the  sequence  is  empty.   The  caller  should  free  the  returned  structures  using
ber_bvecfree().

W  Sequence  of octet strings with lengths.  A BerVarray * should be supplied, which upon return points to a dynamically allocated array of struct berval's containing the
octet strings and their lengths. The array is terminated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The  caller
should free the returned structures using ber_bvarray_free().

M  Sequence of octet strings with lengths.  This is a generalized form of the previous three formats.  A void ** (ptr) should be supplied, followed by a ber_len_t * (len)
and a ber_len_t (off).  Upon return (ptr) will point to a dynamically allocated array whose elements are all of size (*len).  A struct berval will be  filled  starting
at offset (off) in each element.  The strings in each struct berval reside in memory assigned to the BerElement and must not be freed by the caller.  The array is ter‐
minated by a struct berval with a NULL bv_val string pointer.  NULL is returned if the sequence is empty.  The number of elements in the array is also stored in (*len)
on return.  The caller should free the returned array using ber_memfree().

l  Length of the next element.  A pointer to a ber_len_t should be supplied.

t  Tag of the next element.  A pointer to a ber_tag_t should be supplied.

T  Skip element and return its tag.  A pointer to a ber_tag_t should be supplied.

x  Skip element.  The next element is skipped.

{  Begin sequence.  No parameter is required.  The initial sequence tag and length are skipped.

}  End sequence.  No parameter is required and no action is taken.

[  Begin set.  No parameter is required.  The initial set tag and length are skipped.

]  End set.  No parameter is required and no action is taken.

The  ber_get_int()  routine tries to interpret the next element as an integer, returning the result in num.  The tag of whatever it finds is returned on success, LBER_ERROR (-1)
on failure.

The ber_get_stringb() routine is used to read an octet string into a preallocated buffer.  The len parameter should be initialized to the size of the buffer,  and  will  contain
the length of the octet string read upon return.  The buffer should be big enough to take the octet string value plus a terminating NULL byte.

The ber_get_stringa() routine is used to dynamically allocate space into which an octet string is read.  The caller should free the returned string using ber_memfree().

The  ber_get_stringal() routine is used to dynamically allocate space into which an octet string and its length are read.  It takes a struct berval **, and returns the result in
this parameter.  The caller should free the returned structure using ber_bvfree().

The ber_get_stringbv() routine is used to read an octet string and its length into the provided struct berval *. If the alloc parameter is zero, the string will reside in memory
assigned  to  the BerElement, and must not be freed by the caller. If the alloc parameter is non-zero, the string will be copied into dynamically allocated space which should be
returned using ber_memfree().

The ber_get_null() routine is used to read a NULL element.  It returns the tag of the element it skips over.

The ber_get_boolean() routine is used to read a boolean value.  It is called the same way that ber_get_int() is called.

The ber_get_enum() routine is used to read a enumeration value.  It is called the same way that ber_get_int() is called.

The ber_get_bitstringa() routine is used to read a bitstring value.  It takes a char ** which will hold the dynamically allocated bits, followed by an ber_len_t  *,  which  will
point to the length (in bits) of the bitstring returned.  The caller should free the returned string using ber_memfree().

The  ber_first_element()  routine is used to return the tag and length of the first element in a set or sequence.  It also returns in cookie a magic cookie parameter that should
be passed to subsequent calls to ber_next_element(), which returns similar information.

EXAMPLES
Assume the variable ber contains a lightweight BER encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

The element can be decoded using ber_scanf() as follows.

ber_int_t    scope, deref, size, time, attrsonly;
char   *dn, **attrs;
ber_tag_t tag;

tag = ber_scanf( ber, "{aeeiib{v}}",
&amp;dn, &amp;scope, &amp;deref,
&amp;size, &amp;time, &amp;attrsonly, &amp;attrs );

if( tag == LBER_ERROR ) {
/* error */
} else {
/* success */
}

ber_memfree( dn );
ber_memvfree( attrs );

ERRORS
If an error occurs during decoding, generally these routines return LBER_ERROR ((ber_tag_t)-1).

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.  Some routines may dynamically allocate memory which must be freed  by  the  caller  using
supplied deallocation routines.

SEE ALSO
lber-encode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_DECODE(3)
LBER_ENCODE(3)                                                                  Library Functions Manual                                                                  LBER_ENCODE(3)

NAME
ber_alloc_t,  ber_flush,  ber_flush2,  ber_printf,  ber_put_int,  ber_put_enum, ber_put_ostring, ber_put_string, ber_put_null, ber_put_boolean, ber_put_bitstring, ber_start_seq,
ber_start_set, ber_put_seq, ber_put_set - OpenLDAP LBER simplified Basic Encoding Rules library routines for encoding

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

BerElement *ber_alloc_t(int options);

int ber_flush(Sockbuf *sb, BerElement *ber, int freeit);

int ber_flush2(Sockbuf *sb, BerElement *ber, int freeit);

int ber_printf(BerElement *ber, const char *fmt, ...);

int ber_put_int(BerElement *ber, ber_int_t num, ber_tag_t tag);

int ber_put_enum(BerElement *ber, ber_int_t num, ber_tag_t tag);

int ber_put_ostring(BerElement *ber, const char *str, ber_len_t len, ber_tag_t tag);

int ber_put_string(BerElement *ber, const char *str, ber_tag_t tag);

int ber_put_null(BerElement *ber, ber_tag_t tag);

int ber_put_boolean(BerElement *ber, ber_int_t bool, ber_tag_t tag);

int ber_put_bitstring(BerElement *ber, const char *str, ber_len_t blen, ber_tag_t tag);

int ber_start_seq(BerElement *ber, ber_tag_t tag);

int ber_start_set(BerElement *ber, ber_tag_t tag);

int ber_put_seq(BerElement *ber);

int ber_put_set(BerElement *ber);

DESCRIPTION
These routines provide a subroutine interface to a simplified implementation of the Basic Encoding Rules of ASN.1.  The version of BER these routines support is the one  defined
for the LDAP protocol.  The encoding rules are the same as BER, except that only definite form lengths are used, and bitstrings and octet strings are always encoded in primitive
form.  This man page describes the encoding routines in the lber library.  See lber-decode(3) for details on the corresponding  decoding  routines.   Consult  lber-types(3)  for
information about types, allocators, and deallocators.

Normally,  the  only  routines  that  need  to  be called by an application are ber_alloc_t() to allocate a BER element for encoding, ber_printf() to do the actual encoding, and
ber_flush2() to actually write the element.  The other routines are provided for those applications that need more control than ber_printf() provides.  In  general,  these  rou‐
tines return the length of the element encoded, or -1 if an error occurred.

The ber_alloc_t() routine is used to allocate a new BER element.  It should be called with an argument of LBER_USE_DER.

The ber_flush2() routine is used to actually write the element to a socket (or file) descriptor, once it has been fully encoded (using ber_printf() and friends).  See lber-sock‐
buf(3) for more details on the Sockbuf implementation of the sb parameter.  If the freeit parameter is non-zero, the supplied ber will be freed.   If  LBER_FLUSH_FREE_ON_SUCCESS
is used, the ber is only freed when successfully flushed, otherwise it is left intact; if LBER_FLUSH_FREE_ON_ERROR is used, the ber is only freed when an error occurs, otherwise
it is left intact; if LBER_FLUSH_FREE_ALWAYS is used, the ber is freed anyway.  This function differs from the original ber_flush(3) function, whose behavior corresponds to that
indicated  for LBER_FLUSH_FREE_ON_SUCCESS.  Note that in the future, the behavior of ber_flush(3) with freeit non-zero might change into that of ber_flush2(3) with freeit set to
LBER_FLUSH_FREE_ALWAYS.

The ber_printf() routine is used to encode a BER element in much the same way that sprintf(3) works.  One important difference, though, is that some state  information  is  kept
with  the ber parameter so that multiple calls can be made to ber_printf() to append things to the end of the BER element.  Ber_printf() writes to ber, a pointer to a BerElement
such as returned by ber_alloc_t().  It interprets and formats its arguments according to the format string fmt.  The format string can contain the following characters:

b  Boolean.  An ber_int_t parameter should be supplied.  A boolean element is output.

e  Enumeration.  An ber_int_t parameter should be supplied.  An enumeration element is output.

i  Integer.  An ber_int_t parameter should be supplied.  An integer element is output.

B  Bitstring.  A char * pointer to the start of the bitstring is supplied, followed by the number of bits in the bitstring.  A bitstring element is output.

n  Null.  No parameter is required.  A null element is output.

o  Octet string.  A char * is supplied, followed by the length of the string pointed to.  An octet string element is output.

O  Octet string.  A struct berval * is supplied.  An octet string element is output.

s  Octet string.  A null-terminated string is supplied.  An octet string element is output, not including the trailing NULL octet.

t  Tag.  A ber_tag_t specifying the tag to give the next element is provided.  This works across calls.

v  Several octet strings.  A null-terminated array of char *'s is supplied.  Note that a construct like '{v}' is required to get an actual SEQUENCE OF octet strings.

V  Several octet strings.  A null-terminated array of struct berval *'s is supplied.  Note that a construct like '{V}' is required to get  an  actual  SEQUENCE  OF  octet
strings.

W  Several  octet  strings.  An array of struct berval's is supplied.  The array is terminated by a struct berval with a NULL bv_val.  Note that a construct like '{W}' is
required to get an actual SEQUENCE OF octet strings.

{  Begin sequence.  No parameter is required.

}  End sequence.  No parameter is required.

[  Begin set.  No parameter is required.

]  End set.  No parameter is required.

The ber_put_int() routine writes the integer element num to the BER element ber.

The ber_put_enum() routine writes the enumeration element num to the BER element ber.

The ber_put_boolean() routine writes the boolean value given by bool to the BER element.

The ber_put_bitstring() routine writes blen bits starting at str as a bitstring value to the given BER element.  Note that blen is the length in bits of the bitstring.

The ber_put_ostring() routine writes len bytes starting at str to the BER element as an octet string.

The ber_put_string() routine writes the null-terminated string (minus the terminating ' ') to the BER element as an octet string.

The ber_put_null() routine writes a NULL element to the BER element.

The ber_start_seq() routine is used to start a sequence in the BER element.  The ber_start_set() routine works similarly.  The end of the sequence or set is marked by the  near‐
est matching call to ber_put_seq() or ber_put_set(), respectively.

EXAMPLES
Assuming the following variable declarations, and that the variables have been assigned appropriately, an lber encoding of the following ASN.1 object:

AlmostASearchRequest := SEQUENCE {
baseObject      DistinguishedName,
scope           ENUMERATED {
baseObject    (0),
singleLevel   (1),
wholeSubtree  (2)
},
derefAliases    ENUMERATED {
neverDerefaliases   (0),
derefInSearching    (1),
derefFindingBaseObj (2),
alwaysDerefAliases  (3)
},
sizelimit       INTEGER (0 .. 65535),
timelimit       INTEGER (0 .. 65535),
attrsOnly       BOOLEAN,
attributes      SEQUENCE OF AttributeType
}

can be achieved like so:

int rc;
ber_int_t    scope, ali, size, time, attrsonly;
char   *dn, **attrs;
BerElement *ber;

/* ... fill in values ... */

ber = ber_alloc_t( LBER_USE_DER );

if ( ber == NULL ) {
/* error */
}

rc = ber_printf( ber, "{siiiib{v}}", dn, scope, ali,
size, time, attrsonly, attrs );

if( rc == -1 ) {
/* error */
} else {
/* success */
}

ERRORS
If an error occurs during encoding, generally these routines return -1.

NOTES
The return values for all of these functions are declared in the &amp;lt;lber.h&amp;gt; header file.

SEE ALSO
lber-decode(3), lber-memory(3), lber-sockbuf(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_ENCODE(3)
LBER_MEMORY(3)                                                                  Library Functions Manual                                                                  LBER_MEMORY(3)

NAME
ber_memalloc, ber_memcalloc, ber_memrealloc, ber_memfree, ber_memvfree - OpenLDAP LBER memory allocators

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

void *ber_memalloc(ber_len_t bytes);

void *ber_memcalloc(ber_len_t nelems, ber_len_t bytes);

void *ber_memrealloc(void *ptr, ber_len_t bytes);

void ber_memfree(void *ptr);

void ber_memvfree(void **vec);

DESCRIPTION
These routines are used to allocate/deallocate memory used/returned by the Lightweight BER library as required by lber-encode(3) and lber-decode(3).  ber_memalloc(), ber_memcal‐
loc(), ber_memrealloc(), and ber_memfree() are used exactly like the standard malloc(3), calloc(3), realloc(3), and free(3) routines, respectively.  The  ber_memvfree()  routine
is used to free a dynamically allocated array of pointers to arbitrary dynamically allocated objects.

SEE ALSO
lber-decode(3), lber-encode(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LBER_MEMORY(3)
LBER_SOCKBUF(3)                                                                 Library Functions Manual                                                                 LBER_SOCKBUF(3)

NAME
ber_sockbuf_alloc, ber_sockbuf_free, ber_sockbuf_ctrl, ber_sockbuf_add_io, ber_sockbuf_remove_io, Sockbuf_IO - OpenLDAP LBER I/O infrastructure

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

Sockbuf *ber_sockbuf_alloc( void );

void ber_sockbuf_free(Sockbuf *sb);

int ber_sockbuf_ctrl(Sockbuf *sb, int opt, void *arg);

int ber_sockbuf_add_io(Sockbuf *sb, Sockbuf_IO *sbio, int layer, void *arg);

int ber_sockbuf_remove_io(Sockbuf *sb, Sockbuf_IO *sbio, int layer);

typedef struct sockbuf_io_desc {
int sbiod_level;
Sockbuf *sbiod_sb;
Sockbuf_IO *sbiod_io;
void *sbiod_pvt;
struct sockbuf_io_desc *sbiod_next;
} Sockbuf_IO_Desc;

typedef struct sockbuf_io {
int (*sbi_setup)(Sockbuf_IO_Desc *sbiod, void *arg);
int (*sbi_remove)(Sockbuf_IO_Desc *sbiod);
int (*sbi_ctrl)(Sockbuf_IO_Desc *sbiod, int opt, void *arg);
ber_slen_t (*sbi_read)(Sockbuf_IO_Desc *sbiod, void *buf, ber_len_t len);
ber_slen_t (*sbi_write)(Sockbuf_IO_Desc *sbiod, void *buf, ber_len_t len);
int (*sbi_close)(Sockbuf_IO_Desc *sbiod);
} Sockbuf_IO;

DESCRIPTION
These  routines  are  used  to manage the low level I/O operations performed by the Lightweight BER library. They are called implicitly by the other libraries and usually do not
need to be called directly from applications.  The I/O framework is modularized and new transport layers can be supported by appropriately defining a  Sockbuf_IO  structure  and
installing  it onto an existing Sockbuf.  Sockbuf structures are allocated and freed by ber_sockbuf_alloc() and ber_sockbuf_free(), respectively. The ber_sockbuf_ctrl() function
is used to get and set options related to a Sockbuf or to a specific I/O layer of the Sockbuf.  The ber_sockbuf_add_io() and ber_sockbuf_remove_io() functions are  used  to  add
and remove specific I/O layers on a Sockbuf.

Options for ber_sockbuf_ctrl() include:

LBER_SB_OPT_HAS_IO
Takes a Sockbuf_IO * argument and returns 1 if the given handler is installed on the Sockbuf, otherwise returns 0.

LBER_SB_OPT_GET_FD
Retrieves the file descriptor associated to the Sockbuf; arg must be a ber_socket_t *.  The return value will be 1 if a valid descriptor was present, -1 otherwise.

LBER_SB_OPT_SET_FD
Sets the file descriptor of the Sockbuf to the descriptor pointed to by arg; arg must be a ber_socket_t *.  The return value will always be 1.

LBER_SB_OPT_SET_NONBLOCK
Toggles the non-blocking state of the file descriptor associated to the Sockbuf.  arg should be NULL to disable and non-NULL to enable the non-blocking state.  The return
value will be 1 for success, -1 otherwise.

LBER_SB_OPT_DRAIN
Flush (read and discard) all available input on the Sockbuf.  The return value will be 1.

LBER_SB_OPT_NEEDS_READ
Returns non-zero if input is waiting to be read.

LBER_SB_OPT_NEEDS_WRITE
Returns non-zero if the Sockbuf is ready to be written.

LBER_SB_OPT_GET_MAX_INCOMING
Returns the maximum allowed size of an incoming message; arg must be a ber_len_t *.  The return value will be 1.

LBER_SB_OPT_SET_MAX_INCOMING
Sets the maximum allowed size of an incoming message; arg must be a ber_len_t *.  The return value will be 1.

Options not in this list will be passed down to each Sockbuf_IO handler in turn until one of them processes it. If the option is not handled ber_sockbuf_ctrl() will return 0.

Multiple Sockbuf_IO handlers can be stacked in multiple layers to provide various functionality.  Currently defined layers include

LBER_SBIOD_LEVEL_PROVIDER
the lowest layer, talking directly to a network

LBER_SBIOD_LEVEL_TRANSPORT
an intermediate layer

LBER_SBIOD_LEVEL_APPLICATION
a higher layer

Currently defined Sockbuf_IO handlers in liblber include

ber_sockbuf_io_tcp
The default stream-oriented provider

ber_sockbuf_io_fd
A stream-oriented provider for local IPC sockets

ber_sockbuf_io_dgram
A datagram-oriented provider. This handler is only present if the liblber library was built with LDAP_CONNECTIONLESS defined.

ber_sockbuf_io_readahead
A buffering layer, usually used with a datagram provider to hide the datagram semantics from upper layers.

ber_sockbuf_io_debug
A generic handler that outputs hex dumps of all traffic. This handler may be inserted multiple times at arbitrary layers to show the flow of data between other handlers.

Additional handlers may be present in libldap if support for them was enabled:

ldap_pvt_sockbuf_io_sasl
An application layer handler for SASL encoding/decoding.

sb_tls_sbio
A transport layer handler for SSL/TLS encoding/decoding. Note that this handler is private to the library and is not exposed in the API.

The provided handlers are all instantiated implicitly by libldap, and applications generally will not need to directly manipulate them.

SEE ALSO
lber-decode(3), lber-encode(3), lber-types(3), ldap_get_option(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                        LBER_SOCKBUF(3)
LBER_TYPES(3)                                                                   Library Functions Manual                                                                   LBER_TYPES(3)

NAME
ber_int_t,  ber_uint_t,  ber_len_t,  ber_slen_t,  ber_tag_t,  struct  berval, BerValue, BerVarray, BerElement, ber_bvfree, ber_bvecfree, ber_bvecadd, ber_bvarray_free, ber_bvar‐
ray_add, ber_bvdup, ber_dupbv, ber_bvstr, ber_bvstrdup, ber_str2bv, ber_alloc_t, ber_init, ber_init2, ber_free - OpenLDAP LBER types and allocation functions

LIBRARY
OpenLDAP LBER (liblber, -llber)

SYNOPSIS
#include &amp;lt;lber.h&amp;gt;

typedef impl_tag_t ber_tag_t;
typedef impl_int_t ber_int_t;
typedef impl_uint_t ber_uint_t;
typedef impl_len_t ber_len_t;
typedef impl_slen_t ber_slen_t;

typedef struct berval {
ber_len_t bv_len;
char *bv_val;
} BerValue, *BerVarray;

typedef struct berelement BerElement;

void ber_bvfree(struct berval *bv);

void ber_bvecfree(struct berval **bvec);

void ber_bvecadd(struct berval ***bvec, struct berval *bv);

void ber_bvarray_free(struct berval *bvarray);

void ber_bvarray_add(BerVarray *bvarray, BerValue *bv);

struct berval *ber_bvdup(const struct berval *bv);

struct berval *ber_dupbv(const struct berval *dst, struct berval *src);

struct berval *ber_bvstr(const char *str);

struct berval *ber_bvstrdup(const char *str);

struct berval *ber_str2bv(const char *str, ber_len_t len, int dup, struct berval *bv);

BerElement *ber_alloc_t(int options);

BerElement *ber_init(struct berval *bv);

void ber_init2(BerElement *ber, struct berval *bv, int options);

void ber_free(BerElement *ber, int freebuf);

DESCRIPTION
The following are the basic types and structures defined for use with the Lightweight BER library.

ber_int_t is a signed integer of at least 32 bits.  It is commonly equivalent to int.  ber_uint_t is the unsigned variant of ber_int_t.

ber_len_t is an unsigned integer of at least 32 bits used to represent a length.  It is commonly equivalent to a size_t.  ber_slen_t is the signed variant to ber_len_t.

ber_tag_t is an unsigned integer of at least 32 bits used to represent a BER tag.  It is commonly equivalent to a unsigned long.

The actual definitions of the integral impl_TYPE_t types are platform specific.

BerValue, commonly used as struct berval, is used to hold an arbitrary sequence of octets.  bv_val points to bv_len octets.  bv_val is  not  necessarily  terminated  by  a  NULL
(zero) octet.  ber_bvfree() frees a BerValue, pointed to by bv, returned from this API.  If bv is NULL, the routine does nothing.

ber_bvecfree() frees an array of BerValues (and the array), pointed to by bvec, returned from this API.  If bvec is NULL, the routine does nothing.  ber_bvecadd() appends the bv
pointer to the bvec array.  Space for the array is allocated as needed.  The end of the array is marked by a NULL pointer.

ber_bvarray_free() frees an array of BerValues (and the array), pointed to by bvarray, returned from this API.  If bvarray is NULL, the routine does nothing.   ber_bvarray_add()
appends the contents of the BerValue pointed to by bv to the bvarray array.  Space for the new element is allocated as needed.  The end of the array is marked by a BerValue with
a NULL bv_val field.

ber_bvdup() returns a copy of a BerValue.  The routine returns NULL upon error (e.g. out of memory).  The caller should use ber_bvfree() to deallocate  the  resulting  BerValue.
ber_dupbv()  copies  a  BerValue from src to dst.  If dst is NULL a new BerValue will be allocated to hold the copy.  The routine returns NULL upon error, otherwise it returns a
pointer to the copy.  If dst is NULL the caller should use ber_bvfree() to deallocate  the  resulting  BerValue,  otherwise  ber_memfree()  should  be  used  to  deallocate  the
dst-&amp;gt;bv_val.   (The  ber_bvdup()  function  is internally implemented as ber_dupbv(NULL, bv).  ber_bvdup() is provided only for compatibility with an expired draft of the LDAP C
API; ber_dupbv() is the preferred interface.)

ber_bvstr() returns a BerValue containing the string pointed to by str.  ber_bvstrdup() returns a BerValue containing a copy of the  string  pointed  to  by  str.   ber_str2bv()
returns  a  BerValue  containing the string pointed to by str, whose length may be optionally specified in len.  If dup is non-zero, the BerValue will contain a copy of str.  If
len is zero, the number of bytes to copy will be determined by strlen(3), otherwise len bytes will be copied.  If bv is  non-NULL,  the  result  will  be  stored  in  the  given
BerValue, otherwise a new BerValue will be allocated to store the result.  NOTE: Both ber_bvstr() and ber_bvstrdup() are implemented as macros using ber_str2bv() in this version
of the library.

BerElement is an opaque structure used to maintain state information used in encoding and  decoding.   ber_alloc_t()  is  used  to  create  an  empty  BerElement  structure.  If
LBER_USE_DER is specified for the options parameter then data lengths for data written to the BerElement will be encoded in the minimal number of octets required, otherwise they
will always be written as four byte values.  ber_init() creates a BerElement structure that is initialized with a copy of the data in its bv parameter.  ber_init2()  initializes
an  existing  BerElement ber using the data in the bv parameter. The data is referenced directly, not copied. The options parameter is the same as for ber_alloc_t().  ber_free()
frees a BerElement pointed to by ber.  If ber is NULL, the routine does nothing.  If freebuf is zero, the internal buffer is not freed.

SEE ALSO
lber-encode(3), lber-decode(3), lber-memory(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                          LBER_TYPES(3)
LDAP_ERROR(3)                                                                   Library Functions Manual                                                                   LDAP_ERROR(3)

NAME
ldap_perror, ld_errno, ldap_result2error, ldap_errlist, ldap_err2string - LDAP protocol error handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

char *ldap_err2string( int err );

DESCRIPTION
The  ldap_err2string()  routine  provides  short  description  of the various codes returned by routines in this library.  The returned string is a pointer to a static area that
should not be modified.

These codes are either negative, indicating an API error code; positive, indicating an LDAP resultCode other than 'success' (0), or - zero, indicating both successful use of the
API and the LDAP resultCode 'success' (0).

The   code  associated  with  an  LDAP  session  is  accessible  using  ldap_get_option(3)  and  ldap_set_option(3)  with  the  LDAP_OPT_RESULT_CODE  option  (previously  called
LDAP_OPT_ERROR_NUMBER).

PROTOCOL RESULT CODES
This section provides a partial list of protocol codes recognized by the library.  As LDAP is extensible, additional values may be returned.  A complete  listing  of  registered
LDAP result codes can be obtained from the Internet Assigned Numbers Authority &amp;lt;http://www.iana.org&amp;gt;.

LDAP_SUCCESS        The request was successful.

LDAP_OPERATIONS_ERROR
An operations error occurred.

LDAP_PROTOCOL_ERROR A protocol violation was detected.

LDAP_TIMELIMIT_EXCEEDED
An LDAP time limit was exceeded.

LDAP_SIZELIMIT_EXCEEDED
An LDAP size limit was exceeded.

LDAP_COMPARE_FALSE  A compare operation returned false.

LDAP_COMPARE_TRUE   A compare operation returned true.

LDAP_STRONG_AUTH_NOT_SUPPORTED
The LDAP server does not support strong authentication.

LDAP_STRONG_AUTH_REQUIRED
Strong authentication is required for the operation.

LDAP_PARTIAL_RESULTS
Partial results only returned.

LDAP_NO_SUCH_ATTRIBUTE
The attribute type specified does not exist in the entry.

LDAP_UNDEFINED_TYPE The attribute type specified is invalid.

LDAP_INAPPROPRIATE_MATCHING
Filter type not supported for the specified attribute.

LDAP_CONSTRAINT_VIOLATION
An attribute value specified violates some constraint (e.g., a postalAddress has too many lines, or a line that is too long).

LDAP_TYPE_OR_VALUE_EXISTS
An attribute type or attribute value specified already exists in the entry.

LDAP_INVALID_SYNTAX An invalid attribute value was specified.

LDAP_NO_SUCH_OBJECT The specified object does not exist in The Directory.

LDAP_ALIAS_PROBLEM  An alias in The Directory points to a nonexistent entry.

LDAP_INVALID_DN_SYNTAX
A syntactically invalid DN was specified.

LDAP_IS_LEAF        The object specified is a leaf.

LDAP_ALIAS_DEREF_PROBLEM
A problem was encountered when dereferencing an alias.

LDAP_INAPPROPRIATE_AUTH
Inappropriate authentication was specified (e.g., LDAP_AUTH_SIMPLE was specified and the entry does not have a userPassword attribute).

LDAP_INVALID_CREDENTIALS
Invalid credentials were presented (e.g., the wrong password).

LDAP_INSUFFICIENT_ACCESS
The user has insufficient access to perform the operation.

LDAP_BUSY           The DSA is busy.

LDAP_UNAVAILABLE    The DSA is unavailable.

LDAP_UNWILLING_TO_PERFORM
The DSA is unwilling to perform the operation.

LDAP_LOOP_DETECT    A loop was detected.

LDAP_NAMING_VIOLATION
A naming violation occurred.

LDAP_OBJECT_CLASS_VIOLATION
An object class violation occurred (e.g., a "must" attribute was missing from the entry).

LDAP_NOT_ALLOWED_ON_NONLEAF
The operation is not allowed on a nonleaf object.

LDAP_NOT_ALLOWED_ON_RDN
The operation is not allowed on an RDN.

LDAP_ALREADY_EXISTS The entry already exists.

LDAP_NO_OBJECT_CLASS_MODS
Object class modifications are not allowed.

LDAP_OTHER          An unknown error occurred.

API ERROR CODES
This  section  provides  a  complete list of API error codes recognized by the library.   Note that LDAP_SUCCESS indicates success of an API call in addition to representing the
return of the LDAP 'success' resultCode.

LDAP_SERVER_DOWN    The LDAP library can't contact the LDAP server.

LDAP_LOCAL_ERROR    Some local error occurred.  This is usually a failed dynamic memory allocation.

LDAP_ENCODING_ERROR An error was encountered encoding parameters to send to the LDAP server.

LDAP_DECODING_ERROR An error was encountered decoding a result from the LDAP server.

LDAP_TIMEOUT        A timelimit was exceeded while waiting for a result.

LDAP_AUTH_UNKNOWN   The authentication method specified to ldap_bind() is not known.

LDAP_FILTER_ERROR   An invalid filter was supplied to ldap_search() (e.g., unbalanced parentheses).

LDAP_PARAM_ERROR    An ldap routine was called with a bad parameter.

LDAP_NO_MEMORY      An memory allocation (e.g., malloc(3) or other dynamic memory allocator) call failed in an ldap library routine.

LDAP_USER_CANCELED  Indicates the user cancelled the operation.

LDAP_CONNECT_ERROR  Indicates a connection problem.

LDAP_NOT_SUPPORTED  Indicates the routine was called in a manner not supported by the library.

LDAP_CONTROL_NOT_FOUND
Indicates the control provided is unknown to the client library.

LDAP_NO_RESULTS_RETURNED
Indicates no results returned.

LDAP_MORE_RESULTS_TO_RETURN
Indicates more results could be returned.

LDAP_CLIENT_LOOP    Indicates the library has detected a loop in its processing.

LDAP_REFERRAL_LIMIT_EXCEEDED
Indicates the referral limit has been exceeded.

DEPRECATED
Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed
to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3),

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                          LDAP_ERROR(3)
ldap(n)                                                                                LDAP client                                                                               ldap(n)

________________________________________________________________________________________________________________________________________________________________________________________

NAME
ldap - LDAP client

SYNOPSIS
package require Tcl  8.4

package require ldap  ?1.8?

::ldap::connect host ?port?

::ldap::secure_connect host ?port?

::ldap::disconnect handle

::ldap::starttls handle ?cafile? ?certfile? ?keyfile?

::ldap::bind handle ?name? ?password?

::ldap::bindSASL handle ?name? ?password?

::ldap::unbind handle

::ldap::search handle baseObject filterString attributes options

::ldap::searchInit handle baseObject filterString attributes options

::ldap::searchNext handle

::ldap::searchEnd handle

::ldap::modify handle dn attrValToReplace ?attrToDelete? ?attrValToAdd?

::ldap::modifyMulti handle dn attrValToReplace ?attrValToDelete? ?attrValToAdd?

::ldap::add handle dn attrValueTuples

::ldap::addMulti handle dn attrValueTuples

::ldap::delete handle dn

::ldap::modifyDN handle dn newrdn ?deleteOld? ?newSuperior?

::ldap::info ip handle

::ldap::info bound handle

::ldap::info bounduser handle

::ldap::info connections

::ldap::info tls handle

::ldap::info saslmechanisms handle

::ldap::info control handle

::ldap::info extensions extensions

::ldap::info whoami handle

________________________________________________________________________________________________________________________________________________________________________________________

DESCRIPTION
The  ldap package provides a Tcl-only client library for the LDAPv3 protocol as specified in RFC 4511 (http://www.rfc-editor.org/rfc/rfc4511.txt).  It works by opening the stan‐
dard (or secure) LDAP socket on the server, and then providing a Tcl API to access the LDAP protocol commands.  All server errors are returned as Tcl errors (thrown) which  must
be caught with the Tcl catch command.

TLS SECURITY CONSIDERATIONS
This package uses the TLS package to handle the security for https urls and other socket connections.

Policy  decisions  like  the  set  of protocols to support and what ciphers to use are not the responsibility of TLS, nor of this package itself however.  Such decisions are the
responsibility of whichever application is using the package, and are likely influenced by the set of servers the application will talk to as well.

For example, in light of the recent POODLE attack [http://googleonlinesecurity.blogspot.co.uk/2014/10/this-poodle-bites-exploiting-ssl-30.html] discovered by Google many servers
will  disable  support  for  the SSLv3 protocol.  To handle this change the applications using TLS must be patched, and not this package, nor TLS itself.  Such a patch may be as
simple as generally activating tls1 support, as shown in the example below.

package require tls
tls::init -tls1 1 ;# forcibly activate support for the TLS1 protocol

... your own application code ...

COMMANDS
::ldap::connect host ?port?
Opens a LDAPv3 connection to the specified host, at the given port, and returns a token for the connection. This token is the handle argument for all other  commands.  If
no port is specified it will default to 389.

The command blocks until the connection has been established, or establishment definitely failed.

::ldap::secure_connect host ?port?
Like  ::ldap::connect, except that the created connection is secured by SSL. The port defaults to 636.  This command depends on the availability of the package TLS, which
is a SSL binding for Tcl. If TLS is not available, then this command will fail.

The command blocks until the connection has been established, or establishment definitely failed.

::ldap::disconnect handle
Closes the ldap connection refered to by the token handle. Returns the empty string as its result.

::ldap::starttls handle ?cafile? ?certfile? ?keyfile?
Start TLS negotiation on the connection denoted by handle.  This is currently experimental and subject to change, more control over  the  TLS  details  will  probably  be
exposed later, to allow users to fine tune the negotiation according to their security needs.

::ldap::bind handle ?name? ?password?
This  command  authenticates  the  ldap  connection  refered to by the token in handle, with a user name and associated password. It blocks until a response from the ldap
server arrives. Its result is the empty string.  Both name and passwd default to the empty string if they are not specified.  By leaving out name and passwd you can  make
an anonymous bind to the ldap server.  You can issue ::ldap::bind again to bind with different credentials.

::ldap::bindSASL handle ?name? ?password?
This  command  uses SASL authentication mechanisms to do a multistage bind.  Its otherwise identical to the standard ::ldap::bind.  This feature is currently experimental
and subject to change. See the documentation for the SASL and the "SASL.txt" in the tcllib CVS repository for details how to setup and use SASL with openldap.

::ldap::unbind handle
This command asks the ldap server to release the last bind done for the connection refered to by the token in handle.  The handle is invalid  after  the  unbind,  as  the
server closes the connection.  So this is effectivly just a more polite disconnect operation.

::ldap::search handle baseObject filterString attributes options
This  command  performs  a  LDAP search below the baseObject tree using a complex LDAP search expression filterString and returns the specified attributes of all matching
objects (DNs). If the list of attributes was empty all attributes are returned. The command blocks until it has received all results.  The valid options are identical  to
the options listed for ::ldap::searchInit.

An example of a search expression is

set filterString "|(cn=Linus*)(sn=Torvalds*)"

The  return  value of the command is a list of nested dictionaries. The first level keys are object identifiers (DNs), second levels keys are attribute names. In other words, it
is in the form

{dn1 {attr1 {val11 val12 ...} attr2 {val21...} ...}} {dn2 {a1 {v11 ...} ...}} ...

::ldap::searchInit handle baseObject filterString attributes options
This command initiates a LDAP search below the baseObject tree using a complex LDAP search expression filterString.  The search  gets  the  specified  attributes  of  all
matching  objects  (DNs).   The  command itself just starts the search, to retrieve the actual results, use ::ldap::searchNext.  A search can be terminated at any time by
::ldap::searchEnd. This informs the server that no further results should be sent by sending and ABANDON message and cleans up the internal state of the search.  Only one
::ldap::search  can  be  active at a given time, this includes the introspection commands ::ldap::info saslmechanisms, ldap::info control and ldap::info extensions, which
invoke a search internally.  Error responses from the server due to wrong arguments or similar things are returned with the first ::ldap::searchNext call  and  should  be
checked  and  dealed with there.  If the list of requested attributes is empty all attributes will be returned.  The parameter options specifies the options to be used in
the search, and has the following format:

{-option1 value1 -option2 value2 ... }

Following options are available:

-scope base one sub
Control the scope of the search to be one of base, one, or sub,  to  specify  a  base object,  one-level or  subtree  search.   The  default is sub.

-derefaliases never search find always
Control how aliases dereferencing is done.  Should be one of never, always, search,  or  find  to specify that aliases are never dereferenced, always dereferenced,
dereferenced when searching, or dereferenced only when locating the base object for the search.  The default is to never dereference aliases.

-sizelimit num
Determines the maximum number of entries to return in a search. If specified as 0 no limit is enforced. The server may enforce a configuration dependent sizelimit,
which may be lower than the one given by this option. The default is 0, no limit.

-timelimit seconds
Asks the server to use a timelimit of seconds for the search. Zero means no limit. The default is 0, no limit.

-attrsonly boolean
If set to 1 only the attribute names but not the values will be present in the search result.  The default is to retrieve attribute names and values.

-referencevar varname
If set the search result reference LDAPURIs, if any, are returned in the given variable.  The caller can than decide to follow those  references  and  query  other
LDAP servers for further results.

::ldap::searchNext handle
This  command  returns  the  next  entry from a LDAP search initiated by ::ldap::searchInit. It returns only after a new result is received or when no further results are
available, but takes care to keep the event loop alive.  The returned entry is a list with two elements: the first is the DN of the entry,  the  second  is  the  list  of
attributes and values, under the format:

dn {attr1 {val11 val12 ...} attr2 {val21...} ...}

The ::ldap::searchNext command returns an empty list at the end of the search.

::ldap::searchEnd handle
This  command  terminates a LDAP search initiated by ::ldap::searchInit. It also cleans up the internal state so a new search can be initiated.  If the client has not yet
received all results, the client sends an ABANDON message to inform the server that no further results for the previous search should to be sent.

::ldap::modify handle dn attrValToReplace ?attrToDelete? ?attrValToAdd?
This command modifies the object dn on the ldap server we are connected to via handle. It replaces attributes with new values, deletes attributes, and adds new attributes
with new values.  All arguments are dictionaries mapping attribute names to values. The optional arguments default to the empty dictionary, which means that no attributes
will be deleted nor added.

dictionary attrValToReplace (in)
No attributes will be changed if this argument is empty. The dictionary contains the new attributes and their values. They replace  all  attributes  known  to  the
object.

dictionary attrToDelete (in)
No  attributes  will  be deleted if this argument is empty. The dictionary values are restrictions on the deletion. An attribute listed here will be deleted if and
only if its current value at the server matches the value specified in the dictionary, or if the value in the dictionary is the empty string.

dictionary attrValToAdd (in)
No attributes will be added if this argument is empty. The dictionary values are the values for the new attributes.

The command blocks until all modifications have completed. Its result is the empty string.

::ldap::modifyMulti handle dn attrValToReplace ?attrValToDelete? ?attrValToAdd?
This command modifies the object dn on the ldap server we are connected to via handle. It replaces attributes with new values, deletes attributes, and adds new attributes
with new values.  All arguments are lists with the format:

attr1 {val11 val12 ...} attr2 {val21...} ...

where each value list may be empty for deleting all attributes.  The optional arguments default to empty lists of attributes to delete and to add.

list attrValToReplace (in)
No  attributes  will  be  changed  if this argument is empty. The dictionary contains the new attributes and their values. They replace all attributes known to the
object.

list attrValToDelete (in)
No attributes will be deleted if this argument is empty. If no value is specified, the whole set of values for an attribute will be deleted.

list attrValToAdd (in)
No attributes will be added if this argument is empty.

The command blocks until all modifications have completed. Its result is the empty string.

::ldap::add handle dn attrValueTuples
This command creates a new object using the specified dn. The attributes of the new object are  set  to  the  values  in  the  list  attrValueTuples.   Multiple  valuated
attributes may be specified using multiple tuples.  The command blocks until the operation has completed. Its result is the empty string.

::ldap::addMulti handle dn attrValueTuples
This  command is the preferred one to create a new object using the specified dn. The attributes of the new object are set to the values in the dictionary attrValueTuples
(which is keyed by the attribute names).  Each tuple is a list containing multiple values.  The command blocks until the operation has completed. Its result is the  empty
string.

::ldap::delete handle dn
This  command  removes  the object specified by dn, and all its attributes from the server.  The command blocks until the operation has completed. Its result is the empty
string.

::ldap::modifyDN handle dn newrdn ?deleteOld? ?newSuperior?
] This command moves or copies the object specified by dn to a new location in the tree of object. This location is specified by newrdn, a  relative  designation,  or  by
newrdn and newSuperior, a absolute designation.  The optional argument deleteOld defaults to true, i.e. a move operation. If deleteOld is not set, then the operation will
create a copy of dn in the new location.  The optional argument newSuperior defaults an empty string, meaning that the object must not be relocated in another  branch  of
the tree. If this argument is given, the argument deleteOld must be specified also.  The command blocks until the operation has completed. Its result is the empty string.

::ldap::info ip handle
This command returns the IP address of the remote LDAP server the handle is connected to.

::ldap::info bound handle
This command returns 1 if a handle has successfully completed a ::ldap::bind.  If no bind was done or it failed, a 0 is returned.

::ldap::info bounduser handle
This command returns the username used in the bind operation if a handle has successfully completed a ::ldap::bind.  If no bound was done or it failed, an empty string is
returned.

::ldap::info connections
This command returns all currently existing ldap connection handles.

::ldap::info tls handle
This command returns 1 if the ldap connection handle used TLS/SSL for connection via ldap::secure_connect or completed ldap::starttls, 0 otherwise.

::ldap::info saslmechanisms handle
Return the supported SASL mechanisms advertised by the server. Only valid in a bound state (anonymous or other).

::ldap::info control handle
Return the supported controls advertised by the server as a list of OIDs. Only valid in a bound state.  This is currently experimental and subject to change.

::ldap::info extensions extensions
Returns the supported LDAP extensions as list of OIDs. Only valid in a bound state.  This is currently experimental and subject to change.

::ldap::info whoami handle
Returns authzId for the current connection. This implements the RFC 4532 protocol extension.

EXAMPLES
A small example, extracted from the test application coming with this code.

package require ldap

# Connect, bind, add a new object, modify it in various ways

set handle [ldap::connect localhost 9009]

set dn "cn=Manager, o=University of Michigan, c=US"
set pw secret

ldap::bind $handle $dn $pw

set dn "cn=Test User,ou=People,o=University of Michigan,c=US"

ldap::add $handle $dn {
objectClass     OpenLDAPperson
cn              {Test User}
mail            test.user@google.com
uid             testuid
sn              User
telephoneNumber +31415926535
telephoneNumber +27182818285
}

set dn "cn=Another User,ou=People,o=University of Michigan,c=US"

ldap::addMulti $handle $dn {
objectClass     {OpenLDAPperson}
cn              {{Anotther User}}
mail            {test.user@google.com}
uid             {testuid}
sn              {User}
telephoneNumber {+31415926535 +27182818285}
}

# Replace all attributes
ldap::modify $handle $dn [list drink icetea uid JOLO]

# Add some more
ldap::modify $handle $dn {} {} [list drink water  drink orangeJuice pager "+1 313 555 7671"]

# Delete
ldap::modify $handle $dn {} [list drink water  pager ""]

# Move
ldap::modifyDN $handle $dn "cn=Tester"

# Kill the test object, and shut the connection down.
set dn "cn=Tester,ou=People,o=University of Michigan,c=US"
ldap::delete $handle $dn

ldap::unbind     $handle
ldap::disconnect $handle

And a another example, a simple query, and processing the results.

package require ldap
set handle [ldap::connect ldap.acme.com 389]
ldap::bind $handle
set results [ldap::search $handle "o=acme,dc=com" "(uid=jdoe)" {}]
foreach result $results {
foreach {object attributes} $result break

# The processing here is similar to what 'parray' does.
# I.e. finding the longest attribute name and then
# generating properly aligned output listing all attributes
# and their values.

set width 0
set sortedAttribs {}
foreach {type values} $attributes {
if {[string length $type] &amp;gt; $width} {
set width [string length $type]
}
lappend sortedAttribs [list $type $values]
}

puts "object='$object'"

foreach sortedAttrib  $sortedAttribs {
foreach {type values} $sortedAttrib break
foreach value $values {
regsub -all "\[\x01-\x1f\]" $value ? value
puts [format "  %-${width}s %s" $type $value]
}
}
puts ""
}
ldap::unbind $handle
ldap::disconnect $handle

BUGS, IDEAS, FEEDBACK
This document, and the package it  describes,  will  undoubtedly  contain  bugs  and  other  problems.   Please  report  such  in  the  category  ldap  of  the  Tcllib  Trackers
[http://core.tcl.tk/tcllib/reportlist].  Please also report any ideas for enhancements you may have for either package and/or documentation.

KEYWORDS
directory access, internet, ldap, ldap client, protocol, rfc 2251, rfc 4511, x.500

CATEGORY
Networking

COPYRIGHT
Copyright (c) 2004 Andreas Kupries &amp;lt;andreas_kupries@users.sourceforge.net&amp;gt;
Copyright (c) 2004 Jochen Loewer &amp;lt;loewerj@web.de&amp;gt;
Copyright (c) 2006 Michael Schlenker &amp;lt;mic42@users.sourceforge.net&amp;gt;

tcllib                                                                                    1.6.9                                                                                  ldap(n)
LDAP_ABANDON(3)                                                                 Library Functions Manual                                                                 LDAP_ABANDON(3)

NAME
ldap_abandon_ext - Abandon an LDAP operation in progress

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_abandon_ext(
LDAP *ld,
Bint msgid,
LDAPControl **sctrls,
LDAPControl **cctrls );

DESCRIPTION
The  ldap_abandon_ext() routine is used to send a LDAP Abandon request for an operation in progress.  The msgid passed should be the message id of an outstanding LDAP operation,
such as returned by ldap_search_ext(3).

ldap_abandon_ext() checks to see if the result of the operation has already come in.  If it has, it deletes it from the queue of pending messages.  If  not,  it  sends  an  LDAP
abandon request to the LDAP server.

The caller can expect that the result of an abandoned operation will not be returned from a future call to ldap_result(3).

ldap_abandon_ext() allows server and client controls to be passed in via the sctrls and cctrls parameters, respectively.

ldap_abandon_ext() returns a code indicating success or, in the case of failure, the nature of the failure.  See ldap_error(3) for details.

DEPRECATED INTERFACES
The ldap_abandon() routine is deprecated in favor of the ldap_abandon_ext() routine.

Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed
to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3), ldap_error(3), ldap_result(3), ldap_search_ext(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                        LDAP_ABANDON(3)
LDAP_ABANDON(3)                                                                 Library Functions Manual                                                                 LDAP_ABANDON(3)

NAME
ldap_abandon_ext - Abandon an LDAP operation in progress

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_abandon_ext(
LDAP *ld,
Bint msgid,
LDAPControl **sctrls,
LDAPControl **cctrls );

DESCRIPTION
The  ldap_abandon_ext() routine is used to send a LDAP Abandon request for an operation in progress.  The msgid passed should be the message id of an outstanding LDAP operation,
such as returned by ldap_search_ext(3).

ldap_abandon_ext() checks to see if the result of the operation has already come in.  If it has, it deletes it from the queue of pending messages.  If  not,  it  sends  an  LDAP
abandon request to the LDAP server.

The caller can expect that the result of an abandoned operation will not be returned from a future call to ldap_result(3).

ldap_abandon_ext() allows server and client controls to be passed in via the sctrls and cctrls parameters, respectively.

ldap_abandon_ext() returns a code indicating success or, in the case of failure, the nature of the failure.  See ldap_error(3) for details.

DEPRECATED INTERFACES
The ldap_abandon() routine is deprecated in favor of the ldap_abandon_ext() routine.

Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed
to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3), ldap_error(3), ldap_result(3), ldap_search_ext(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                        LDAP_ABANDON(3)
LDAP_ADD(3)                                                                     Library Functions Manual                                                                     LDAP_ADD(3)

NAME
ldap_add_ext, ldap_add_ext_s - Perform an LDAP add operation

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_add_ext(
LDAP *ld,
const char *dn,
LDAPMod **attrs,
LDAPControl **sctrls,
LDAPControl **cctrls,
int *msgidp );

int ldap_add_ext_s(
LDAP *ld,
const char *dn,
LDAPMod **attrs,
LDAPControl *sctrls,
LDAPControl *cctrls );

DESCRIPTION
The  ldap_add_ext_s()  routine  is used to perform an LDAP add operation.  It takes dn, the DN of the entry to add, and attrs, a null-terminated array of the entry's attributes.
The LDAPMod structure is used to represent attributes, with the mod_type and mod_values fields being used as described under ldap_modify_ext(3), and the ldap_op field being used
only if you need to specify the LDAP_MOD_BVALUES option. Otherwise, it should be set to zero.

Note  that  all  entries  except that specified by the last component in the given DN must already exist.  ldap_add_ext_s() returns an code indicating success or, in the case of
failure, indicating the nature of failure of the operation.  See ldap_error(3) for more details.

The ldap_add_ext() routine works just like ldap_add_ext_s(), but it is asynchronous.  It returns the message id of the request it initiated.  The result of this operation can be
obtained by calling ldap_result(3).

DEPRECATED INTERFACES
The ldap_add() and ldap_add_s() routines are deprecated in favor of the ldap_add_ext() and ldap_add_ext_s() routines, respectively.

Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed
to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3), ldap_error(3), ldap_modify(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                            LDAP_ADD(3)
LDAP_ADD(3)                                                                     Library Functions Manual                                                                     LDAP_ADD(3)

NAME
ldap_add_ext, ldap_add_ext_s - Perform an LDAP add operation

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_add_ext(
LDAP *ld,
const char *dn,
LDAPMod **attrs,
LDAPControl **sctrls,
LDAPControl **cctrls,
int *msgidp );

int ldap_add_ext_s(
LDAP *ld,
const char *dn,
LDAPMod **attrs,
LDAPControl *sctrls,
LDAPControl *cctrls );

DESCRIPTION
The  ldap_add_ext_s()  routine  is used to perform an LDAP add operation.  It takes dn, the DN of the entry to add, and attrs, a null-terminated array of the entry's attributes.
The LDAPMod structure is used to represent attributes, with the mod_type and mod_values fields being used as described under ldap_modify_ext(3), and the ldap_op field being used
only if you need to specify the LDAP_MOD_BVALUES option. Otherwise, it should be set to zero.

Note  that  all  entries  except that specified by the last component in the given DN must already exist.  ldap_add_ext_s() returns an code indicating success or, in the case of
failure, indicating the nature of failure of the operation.  See ldap_error(3) for more details.

The ldap_add_ext() routine works just like ldap_add_ext_s(), but it is asynchronous.  It returns the message id of the request it initiated.  The result of this operation can be
obtained by calling ldap_result(3).

DEPRECATED INTERFACES
The ldap_add() and ldap_add_s() routines are deprecated in favor of the ldap_add_ext() and ldap_add_ext_s() routines, respectively.

Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed
to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3), ldap_error(3), ldap_modify(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                            LDAP_ADD(3)
LDAP_ADD(3)                                                                     Library Functions Manual                                                                     LDAP_ADD(3)

NAME
ldap_add_ext, ldap_add_ext_s - Perform an LDAP add operation

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_add_ext(
LDAP *ld,
const char *dn,
LDAPMod **attrs,
LDAPControl **sctrls,
LDAPControl **cctrls,
int *msgidp );

int ldap_add_ext_s(
LDAP *ld,
const char *dn,
LDAPMod **attrs,
LDAPControl *sctrls,
LDAPControl *cctrls );

DESCRIPTION
The  ldap_add_ext_s()  routine  is used to perform an LDAP add operation.  It takes dn, the DN of the entry to add, and attrs, a null-terminated array of the entry's attributes.
The LDAPMod structure is used to represent attributes, with the mod_type and mod_values fields being used as described under ldap_modify_ext(3), and the ldap_op field being used
only if you need to specify the LDAP_MOD_BVALUES option. Otherwise, it should be set to zero.

Note  that  all  entries  except that specified by the last component in the given DN must already exist.  ldap_add_ext_s() returns an code indicating success or, in the case of
failure, indicating the nature of failure of the operation.  See ldap_error(3) for more details.

The ldap_add_ext() routine works just like ldap_add_ext_s(), but it is asynchronous.  It returns the message id of the request it initiated.  The result of this operation can be
obtained by calling ldap_result(3).

DEPRECATED INTERFACES
The ldap_add() and ldap_add_s() routines are deprecated in favor of the ldap_add_ext() and ldap_add_ext_s() routines, respectively.

Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed
to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3), ldap_error(3), ldap_modify(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                            LDAP_ADD(3)
LDAP_ADD(3)                                                                     Library Functions Manual                                                                     LDAP_ADD(3)

NAME
ldap_add_ext, ldap_add_ext_s - Perform an LDAP add operation

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_add_ext(
LDAP *ld,
const char *dn,
LDAPMod **attrs,
LDAPControl **sctrls,
LDAPControl **cctrls,
int *msgidp );

int ldap_add_ext_s(
LDAP *ld,
const char *dn,
LDAPMod **attrs,
LDAPControl *sctrls,
LDAPControl *cctrls );

DESCRIPTION
The  ldap_add_ext_s()  routine  is used to perform an LDAP add operation.  It takes dn, the DN of the entry to add, and attrs, a null-terminated array of the entry's attributes.
The LDAPMod structure is used to represent attributes, with the mod_type and mod_values fields being used as described under ldap_modify_ext(3), and the ldap_op field being used
only if you need to specify the LDAP_MOD_BVALUES option. Otherwise, it should be set to zero.

Note  that  all  entries  except that specified by the last component in the given DN must already exist.  ldap_add_ext_s() returns an code indicating success or, in the case of
failure, indicating the nature of failure of the operation.  See ldap_error(3) for more details.

The ldap_add_ext() routine works just like ldap_add_ext_s(), but it is asynchronous.  It returns the message id of the request it initiated.  The result of this operation can be
obtained by calling ldap_result(3).

DEPRECATED INTERFACES
The ldap_add() and ldap_add_s() routines are deprecated in favor of the ldap_add_ext() and ldap_add_ext_s() routines, respectively.

Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed
to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3), ldap_error(3), ldap_modify(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                            LDAP_ADD(3)
LDAP_SCHEMA(3)                                                                  Library Functions Manual                                                                  LDAP_SCHEMA(3)

NAME
ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,
ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object‐
class_free, ldap_scherr2str - Schema definition handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;
#include &amp;lt;ldap_schema.h&amp;gt;

LDAPSyntax * ldap_str2syntax(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_syntax2str(syn)
const LDAPSyntax * syn;

const char * ldap_syntax2name(syn)
LDAPSyntax * syn;

ldap_syntax_free(syn)
LDAPSyntax * syn;

LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_matchingrule2str(mr);
const LDAPMatchingRule * mr;

const char * ldap_matchingrule2name(mr)
LDAPMatchingRule * mr;

ldap_matchingrule_free(mr)
LDAPMatchingRule * mr;

LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_attributetype2str(at)
const LDAPAttributeType * at;

const char * ldap_attributetype2name(at)
LDAPAttributeType * at;

ldap_attributetype_free(at)
LDAPAttributeType * at;

LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_objectclass2str(oc)
const LDAPObjectClass * oc;

const char * ldap_objectclass2name(oc)
LDAPObjectClass * oc;

ldap_objectclass_free(oc)
LDAPObjectClass * oc;

char * ldap_scherr2str(code)
int code;

DESCRIPTION
These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:
syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.

ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate
kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,
the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter‐
minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a
bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:

LDAP_SCHEMA_ALLOW_NONE
strict parsing according to RFC 4512.

LDAP_SCHEMA_ALLOW_NO_OID
permit definitions that do not contain an initial OID.

LDAP_SCHEMA_ALLOW_QUOTED
permit quotes around some items that should not have them.

LDAP_SCHEMA_ALLOW_DESCR
permit a descr instead of a numeric OID in places where the syntax expect the latter.

LDAP_SCHEMA_ALLOW_DESCR_PREFIX
permit that the initial numeric OID contains a prefix in descr format.

LDAP_SCHEMA_ALLOW_ALL
be very liberal, include all options.

The structures returned are as follows:

typedef struct ldap_schema_extension_item {
char *lsei_name;        /* Extension name */
char **lsei_values;     /* Extension values */
} LDAPSchemaExtensionItem;

typedef struct ldap_syntax {
char *syn_oid;          /* OID */
char **syn_names;       /* Names */
char *syn_desc;         /* Description */
LDAPSchemaExtensionItem **syn_extensions; /* Extension */
} LDAPSyntax;

typedef struct ldap_matchingrule {
char *mr_oid;           /* OID */
char **mr_names;        /* Names */
char *mr_desc;          /* Description */
int  mr_obsolete;       /* Is obsolete? */
char *mr_syntax_oid;    /* Syntax of asserted values */
LDAPSchemaExtensionItem **mr_extensions; /* Extensions */
} LDAPMatchingRule;

typedef struct ldap_attributetype {
char *at_oid;           /* OID */
char **at_names;        /* Names */
char *at_desc;          /* Description */
int  at_obsolete;       /* Is obsolete? */
char *at_sup_oid;       /* OID of superior type */
char *at_equality_oid;  /* OID of equality matching rule */
char *at_ordering_oid;  /* OID of ordering matching rule */
char *at_substr_oid;    /* OID of substrings matching rule */
char *at_syntax_oid;    /* OID of syntax of values */
int  at_syntax_len;     /* Suggested minimum maximum length */
int  at_single_value;   /* Is single-valued?  */
int  at_collective;     /* Is collective? */
int  at_no_user_mod;    /* Are changes forbidden through LDAP? */
int  at_usage;          /* Usage, see below */
LDAPSchemaExtensionItem **at_extensions; /* Extensions */
} LDAPAttributeType;

typedef struct ldap_objectclass {
char *oc_oid;           /* OID */
char **oc_names;        /* Names */
char *oc_desc;          /* Description */
int  oc_obsolete;       /* Is obsolete? */
char **oc_sup_oids;     /* OIDs of superior classes */
int  oc_kind;           /* Kind, see below */
char **oc_at_oids_must; /* OIDs of required attribute types */
char **oc_at_oids_may;  /* OIDs of optional attribute types */
LDAPSchemaExtensionItem **oc_extensions; /* Extensions */
} LDAPObjectClass;

Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:

LDAP_SCHEMA_NO
The answer to the question is no.

LDAP_SCHEMA_YES
The answer to the question is yes.

For attribute types, the following usages are possible:

LDAP_SCHEMA_USER_APPLICATIONS
the attribute type is non-operational.

LDAP_SCHEMA_DIRECTORY_OPERATION
the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute
type.

LDAP_SCHEMA_DISTRIBUTED_OPERATION
the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.

LDAP_SCHEMA_DSA_OPERATION
the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different
servers that master the entry.

Object classes can be of three kinds:

LDAP_SCHEMA_ABSTRACT
the object class is abstract, i.e. there cannot be entries of this class alone.

LDAP_SCHEMA_STRUCTURAL
the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned
cannot be changed: none of those present can be removed and none other can be added.

LDAP_SCHEMA_AUXILIARY
the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added
or removed at the same time as needed by the set of object classes resulting from the operation.

Routines ldap_xxx2name() return a canonical name for the definition.

Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that
must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.

ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The
argument code comes from one of the parsing routines and can adopt the following values:

LDAP_SCHERR_OUTOFMEM
Out of memory.

LDAP_SCHERR_UNEXPTOKEN
Unexpected token.

LDAP_SCHERR_NOLEFTPAREN
Missing opening parenthesis.

LDAP_SCHERR_NORIGHTPAREN
Missing closing parenthesis.

LDAP_SCHERR_NODIGIT
Expecting digit.

LDAP_SCHERR_BADNAME
Expecting a name.

LDAP_SCHERR_BADDESC
Bad description.

LDAP_SCHERR_BADSUP
Bad superiors.

LDAP_SCHERR_DUPOPT
Duplicate option.

LDAP_SCHERR_EMPTY
Unexpected end of data.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_SCHEMA(3)
LDAP_SCHEMA(3)                                                                  Library Functions Manual                                                                  LDAP_SCHEMA(3)

NAME
ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,
ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object‐
class_free, ldap_scherr2str - Schema definition handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;
#include &amp;lt;ldap_schema.h&amp;gt;

LDAPSyntax * ldap_str2syntax(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_syntax2str(syn)
const LDAPSyntax * syn;

const char * ldap_syntax2name(syn)
LDAPSyntax * syn;

ldap_syntax_free(syn)
LDAPSyntax * syn;

LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_matchingrule2str(mr);
const LDAPMatchingRule * mr;

const char * ldap_matchingrule2name(mr)
LDAPMatchingRule * mr;

ldap_matchingrule_free(mr)
LDAPMatchingRule * mr;

LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_attributetype2str(at)
const LDAPAttributeType * at;

const char * ldap_attributetype2name(at)
LDAPAttributeType * at;

ldap_attributetype_free(at)
LDAPAttributeType * at;

LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_objectclass2str(oc)
const LDAPObjectClass * oc;

const char * ldap_objectclass2name(oc)
LDAPObjectClass * oc;

ldap_objectclass_free(oc)
LDAPObjectClass * oc;

char * ldap_scherr2str(code)
int code;

DESCRIPTION
These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:
syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.

ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate
kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,
the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter‐
minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a
bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:

LDAP_SCHEMA_ALLOW_NONE
strict parsing according to RFC 4512.

LDAP_SCHEMA_ALLOW_NO_OID
permit definitions that do not contain an initial OID.

LDAP_SCHEMA_ALLOW_QUOTED
permit quotes around some items that should not have them.

LDAP_SCHEMA_ALLOW_DESCR
permit a descr instead of a numeric OID in places where the syntax expect the latter.

LDAP_SCHEMA_ALLOW_DESCR_PREFIX
permit that the initial numeric OID contains a prefix in descr format.

LDAP_SCHEMA_ALLOW_ALL
be very liberal, include all options.

The structures returned are as follows:

typedef struct ldap_schema_extension_item {
char *lsei_name;        /* Extension name */
char **lsei_values;     /* Extension values */
} LDAPSchemaExtensionItem;

typedef struct ldap_syntax {
char *syn_oid;          /* OID */
char **syn_names;       /* Names */
char *syn_desc;         /* Description */
LDAPSchemaExtensionItem **syn_extensions; /* Extension */
} LDAPSyntax;

typedef struct ldap_matchingrule {
char *mr_oid;           /* OID */
char **mr_names;        /* Names */
char *mr_desc;          /* Description */
int  mr_obsolete;       /* Is obsolete? */
char *mr_syntax_oid;    /* Syntax of asserted values */
LDAPSchemaExtensionItem **mr_extensions; /* Extensions */
} LDAPMatchingRule;

typedef struct ldap_attributetype {
char *at_oid;           /* OID */
char **at_names;        /* Names */
char *at_desc;          /* Description */
int  at_obsolete;       /* Is obsolete? */
char *at_sup_oid;       /* OID of superior type */
char *at_equality_oid;  /* OID of equality matching rule */
char *at_ordering_oid;  /* OID of ordering matching rule */
char *at_substr_oid;    /* OID of substrings matching rule */
char *at_syntax_oid;    /* OID of syntax of values */
int  at_syntax_len;     /* Suggested minimum maximum length */
int  at_single_value;   /* Is single-valued?  */
int  at_collective;     /* Is collective? */
int  at_no_user_mod;    /* Are changes forbidden through LDAP? */
int  at_usage;          /* Usage, see below */
LDAPSchemaExtensionItem **at_extensions; /* Extensions */
} LDAPAttributeType;

typedef struct ldap_objectclass {
char *oc_oid;           /* OID */
char **oc_names;        /* Names */
char *oc_desc;          /* Description */
int  oc_obsolete;       /* Is obsolete? */
char **oc_sup_oids;     /* OIDs of superior classes */
int  oc_kind;           /* Kind, see below */
char **oc_at_oids_must; /* OIDs of required attribute types */
char **oc_at_oids_may;  /* OIDs of optional attribute types */
LDAPSchemaExtensionItem **oc_extensions; /* Extensions */
} LDAPObjectClass;

Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:

LDAP_SCHEMA_NO
The answer to the question is no.

LDAP_SCHEMA_YES
The answer to the question is yes.

For attribute types, the following usages are possible:

LDAP_SCHEMA_USER_APPLICATIONS
the attribute type is non-operational.

LDAP_SCHEMA_DIRECTORY_OPERATION
the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute
type.

LDAP_SCHEMA_DISTRIBUTED_OPERATION
the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.

LDAP_SCHEMA_DSA_OPERATION
the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different
servers that master the entry.

Object classes can be of three kinds:

LDAP_SCHEMA_ABSTRACT
the object class is abstract, i.e. there cannot be entries of this class alone.

LDAP_SCHEMA_STRUCTURAL
the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned
cannot be changed: none of those present can be removed and none other can be added.

LDAP_SCHEMA_AUXILIARY
the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added
or removed at the same time as needed by the set of object classes resulting from the operation.

Routines ldap_xxx2name() return a canonical name for the definition.

Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that
must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.

ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The
argument code comes from one of the parsing routines and can adopt the following values:

LDAP_SCHERR_OUTOFMEM
Out of memory.

LDAP_SCHERR_UNEXPTOKEN
Unexpected token.

LDAP_SCHERR_NOLEFTPAREN
Missing opening parenthesis.

LDAP_SCHERR_NORIGHTPAREN
Missing closing parenthesis.

LDAP_SCHERR_NODIGIT
Expecting digit.

LDAP_SCHERR_BADNAME
Expecting a name.

LDAP_SCHERR_BADDESC
Bad description.

LDAP_SCHERR_BADSUP
Bad superiors.

LDAP_SCHERR_DUPOPT
Duplicate option.

LDAP_SCHERR_EMPTY
Unexpected end of data.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_SCHEMA(3)
LDAP_SCHEMA(3)                                                                  Library Functions Manual                                                                  LDAP_SCHEMA(3)

NAME
ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,
ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object‐
class_free, ldap_scherr2str - Schema definition handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;
#include &amp;lt;ldap_schema.h&amp;gt;

LDAPSyntax * ldap_str2syntax(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_syntax2str(syn)
const LDAPSyntax * syn;

const char * ldap_syntax2name(syn)
LDAPSyntax * syn;

ldap_syntax_free(syn)
LDAPSyntax * syn;

LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_matchingrule2str(mr);
const LDAPMatchingRule * mr;

const char * ldap_matchingrule2name(mr)
LDAPMatchingRule * mr;

ldap_matchingrule_free(mr)
LDAPMatchingRule * mr;

LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_attributetype2str(at)
const LDAPAttributeType * at;

const char * ldap_attributetype2name(at)
LDAPAttributeType * at;

ldap_attributetype_free(at)
LDAPAttributeType * at;

LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_objectclass2str(oc)
const LDAPObjectClass * oc;

const char * ldap_objectclass2name(oc)
LDAPObjectClass * oc;

ldap_objectclass_free(oc)
LDAPObjectClass * oc;

char * ldap_scherr2str(code)
int code;

DESCRIPTION
These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:
syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.

ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate
kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,
the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter‐
minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a
bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:

LDAP_SCHEMA_ALLOW_NONE
strict parsing according to RFC 4512.

LDAP_SCHEMA_ALLOW_NO_OID
permit definitions that do not contain an initial OID.

LDAP_SCHEMA_ALLOW_QUOTED
permit quotes around some items that should not have them.

LDAP_SCHEMA_ALLOW_DESCR
permit a descr instead of a numeric OID in places where the syntax expect the latter.

LDAP_SCHEMA_ALLOW_DESCR_PREFIX
permit that the initial numeric OID contains a prefix in descr format.

LDAP_SCHEMA_ALLOW_ALL
be very liberal, include all options.

The structures returned are as follows:

typedef struct ldap_schema_extension_item {
char *lsei_name;        /* Extension name */
char **lsei_values;     /* Extension values */
} LDAPSchemaExtensionItem;

typedef struct ldap_syntax {
char *syn_oid;          /* OID */
char **syn_names;       /* Names */
char *syn_desc;         /* Description */
LDAPSchemaExtensionItem **syn_extensions; /* Extension */
} LDAPSyntax;

typedef struct ldap_matchingrule {
char *mr_oid;           /* OID */
char **mr_names;        /* Names */
char *mr_desc;          /* Description */
int  mr_obsolete;       /* Is obsolete? */
char *mr_syntax_oid;    /* Syntax of asserted values */
LDAPSchemaExtensionItem **mr_extensions; /* Extensions */
} LDAPMatchingRule;

typedef struct ldap_attributetype {
char *at_oid;           /* OID */
char **at_names;        /* Names */
char *at_desc;          /* Description */
int  at_obsolete;       /* Is obsolete? */
char *at_sup_oid;       /* OID of superior type */
char *at_equality_oid;  /* OID of equality matching rule */
char *at_ordering_oid;  /* OID of ordering matching rule */
char *at_substr_oid;    /* OID of substrings matching rule */
char *at_syntax_oid;    /* OID of syntax of values */
int  at_syntax_len;     /* Suggested minimum maximum length */
int  at_single_value;   /* Is single-valued?  */
int  at_collective;     /* Is collective? */
int  at_no_user_mod;    /* Are changes forbidden through LDAP? */
int  at_usage;          /* Usage, see below */
LDAPSchemaExtensionItem **at_extensions; /* Extensions */
} LDAPAttributeType;

typedef struct ldap_objectclass {
char *oc_oid;           /* OID */
char **oc_names;        /* Names */
char *oc_desc;          /* Description */
int  oc_obsolete;       /* Is obsolete? */
char **oc_sup_oids;     /* OIDs of superior classes */
int  oc_kind;           /* Kind, see below */
char **oc_at_oids_must; /* OIDs of required attribute types */
char **oc_at_oids_may;  /* OIDs of optional attribute types */
LDAPSchemaExtensionItem **oc_extensions; /* Extensions */
} LDAPObjectClass;

Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:

LDAP_SCHEMA_NO
The answer to the question is no.

LDAP_SCHEMA_YES
The answer to the question is yes.

For attribute types, the following usages are possible:

LDAP_SCHEMA_USER_APPLICATIONS
the attribute type is non-operational.

LDAP_SCHEMA_DIRECTORY_OPERATION
the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute
type.

LDAP_SCHEMA_DISTRIBUTED_OPERATION
the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.

LDAP_SCHEMA_DSA_OPERATION
the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different
servers that master the entry.

Object classes can be of three kinds:

LDAP_SCHEMA_ABSTRACT
the object class is abstract, i.e. there cannot be entries of this class alone.

LDAP_SCHEMA_STRUCTURAL
the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned
cannot be changed: none of those present can be removed and none other can be added.

LDAP_SCHEMA_AUXILIARY
the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added
or removed at the same time as needed by the set of object classes resulting from the operation.

Routines ldap_xxx2name() return a canonical name for the definition.

Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that
must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.

ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The
argument code comes from one of the parsing routines and can adopt the following values:

LDAP_SCHERR_OUTOFMEM
Out of memory.

LDAP_SCHERR_UNEXPTOKEN
Unexpected token.

LDAP_SCHERR_NOLEFTPAREN
Missing opening parenthesis.

LDAP_SCHERR_NORIGHTPAREN
Missing closing parenthesis.

LDAP_SCHERR_NODIGIT
Expecting digit.

LDAP_SCHERR_BADNAME
Expecting a name.

LDAP_SCHERR_BADDESC
Bad description.

LDAP_SCHERR_BADSUP
Bad superiors.

LDAP_SCHERR_DUPOPT
Duplicate option.

LDAP_SCHERR_EMPTY
Unexpected end of data.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_SCHEMA(3)
LDAP_BIND(3)                                                                    Library Functions Manual                                                                    LDAP_BIND(3)

NAME
ldap_bind,   ldap_bind_s,   ldap_simple_bind,  ldap_simple_bind_s,  ldap_sasl_bind,  ldap_sasl_bind_s,  ldap_sasl_interactive_bind_s,  ldap_parse_sasl_bind_result,  ldap_unbind,
ldap_unbind_s, ldap_unbind_ext, ldap_unbind_ext_s, ldap_set_rebind_proc - LDAP bind routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_bind(LDAP *ld, const char *who, const char *cred,
int method);

int ldap_bind_s(LDAP *ld, const char *who, const char *cred,
int method);

int ldap_simple_bind(LDAP *ld, const char *who, const char *passwd);

int ldap_simple_bind_s(LDAP *ld, const char *who, const char *passwd);

int ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,
struct berval *cred, LDAPControl *sctrls[],
LDAPControl *cctrls[], int *msgidp);

int ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,
struct berval *cred, LDAPControl *sctrls[],
LDAPControl *cctrls[], struct berval **servercredp);

int ldap_parse_sasl_bind_result(LDAP *ld, LDAPMessage *res,
struct berval **servercredp, int freeit);

int ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn,
const char *mechs,
LDAPControl *sctrls[], LDAPControl *cctrls[],
unsigned flags, LDAP_SASL_INTERACT_PROC *interact,
void *defaults);

int ldap_sasl_interactive_bind(LDAP *ld, const char *dn,
const char *mechs,
LDAPControl *sctrls[], LDAPControl *cctrls[],
unsigned flags, LDAP_SASL_INTERACT_PROC *interact,
void *defaults, LDAPMessage *result,
const char **rmechp, int *msgidp);

int (LDAP_SASL_INTERACT_PROC)(LDAP *ld, unsigned flags, void *defaults, void *sasl_interact);

int ldap_unbind(LDAP *ld);

int ldap_unbind_s(LDAP *ld);

int ldap_unbind_ext(LDAP *ld, LDAPControl *sctrls[],
LDAPControl *cctrls[]);

int ldap_unbind_ext_s(LDAP *ld, LDAPControl *sctrls[],
LDAPControl *cctrls[]);

int ldap_set_rebind_proc (LDAP *ld, LDAP_REBIND_PROC *ldap_proc, void *params);

int (LDAP_REBIND_PROC)(LDAP *ld, LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *params);

DESCRIPTION
These routines provide various interfaces to the LDAP bind operation.  After an association with an LDAP server is made using ldap_init(3), an LDAP bind operation should be per‐
formed  before  other operations are attempted over the connection.  An LDAP bind is required when using Version 2 of the LDAP protocol; it is optional for Version 3 but is usu‐
ally needed due to security considerations.

There are three types of bind calls, ones providing simple authentication, ones providing SASL authentication, and general routines  capable  of  doing  either  simple  or  SASL
authentication.

SASL  (Simple  Authentication and Security Layer) can negotiate one of many different kinds of authentication.  Both synchronous and asynchronous versions of each variant of the
bind call are provided.  All routines take ld as their first parameter, as returned from ldap_init(3).

SIMPLE AUTHENTICATION
The simplest form of the bind call is ldap_simple_bind_s().  It takes the DN to bind as in who, and the userPassword associated with the entry in passwd.   It  returns  an  LDAP
error  indication  (see ldap_error(3)).  The ldap_simple_bind() call is asynchronous, taking the same parameters but only initiating the bind operation and returning the message
id of the request it sent.  The result of the operation can be obtained by a subsequent call to ldap_result(3).

GENERAL AUTHENTICATION
The ldap_bind() and ldap_bind_s() routines can be used when the authentication method to use needs to be selected at runtime.  They both take an extra method parameter selecting
the  authentication  method  to  use.   It  should  be  set to LDAP_AUTH_SIMPLE to select simple authentication.  ldap_bind() returns the message id of the request it initiates.
ldap_bind_s() returns an LDAP error indication.

SASL AUTHENTICATION
For SASL binds the server always ignores any provided DN, so the dn parameter should always be NULL.  ldap_sasl_bind_s() sends a single SASL bind request  with  the  given  SASL
mechanism and credentials in the cred parameter. The format of the credentials depends on the particular SASL mechanism in use. For mechanisms that provide mutual authentication
the server's credentials will be returned in the servercredp parameter.  The routine returns an LDAP error indication (see ldap_error(3)).  The ldap_sasl_bind()  call  is  asyn‐
chronous,  taking  the  same parameters but only sending the request and returning the message id of the request it sent. The result of the operation can be obtained by a subse‐
quent call to ldap_result(3).  The result must be additionally parsed by ldap_parse_sasl_bind_result() to obtain any server credentials sent from the server.

Many SASL mechanisms require multiple message exchanges to perform a complete authentication. Applications should generally use ldap_sasl_interactive_bind_s() rather than  call‐
ing  the  basic ldap_sasl_bind() functions directly. The mechs parameter should contain a space-separated list of candidate mechanisms to use. If this parameter is NULL or empty
the library will query the supportedSASLMechanisms attribute from the server's rootDSE for the list of SASL mechanisms the server supports.  The  flags  parameter  controls  the
interaction used to retrieve any necessary SASL authentication parameters and should be one of:

LDAP_SASL_AUTOMATIC
use defaults if available, prompt otherwise

LDAP_SASL_INTERACTIVE
always prompt

LDAP_SASL_QUIET
never prompt

The  interact  function uses the provided defaults to handle requests from the SASL library for particular authentication parameters. There is no defined format for the defaults
information; it is up to the caller to use whatever format is appropriate for the supplied interact function.   The  sasl_interact  parameter  comes  from  the  underlying  SASL
library. When used with Cyrus SASL this is an array of sasl_interact_t structures. The Cyrus SASL library will prompt for a variety of inputs, including:

SASL_CB_GETREALM
the realm for the authentication attempt

SASL_CB_AUTHNAME
the username to authenticate

SASL_CB_PASS
the password for the provided username

SASL_CB_USER
the username to use for proxy authorization

SASL_CB_NOECHOPROMPT
generic prompt for input with input echoing disabled

SASL_CB_ECHOPROMPT
generic prompt for input with input echoing enabled

SASL_CB_LIST_END
indicates the end of the array of prompts

See the Cyrus SASL documentation for more details.

Applications  which need to manage connections asynchronously may use ldap_sasl_interactive_bind() instead of the synchronous version.  A valid mechs parameter must be supplied,
otherwise the library will be forced to query the server for a list of supported mechanisms, and this query will be performed synchronously.  The other parameters are  the  same
as  for  the  synchronous function, with three additional parameters.  The actual SASL mechanism that was used, and the message ID for use with ldap_result() will be returned in
rmechp and msgidp, respectively.  The value in rmechp must not be modified by the caller and must be passed back on each subsequent call. The message obtained from ldap_result()
must  be  passed  in the result parameter.  This parameter must be NULL when initiating a new Bind. The caller must free the result message after each call using ldap_msgfree().
The ldap_sasl_interactive_bind() function returns an LDAP result code. If the code is LDAP_SASL_BIND_IN_PROGRESS then the Bind is not complete yet, and  this  function  must  be
called again with the next result from the server.

REBINDING
The  ldap_set_rebind_proc function() sets the process to use for binding when an operation returns a referral. This function is used when an application needs to bind to another
server in order to follow a referral or search continuation reference.

The function takes ld, the rebind function, and the params, the arbitrary data like state information which the client might need to  properly  rebind.   The  LDAP_OPT_REFERRALS
option in the ld must be set to ON for the libraries to use the rebind function. Use the ldap_set_option function to set the value.

The rebind function parameters are as follows:

The ld parameter must be used by the application when binding to the referred server if the application wants the libraries to follow the referral.

The url parameter points to the URL referral string received from the LDAP server.  The LDAP application can use the ldap_url_parse(3) function to parse the string into its com‐
ponents.

The request parameter specifies the type of request that generated the referral.

The msgid parameter specifies the message ID of the request generating the referral.

The params parameter is the same value as passed originally to the ldap_set_rebind_proc() function.

The LDAP libraries set all the parameters when they call the rebind function. The application should not attempt to free either the ld or the url structures in the rebind  func‐
tion.

The  application  must  supply to the rebind function the required authentication information such as, user name, password, and certificates. The rebind function must use a syn‐
chronous bind method.

UNBINDING
The ldap_unbind() call is used to unbind from the directory, terminate the current association, and free the resources contained in the ld structure.  Once  it  is  called,  the
connection  to  the LDAP server is closed, and the ld structure is invalid.  The ldap_unbind_s() call is just another name for ldap_unbind(); both of these calls are synchronous
in nature.

The ldap_unbind_ext() and ldap_unbind_ext_s() allows the operations to specify  controls.

ERRORS
Asynchronous routines will return -1 in case of error, setting the ld_errno parameter of the ld structure.  Synchronous  routines  return  whatever  ld_errno  is  set  to.   See
ldap_error(3) for more information.

NOTES
If  an anonymous bind is sufficient for the application, the rebind process need not be provided. The LDAP libraries with the LDAP_OPT_REFERRALS option set to ON (default value)
will automatically follow referrals using an anonymous bind.

If the application needs stronger authentication than an anonymous bind, you need to provide a rebind process for that authentication method.  The bind method must  be  synchro‐
nous.

SEE ALSO
ldap(3), ldap_error(3), ldap_open(3), ldap_set_option(3), ldap_url_parse(3) RFC 4422 (http://www.rfc-editor.org), Cyrus SASL (http://asg.web.cmu.edu/sasl/)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                           LDAP_BIND(3)
LDAP_BIND(3)                                                                    Library Functions Manual                                                                    LDAP_BIND(3)

NAME
ldap_bind,   ldap_bind_s,   ldap_simple_bind,  ldap_simple_bind_s,  ldap_sasl_bind,  ldap_sasl_bind_s,  ldap_sasl_interactive_bind_s,  ldap_parse_sasl_bind_result,  ldap_unbind,
ldap_unbind_s, ldap_unbind_ext, ldap_unbind_ext_s, ldap_set_rebind_proc - LDAP bind routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_bind(LDAP *ld, const char *who, const char *cred,
int method);

int ldap_bind_s(LDAP *ld, const char *who, const char *cred,
int method);

int ldap_simple_bind(LDAP *ld, const char *who, const char *passwd);

int ldap_simple_bind_s(LDAP *ld, const char *who, const char *passwd);

int ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,
struct berval *cred, LDAPControl *sctrls[],
LDAPControl *cctrls[], int *msgidp);

int ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,
struct berval *cred, LDAPControl *sctrls[],
LDAPControl *cctrls[], struct berval **servercredp);

int ldap_parse_sasl_bind_result(LDAP *ld, LDAPMessage *res,
struct berval **servercredp, int freeit);

int ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn,
const char *mechs,
LDAPControl *sctrls[], LDAPControl *cctrls[],
unsigned flags, LDAP_SASL_INTERACT_PROC *interact,
void *defaults);

int ldap_sasl_interactive_bind(LDAP *ld, const char *dn,
const char *mechs,
LDAPControl *sctrls[], LDAPControl *cctrls[],
unsigned flags, LDAP_SASL_INTERACT_PROC *interact,
void *defaults, LDAPMessage *result,
const char **rmechp, int *msgidp);

int (LDAP_SASL_INTERACT_PROC)(LDAP *ld, unsigned flags, void *defaults, void *sasl_interact);

int ldap_unbind(LDAP *ld);

int ldap_unbind_s(LDAP *ld);

int ldap_unbind_ext(LDAP *ld, LDAPControl *sctrls[],
LDAPControl *cctrls[]);

int ldap_unbind_ext_s(LDAP *ld, LDAPControl *sctrls[],
LDAPControl *cctrls[]);

int ldap_set_rebind_proc (LDAP *ld, LDAP_REBIND_PROC *ldap_proc, void *params);

int (LDAP_REBIND_PROC)(LDAP *ld, LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *params);

DESCRIPTION
These routines provide various interfaces to the LDAP bind operation.  After an association with an LDAP server is made using ldap_init(3), an LDAP bind operation should be per‐
formed  before  other operations are attempted over the connection.  An LDAP bind is required when using Version 2 of the LDAP protocol; it is optional for Version 3 but is usu‐
ally needed due to security considerations.

There are three types of bind calls, ones providing simple authentication, ones providing SASL authentication, and general routines  capable  of  doing  either  simple  or  SASL
authentication.

SASL  (Simple  Authentication and Security Layer) can negotiate one of many different kinds of authentication.  Both synchronous and asynchronous versions of each variant of the
bind call are provided.  All routines take ld as their first parameter, as returned from ldap_init(3).

SIMPLE AUTHENTICATION
The simplest form of the bind call is ldap_simple_bind_s().  It takes the DN to bind as in who, and the userPassword associated with the entry in passwd.   It  returns  an  LDAP
error  indication  (see ldap_error(3)).  The ldap_simple_bind() call is asynchronous, taking the same parameters but only initiating the bind operation and returning the message
id of the request it sent.  The result of the operation can be obtained by a subsequent call to ldap_result(3).

GENERAL AUTHENTICATION
The ldap_bind() and ldap_bind_s() routines can be used when the authentication method to use needs to be selected at runtime.  They both take an extra method parameter selecting
the  authentication  method  to  use.   It  should  be  set to LDAP_AUTH_SIMPLE to select simple authentication.  ldap_bind() returns the message id of the request it initiates.
ldap_bind_s() returns an LDAP error indication.

SASL AUTHENTICATION
For SASL binds the server always ignores any provided DN, so the dn parameter should always be NULL.  ldap_sasl_bind_s() sends a single SASL bind request  with  the  given  SASL
mechanism and credentials in the cred parameter. The format of the credentials depends on the particular SASL mechanism in use. For mechanisms that provide mutual authentication
the server's credentials will be returned in the servercredp parameter.  The routine returns an LDAP error indication (see ldap_error(3)).  The ldap_sasl_bind()  call  is  asyn‐
chronous,  taking  the  same parameters but only sending the request and returning the message id of the request it sent. The result of the operation can be obtained by a subse‐
quent call to ldap_result(3).  The result must be additionally parsed by ldap_parse_sasl_bind_result() to obtain any server credentials sent from the server.

Many SASL mechanisms require multiple message exchanges to perform a complete authentication. Applications should generally use ldap_sasl_interactive_bind_s() rather than  call‐
ing  the  basic ldap_sasl_bind() functions directly. The mechs parameter should contain a space-separated list of candidate mechanisms to use. If this parameter is NULL or empty
the library will query the supportedSASLMechanisms attribute from the server's rootDSE for the list of SASL mechanisms the server supports.  The  flags  parameter  controls  the
interaction used to retrieve any necessary SASL authentication parameters and should be one of:

LDAP_SASL_AUTOMATIC
use defaults if available, prompt otherwise

LDAP_SASL_INTERACTIVE
always prompt

LDAP_SASL_QUIET
never prompt

The  interact  function uses the provided defaults to handle requests from the SASL library for particular authentication parameters. There is no defined format for the defaults
information; it is up to the caller to use whatever format is appropriate for the supplied interact function.   The  sasl_interact  parameter  comes  from  the  underlying  SASL
library. When used with Cyrus SASL this is an array of sasl_interact_t structures. The Cyrus SASL library will prompt for a variety of inputs, including:

SASL_CB_GETREALM
the realm for the authentication attempt

SASL_CB_AUTHNAME
the username to authenticate

SASL_CB_PASS
the password for the provided username

SASL_CB_USER
the username to use for proxy authorization

SASL_CB_NOECHOPROMPT
generic prompt for input with input echoing disabled

SASL_CB_ECHOPROMPT
generic prompt for input with input echoing enabled

SASL_CB_LIST_END
indicates the end of the array of prompts

See the Cyrus SASL documentation for more details.

Applications  which need to manage connections asynchronously may use ldap_sasl_interactive_bind() instead of the synchronous version.  A valid mechs parameter must be supplied,
otherwise the library will be forced to query the server for a list of supported mechanisms, and this query will be performed synchronously.  The other parameters are  the  same
as  for  the  synchronous function, with three additional parameters.  The actual SASL mechanism that was used, and the message ID for use with ldap_result() will be returned in
rmechp and msgidp, respectively.  The value in rmechp must not be modified by the caller and must be passed back on each subsequent call. The message obtained from ldap_result()
must  be  passed  in the result parameter.  This parameter must be NULL when initiating a new Bind. The caller must free the result message after each call using ldap_msgfree().
The ldap_sasl_interactive_bind() function returns an LDAP result code. If the code is LDAP_SASL_BIND_IN_PROGRESS then the Bind is not complete yet, and  this  function  must  be
called again with the next result from the server.

REBINDING
The  ldap_set_rebind_proc function() sets the process to use for binding when an operation returns a referral. This function is used when an application needs to bind to another
server in order to follow a referral or search continuation reference.

The function takes ld, the rebind function, and the params, the arbitrary data like state information which the client might need to  properly  rebind.   The  LDAP_OPT_REFERRALS
option in the ld must be set to ON for the libraries to use the rebind function. Use the ldap_set_option function to set the value.

The rebind function parameters are as follows:

The ld parameter must be used by the application when binding to the referred server if the application wants the libraries to follow the referral.

The url parameter points to the URL referral string received from the LDAP server.  The LDAP application can use the ldap_url_parse(3) function to parse the string into its com‐
ponents.

The request parameter specifies the type of request that generated the referral.

The msgid parameter specifies the message ID of the request generating the referral.

The params parameter is the same value as passed originally to the ldap_set_rebind_proc() function.

The LDAP libraries set all the parameters when they call the rebind function. The application should not attempt to free either the ld or the url structures in the rebind  func‐
tion.

The  application  must  supply to the rebind function the required authentication information such as, user name, password, and certificates. The rebind function must use a syn‐
chronous bind method.

UNBINDING
The ldap_unbind() call is used to unbind from the directory, terminate the current association, and free the resources contained in the ld structure.  Once  it  is  called,  the
connection  to  the LDAP server is closed, and the ld structure is invalid.  The ldap_unbind_s() call is just another name for ldap_unbind(); both of these calls are synchronous
in nature.

The ldap_unbind_ext() and ldap_unbind_ext_s() allows the operations to specify  controls.

ERRORS
Asynchronous routines will return -1 in case of error, setting the ld_errno parameter of the ld structure.  Synchronous  routines  return  whatever  ld_errno  is  set  to.   See
ldap_error(3) for more information.

NOTES
If  an anonymous bind is sufficient for the application, the rebind process need not be provided. The LDAP libraries with the LDAP_OPT_REFERRALS option set to ON (default value)
will automatically follow referrals using an anonymous bind.

If the application needs stronger authentication than an anonymous bind, you need to provide a rebind process for that authentication method.  The bind method must  be  synchro‐
nous.

SEE ALSO
ldap(3), ldap_error(3), ldap_open(3), ldap_set_option(3), ldap_url_parse(3) RFC 4422 (http://www.rfc-editor.org), Cyrus SASL (http://asg.web.cmu.edu/sasl/)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                           LDAP_BIND(3)
LDAP_COMPARE(3)                                                                 Library Functions Manual                                                                 LDAP_COMPARE(3)

NAME
ldap_compare, ldap_compare_s, ldap_compare_ext, ldap_compare_ext_s - Perform an LDAP compare operation.

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_compare_ext(
LDAP *ld,
char *dn,
char *attr,
const struct berval *bvalue,
LDAPControl **serverctrls,
LDAPControl **clientctrls,
int *msgidp );

int ldap_compare_ext_s(
LDAP *ld,
char *dn,
char *attr,
const struct berval *bvalue,
LDAPControl **serverctrls,
LDAPControl **clientctrls );

DESCRIPTION
The  ldap_compare_ext_s()  routine  is used to perform an LDAP compare operation synchronously.  It takes dn, the DN of the entry upon which to perform the compare, and attr and
value, the attribute description and value to compare to those found in the entry.  It returns a code, which will be LDAP_COMPARE_TRUE if the entry contains the attribute  value
and LDAP_COMPARE_FALSE if it does not.  Otherwise, an error code is returned that indicates the nature of the problem.  See ldap(3) for details.

The ldap_compare_ext() routine is used to perform an LDAP compare operation asynchronously.  It takes the same parameters as ldap_compare_ext_s(), but provides the message id of
the request it initiated in the integer pointed to msgidp.  The result of the compare can be obtained by a subsequent call to ldap_result(3).

Both routines allow server and client controls to be specified to extend the compare request.

DEPRECATED INTERFACES
The routines ldap_compare() and ldap_compare_s() are deprecated in favor of ldap_compare_ext() and ldap_compare_ext_s(), respectively.

Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed
to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                        LDAP_COMPARE(3)
LDAP_COMPARE(3)                                                                 Library Functions Manual                                                                 LDAP_COMPARE(3)

NAME
ldap_compare, ldap_compare_s, ldap_compare_ext, ldap_compare_ext_s - Perform an LDAP compare operation.

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_compare_ext(
LDAP *ld,
char *dn,
char *attr,
const struct berval *bvalue,
LDAPControl **serverctrls,
LDAPControl **clientctrls,
int *msgidp );

int ldap_compare_ext_s(
LDAP *ld,
char *dn,
char *attr,
const struct berval *bvalue,
LDAPControl **serverctrls,
LDAPControl **clientctrls );

DESCRIPTION
The  ldap_compare_ext_s()  routine  is used to perform an LDAP compare operation synchronously.  It takes dn, the DN of the entry upon which to perform the compare, and attr and
value, the attribute description and value to compare to those found in the entry.  It returns a code, which will be LDAP_COMPARE_TRUE if the entry contains the attribute  value
and LDAP_COMPARE_FALSE if it does not.  Otherwise, an error code is returned that indicates the nature of the problem.  See ldap(3) for details.

The ldap_compare_ext() routine is used to perform an LDAP compare operation asynchronously.  It takes the same parameters as ldap_compare_ext_s(), but provides the message id of
the request it initiated in the integer pointed to msgidp.  The result of the compare can be obtained by a subsequent call to ldap_result(3).

Both routines allow server and client controls to be specified to extend the compare request.

DEPRECATED INTERFACES
The routines ldap_compare() and ldap_compare_s() are deprecated in favor of ldap_compare_ext() and ldap_compare_ext_s(), respectively.

Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed
to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                        LDAP_COMPARE(3)
LDAP_COMPARE(3)                                                                 Library Functions Manual                                                                 LDAP_COMPARE(3)

NAME
ldap_compare, ldap_compare_s, ldap_compare_ext, ldap_compare_ext_s - Perform an LDAP compare operation.

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_compare_ext(
LDAP *ld,
char *dn,
char *attr,
const struct berval *bvalue,
LDAPControl **serverctrls,
LDAPControl **clientctrls,
int *msgidp );

int ldap_compare_ext_s(
LDAP *ld,
char *dn,
char *attr,
const struct berval *bvalue,
LDAPControl **serverctrls,
LDAPControl **clientctrls );

DESCRIPTION
The  ldap_compare_ext_s()  routine  is used to perform an LDAP compare operation synchronously.  It takes dn, the DN of the entry upon which to perform the compare, and attr and
value, the attribute description and value to compare to those found in the entry.  It returns a code, which will be LDAP_COMPARE_TRUE if the entry contains the attribute  value
and LDAP_COMPARE_FALSE if it does not.  Otherwise, an error code is returned that indicates the nature of the problem.  See ldap(3) for details.

The ldap_compare_ext() routine is used to perform an LDAP compare operation asynchronously.  It takes the same parameters as ldap_compare_ext_s(), but provides the message id of
the request it initiated in the integer pointed to msgidp.  The result of the compare can be obtained by a subsequent call to ldap_result(3).

Both routines allow server and client controls to be specified to extend the compare request.

DEPRECATED INTERFACES
The routines ldap_compare() and ldap_compare_s() are deprecated in favor of ldap_compare_ext() and ldap_compare_ext_s(), respectively.

Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed
to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                        LDAP_COMPARE(3)
LDAP_COMPARE(3)                                                                 Library Functions Manual                                                                 LDAP_COMPARE(3)

NAME
ldap_compare, ldap_compare_s, ldap_compare_ext, ldap_compare_ext_s - Perform an LDAP compare operation.

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_compare_ext(
LDAP *ld,
char *dn,
char *attr,
const struct berval *bvalue,
LDAPControl **serverctrls,
LDAPControl **clientctrls,
int *msgidp );

int ldap_compare_ext_s(
LDAP *ld,
char *dn,
char *attr,
const struct berval *bvalue,
LDAPControl **serverctrls,
LDAPControl **clientctrls );

DESCRIPTION
The  ldap_compare_ext_s()  routine  is used to perform an LDAP compare operation synchronously.  It takes dn, the DN of the entry upon which to perform the compare, and attr and
value, the attribute description and value to compare to those found in the entry.  It returns a code, which will be LDAP_COMPARE_TRUE if the entry contains the attribute  value
and LDAP_COMPARE_FALSE if it does not.  Otherwise, an error code is returned that indicates the nature of the problem.  See ldap(3) for details.

The ldap_compare_ext() routine is used to perform an LDAP compare operation asynchronously.  It takes the same parameters as ldap_compare_ext_s(), but provides the message id of
the request it initiated in the integer pointed to msgidp.  The result of the compare can be obtained by a subsequent call to ldap_result(3).

Both routines allow server and client controls to be specified to extend the compare request.

DEPRECATED INTERFACES
The routines ldap_compare() and ldap_compare_s() are deprecated in favor of ldap_compare_ext() and ldap_compare_ext_s(), respectively.

Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed
to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                        LDAP_COMPARE(3)
LDAP_CONTROLS(3)                                                                Library Functions Manual                                                                LDAP_CONTROLS(3)

NAME
ldap_control_create, ldap_control_find, ldap_control_dup, ldap_controls_dup, ldap_control_free, ldap_controls_free - LDAP control manipulation routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_control_create(const char *oid, int iscritical, struct berval *value, int dupval, LDAPControl **ctrlp);

LDAPControl *ldap_control_find( const char *oid, LDAPControl **ctrls, LDAPControl ***nextctrlp);

LDAPControl *ldap_control_dup(LDAPControl *ctrl);

LDAPControl **ldap_controls_dup(LDAPControl **ctrls);

void ldap_control_free(LDAPControl *ctrl);

void ldap_controls_free(LDAPControl **ctrls);

DESCRIPTION
These routines are used to manipulate structures used for LDAP controls.

ldap_control_create()  creates  a  control with the specified OID using the contents of the value parameter for the control value, if any.  The content of value is duplicated if
dupval is non-zero.  The iscritical parameter must be non-zero for a critical control. The created control is returned in the ctrlp parameter.  The routine returns  LDAP_SUCCESS
on  success  or  some  other error code on failure.  The content of value, for supported control types, can be prepared using helpers provided by this implementation of libldap,
usually in the form ldap_create_&amp;lt;control name&amp;gt;_control_value().  Otherwise, it can be BER-encoded using the functionalities of liblber.

ldap_control_find() searches the NULL-terminated ctrls array for a control whose OID matches the oid parameter.  The routine returns a pointer to the control if found, NULL oth‐
erwise.   If  the  parameter nextctrlp is not NULL, on return it will point to the next control in the array, and can be passed to the ldap_control_find() routine for subsequent
calls, to find further occurrences of the same control type.  The use of this function is discouraged; the recommended way of handling controls in responses  consists  in  going
through the array of controls, dealing with each of them in the returned order, since it could matter.

ldap_control_dup() duplicates an individual control structure, and ldap_controls_dup() duplicates a NULL-terminated array of controls.

ldap_control_free() frees an individual control structure, and ldap_controls_free() frees a NULL-terminated array of controls.

SEE ALSO
ldap(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                       LDAP_CONTROLS(3)
LDAP_CONTROLS(3)                                                                Library Functions Manual                                                                LDAP_CONTROLS(3)

NAME
ldap_control_create, ldap_control_find, ldap_control_dup, ldap_controls_dup, ldap_control_free, ldap_controls_free - LDAP control manipulation routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_control_create(const char *oid, int iscritical, struct berval *value, int dupval, LDAPControl **ctrlp);

LDAPControl *ldap_control_find( const char *oid, LDAPControl **ctrls, LDAPControl ***nextctrlp);

LDAPControl *ldap_control_dup(LDAPControl *ctrl);

LDAPControl **ldap_controls_dup(LDAPControl **ctrls);

void ldap_control_free(LDAPControl *ctrl);

void ldap_controls_free(LDAPControl **ctrls);

DESCRIPTION
These routines are used to manipulate structures used for LDAP controls.

ldap_control_create()  creates  a  control with the specified OID using the contents of the value parameter for the control value, if any.  The content of value is duplicated if
dupval is non-zero.  The iscritical parameter must be non-zero for a critical control. The created control is returned in the ctrlp parameter.  The routine returns  LDAP_SUCCESS
on  success  or  some  other error code on failure.  The content of value, for supported control types, can be prepared using helpers provided by this implementation of libldap,
usually in the form ldap_create_&amp;lt;control name&amp;gt;_control_value().  Otherwise, it can be BER-encoded using the functionalities of liblber.

ldap_control_find() searches the NULL-terminated ctrls array for a control whose OID matches the oid parameter.  The routine returns a pointer to the control if found, NULL oth‐
erwise.   If  the  parameter nextctrlp is not NULL, on return it will point to the next control in the array, and can be passed to the ldap_control_find() routine for subsequent
calls, to find further occurrences of the same control type.  The use of this function is discouraged; the recommended way of handling controls in responses  consists  in  going
through the array of controls, dealing with each of them in the returned order, since it could matter.

ldap_control_dup() duplicates an individual control structure, and ldap_controls_dup() duplicates a NULL-terminated array of controls.

ldap_control_free() frees an individual control structure, and ldap_controls_free() frees a NULL-terminated array of controls.

SEE ALSO
ldap(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                       LDAP_CONTROLS(3)
LDAP_CONTROLS(3)                                                                Library Functions Manual                                                                LDAP_CONTROLS(3)

NAME
ldap_control_create, ldap_control_find, ldap_control_dup, ldap_controls_dup, ldap_control_free, ldap_controls_free - LDAP control manipulation routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_control_create(const char *oid, int iscritical, struct berval *value, int dupval, LDAPControl **ctrlp);

LDAPControl *ldap_control_find( const char *oid, LDAPControl **ctrls, LDAPControl ***nextctrlp);

LDAPControl *ldap_control_dup(LDAPControl *ctrl);

LDAPControl **ldap_controls_dup(LDAPControl **ctrls);

void ldap_control_free(LDAPControl *ctrl);

void ldap_controls_free(LDAPControl **ctrls);

DESCRIPTION
These routines are used to manipulate structures used for LDAP controls.

ldap_control_create()  creates  a  control with the specified OID using the contents of the value parameter for the control value, if any.  The content of value is duplicated if
dupval is non-zero.  The iscritical parameter must be non-zero for a critical control. The created control is returned in the ctrlp parameter.  The routine returns  LDAP_SUCCESS
on  success  or  some  other error code on failure.  The content of value, for supported control types, can be prepared using helpers provided by this implementation of libldap,
usually in the form ldap_create_&amp;lt;control name&amp;gt;_control_value().  Otherwise, it can be BER-encoded using the functionalities of liblber.

ldap_control_find() searches the NULL-terminated ctrls array for a control whose OID matches the oid parameter.  The routine returns a pointer to the control if found, NULL oth‐
erwise.   If  the  parameter nextctrlp is not NULL, on return it will point to the next control in the array, and can be passed to the ldap_control_find() routine for subsequent
calls, to find further occurrences of the same control type.  The use of this function is discouraged; the recommended way of handling controls in responses  consists  in  going
through the array of controls, dealing with each of them in the returned order, since it could matter.

ldap_control_dup() duplicates an individual control structure, and ldap_controls_dup() duplicates a NULL-terminated array of controls.

ldap_control_free() frees an individual control structure, and ldap_controls_free() frees a NULL-terminated array of controls.

SEE ALSO
ldap(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                       LDAP_CONTROLS(3)
LDAP_CONTROLS(3)                                                                Library Functions Manual                                                                LDAP_CONTROLS(3)

NAME
ldap_control_create, ldap_control_find, ldap_control_dup, ldap_controls_dup, ldap_control_free, ldap_controls_free - LDAP control manipulation routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_control_create(const char *oid, int iscritical, struct berval *value, int dupval, LDAPControl **ctrlp);

LDAPControl *ldap_control_find( const char *oid, LDAPControl **ctrls, LDAPControl ***nextctrlp);

LDAPControl *ldap_control_dup(LDAPControl *ctrl);

LDAPControl **ldap_controls_dup(LDAPControl **ctrls);

void ldap_control_free(LDAPControl *ctrl);

void ldap_controls_free(LDAPControl **ctrls);

DESCRIPTION
These routines are used to manipulate structures used for LDAP controls.

ldap_control_create()  creates  a  control with the specified OID using the contents of the value parameter for the control value, if any.  The content of value is duplicated if
dupval is non-zero.  The iscritical parameter must be non-zero for a critical control. The created control is returned in the ctrlp parameter.  The routine returns  LDAP_SUCCESS
on  success  or  some  other error code on failure.  The content of value, for supported control types, can be prepared using helpers provided by this implementation of libldap,
usually in the form ldap_create_&amp;lt;control name&amp;gt;_control_value().  Otherwise, it can be BER-encoded using the functionalities of liblber.

ldap_control_find() searches the NULL-terminated ctrls array for a control whose OID matches the oid parameter.  The routine returns a pointer to the control if found, NULL oth‐
erwise.   If  the  parameter nextctrlp is not NULL, on return it will point to the next control in the array, and can be passed to the ldap_control_find() routine for subsequent
calls, to find further occurrences of the same control type.  The use of this function is discouraged; the recommended way of handling controls in responses  consists  in  going
through the array of controls, dealing with each of them in the returned order, since it could matter.

ldap_control_dup() duplicates an individual control structure, and ldap_controls_dup() duplicates a NULL-terminated array of controls.

ldap_control_free() frees an individual control structure, and ldap_controls_free() frees a NULL-terminated array of controls.

SEE ALSO
ldap(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                       LDAP_CONTROLS(3)
LDAP_CONTROLS(3)                                                                Library Functions Manual                                                                LDAP_CONTROLS(3)

NAME
ldap_control_create, ldap_control_find, ldap_control_dup, ldap_controls_dup, ldap_control_free, ldap_controls_free - LDAP control manipulation routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_control_create(const char *oid, int iscritical, struct berval *value, int dupval, LDAPControl **ctrlp);

LDAPControl *ldap_control_find( const char *oid, LDAPControl **ctrls, LDAPControl ***nextctrlp);

LDAPControl *ldap_control_dup(LDAPControl *ctrl);

LDAPControl **ldap_controls_dup(LDAPControl **ctrls);

void ldap_control_free(LDAPControl *ctrl);

void ldap_controls_free(LDAPControl **ctrls);

DESCRIPTION
These routines are used to manipulate structures used for LDAP controls.

ldap_control_create()  creates  a  control with the specified OID using the contents of the value parameter for the control value, if any.  The content of value is duplicated if
dupval is non-zero.  The iscritical parameter must be non-zero for a critical control. The created control is returned in the ctrlp parameter.  The routine returns  LDAP_SUCCESS
on  success  or  some  other error code on failure.  The content of value, for supported control types, can be prepared using helpers provided by this implementation of libldap,
usually in the form ldap_create_&amp;lt;control name&amp;gt;_control_value().  Otherwise, it can be BER-encoded using the functionalities of liblber.

ldap_control_find() searches the NULL-terminated ctrls array for a control whose OID matches the oid parameter.  The routine returns a pointer to the control if found, NULL oth‐
erwise.   If  the  parameter nextctrlp is not NULL, on return it will point to the next control in the array, and can be passed to the ldap_control_find() routine for subsequent
calls, to find further occurrences of the same control type.  The use of this function is discouraged; the recommended way of handling controls in responses  consists  in  going
through the array of controls, dealing with each of them in the returned order, since it could matter.

ldap_control_dup() duplicates an individual control structure, and ldap_controls_dup() duplicates a NULL-terminated array of controls.

ldap_control_free() frees an individual control structure, and ldap_controls_free() frees a NULL-terminated array of controls.

SEE ALSO
ldap(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                       LDAP_CONTROLS(3)
LDAP_CONTROLS(3)                                                                Library Functions Manual                                                                LDAP_CONTROLS(3)

NAME
ldap_control_create, ldap_control_find, ldap_control_dup, ldap_controls_dup, ldap_control_free, ldap_controls_free - LDAP control manipulation routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_control_create(const char *oid, int iscritical, struct berval *value, int dupval, LDAPControl **ctrlp);

LDAPControl *ldap_control_find( const char *oid, LDAPControl **ctrls, LDAPControl ***nextctrlp);

LDAPControl *ldap_control_dup(LDAPControl *ctrl);

LDAPControl **ldap_controls_dup(LDAPControl **ctrls);

void ldap_control_free(LDAPControl *ctrl);

void ldap_controls_free(LDAPControl **ctrls);

DESCRIPTION
These routines are used to manipulate structures used for LDAP controls.

ldap_control_create()  creates  a  control with the specified OID using the contents of the value parameter for the control value, if any.  The content of value is duplicated if
dupval is non-zero.  The iscritical parameter must be non-zero for a critical control. The created control is returned in the ctrlp parameter.  The routine returns  LDAP_SUCCESS
on  success  or  some  other error code on failure.  The content of value, for supported control types, can be prepared using helpers provided by this implementation of libldap,
usually in the form ldap_create_&amp;lt;control name&amp;gt;_control_value().  Otherwise, it can be BER-encoded using the functionalities of liblber.

ldap_control_find() searches the NULL-terminated ctrls array for a control whose OID matches the oid parameter.  The routine returns a pointer to the control if found, NULL oth‐
erwise.   If  the  parameter nextctrlp is not NULL, on return it will point to the next control in the array, and can be passed to the ldap_control_find() routine for subsequent
calls, to find further occurrences of the same control type.  The use of this function is discouraged; the recommended way of handling controls in responses  consists  in  going
through the array of controls, dealing with each of them in the returned order, since it could matter.

ldap_control_dup() duplicates an individual control structure, and ldap_controls_dup() duplicates a NULL-terminated array of controls.

ldap_control_free() frees an individual control structure, and ldap_controls_free() frees a NULL-terminated array of controls.

SEE ALSO
ldap(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                       LDAP_CONTROLS(3)
LDAP_CONTROLS(3)                                                                Library Functions Manual                                                                LDAP_CONTROLS(3)

NAME
ldap_control_create, ldap_control_find, ldap_control_dup, ldap_controls_dup, ldap_control_free, ldap_controls_free - LDAP control manipulation routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_control_create(const char *oid, int iscritical, struct berval *value, int dupval, LDAPControl **ctrlp);

LDAPControl *ldap_control_find( const char *oid, LDAPControl **ctrls, LDAPControl ***nextctrlp);

LDAPControl *ldap_control_dup(LDAPControl *ctrl);

LDAPControl **ldap_controls_dup(LDAPControl **ctrls);

void ldap_control_free(LDAPControl *ctrl);

void ldap_controls_free(LDAPControl **ctrls);

DESCRIPTION
These routines are used to manipulate structures used for LDAP controls.

ldap_control_create()  creates  a  control with the specified OID using the contents of the value parameter for the control value, if any.  The content of value is duplicated if
dupval is non-zero.  The iscritical parameter must be non-zero for a critical control. The created control is returned in the ctrlp parameter.  The routine returns  LDAP_SUCCESS
on  success  or  some  other error code on failure.  The content of value, for supported control types, can be prepared using helpers provided by this implementation of libldap,
usually in the form ldap_create_&amp;lt;control name&amp;gt;_control_value().  Otherwise, it can be BER-encoded using the functionalities of liblber.

ldap_control_find() searches the NULL-terminated ctrls array for a control whose OID matches the oid parameter.  The routine returns a pointer to the control if found, NULL oth‐
erwise.   If  the  parameter nextctrlp is not NULL, on return it will point to the next control in the array, and can be passed to the ldap_control_find() routine for subsequent
calls, to find further occurrences of the same control type.  The use of this function is discouraged; the recommended way of handling controls in responses  consists  in  going
through the array of controls, dealing with each of them in the returned order, since it could matter.

ldap_control_dup() duplicates an individual control structure, and ldap_controls_dup() duplicates a NULL-terminated array of controls.

ldap_control_free() frees an individual control structure, and ldap_controls_free() frees a NULL-terminated array of controls.

SEE ALSO
ldap(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                       LDAP_CONTROLS(3)
LDAP_FIRST_ENTRY(3)                                                             Library Functions Manual                                                             LDAP_FIRST_ENTRY(3)

NAME
ldap_first_entry, ldap_next_entry, ldap_count_entries - LDAP result entry parsing and counting routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_count_entries( LDAP *ld, LDAPMessage *result )

LDAPMessage *ldap_first_entry( LDAP *ld, LDAPMessage *result )

LDAPMessage *ldap_next_entry( LDAP *ld, LDAPMessage *entry )

DESCRIPTION
These routines are used to parse results received from ldap_result(3) or the synchronous LDAP search operation routines ldap_search_s(3) and ldap_search_st(3).

The ldap_first_entry() routine is used to retrieve the first entry in a chain of search results.  It takes the result as returned by a call to ldap_result(3) or ldap_search_s(3)
or ldap_search_st(3) and returns a pointer to the first entry in the result.

This pointer should be supplied on a subsequent call to ldap_next_entry() to get the next entry, the result of which should be supplied to the next  call  to  ldap_next_entry(),
etc.   ldap_next_entry()  will  return NULL when there are no more entries.  The entries returned from these calls are used in calls to the routines described in ldap_get_dn(3),
ldap_first_attribute(3), ldap_get_values(3), etc.

A count of the number of entries in the search result can be obtained by calling ldap_count_entries().

ERRORS
If an error occurs in ldap_first_entry() or ldap_next_entry(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  If an error  occurs  in
ldap_count_entries(), -1 is returned, and ld_errno is set appropriately.  See ldap_error(3) for a description of possible error codes.

SEE ALSO
ldap(3), ldap_result(3), ldap_search(3), ldap_first_attribute(3), ldap_get_values(3), ldap_get_dn(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                    LDAP_FIRST_ENTRY(3)
LDAP_FIRST_MESSAGE(3)                                                           Library Functions Manual                                                           LDAP_FIRST_MESSAGE(3)

NAME
ldap_first_message, ldap_next_message, ldap_count_messages - Stepping through messages in a result chain

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_count_messages( LDAP *ld, LDAPMessage *result )

LDAPMessage *ldap_first_message( LDAP *ld, LDAPMessage *result )

LDAPMessage *ldap_next_message( LDAP *ld, LDAPMessage *message )

DESCRIPTION
These  routines  are  used  to step through the messages in a result chain received from ldap_result(3).  For search operations, the result chain can contain referral, entry and
result messages. The ldap_msgtype(3) function can be used to distinguish between the different message types.

The ldap_first_message() routine is used to retrieve the first message in a result chain.  It takes the result as returned by  a  call  to  ldap_result(3),  ldap_search_s(3)  or
ldap_search_st(3) and returns a pointer to the first message in the result chain.

This  pointer  should  be supplied on a subsequent call to ldap_next_message() to get the next message, the result of which should be supplied to the next call to ldap_next_mes‐
sage(), etc.  ldap_next_message() will return NULL when there are no more messages.

These functions are useful when using routines like ldap_parse_result(3) that only operate on the first result in the chain.

A count of the number of messages in the result chain can be obtained by calling ldap_count_messages().  It can also be used to count the number of remaining messages in a chain
if  called  with  a  message,  entry  or  reference  returned  by  ldap_first_message() , ldap_next_message() , ldap_first_entry(3), ldap_next_entry(3), ldap_first_reference(3),
ldap_next_reference(3).

ERRORS
If an error occurs in ldap_first_message() or ldap_next_message(), NULL is returned.  If an error occurs in ldap_count_messages(), -1 is returned.

SEE ALSO
ldap(3), ldap_search(3), ldap_result(3), ldap_parse_result(3), ldap_first_entry(3), ldap_first_reference(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                  LDAP_FIRST_MESSAGE(3)
LDAP_FIRST_REFERENCE(3)                                                         Library Functions Manual                                                         LDAP_FIRST_REFERENCE(3)

NAME
ldap_first_reference, ldap_next_reference, ldap_count_references - Stepping through continuation references in a result chain

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_count_references( LDAP *ld, LDAPMessage *result )

LDAPMessage *ldap_first_reference( LDAP *ld, LDAPMessage *result )

LDAPMessage *ldap_next_reference( LDAP *ld, LDAPMessage *reference )

DESCRIPTION
These routines are used to step through the continuation references in a result chain received from ldap_result(3) or the synchronous LDAP search operation routines.

The  ldap_first_reference()  routine  is  used  to  retrieve  the  first  reference  message  in  a  result  chain.  It takes the result as returned by a call to ldap_result(3),
ldap_search_s(3) or ldap_search_st(3) and returns a pointer to the first reference message in the result chain.

This pointer should be supplied on a subsequent call to ldap_next_reference() to get the next reference message, the result of which should be  supplied  to  the  next  call  to
ldap_next_reference(),  etc.   ldap_next_reference()  will  return  NULL when there are no more reference messages.  The reference messages returned from these calls are used by
ldap_parse_reference(3) to extract referrals and controls.

A count of the number of reference messages in the search result can be obtained by calling ldap_count_references().  It can also be used to count the number of  reference  mes‐
sages remaining in a result chain.

ERRORS
If an error occurs in ldap_first_reference() or ldap_next_reference(), NULL is returned.  If an error occurs in ldap_count_references(), -1 is returned.

SEE ALSO
ldap(3), ldap_result(3), ldap_search(3), ldap_parse_reference(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                LDAP_FIRST_REFERENCE(3)
LDAP_GET_VALUES(3)                                                              Library Functions Manual                                                              LDAP_GET_VALUES(3)

NAME
ldap_get_values, ldap_get_values_len, ldap_count_values - LDAP attribute value handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

char **ldap_get_values(ld, entry, attr)
LDAP *ld;
LDAPMessage *entry;
char *attr;

struct berval **ldap_get_values_len(ld, entry, attr)
LDAP *ld;
LDAPMessage *entry;
char *attr;

int ldap_count_values(vals)
char **vals;

int ldap_count_values_len(vals)
struct berval **vals;

void ldap_value_free(vals)
char **vals;

void ldap_value_free_len(vals)
struct berval **vals;

DESCRIPTION
These  routines  are  used  to retrieve and manipulate attribute values from an LDAP entry as returned by ldap_first_entry(3) or ldap_next_entry(3).  ldap_get_values() takes the
entry and the attribute attr whose values are desired and returns a NULL-terminated array  of  the  attribute's  values.   attr  may  be  an  attribute  type  as  returned  from
ldap_first_attribute(3) or ldap_next_attribute(3), or if the attribute type is known it can simply be given.

The number of values in the array can be counted by calling ldap_count_values().  The array of values returned can be freed by calling ldap_value_free().

If  the attribute values are binary in nature, and thus not suitable to be returned as an array of char *'s, the ldap_get_values_len() routine can be used instead.  It takes the
same parameters as ldap_get_values(), but returns a NULL-terminated array of pointers to berval structures, each containing the length of and a pointer to a value.

The number of values in the array can be counted by calling ldap_count_values_len().  The array of values returned can be freed by calling ldap_value_free_len().

ERRORS
If an error occurs in ldap_get_values() or ldap_get_values_len(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the  error.   See  ldap_error(3)
for a description of possible error codes.

NOTES
These routines dynamically allocate memory which the caller must free using the supplied routines.

SEE ALSO
ldap(3), ldap_first_entry(3), ldap_first_attribute(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                     LDAP_GET_VALUES(3)
LDAP_GET_VALUES(3)                                                              Library Functions Manual                                                              LDAP_GET_VALUES(3)

NAME
ldap_get_values, ldap_get_values_len, ldap_count_values - LDAP attribute value handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

char **ldap_get_values(ld, entry, attr)
LDAP *ld;
LDAPMessage *entry;
char *attr;

struct berval **ldap_get_values_len(ld, entry, attr)
LDAP *ld;
LDAPMessage *entry;
char *attr;

int ldap_count_values(vals)
char **vals;

int ldap_count_values_len(vals)
struct berval **vals;

void ldap_value_free(vals)
char **vals;

void ldap_value_free_len(vals)
struct berval **vals;

DESCRIPTION
These  routines  are  used  to retrieve and manipulate attribute values from an LDAP entry as returned by ldap_first_entry(3) or ldap_next_entry(3).  ldap_get_values() takes the
entry and the attribute attr whose values are desired and returns a NULL-terminated array  of  the  attribute's  values.   attr  may  be  an  attribute  type  as  returned  from
ldap_first_attribute(3) or ldap_next_attribute(3), or if the attribute type is known it can simply be given.

The number of values in the array can be counted by calling ldap_count_values().  The array of values returned can be freed by calling ldap_value_free().

If  the attribute values are binary in nature, and thus not suitable to be returned as an array of char *'s, the ldap_get_values_len() routine can be used instead.  It takes the
same parameters as ldap_get_values(), but returns a NULL-terminated array of pointers to berval structures, each containing the length of and a pointer to a value.

The number of values in the array can be counted by calling ldap_count_values_len().  The array of values returned can be freed by calling ldap_value_free_len().

ERRORS
If an error occurs in ldap_get_values() or ldap_get_values_len(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the  error.   See  ldap_error(3)
for a description of possible error codes.

NOTES
These routines dynamically allocate memory which the caller must free using the supplied routines.

SEE ALSO
ldap(3), ldap_first_entry(3), ldap_first_attribute(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                     LDAP_GET_VALUES(3)
LDAP_GET_DN(3)                                                                  Library Functions Manual                                                                  LDAP_GET_DN(3)

NAME
ldap_get_dn, ldap_explode_dn, ldap_explode_rdn, ldap_dn2ufn - LDAP DN handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

char *ldap_get_dn( LDAP *ld, LDAPMessage *entry )

int ldap_str2dn( const char *str, LDAPDN *dn, unsigned flags )

void ldap_dnfree( LDAPDN dn )

int ldap_dn2str( LDAPDN dn, char **str, unsigned flags )

char **ldap_explode_dn( const char *dn, int notypes )

char **ldap_explode_rdn( const char *rdn, int notypes )

char *ldap_dn2ufn( const char * dn )

char *ldap_dn2dcedn( const char * dn )

char *ldap_dcedn2dn( const char * dn )

char *ldap_dn2ad_canonical( const char * dn )

DESCRIPTION
These  routines  allow  LDAP entry names (Distinguished Names, or DNs) to be obtained, parsed, converted to a user-friendly form, and tested.  A DN has the form described in RFC
4414 "Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names".

The ldap_get_dn() routine takes an entry as returned by ldap_first_entry(3) or ldap_next_entry(3) and returns a copy of the entry's DN.  Space for the DN will be obtained dynam‐
ically and should be freed by the caller using ldap_memfree(3).

ldap_str2dn()  parses  a  string representation of a distinguished name contained in str into its components, which are stored in dn as ldap_ava structures, arranged in LDAPAVA,
LDAPRDN, and LDAPDN terms.  Space for dn will be obtained dynamically and should be freed by the caller using ldap_dnfree(3).  The LDAPDN is defined as:

typedef struct ldap_ava {
struct berval la_attr;
struct berval la_value;
unsigned la_flags;
} LDAPAVA;

typedef LDAPAVA** LDAPRDN;
typedef LDAPRDN* LDAPDN;

The attribute types and the attribute values are not normalized.  The la_flags can be either LDAP_AVA_STRING or LDAP_AVA_BINARY, the latter meaning that  the  value  is  BER/DER
encoded  and  thus must be represented as, quoting from RFC 4514, " ... an octothorpe character ('#' ASCII 35) followed by the hexadecimal representation of each of the bytes of
the BER encoding of the X.500 AttributeValue."  The flags parameter to ldap_str2dn() can be

LDAP_DN_FORMAT_LDAPV3
LDAP_DN_FORMAT_LDAPV2
LDAP_DN_FORMAT_DCE

which defines what DN syntax is expected (according to RFC 4514, RFC 1779 and DCE, respectively).  The format can be ORed to the flags

LDAP_DN_P_NO_SPACES
LDAP_DN_P_NO_SPACE_AFTER_RDN
...
LDAP_DN_PEDANTIC

The latter is a shortcut for all the previous limitations.

LDAP_DN_P_NO_SPACES does not allow extra spaces in the dn; the default is to  silently  eliminate  spaces  around  AVA  separators  ('='),  RDN  component  separators  ('+'  for
LDAPv3/LDAPv2 or ',' for DCE) and RDN separators (',' LDAPv3/LDAPv2 or '/' for DCE).

LDAP_DN_P_NO_SPACE_AFTER_RDN does not allow a single space after RDN separators.

ldap_dn2str() performs the inverse operation, yielding in str a string representation of dn.  It allows the same values for flags as ldap_str2dn(), plus

LDAP_DN_FORMAT_UFN
LDAP_DN_FORMAT_AD_CANONICAL

for user-friendly naming (RFC 1781) and AD canonical.

The following routines are viewed as deprecated in favor of ldap_str2dn() and ldap_dn2str().  They are provided to support legacy applications.

The  ldap_explode_dn()  routine  takes a DN as returned by ldap_get_dn() and breaks it up into its component parts.  Each part is known as a Relative Distinguished Name, or RDN.
ldap_explode_dn() returns a NULL-terminated array, each component of which contains an RDN from the DN.  The notypes parameter is used to request that only  the  RDN  values  be
returned,  not their types.  For example, the DN "cn=Bob, c=US" would return as either { "cn=Bob", "c=US", NULL } or { "Bob", "US", NULL }, depending on whether notypes was 0 or
1, respectively.  Assertion values in RDN strings may included escaped characters.  The result can be freed by calling ldap_value_free(3).

Similarly, the ldap_explode_rdn() routine takes an RDN as returned by ldap_explode_dn(dn,0) and breaks it up into its "type=value" component  parts  (or  just  "value",  if  the
notypes parameter is set).  Note the value is not unescaped.  The result can be freed by calling ldap_value_free(3).

ldap_dn2ufn() is used to turn a DN as returned by ldap_get_dn(3) into a more user-friendly form, stripping off all type names.  See "Using the Directory to Achieve User Friendly
Naming" (RFC 1781) for more details on the UFN format.  Due to the ambiguous nature of the format, it is generally only used  for  display  purposes.   The  space  for  the  UFN
returned is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).

ldap_dn2dcedn() is used to turn a DN as returned by ldap_get_dn(3) into a DCE-style DN, e.g. a string with most-significant to least significant rdns separated by slashes ('/');
rdn components are separated by commas (',').  Only printable chars (e.g. LDAPv2 printable string) are allowed, at least in this implementation.   ldap_dcedn2dn()  performs  the
opposite  operation.   ldap_dn2ad_canonical() turns a DN into a AD canonical name, which is basically a DCE dn with attribute types omitted.  The trailing domain, if present, is
turned in a DNS-like domain.  The space for the returned value is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).

ERRORS
If an error occurs in ldap_get_dn(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  See ldap_error(3) for a description  of  possible
error codes.  ldap_explode_dn(), ldap_explode_rdn(), ldap_dn2ufn(), ldap_dn2dcedn(), ldap_dcedn2dn(), and ldap_dn2ad_canonical() will return NULL with errno(3) set appropriately
in case of trouble.

NOTES
These routines dynamically allocate memory that the caller must free.

SEE ALSO
ldap(3), ldap_error(3), ldap_first_entry(3), ldap_memfree(3), ldap_value_free(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_GET_DN(3)
LDAP_DELETE(3)                                                                  Library Functions Manual                                                                  LDAP_DELETE(3)

NAME
ldap_delete, ldap_delete_s, ldap_delete_ext, ldap_delete_ext_s - Perform an LDAP delete operation.

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_delete_s(ld, dn)
LDAP *ld;
char *dn;

int ldap_delete(ld, dn)
LDAP *ld;
char *dn;

int ldap_delete_ext(ld, dn, serverctrls, clientctrls, msgidp)
LDAP *ld;
char *dn;
LDAPControl **serverctrls, **clientctrls;
int *msgidp;

int ldap_delete_ext_s(ld, dn, serverctrls, clientctrls)
LDAP *ld;
char *dn;
LDAPControl **serverctrls, **clientctrls;

DESCRIPTION
The ldap_delete_s() routine is used to perform an LDAP delete operation synchronously. It takes dn, the DN of the entry to be deleted.  It returns an LDAP error code, indicating
the success or failure of the operation.

The ldap_delete() routine is used to perform an LDAP delete operation asynchronously. It takes the same parameters as ldap_delete_s(), but returns the message id of the  request
it initiated. The result of the delete can be obtained by a subsequent call to ldap_result(3).

The  ldap_delete_ext() routine  allows  server  and client controls to be specified to extend the delete request. This routine is asynchronous like ldap_delete(), but its return
value is an LDAP error code. It stores the message id of the request in the integer pointed to by msgidp.

The ldap_delete_ext_s() routine is the synchronous version of ldap_delete_ext().  It also returns an LDAP error code indicating success or failure of the operation.

ERRORS
ldap_delete_s() returns an LDAP error code which can be interpreted by calling one of ldap_perror(3) and friends.  ldap_delete() returns -1 if something  went  wrong  initiating
the request. It returns the non-negative message id of the request if things went ok.

ldap_delete_ext() and ldap_delete_ext_s() return some Non-zero value if something  went wrong initiating the request, else return 0.

SEE ALSO
ldap(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_DELETE(3)
LDAP_DELETE(3)                                                                  Library Functions Manual                                                                  LDAP_DELETE(3)

NAME
ldap_delete, ldap_delete_s, ldap_delete_ext, ldap_delete_ext_s - Perform an LDAP delete operation.

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_delete_s(ld, dn)
LDAP *ld;
char *dn;

int ldap_delete(ld, dn)
LDAP *ld;
char *dn;

int ldap_delete_ext(ld, dn, serverctrls, clientctrls, msgidp)
LDAP *ld;
char *dn;
LDAPControl **serverctrls, **clientctrls;
int *msgidp;

int ldap_delete_ext_s(ld, dn, serverctrls, clientctrls)
LDAP *ld;
char *dn;
LDAPControl **serverctrls, **clientctrls;

DESCRIPTION
The ldap_delete_s() routine is used to perform an LDAP delete operation synchronously. It takes dn, the DN of the entry to be deleted.  It returns an LDAP error code, indicating
the success or failure of the operation.

The ldap_delete() routine is used to perform an LDAP delete operation asynchronously. It takes the same parameters as ldap_delete_s(), but returns the message id of the  request
it initiated. The result of the delete can be obtained by a subsequent call to ldap_result(3).

The  ldap_delete_ext() routine  allows  server  and client controls to be specified to extend the delete request. This routine is asynchronous like ldap_delete(), but its return
value is an LDAP error code. It stores the message id of the request in the integer pointed to by msgidp.

The ldap_delete_ext_s() routine is the synchronous version of ldap_delete_ext().  It also returns an LDAP error code indicating success or failure of the operation.

ERRORS
ldap_delete_s() returns an LDAP error code which can be interpreted by calling one of ldap_perror(3) and friends.  ldap_delete() returns -1 if something  went  wrong  initiating
the request. It returns the non-negative message id of the request if things went ok.

ldap_delete_ext() and ldap_delete_ext_s() return some Non-zero value if something  went wrong initiating the request, else return 0.

SEE ALSO
ldap(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_DELETE(3)
LDAP_DELETE(3)                                                                  Library Functions Manual                                                                  LDAP_DELETE(3)

NAME
ldap_delete, ldap_delete_s, ldap_delete_ext, ldap_delete_ext_s - Perform an LDAP delete operation.

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_delete_s(ld, dn)
LDAP *ld;
char *dn;

int ldap_delete(ld, dn)
LDAP *ld;
char *dn;

int ldap_delete_ext(ld, dn, serverctrls, clientctrls, msgidp)
LDAP *ld;
char *dn;
LDAPControl **serverctrls, **clientctrls;
int *msgidp;

int ldap_delete_ext_s(ld, dn, serverctrls, clientctrls)
LDAP *ld;
char *dn;
LDAPControl **serverctrls, **clientctrls;

DESCRIPTION
The ldap_delete_s() routine is used to perform an LDAP delete operation synchronously. It takes dn, the DN of the entry to be deleted.  It returns an LDAP error code, indicating
the success or failure of the operation.

The ldap_delete() routine is used to perform an LDAP delete operation asynchronously. It takes the same parameters as ldap_delete_s(), but returns the message id of the  request
it initiated. The result of the delete can be obtained by a subsequent call to ldap_result(3).

The  ldap_delete_ext() routine  allows  server  and client controls to be specified to extend the delete request. This routine is asynchronous like ldap_delete(), but its return
value is an LDAP error code. It stores the message id of the request in the integer pointed to by msgidp.

The ldap_delete_ext_s() routine is the synchronous version of ldap_delete_ext().  It also returns an LDAP error code indicating success or failure of the operation.

ERRORS
ldap_delete_s() returns an LDAP error code which can be interpreted by calling one of ldap_perror(3) and friends.  ldap_delete() returns -1 if something  went  wrong  initiating
the request. It returns the non-negative message id of the request if things went ok.

ldap_delete_ext() and ldap_delete_ext_s() return some Non-zero value if something  went wrong initiating the request, else return 0.

SEE ALSO
ldap(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_DELETE(3)
LDAP_DELETE(3)                                                                  Library Functions Manual                                                                  LDAP_DELETE(3)

NAME
ldap_delete, ldap_delete_s, ldap_delete_ext, ldap_delete_ext_s - Perform an LDAP delete operation.

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_delete_s(ld, dn)
LDAP *ld;
char *dn;

int ldap_delete(ld, dn)
LDAP *ld;
char *dn;

int ldap_delete_ext(ld, dn, serverctrls, clientctrls, msgidp)
LDAP *ld;
char *dn;
LDAPControl **serverctrls, **clientctrls;
int *msgidp;

int ldap_delete_ext_s(ld, dn, serverctrls, clientctrls)
LDAP *ld;
char *dn;
LDAPControl **serverctrls, **clientctrls;

DESCRIPTION
The ldap_delete_s() routine is used to perform an LDAP delete operation synchronously. It takes dn, the DN of the entry to be deleted.  It returns an LDAP error code, indicating
the success or failure of the operation.

The ldap_delete() routine is used to perform an LDAP delete operation asynchronously. It takes the same parameters as ldap_delete_s(), but returns the message id of the  request
it initiated. The result of the delete can be obtained by a subsequent call to ldap_result(3).

The  ldap_delete_ext() routine  allows  server  and client controls to be specified to extend the delete request. This routine is asynchronous like ldap_delete(), but its return
value is an LDAP error code. It stores the message id of the request in the integer pointed to by msgidp.

The ldap_delete_ext_s() routine is the synchronous version of ldap_delete_ext().  It also returns an LDAP error code indicating success or failure of the operation.

ERRORS
ldap_delete_s() returns an LDAP error code which can be interpreted by calling one of ldap_perror(3) and friends.  ldap_delete() returns -1 if something  went  wrong  initiating
the request. It returns the non-negative message id of the request if things went ok.

ldap_delete_ext() and ldap_delete_ext_s() return some Non-zero value if something  went wrong initiating the request, else return 0.

SEE ALSO
ldap(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_DELETE(3)
LDAP_OPEN(3)                                                                    Library Functions Manual                                                                    LDAP_OPEN(3)

NAME
ldap_dup, ldap_destroy, - Duplicate and destroy LDAP session handles

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

LDAP *ldap_dup(
LDAP *old );

int ldap_destroy(
LDAP *old );

DESCRIPTION
ldap_dup()  duplicates  an  existing LDAP (LDAP *) session handle.  The new session handle may be used concurrently with the original session handle.  In a threaded environment,
different threads may execute concurrent requests on the same connection/session without fear of contamination.  Each session handle manages its own private error results.

ldap_destroy() destroys an existing session handle.

The ldap_dup() and ldap_destroy() functions are used in conjunction with a "thread safe" version of libldap (libldap_r) to enable operation thread safe API calls, so that a sin‐
gle session may be simultaneously used across multiple threads with consistent error handling.

When  a session is created through the use of one of the session creation functions including ldap_open(3), ldap_init(3), ldap_initialize(3) or ldap_init_fd(3) an LDAP * session
handle is returned to the application.  The session handle may be shared amongst threads, however the error codes are unique to a session handle.   Multiple  threads  performing
different operations using the same session handle will result in inconsistent error codes and return values.

To  prevent this confusion, ldap_dup() is used duplicate an existing session handle so that multiple threads can share the session, and maintain consistent error information and
results.

The message queues for a session are shared between sibling session handles.  Results of operations on a sibling session handles are accessible to all the sibling  session  han‐
dles.  Applications desiring results associated with a specific operation should provide the appropriate msgid to ldap_result().  Applications should avoid calling ldap_result()
with LDAP_RES_ANY as that may "steal" and return results in the calling thread that another operation in a different thread, using a different session  handle,  may  require  to
complete.

When ldap_unbind() is called on a session handle with siblings, all the siblings become invalid.

Siblings  must be destroyed using ldap_destroy().  Session handle resources associated with the original (LDAP *) will be freed when the last session handle is destroyed or when
ldap_unbind() is called, if no other session handles currently exist.

ERRORS
If an error occurs, ldap_dup() will return NULL and errno should be set appropriately.  ldap_destroy() will directly return the LDAP code associated to the error  (or  LDAP_SUC‐
CESS in case of success); errno should be set as well whenever appropriate.

SEE ALSO
ldap_open(3), ldap_init(3), ldap_initialize(3), ldap_init_fd(3), errno(3)

ACKNOWLEDGEMENTS
This  work is based on the previously proposed LDAP C API Concurrency Extensions draft (draft-zeilenga-ldap-c-api-concurrency-00.txt) effort.  OpenLDAP Software is developed and
maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                           LDAP_OPEN(3)
LDAP_GET_DN(3)                                                                  Library Functions Manual                                                                  LDAP_GET_DN(3)

NAME
ldap_get_dn, ldap_explode_dn, ldap_explode_rdn, ldap_dn2ufn - LDAP DN handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

char *ldap_get_dn( LDAP *ld, LDAPMessage *entry )

int ldap_str2dn( const char *str, LDAPDN *dn, unsigned flags )

void ldap_dnfree( LDAPDN dn )

int ldap_dn2str( LDAPDN dn, char **str, unsigned flags )

char **ldap_explode_dn( const char *dn, int notypes )

char **ldap_explode_rdn( const char *rdn, int notypes )

char *ldap_dn2ufn( const char * dn )

char *ldap_dn2dcedn( const char * dn )

char *ldap_dcedn2dn( const char * dn )

char *ldap_dn2ad_canonical( const char * dn )

DESCRIPTION
These  routines  allow  LDAP entry names (Distinguished Names, or DNs) to be obtained, parsed, converted to a user-friendly form, and tested.  A DN has the form described in RFC
4414 "Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names".

The ldap_get_dn() routine takes an entry as returned by ldap_first_entry(3) or ldap_next_entry(3) and returns a copy of the entry's DN.  Space for the DN will be obtained dynam‐
ically and should be freed by the caller using ldap_memfree(3).

ldap_str2dn()  parses  a  string representation of a distinguished name contained in str into its components, which are stored in dn as ldap_ava structures, arranged in LDAPAVA,
LDAPRDN, and LDAPDN terms.  Space for dn will be obtained dynamically and should be freed by the caller using ldap_dnfree(3).  The LDAPDN is defined as:

typedef struct ldap_ava {
struct berval la_attr;
struct berval la_value;
unsigned la_flags;
} LDAPAVA;

typedef LDAPAVA** LDAPRDN;
typedef LDAPRDN* LDAPDN;

The attribute types and the attribute values are not normalized.  The la_flags can be either LDAP_AVA_STRING or LDAP_AVA_BINARY, the latter meaning that  the  value  is  BER/DER
encoded  and  thus must be represented as, quoting from RFC 4514, " ... an octothorpe character ('#' ASCII 35) followed by the hexadecimal representation of each of the bytes of
the BER encoding of the X.500 AttributeValue."  The flags parameter to ldap_str2dn() can be

LDAP_DN_FORMAT_LDAPV3
LDAP_DN_FORMAT_LDAPV2
LDAP_DN_FORMAT_DCE

which defines what DN syntax is expected (according to RFC 4514, RFC 1779 and DCE, respectively).  The format can be ORed to the flags

LDAP_DN_P_NO_SPACES
LDAP_DN_P_NO_SPACE_AFTER_RDN
...
LDAP_DN_PEDANTIC

The latter is a shortcut for all the previous limitations.

LDAP_DN_P_NO_SPACES does not allow extra spaces in the dn; the default is to  silently  eliminate  spaces  around  AVA  separators  ('='),  RDN  component  separators  ('+'  for
LDAPv3/LDAPv2 or ',' for DCE) and RDN separators (',' LDAPv3/LDAPv2 or '/' for DCE).

LDAP_DN_P_NO_SPACE_AFTER_RDN does not allow a single space after RDN separators.

ldap_dn2str() performs the inverse operation, yielding in str a string representation of dn.  It allows the same values for flags as ldap_str2dn(), plus

LDAP_DN_FORMAT_UFN
LDAP_DN_FORMAT_AD_CANONICAL

for user-friendly naming (RFC 1781) and AD canonical.

The following routines are viewed as deprecated in favor of ldap_str2dn() and ldap_dn2str().  They are provided to support legacy applications.

The  ldap_explode_dn()  routine  takes a DN as returned by ldap_get_dn() and breaks it up into its component parts.  Each part is known as a Relative Distinguished Name, or RDN.
ldap_explode_dn() returns a NULL-terminated array, each component of which contains an RDN from the DN.  The notypes parameter is used to request that only  the  RDN  values  be
returned,  not their types.  For example, the DN "cn=Bob, c=US" would return as either { "cn=Bob", "c=US", NULL } or { "Bob", "US", NULL }, depending on whether notypes was 0 or
1, respectively.  Assertion values in RDN strings may included escaped characters.  The result can be freed by calling ldap_value_free(3).

Similarly, the ldap_explode_rdn() routine takes an RDN as returned by ldap_explode_dn(dn,0) and breaks it up into its "type=value" component  parts  (or  just  "value",  if  the
notypes parameter is set).  Note the value is not unescaped.  The result can be freed by calling ldap_value_free(3).

ldap_dn2ufn() is used to turn a DN as returned by ldap_get_dn(3) into a more user-friendly form, stripping off all type names.  See "Using the Directory to Achieve User Friendly
Naming" (RFC 1781) for more details on the UFN format.  Due to the ambiguous nature of the format, it is generally only used  for  display  purposes.   The  space  for  the  UFN
returned is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).

ldap_dn2dcedn() is used to turn a DN as returned by ldap_get_dn(3) into a DCE-style DN, e.g. a string with most-significant to least significant rdns separated by slashes ('/');
rdn components are separated by commas (',').  Only printable chars (e.g. LDAPv2 printable string) are allowed, at least in this implementation.   ldap_dcedn2dn()  performs  the
opposite  operation.   ldap_dn2ad_canonical() turns a DN into a AD canonical name, which is basically a DCE dn with attribute types omitted.  The trailing domain, if present, is
turned in a DNS-like domain.  The space for the returned value is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).

ERRORS
If an error occurs in ldap_get_dn(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  See ldap_error(3) for a description  of  possible
error codes.  ldap_explode_dn(), ldap_explode_rdn(), ldap_dn2ufn(), ldap_dn2dcedn(), ldap_dcedn2dn(), and ldap_dn2ad_canonical() will return NULL with errno(3) set appropriately
in case of trouble.

NOTES
These routines dynamically allocate memory that the caller must free.

SEE ALSO
ldap(3), ldap_error(3), ldap_first_entry(3), ldap_memfree(3), ldap_value_free(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_GET_DN(3)
LDAP_GET_DN(3)                                                                  Library Functions Manual                                                                  LDAP_GET_DN(3)

NAME
ldap_get_dn, ldap_explode_dn, ldap_explode_rdn, ldap_dn2ufn - LDAP DN handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

char *ldap_get_dn( LDAP *ld, LDAPMessage *entry )

int ldap_str2dn( const char *str, LDAPDN *dn, unsigned flags )

void ldap_dnfree( LDAPDN dn )

int ldap_dn2str( LDAPDN dn, char **str, unsigned flags )

char **ldap_explode_dn( const char *dn, int notypes )

char **ldap_explode_rdn( const char *rdn, int notypes )

char *ldap_dn2ufn( const char * dn )

char *ldap_dn2dcedn( const char * dn )

char *ldap_dcedn2dn( const char * dn )

char *ldap_dn2ad_canonical( const char * dn )

DESCRIPTION
These  routines  allow  LDAP entry names (Distinguished Names, or DNs) to be obtained, parsed, converted to a user-friendly form, and tested.  A DN has the form described in RFC
4414 "Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names".

The ldap_get_dn() routine takes an entry as returned by ldap_first_entry(3) or ldap_next_entry(3) and returns a copy of the entry's DN.  Space for the DN will be obtained dynam‐
ically and should be freed by the caller using ldap_memfree(3).

ldap_str2dn()  parses  a  string representation of a distinguished name contained in str into its components, which are stored in dn as ldap_ava structures, arranged in LDAPAVA,
LDAPRDN, and LDAPDN terms.  Space for dn will be obtained dynamically and should be freed by the caller using ldap_dnfree(3).  The LDAPDN is defined as:

typedef struct ldap_ava {
struct berval la_attr;
struct berval la_value;
unsigned la_flags;
} LDAPAVA;

typedef LDAPAVA** LDAPRDN;
typedef LDAPRDN* LDAPDN;

The attribute types and the attribute values are not normalized.  The la_flags can be either LDAP_AVA_STRING or LDAP_AVA_BINARY, the latter meaning that  the  value  is  BER/DER
encoded  and  thus must be represented as, quoting from RFC 4514, " ... an octothorpe character ('#' ASCII 35) followed by the hexadecimal representation of each of the bytes of
the BER encoding of the X.500 AttributeValue."  The flags parameter to ldap_str2dn() can be

LDAP_DN_FORMAT_LDAPV3
LDAP_DN_FORMAT_LDAPV2
LDAP_DN_FORMAT_DCE

which defines what DN syntax is expected (according to RFC 4514, RFC 1779 and DCE, respectively).  The format can be ORed to the flags

LDAP_DN_P_NO_SPACES
LDAP_DN_P_NO_SPACE_AFTER_RDN
...
LDAP_DN_PEDANTIC

The latter is a shortcut for all the previous limitations.

LDAP_DN_P_NO_SPACES does not allow extra spaces in the dn; the default is to  silently  eliminate  spaces  around  AVA  separators  ('='),  RDN  component  separators  ('+'  for
LDAPv3/LDAPv2 or ',' for DCE) and RDN separators (',' LDAPv3/LDAPv2 or '/' for DCE).

LDAP_DN_P_NO_SPACE_AFTER_RDN does not allow a single space after RDN separators.

ldap_dn2str() performs the inverse operation, yielding in str a string representation of dn.  It allows the same values for flags as ldap_str2dn(), plus

LDAP_DN_FORMAT_UFN
LDAP_DN_FORMAT_AD_CANONICAL

for user-friendly naming (RFC 1781) and AD canonical.

The following routines are viewed as deprecated in favor of ldap_str2dn() and ldap_dn2str().  They are provided to support legacy applications.

The  ldap_explode_dn()  routine  takes a DN as returned by ldap_get_dn() and breaks it up into its component parts.  Each part is known as a Relative Distinguished Name, or RDN.
ldap_explode_dn() returns a NULL-terminated array, each component of which contains an RDN from the DN.  The notypes parameter is used to request that only  the  RDN  values  be
returned,  not their types.  For example, the DN "cn=Bob, c=US" would return as either { "cn=Bob", "c=US", NULL } or { "Bob", "US", NULL }, depending on whether notypes was 0 or
1, respectively.  Assertion values in RDN strings may included escaped characters.  The result can be freed by calling ldap_value_free(3).

Similarly, the ldap_explode_rdn() routine takes an RDN as returned by ldap_explode_dn(dn,0) and breaks it up into its "type=value" component  parts  (or  just  "value",  if  the
notypes parameter is set).  Note the value is not unescaped.  The result can be freed by calling ldap_value_free(3).

ldap_dn2ufn() is used to turn a DN as returned by ldap_get_dn(3) into a more user-friendly form, stripping off all type names.  See "Using the Directory to Achieve User Friendly
Naming" (RFC 1781) for more details on the UFN format.  Due to the ambiguous nature of the format, it is generally only used  for  display  purposes.   The  space  for  the  UFN
returned is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).

ldap_dn2dcedn() is used to turn a DN as returned by ldap_get_dn(3) into a DCE-style DN, e.g. a string with most-significant to least significant rdns separated by slashes ('/');
rdn components are separated by commas (',').  Only printable chars (e.g. LDAPv2 printable string) are allowed, at least in this implementation.   ldap_dcedn2dn()  performs  the
opposite  operation.   ldap_dn2ad_canonical() turns a DN into a AD canonical name, which is basically a DCE dn with attribute types omitted.  The trailing domain, if present, is
turned in a DNS-like domain.  The space for the returned value is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).

ERRORS
If an error occurs in ldap_get_dn(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  See ldap_error(3) for a description  of  possible
error codes.  ldap_explode_dn(), ldap_explode_rdn(), ldap_dn2ufn(), ldap_dn2dcedn(), ldap_dcedn2dn(), and ldap_dn2ad_canonical() will return NULL with errno(3) set appropriately
in case of trouble.

NOTES
These routines dynamically allocate memory that the caller must free.

SEE ALSO
ldap(3), ldap_error(3), ldap_first_entry(3), ldap_memfree(3), ldap_value_free(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_GET_DN(3)
LDAP_GET_DN(3)                                                                  Library Functions Manual                                                                  LDAP_GET_DN(3)

NAME
ldap_get_dn, ldap_explode_dn, ldap_explode_rdn, ldap_dn2ufn - LDAP DN handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

char *ldap_get_dn( LDAP *ld, LDAPMessage *entry )

int ldap_str2dn( const char *str, LDAPDN *dn, unsigned flags )

void ldap_dnfree( LDAPDN dn )

int ldap_dn2str( LDAPDN dn, char **str, unsigned flags )

char **ldap_explode_dn( const char *dn, int notypes )

char **ldap_explode_rdn( const char *rdn, int notypes )

char *ldap_dn2ufn( const char * dn )

char *ldap_dn2dcedn( const char * dn )

char *ldap_dcedn2dn( const char * dn )

char *ldap_dn2ad_canonical( const char * dn )

DESCRIPTION
These  routines  allow  LDAP entry names (Distinguished Names, or DNs) to be obtained, parsed, converted to a user-friendly form, and tested.  A DN has the form described in RFC
4414 "Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names".

The ldap_get_dn() routine takes an entry as returned by ldap_first_entry(3) or ldap_next_entry(3) and returns a copy of the entry's DN.  Space for the DN will be obtained dynam‐
ically and should be freed by the caller using ldap_memfree(3).

ldap_str2dn()  parses  a  string representation of a distinguished name contained in str into its components, which are stored in dn as ldap_ava structures, arranged in LDAPAVA,
LDAPRDN, and LDAPDN terms.  Space for dn will be obtained dynamically and should be freed by the caller using ldap_dnfree(3).  The LDAPDN is defined as:

typedef struct ldap_ava {
struct berval la_attr;
struct berval la_value;
unsigned la_flags;
} LDAPAVA;

typedef LDAPAVA** LDAPRDN;
typedef LDAPRDN* LDAPDN;

The attribute types and the attribute values are not normalized.  The la_flags can be either LDAP_AVA_STRING or LDAP_AVA_BINARY, the latter meaning that  the  value  is  BER/DER
encoded  and  thus must be represented as, quoting from RFC 4514, " ... an octothorpe character ('#' ASCII 35) followed by the hexadecimal representation of each of the bytes of
the BER encoding of the X.500 AttributeValue."  The flags parameter to ldap_str2dn() can be

LDAP_DN_FORMAT_LDAPV3
LDAP_DN_FORMAT_LDAPV2
LDAP_DN_FORMAT_DCE

which defines what DN syntax is expected (according to RFC 4514, RFC 1779 and DCE, respectively).  The format can be ORed to the flags

LDAP_DN_P_NO_SPACES
LDAP_DN_P_NO_SPACE_AFTER_RDN
...
LDAP_DN_PEDANTIC

The latter is a shortcut for all the previous limitations.

LDAP_DN_P_NO_SPACES does not allow extra spaces in the dn; the default is to  silently  eliminate  spaces  around  AVA  separators  ('='),  RDN  component  separators  ('+'  for
LDAPv3/LDAPv2 or ',' for DCE) and RDN separators (',' LDAPv3/LDAPv2 or '/' for DCE).

LDAP_DN_P_NO_SPACE_AFTER_RDN does not allow a single space after RDN separators.

ldap_dn2str() performs the inverse operation, yielding in str a string representation of dn.  It allows the same values for flags as ldap_str2dn(), plus

LDAP_DN_FORMAT_UFN
LDAP_DN_FORMAT_AD_CANONICAL

for user-friendly naming (RFC 1781) and AD canonical.

The following routines are viewed as deprecated in favor of ldap_str2dn() and ldap_dn2str().  They are provided to support legacy applications.

The  ldap_explode_dn()  routine  takes a DN as returned by ldap_get_dn() and breaks it up into its component parts.  Each part is known as a Relative Distinguished Name, or RDN.
ldap_explode_dn() returns a NULL-terminated array, each component of which contains an RDN from the DN.  The notypes parameter is used to request that only  the  RDN  values  be
returned,  not their types.  For example, the DN "cn=Bob, c=US" would return as either { "cn=Bob", "c=US", NULL } or { "Bob", "US", NULL }, depending on whether notypes was 0 or
1, respectively.  Assertion values in RDN strings may included escaped characters.  The result can be freed by calling ldap_value_free(3).

Similarly, the ldap_explode_rdn() routine takes an RDN as returned by ldap_explode_dn(dn,0) and breaks it up into its "type=value" component  parts  (or  just  "value",  if  the
notypes parameter is set).  Note the value is not unescaped.  The result can be freed by calling ldap_value_free(3).

ldap_dn2ufn() is used to turn a DN as returned by ldap_get_dn(3) into a more user-friendly form, stripping off all type names.  See "Using the Directory to Achieve User Friendly
Naming" (RFC 1781) for more details on the UFN format.  Due to the ambiguous nature of the format, it is generally only used  for  display  purposes.   The  space  for  the  UFN
returned is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).

ldap_dn2dcedn() is used to turn a DN as returned by ldap_get_dn(3) into a DCE-style DN, e.g. a string with most-significant to least significant rdns separated by slashes ('/');
rdn components are separated by commas (',').  Only printable chars (e.g. LDAPv2 printable string) are allowed, at least in this implementation.   ldap_dcedn2dn()  performs  the
opposite  operation.   ldap_dn2ad_canonical() turns a DN into a AD canonical name, which is basically a DCE dn with attribute types omitted.  The trailing domain, if present, is
turned in a DNS-like domain.  The space for the returned value is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).

ERRORS
If an error occurs in ldap_get_dn(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  See ldap_error(3) for a description  of  possible
error codes.  ldap_explode_dn(), ldap_explode_rdn(), ldap_dn2ufn(), ldap_dn2dcedn(), ldap_dcedn2dn(), and ldap_dn2ad_canonical() will return NULL with errno(3) set appropriately
in case of trouble.

NOTES
These routines dynamically allocate memory that the caller must free.

SEE ALSO
ldap(3), ldap_error(3), ldap_first_entry(3), ldap_memfree(3), ldap_value_free(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_GET_DN(3)
LDAP_GET_DN(3)                                                                  Library Functions Manual                                                                  LDAP_GET_DN(3)

NAME
ldap_get_dn, ldap_explode_dn, ldap_explode_rdn, ldap_dn2ufn - LDAP DN handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

char *ldap_get_dn( LDAP *ld, LDAPMessage *entry )

int ldap_str2dn( const char *str, LDAPDN *dn, unsigned flags )

void ldap_dnfree( LDAPDN dn )

int ldap_dn2str( LDAPDN dn, char **str, unsigned flags )

char **ldap_explode_dn( const char *dn, int notypes )

char **ldap_explode_rdn( const char *rdn, int notypes )

char *ldap_dn2ufn( const char * dn )

char *ldap_dn2dcedn( const char * dn )

char *ldap_dcedn2dn( const char * dn )

char *ldap_dn2ad_canonical( const char * dn )

DESCRIPTION
These  routines  allow  LDAP entry names (Distinguished Names, or DNs) to be obtained, parsed, converted to a user-friendly form, and tested.  A DN has the form described in RFC
4414 "Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names".

The ldap_get_dn() routine takes an entry as returned by ldap_first_entry(3) or ldap_next_entry(3) and returns a copy of the entry's DN.  Space for the DN will be obtained dynam‐
ically and should be freed by the caller using ldap_memfree(3).

ldap_str2dn()  parses  a  string representation of a distinguished name contained in str into its components, which are stored in dn as ldap_ava structures, arranged in LDAPAVA,
LDAPRDN, and LDAPDN terms.  Space for dn will be obtained dynamically and should be freed by the caller using ldap_dnfree(3).  The LDAPDN is defined as:

typedef struct ldap_ava {
struct berval la_attr;
struct berval la_value;
unsigned la_flags;
} LDAPAVA;

typedef LDAPAVA** LDAPRDN;
typedef LDAPRDN* LDAPDN;

The attribute types and the attribute values are not normalized.  The la_flags can be either LDAP_AVA_STRING or LDAP_AVA_BINARY, the latter meaning that  the  value  is  BER/DER
encoded  and  thus must be represented as, quoting from RFC 4514, " ... an octothorpe character ('#' ASCII 35) followed by the hexadecimal representation of each of the bytes of
the BER encoding of the X.500 AttributeValue."  The flags parameter to ldap_str2dn() can be

LDAP_DN_FORMAT_LDAPV3
LDAP_DN_FORMAT_LDAPV2
LDAP_DN_FORMAT_DCE

which defines what DN syntax is expected (according to RFC 4514, RFC 1779 and DCE, respectively).  The format can be ORed to the flags

LDAP_DN_P_NO_SPACES
LDAP_DN_P_NO_SPACE_AFTER_RDN
...
LDAP_DN_PEDANTIC

The latter is a shortcut for all the previous limitations.

LDAP_DN_P_NO_SPACES does not allow extra spaces in the dn; the default is to  silently  eliminate  spaces  around  AVA  separators  ('='),  RDN  component  separators  ('+'  for
LDAPv3/LDAPv2 or ',' for DCE) and RDN separators (',' LDAPv3/LDAPv2 or '/' for DCE).

LDAP_DN_P_NO_SPACE_AFTER_RDN does not allow a single space after RDN separators.

ldap_dn2str() performs the inverse operation, yielding in str a string representation of dn.  It allows the same values for flags as ldap_str2dn(), plus

LDAP_DN_FORMAT_UFN
LDAP_DN_FORMAT_AD_CANONICAL

for user-friendly naming (RFC 1781) and AD canonical.

The following routines are viewed as deprecated in favor of ldap_str2dn() and ldap_dn2str().  They are provided to support legacy applications.

The  ldap_explode_dn()  routine  takes a DN as returned by ldap_get_dn() and breaks it up into its component parts.  Each part is known as a Relative Distinguished Name, or RDN.
ldap_explode_dn() returns a NULL-terminated array, each component of which contains an RDN from the DN.  The notypes parameter is used to request that only  the  RDN  values  be
returned,  not their types.  For example, the DN "cn=Bob, c=US" would return as either { "cn=Bob", "c=US", NULL } or { "Bob", "US", NULL }, depending on whether notypes was 0 or
1, respectively.  Assertion values in RDN strings may included escaped characters.  The result can be freed by calling ldap_value_free(3).

Similarly, the ldap_explode_rdn() routine takes an RDN as returned by ldap_explode_dn(dn,0) and breaks it up into its "type=value" component  parts  (or  just  "value",  if  the
notypes parameter is set).  Note the value is not unescaped.  The result can be freed by calling ldap_value_free(3).

ldap_dn2ufn() is used to turn a DN as returned by ldap_get_dn(3) into a more user-friendly form, stripping off all type names.  See "Using the Directory to Achieve User Friendly
Naming" (RFC 1781) for more details on the UFN format.  Due to the ambiguous nature of the format, it is generally only used  for  display  purposes.   The  space  for  the  UFN
returned is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).

ldap_dn2dcedn() is used to turn a DN as returned by ldap_get_dn(3) into a DCE-style DN, e.g. a string with most-significant to least significant rdns separated by slashes ('/');
rdn components are separated by commas (',').  Only printable chars (e.g. LDAPv2 printable string) are allowed, at least in this implementation.   ldap_dcedn2dn()  performs  the
opposite  operation.   ldap_dn2ad_canonical() turns a DN into a AD canonical name, which is basically a DCE dn with attribute types omitted.  The trailing domain, if present, is
turned in a DNS-like domain.  The space for the returned value is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).

ERRORS
If an error occurs in ldap_get_dn(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  See ldap_error(3) for a description  of  possible
error codes.  ldap_explode_dn(), ldap_explode_rdn(), ldap_dn2ufn(), ldap_dn2dcedn(), ldap_dcedn2dn(), and ldap_dn2ad_canonical() will return NULL with errno(3) set appropriately
in case of trouble.

NOTES
These routines dynamically allocate memory that the caller must free.

SEE ALSO
ldap(3), ldap_error(3), ldap_first_entry(3), ldap_memfree(3), ldap_value_free(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_GET_DN(3)
LDAP_GET_DN(3)                                                                  Library Functions Manual                                                                  LDAP_GET_DN(3)

NAME
ldap_get_dn, ldap_explode_dn, ldap_explode_rdn, ldap_dn2ufn - LDAP DN handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

char *ldap_get_dn( LDAP *ld, LDAPMessage *entry )

int ldap_str2dn( const char *str, LDAPDN *dn, unsigned flags )

void ldap_dnfree( LDAPDN dn )

int ldap_dn2str( LDAPDN dn, char **str, unsigned flags )

char **ldap_explode_dn( const char *dn, int notypes )

char **ldap_explode_rdn( const char *rdn, int notypes )

char *ldap_dn2ufn( const char * dn )

char *ldap_dn2dcedn( const char * dn )

char *ldap_dcedn2dn( const char * dn )

char *ldap_dn2ad_canonical( const char * dn )

DESCRIPTION
These  routines  allow  LDAP entry names (Distinguished Names, or DNs) to be obtained, parsed, converted to a user-friendly form, and tested.  A DN has the form described in RFC
4414 "Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names".

The ldap_get_dn() routine takes an entry as returned by ldap_first_entry(3) or ldap_next_entry(3) and returns a copy of the entry's DN.  Space for the DN will be obtained dynam‐
ically and should be freed by the caller using ldap_memfree(3).

ldap_str2dn()  parses  a  string representation of a distinguished name contained in str into its components, which are stored in dn as ldap_ava structures, arranged in LDAPAVA,
LDAPRDN, and LDAPDN terms.  Space for dn will be obtained dynamically and should be freed by the caller using ldap_dnfree(3).  The LDAPDN is defined as:

typedef struct ldap_ava {
struct berval la_attr;
struct berval la_value;
unsigned la_flags;
} LDAPAVA;

typedef LDAPAVA** LDAPRDN;
typedef LDAPRDN* LDAPDN;

The attribute types and the attribute values are not normalized.  The la_flags can be either LDAP_AVA_STRING or LDAP_AVA_BINARY, the latter meaning that  the  value  is  BER/DER
encoded  and  thus must be represented as, quoting from RFC 4514, " ... an octothorpe character ('#' ASCII 35) followed by the hexadecimal representation of each of the bytes of
the BER encoding of the X.500 AttributeValue."  The flags parameter to ldap_str2dn() can be

LDAP_DN_FORMAT_LDAPV3
LDAP_DN_FORMAT_LDAPV2
LDAP_DN_FORMAT_DCE

which defines what DN syntax is expected (according to RFC 4514, RFC 1779 and DCE, respectively).  The format can be ORed to the flags

LDAP_DN_P_NO_SPACES
LDAP_DN_P_NO_SPACE_AFTER_RDN
...
LDAP_DN_PEDANTIC

The latter is a shortcut for all the previous limitations.

LDAP_DN_P_NO_SPACES does not allow extra spaces in the dn; the default is to  silently  eliminate  spaces  around  AVA  separators  ('='),  RDN  component  separators  ('+'  for
LDAPv3/LDAPv2 or ',' for DCE) and RDN separators (',' LDAPv3/LDAPv2 or '/' for DCE).

LDAP_DN_P_NO_SPACE_AFTER_RDN does not allow a single space after RDN separators.

ldap_dn2str() performs the inverse operation, yielding in str a string representation of dn.  It allows the same values for flags as ldap_str2dn(), plus

LDAP_DN_FORMAT_UFN
LDAP_DN_FORMAT_AD_CANONICAL

for user-friendly naming (RFC 1781) and AD canonical.

The following routines are viewed as deprecated in favor of ldap_str2dn() and ldap_dn2str().  They are provided to support legacy applications.

The  ldap_explode_dn()  routine  takes a DN as returned by ldap_get_dn() and breaks it up into its component parts.  Each part is known as a Relative Distinguished Name, or RDN.
ldap_explode_dn() returns a NULL-terminated array, each component of which contains an RDN from the DN.  The notypes parameter is used to request that only  the  RDN  values  be
returned,  not their types.  For example, the DN "cn=Bob, c=US" would return as either { "cn=Bob", "c=US", NULL } or { "Bob", "US", NULL }, depending on whether notypes was 0 or
1, respectively.  Assertion values in RDN strings may included escaped characters.  The result can be freed by calling ldap_value_free(3).

Similarly, the ldap_explode_rdn() routine takes an RDN as returned by ldap_explode_dn(dn,0) and breaks it up into its "type=value" component  parts  (or  just  "value",  if  the
notypes parameter is set).  Note the value is not unescaped.  The result can be freed by calling ldap_value_free(3).

ldap_dn2ufn() is used to turn a DN as returned by ldap_get_dn(3) into a more user-friendly form, stripping off all type names.  See "Using the Directory to Achieve User Friendly
Naming" (RFC 1781) for more details on the UFN format.  Due to the ambiguous nature of the format, it is generally only used  for  display  purposes.   The  space  for  the  UFN
returned is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).

ldap_dn2dcedn() is used to turn a DN as returned by ldap_get_dn(3) into a DCE-style DN, e.g. a string with most-significant to least significant rdns separated by slashes ('/');
rdn components are separated by commas (',').  Only printable chars (e.g. LDAPv2 printable string) are allowed, at least in this implementation.   ldap_dcedn2dn()  performs  the
opposite  operation.   ldap_dn2ad_canonical() turns a DN into a AD canonical name, which is basically a DCE dn with attribute types omitted.  The trailing domain, if present, is
turned in a DNS-like domain.  The space for the returned value is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).

ERRORS
If an error occurs in ldap_get_dn(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  See ldap_error(3) for a description  of  possible
error codes.  ldap_explode_dn(), ldap_explode_rdn(), ldap_dn2ufn(), ldap_dn2dcedn(), ldap_dcedn2dn(), and ldap_dn2ad_canonical() will return NULL with errno(3) set appropriately
in case of trouble.

NOTES
These routines dynamically allocate memory that the caller must free.

SEE ALSO
ldap(3), ldap_error(3), ldap_first_entry(3), ldap_memfree(3), ldap_value_free(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_GET_DN(3)
LDAP_OPEN(3)                                                                    Library Functions Manual                                                                    LDAP_OPEN(3)

NAME
ldap_dup, ldap_destroy, - Duplicate and destroy LDAP session handles

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

LDAP *ldap_dup(
LDAP *old );

int ldap_destroy(
LDAP *old );

DESCRIPTION
ldap_dup()  duplicates  an  existing LDAP (LDAP *) session handle.  The new session handle may be used concurrently with the original session handle.  In a threaded environment,
different threads may execute concurrent requests on the same connection/session without fear of contamination.  Each session handle manages its own private error results.

ldap_destroy() destroys an existing session handle.

The ldap_dup() and ldap_destroy() functions are used in conjunction with a "thread safe" version of libldap (libldap_r) to enable operation thread safe API calls, so that a sin‐
gle session may be simultaneously used across multiple threads with consistent error handling.

When  a session is created through the use of one of the session creation functions including ldap_open(3), ldap_init(3), ldap_initialize(3) or ldap_init_fd(3) an LDAP * session
handle is returned to the application.  The session handle may be shared amongst threads, however the error codes are unique to a session handle.   Multiple  threads  performing
different operations using the same session handle will result in inconsistent error codes and return values.

To  prevent this confusion, ldap_dup() is used duplicate an existing session handle so that multiple threads can share the session, and maintain consistent error information and
results.

The message queues for a session are shared between sibling session handles.  Results of operations on a sibling session handles are accessible to all the sibling  session  han‐
dles.  Applications desiring results associated with a specific operation should provide the appropriate msgid to ldap_result().  Applications should avoid calling ldap_result()
with LDAP_RES_ANY as that may "steal" and return results in the calling thread that another operation in a different thread, using a different session  handle,  may  require  to
complete.

When ldap_unbind() is called on a session handle with siblings, all the siblings become invalid.

Siblings  must be destroyed using ldap_destroy().  Session handle resources associated with the original (LDAP *) will be freed when the last session handle is destroyed or when
ldap_unbind() is called, if no other session handles currently exist.

ERRORS
If an error occurs, ldap_dup() will return NULL and errno should be set appropriately.  ldap_destroy() will directly return the LDAP code associated to the error  (or  LDAP_SUC‐
CESS in case of success); errno should be set as well whenever appropriate.

SEE ALSO
ldap_open(3), ldap_init(3), ldap_initialize(3), ldap_init_fd(3), errno(3)

ACKNOWLEDGEMENTS
This  work is based on the previously proposed LDAP C API Concurrency Extensions draft (draft-zeilenga-ldap-c-api-concurrency-00.txt) effort.  OpenLDAP Software is developed and
maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                           LDAP_OPEN(3)
LDAP_ERROR(3)                                                                   Library Functions Manual                                                                   LDAP_ERROR(3)

NAME
ldap_perror, ld_errno, ldap_result2error, ldap_errlist, ldap_err2string - LDAP protocol error handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

char *ldap_err2string( int err );

DESCRIPTION
The  ldap_err2string()  routine  provides  short  description  of the various codes returned by routines in this library.  The returned string is a pointer to a static area that
should not be modified.

These codes are either negative, indicating an API error code; positive, indicating an LDAP resultCode other than 'success' (0), or - zero, indicating both successful use of the
API and the LDAP resultCode 'success' (0).

The   code  associated  with  an  LDAP  session  is  accessible  using  ldap_get_option(3)  and  ldap_set_option(3)  with  the  LDAP_OPT_RESULT_CODE  option  (previously  called
LDAP_OPT_ERROR_NUMBER).

PROTOCOL RESULT CODES
This section provides a partial list of protocol codes recognized by the library.  As LDAP is extensible, additional values may be returned.  A complete  listing  of  registered
LDAP result codes can be obtained from the Internet Assigned Numbers Authority &amp;lt;http://www.iana.org&amp;gt;.

LDAP_SUCCESS        The request was successful.

LDAP_OPERATIONS_ERROR
An operations error occurred.

LDAP_PROTOCOL_ERROR A protocol violation was detected.

LDAP_TIMELIMIT_EXCEEDED
An LDAP time limit was exceeded.

LDAP_SIZELIMIT_EXCEEDED
An LDAP size limit was exceeded.

LDAP_COMPARE_FALSE  A compare operation returned false.

LDAP_COMPARE_TRUE   A compare operation returned true.

LDAP_STRONG_AUTH_NOT_SUPPORTED
The LDAP server does not support strong authentication.

LDAP_STRONG_AUTH_REQUIRED
Strong authentication is required for the operation.

LDAP_PARTIAL_RESULTS
Partial results only returned.

LDAP_NO_SUCH_ATTRIBUTE
The attribute type specified does not exist in the entry.

LDAP_UNDEFINED_TYPE The attribute type specified is invalid.

LDAP_INAPPROPRIATE_MATCHING
Filter type not supported for the specified attribute.

LDAP_CONSTRAINT_VIOLATION
An attribute value specified violates some constraint (e.g., a postalAddress has too many lines, or a line that is too long).

LDAP_TYPE_OR_VALUE_EXISTS
An attribute type or attribute value specified already exists in the entry.

LDAP_INVALID_SYNTAX An invalid attribute value was specified.

LDAP_NO_SUCH_OBJECT The specified object does not exist in The Directory.

LDAP_ALIAS_PROBLEM  An alias in The Directory points to a nonexistent entry.

LDAP_INVALID_DN_SYNTAX
A syntactically invalid DN was specified.

LDAP_IS_LEAF        The object specified is a leaf.

LDAP_ALIAS_DEREF_PROBLEM
A problem was encountered when dereferencing an alias.

LDAP_INAPPROPRIATE_AUTH
Inappropriate authentication was specified (e.g., LDAP_AUTH_SIMPLE was specified and the entry does not have a userPassword attribute).

LDAP_INVALID_CREDENTIALS
Invalid credentials were presented (e.g., the wrong password).

LDAP_INSUFFICIENT_ACCESS
The user has insufficient access to perform the operation.

LDAP_BUSY           The DSA is busy.

LDAP_UNAVAILABLE    The DSA is unavailable.

LDAP_UNWILLING_TO_PERFORM
The DSA is unwilling to perform the operation.

LDAP_LOOP_DETECT    A loop was detected.

LDAP_NAMING_VIOLATION
A naming violation occurred.

LDAP_OBJECT_CLASS_VIOLATION
An object class violation occurred (e.g., a "must" attribute was missing from the entry).

LDAP_NOT_ALLOWED_ON_NONLEAF
The operation is not allowed on a nonleaf object.

LDAP_NOT_ALLOWED_ON_RDN
The operation is not allowed on an RDN.

LDAP_ALREADY_EXISTS The entry already exists.

LDAP_NO_OBJECT_CLASS_MODS
Object class modifications are not allowed.

LDAP_OTHER          An unknown error occurred.

API ERROR CODES
This  section  provides  a  complete list of API error codes recognized by the library.   Note that LDAP_SUCCESS indicates success of an API call in addition to representing the
return of the LDAP 'success' resultCode.

LDAP_SERVER_DOWN    The LDAP library can't contact the LDAP server.

LDAP_LOCAL_ERROR    Some local error occurred.  This is usually a failed dynamic memory allocation.

LDAP_ENCODING_ERROR An error was encountered encoding parameters to send to the LDAP server.

LDAP_DECODING_ERROR An error was encountered decoding a result from the LDAP server.

LDAP_TIMEOUT        A timelimit was exceeded while waiting for a result.

LDAP_AUTH_UNKNOWN   The authentication method specified to ldap_bind() is not known.

LDAP_FILTER_ERROR   An invalid filter was supplied to ldap_search() (e.g., unbalanced parentheses).

LDAP_PARAM_ERROR    An ldap routine was called with a bad parameter.

LDAP_NO_MEMORY      An memory allocation (e.g., malloc(3) or other dynamic memory allocator) call failed in an ldap library routine.

LDAP_USER_CANCELED  Indicates the user cancelled the operation.

LDAP_CONNECT_ERROR  Indicates a connection problem.

LDAP_NOT_SUPPORTED  Indicates the routine was called in a manner not supported by the library.

LDAP_CONTROL_NOT_FOUND
Indicates the control provided is unknown to the client library.

LDAP_NO_RESULTS_RETURNED
Indicates no results returned.

LDAP_MORE_RESULTS_TO_RETURN
Indicates more results could be returned.

LDAP_CLIENT_LOOP    Indicates the library has detected a loop in its processing.

LDAP_REFERRAL_LIMIT_EXCEEDED
Indicates the referral limit has been exceeded.

DEPRECATED
Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed
to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3),

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                          LDAP_ERROR(3)
LDAP_ERROR(3)                                                                   Library Functions Manual                                                                   LDAP_ERROR(3)

NAME
ldap_perror, ld_errno, ldap_result2error, ldap_errlist, ldap_err2string - LDAP protocol error handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

char *ldap_err2string( int err );

DESCRIPTION
The  ldap_err2string()  routine  provides  short  description  of the various codes returned by routines in this library.  The returned string is a pointer to a static area that
should not be modified.

These codes are either negative, indicating an API error code; positive, indicating an LDAP resultCode other than 'success' (0), or - zero, indicating both successful use of the
API and the LDAP resultCode 'success' (0).

The   code  associated  with  an  LDAP  session  is  accessible  using  ldap_get_option(3)  and  ldap_set_option(3)  with  the  LDAP_OPT_RESULT_CODE  option  (previously  called
LDAP_OPT_ERROR_NUMBER).

PROTOCOL RESULT CODES
This section provides a partial list of protocol codes recognized by the library.  As LDAP is extensible, additional values may be returned.  A complete  listing  of  registered
LDAP result codes can be obtained from the Internet Assigned Numbers Authority &amp;lt;http://www.iana.org&amp;gt;.

LDAP_SUCCESS        The request was successful.

LDAP_OPERATIONS_ERROR
An operations error occurred.

LDAP_PROTOCOL_ERROR A protocol violation was detected.

LDAP_TIMELIMIT_EXCEEDED
An LDAP time limit was exceeded.

LDAP_SIZELIMIT_EXCEEDED
An LDAP size limit was exceeded.

LDAP_COMPARE_FALSE  A compare operation returned false.

LDAP_COMPARE_TRUE   A compare operation returned true.

LDAP_STRONG_AUTH_NOT_SUPPORTED
The LDAP server does not support strong authentication.

LDAP_STRONG_AUTH_REQUIRED
Strong authentication is required for the operation.

LDAP_PARTIAL_RESULTS
Partial results only returned.

LDAP_NO_SUCH_ATTRIBUTE
The attribute type specified does not exist in the entry.

LDAP_UNDEFINED_TYPE The attribute type specified is invalid.

LDAP_INAPPROPRIATE_MATCHING
Filter type not supported for the specified attribute.

LDAP_CONSTRAINT_VIOLATION
An attribute value specified violates some constraint (e.g., a postalAddress has too many lines, or a line that is too long).

LDAP_TYPE_OR_VALUE_EXISTS
An attribute type or attribute value specified already exists in the entry.

LDAP_INVALID_SYNTAX An invalid attribute value was specified.

LDAP_NO_SUCH_OBJECT The specified object does not exist in The Directory.

LDAP_ALIAS_PROBLEM  An alias in The Directory points to a nonexistent entry.

LDAP_INVALID_DN_SYNTAX
A syntactically invalid DN was specified.

LDAP_IS_LEAF        The object specified is a leaf.

LDAP_ALIAS_DEREF_PROBLEM
A problem was encountered when dereferencing an alias.

LDAP_INAPPROPRIATE_AUTH
Inappropriate authentication was specified (e.g., LDAP_AUTH_SIMPLE was specified and the entry does not have a userPassword attribute).

LDAP_INVALID_CREDENTIALS
Invalid credentials were presented (e.g., the wrong password).

LDAP_INSUFFICIENT_ACCESS
The user has insufficient access to perform the operation.

LDAP_BUSY           The DSA is busy.

LDAP_UNAVAILABLE    The DSA is unavailable.

LDAP_UNWILLING_TO_PERFORM
The DSA is unwilling to perform the operation.

LDAP_LOOP_DETECT    A loop was detected.

LDAP_NAMING_VIOLATION
A naming violation occurred.

LDAP_OBJECT_CLASS_VIOLATION
An object class violation occurred (e.g., a "must" attribute was missing from the entry).

LDAP_NOT_ALLOWED_ON_NONLEAF
The operation is not allowed on a nonleaf object.

LDAP_NOT_ALLOWED_ON_RDN
The operation is not allowed on an RDN.

LDAP_ALREADY_EXISTS The entry already exists.

LDAP_NO_OBJECT_CLASS_MODS
Object class modifications are not allowed.

LDAP_OTHER          An unknown error occurred.

API ERROR CODES
This  section  provides  a  complete list of API error codes recognized by the library.   Note that LDAP_SUCCESS indicates success of an API call in addition to representing the
return of the LDAP 'success' resultCode.

LDAP_SERVER_DOWN    The LDAP library can't contact the LDAP server.

LDAP_LOCAL_ERROR    Some local error occurred.  This is usually a failed dynamic memory allocation.

LDAP_ENCODING_ERROR An error was encountered encoding parameters to send to the LDAP server.

LDAP_DECODING_ERROR An error was encountered decoding a result from the LDAP server.

LDAP_TIMEOUT        A timelimit was exceeded while waiting for a result.

LDAP_AUTH_UNKNOWN   The authentication method specified to ldap_bind() is not known.

LDAP_FILTER_ERROR   An invalid filter was supplied to ldap_search() (e.g., unbalanced parentheses).

LDAP_PARAM_ERROR    An ldap routine was called with a bad parameter.

LDAP_NO_MEMORY      An memory allocation (e.g., malloc(3) or other dynamic memory allocator) call failed in an ldap library routine.

LDAP_USER_CANCELED  Indicates the user cancelled the operation.

LDAP_CONNECT_ERROR  Indicates a connection problem.

LDAP_NOT_SUPPORTED  Indicates the routine was called in a manner not supported by the library.

LDAP_CONTROL_NOT_FOUND
Indicates the control provided is unknown to the client library.

LDAP_NO_RESULTS_RETURNED
Indicates no results returned.

LDAP_MORE_RESULTS_TO_RETURN
Indicates more results could be returned.

LDAP_CLIENT_LOOP    Indicates the library has detected a loop in its processing.

LDAP_REFERRAL_LIMIT_EXCEEDED
Indicates the referral limit has been exceeded.

DEPRECATED
Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed
to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3),

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                          LDAP_ERROR(3)
LDAP_ERROR(3)                                                                   Library Functions Manual                                                                   LDAP_ERROR(3)

NAME
ldap_perror, ld_errno, ldap_result2error, ldap_errlist, ldap_err2string - LDAP protocol error handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

char *ldap_err2string( int err );

DESCRIPTION
The  ldap_err2string()  routine  provides  short  description  of the various codes returned by routines in this library.  The returned string is a pointer to a static area that
should not be modified.

These codes are either negative, indicating an API error code; positive, indicating an LDAP resultCode other than 'success' (0), or - zero, indicating both successful use of the
API and the LDAP resultCode 'success' (0).

The   code  associated  with  an  LDAP  session  is  accessible  using  ldap_get_option(3)  and  ldap_set_option(3)  with  the  LDAP_OPT_RESULT_CODE  option  (previously  called
LDAP_OPT_ERROR_NUMBER).

PROTOCOL RESULT CODES
This section provides a partial list of protocol codes recognized by the library.  As LDAP is extensible, additional values may be returned.  A complete  listing  of  registered
LDAP result codes can be obtained from the Internet Assigned Numbers Authority &amp;lt;http://www.iana.org&amp;gt;.

LDAP_SUCCESS        The request was successful.

LDAP_OPERATIONS_ERROR
An operations error occurred.

LDAP_PROTOCOL_ERROR A protocol violation was detected.

LDAP_TIMELIMIT_EXCEEDED
An LDAP time limit was exceeded.

LDAP_SIZELIMIT_EXCEEDED
An LDAP size limit was exceeded.

LDAP_COMPARE_FALSE  A compare operation returned false.

LDAP_COMPARE_TRUE   A compare operation returned true.

LDAP_STRONG_AUTH_NOT_SUPPORTED
The LDAP server does not support strong authentication.

LDAP_STRONG_AUTH_REQUIRED
Strong authentication is required for the operation.

LDAP_PARTIAL_RESULTS
Partial results only returned.

LDAP_NO_SUCH_ATTRIBUTE
The attribute type specified does not exist in the entry.

LDAP_UNDEFINED_TYPE The attribute type specified is invalid.

LDAP_INAPPROPRIATE_MATCHING
Filter type not supported for the specified attribute.

LDAP_CONSTRAINT_VIOLATION
An attribute value specified violates some constraint (e.g., a postalAddress has too many lines, or a line that is too long).

LDAP_TYPE_OR_VALUE_EXISTS
An attribute type or attribute value specified already exists in the entry.

LDAP_INVALID_SYNTAX An invalid attribute value was specified.

LDAP_NO_SUCH_OBJECT The specified object does not exist in The Directory.

LDAP_ALIAS_PROBLEM  An alias in The Directory points to a nonexistent entry.

LDAP_INVALID_DN_SYNTAX
A syntactically invalid DN was specified.

LDAP_IS_LEAF        The object specified is a leaf.

LDAP_ALIAS_DEREF_PROBLEM
A problem was encountered when dereferencing an alias.

LDAP_INAPPROPRIATE_AUTH
Inappropriate authentication was specified (e.g., LDAP_AUTH_SIMPLE was specified and the entry does not have a userPassword attribute).

LDAP_INVALID_CREDENTIALS
Invalid credentials were presented (e.g., the wrong password).

LDAP_INSUFFICIENT_ACCESS
The user has insufficient access to perform the operation.

LDAP_BUSY           The DSA is busy.

LDAP_UNAVAILABLE    The DSA is unavailable.

LDAP_UNWILLING_TO_PERFORM
The DSA is unwilling to perform the operation.

LDAP_LOOP_DETECT    A loop was detected.

LDAP_NAMING_VIOLATION
A naming violation occurred.

LDAP_OBJECT_CLASS_VIOLATION
An object class violation occurred (e.g., a "must" attribute was missing from the entry).

LDAP_NOT_ALLOWED_ON_NONLEAF
The operation is not allowed on a nonleaf object.

LDAP_NOT_ALLOWED_ON_RDN
The operation is not allowed on an RDN.

LDAP_ALREADY_EXISTS The entry already exists.

LDAP_NO_OBJECT_CLASS_MODS
Object class modifications are not allowed.

LDAP_OTHER          An unknown error occurred.

API ERROR CODES
This  section  provides  a  complete list of API error codes recognized by the library.   Note that LDAP_SUCCESS indicates success of an API call in addition to representing the
return of the LDAP 'success' resultCode.

LDAP_SERVER_DOWN    The LDAP library can't contact the LDAP server.

LDAP_LOCAL_ERROR    Some local error occurred.  This is usually a failed dynamic memory allocation.

LDAP_ENCODING_ERROR An error was encountered encoding parameters to send to the LDAP server.

LDAP_DECODING_ERROR An error was encountered decoding a result from the LDAP server.

LDAP_TIMEOUT        A timelimit was exceeded while waiting for a result.

LDAP_AUTH_UNKNOWN   The authentication method specified to ldap_bind() is not known.

LDAP_FILTER_ERROR   An invalid filter was supplied to ldap_search() (e.g., unbalanced parentheses).

LDAP_PARAM_ERROR    An ldap routine was called with a bad parameter.

LDAP_NO_MEMORY      An memory allocation (e.g., malloc(3) or other dynamic memory allocator) call failed in an ldap library routine.

LDAP_USER_CANCELED  Indicates the user cancelled the operation.

LDAP_CONNECT_ERROR  Indicates a connection problem.

LDAP_NOT_SUPPORTED  Indicates the routine was called in a manner not supported by the library.

LDAP_CONTROL_NOT_FOUND
Indicates the control provided is unknown to the client library.

LDAP_NO_RESULTS_RETURNED
Indicates no results returned.

LDAP_MORE_RESULTS_TO_RETURN
Indicates more results could be returned.

LDAP_CLIENT_LOOP    Indicates the library has detected a loop in its processing.

LDAP_REFERRAL_LIMIT_EXCEEDED
Indicates the referral limit has been exceeded.

DEPRECATED
Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed
to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3),

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                          LDAP_ERROR(3)
LDAP_GET_DN(3)                                                                  Library Functions Manual                                                                  LDAP_GET_DN(3)

NAME
ldap_get_dn, ldap_explode_dn, ldap_explode_rdn, ldap_dn2ufn - LDAP DN handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

char *ldap_get_dn( LDAP *ld, LDAPMessage *entry )

int ldap_str2dn( const char *str, LDAPDN *dn, unsigned flags )

void ldap_dnfree( LDAPDN dn )

int ldap_dn2str( LDAPDN dn, char **str, unsigned flags )

char **ldap_explode_dn( const char *dn, int notypes )

char **ldap_explode_rdn( const char *rdn, int notypes )

char *ldap_dn2ufn( const char * dn )

char *ldap_dn2dcedn( const char * dn )

char *ldap_dcedn2dn( const char * dn )

char *ldap_dn2ad_canonical( const char * dn )

DESCRIPTION
These  routines  allow  LDAP entry names (Distinguished Names, or DNs) to be obtained, parsed, converted to a user-friendly form, and tested.  A DN has the form described in RFC
4414 "Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names".

The ldap_get_dn() routine takes an entry as returned by ldap_first_entry(3) or ldap_next_entry(3) and returns a copy of the entry's DN.  Space for the DN will be obtained dynam‐
ically and should be freed by the caller using ldap_memfree(3).

ldap_str2dn()  parses  a  string representation of a distinguished name contained in str into its components, which are stored in dn as ldap_ava structures, arranged in LDAPAVA,
LDAPRDN, and LDAPDN terms.  Space for dn will be obtained dynamically and should be freed by the caller using ldap_dnfree(3).  The LDAPDN is defined as:

typedef struct ldap_ava {
struct berval la_attr;
struct berval la_value;
unsigned la_flags;
} LDAPAVA;

typedef LDAPAVA** LDAPRDN;
typedef LDAPRDN* LDAPDN;

The attribute types and the attribute values are not normalized.  The la_flags can be either LDAP_AVA_STRING or LDAP_AVA_BINARY, the latter meaning that  the  value  is  BER/DER
encoded  and  thus must be represented as, quoting from RFC 4514, " ... an octothorpe character ('#' ASCII 35) followed by the hexadecimal representation of each of the bytes of
the BER encoding of the X.500 AttributeValue."  The flags parameter to ldap_str2dn() can be

LDAP_DN_FORMAT_LDAPV3
LDAP_DN_FORMAT_LDAPV2
LDAP_DN_FORMAT_DCE

which defines what DN syntax is expected (according to RFC 4514, RFC 1779 and DCE, respectively).  The format can be ORed to the flags

LDAP_DN_P_NO_SPACES
LDAP_DN_P_NO_SPACE_AFTER_RDN
...
LDAP_DN_PEDANTIC

The latter is a shortcut for all the previous limitations.

LDAP_DN_P_NO_SPACES does not allow extra spaces in the dn; the default is to  silently  eliminate  spaces  around  AVA  separators  ('='),  RDN  component  separators  ('+'  for
LDAPv3/LDAPv2 or ',' for DCE) and RDN separators (',' LDAPv3/LDAPv2 or '/' for DCE).

LDAP_DN_P_NO_SPACE_AFTER_RDN does not allow a single space after RDN separators.

ldap_dn2str() performs the inverse operation, yielding in str a string representation of dn.  It allows the same values for flags as ldap_str2dn(), plus

LDAP_DN_FORMAT_UFN
LDAP_DN_FORMAT_AD_CANONICAL

for user-friendly naming (RFC 1781) and AD canonical.

The following routines are viewed as deprecated in favor of ldap_str2dn() and ldap_dn2str().  They are provided to support legacy applications.

The  ldap_explode_dn()  routine  takes a DN as returned by ldap_get_dn() and breaks it up into its component parts.  Each part is known as a Relative Distinguished Name, or RDN.
ldap_explode_dn() returns a NULL-terminated array, each component of which contains an RDN from the DN.  The notypes parameter is used to request that only  the  RDN  values  be
returned,  not their types.  For example, the DN "cn=Bob, c=US" would return as either { "cn=Bob", "c=US", NULL } or { "Bob", "US", NULL }, depending on whether notypes was 0 or
1, respectively.  Assertion values in RDN strings may included escaped characters.  The result can be freed by calling ldap_value_free(3).

Similarly, the ldap_explode_rdn() routine takes an RDN as returned by ldap_explode_dn(dn,0) and breaks it up into its "type=value" component  parts  (or  just  "value",  if  the
notypes parameter is set).  Note the value is not unescaped.  The result can be freed by calling ldap_value_free(3).

ldap_dn2ufn() is used to turn a DN as returned by ldap_get_dn(3) into a more user-friendly form, stripping off all type names.  See "Using the Directory to Achieve User Friendly
Naming" (RFC 1781) for more details on the UFN format.  Due to the ambiguous nature of the format, it is generally only used  for  display  purposes.   The  space  for  the  UFN
returned is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).

ldap_dn2dcedn() is used to turn a DN as returned by ldap_get_dn(3) into a DCE-style DN, e.g. a string with most-significant to least significant rdns separated by slashes ('/');
rdn components are separated by commas (',').  Only printable chars (e.g. LDAPv2 printable string) are allowed, at least in this implementation.   ldap_dcedn2dn()  performs  the
opposite  operation.   ldap_dn2ad_canonical() turns a DN into a AD canonical name, which is basically a DCE dn with attribute types omitted.  The trailing domain, if present, is
turned in a DNS-like domain.  The space for the returned value is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).

ERRORS
If an error occurs in ldap_get_dn(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  See ldap_error(3) for a description  of  possible
error codes.  ldap_explode_dn(), ldap_explode_rdn(), ldap_dn2ufn(), ldap_dn2dcedn(), ldap_dcedn2dn(), and ldap_dn2ad_canonical() will return NULL with errno(3) set appropriately
in case of trouble.

NOTES
These routines dynamically allocate memory that the caller must free.

SEE ALSO
ldap(3), ldap_error(3), ldap_first_entry(3), ldap_memfree(3), ldap_value_free(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_GET_DN(3)
LDAP_GET_DN(3)                                                                  Library Functions Manual                                                                  LDAP_GET_DN(3)

NAME
ldap_get_dn, ldap_explode_dn, ldap_explode_rdn, ldap_dn2ufn - LDAP DN handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

char *ldap_get_dn( LDAP *ld, LDAPMessage *entry )

int ldap_str2dn( const char *str, LDAPDN *dn, unsigned flags )

void ldap_dnfree( LDAPDN dn )

int ldap_dn2str( LDAPDN dn, char **str, unsigned flags )

char **ldap_explode_dn( const char *dn, int notypes )

char **ldap_explode_rdn( const char *rdn, int notypes )

char *ldap_dn2ufn( const char * dn )

char *ldap_dn2dcedn( const char * dn )

char *ldap_dcedn2dn( const char * dn )

char *ldap_dn2ad_canonical( const char * dn )

DESCRIPTION
These  routines  allow  LDAP entry names (Distinguished Names, or DNs) to be obtained, parsed, converted to a user-friendly form, and tested.  A DN has the form described in RFC
4414 "Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names".

The ldap_get_dn() routine takes an entry as returned by ldap_first_entry(3) or ldap_next_entry(3) and returns a copy of the entry's DN.  Space for the DN will be obtained dynam‐
ically and should be freed by the caller using ldap_memfree(3).

ldap_str2dn()  parses  a  string representation of a distinguished name contained in str into its components, which are stored in dn as ldap_ava structures, arranged in LDAPAVA,
LDAPRDN, and LDAPDN terms.  Space for dn will be obtained dynamically and should be freed by the caller using ldap_dnfree(3).  The LDAPDN is defined as:

typedef struct ldap_ava {
struct berval la_attr;
struct berval la_value;
unsigned la_flags;
} LDAPAVA;

typedef LDAPAVA** LDAPRDN;
typedef LDAPRDN* LDAPDN;

The attribute types and the attribute values are not normalized.  The la_flags can be either LDAP_AVA_STRING or LDAP_AVA_BINARY, the latter meaning that  the  value  is  BER/DER
encoded  and  thus must be represented as, quoting from RFC 4514, " ... an octothorpe character ('#' ASCII 35) followed by the hexadecimal representation of each of the bytes of
the BER encoding of the X.500 AttributeValue."  The flags parameter to ldap_str2dn() can be

LDAP_DN_FORMAT_LDAPV3
LDAP_DN_FORMAT_LDAPV2
LDAP_DN_FORMAT_DCE

which defines what DN syntax is expected (according to RFC 4514, RFC 1779 and DCE, respectively).  The format can be ORed to the flags

LDAP_DN_P_NO_SPACES
LDAP_DN_P_NO_SPACE_AFTER_RDN
...
LDAP_DN_PEDANTIC

The latter is a shortcut for all the previous limitations.

LDAP_DN_P_NO_SPACES does not allow extra spaces in the dn; the default is to  silently  eliminate  spaces  around  AVA  separators  ('='),  RDN  component  separators  ('+'  for
LDAPv3/LDAPv2 or ',' for DCE) and RDN separators (',' LDAPv3/LDAPv2 or '/' for DCE).

LDAP_DN_P_NO_SPACE_AFTER_RDN does not allow a single space after RDN separators.

ldap_dn2str() performs the inverse operation, yielding in str a string representation of dn.  It allows the same values for flags as ldap_str2dn(), plus

LDAP_DN_FORMAT_UFN
LDAP_DN_FORMAT_AD_CANONICAL

for user-friendly naming (RFC 1781) and AD canonical.

The following routines are viewed as deprecated in favor of ldap_str2dn() and ldap_dn2str().  They are provided to support legacy applications.

The  ldap_explode_dn()  routine  takes a DN as returned by ldap_get_dn() and breaks it up into its component parts.  Each part is known as a Relative Distinguished Name, or RDN.
ldap_explode_dn() returns a NULL-terminated array, each component of which contains an RDN from the DN.  The notypes parameter is used to request that only  the  RDN  values  be
returned,  not their types.  For example, the DN "cn=Bob, c=US" would return as either { "cn=Bob", "c=US", NULL } or { "Bob", "US", NULL }, depending on whether notypes was 0 or
1, respectively.  Assertion values in RDN strings may included escaped characters.  The result can be freed by calling ldap_value_free(3).

Similarly, the ldap_explode_rdn() routine takes an RDN as returned by ldap_explode_dn(dn,0) and breaks it up into its "type=value" component  parts  (or  just  "value",  if  the
notypes parameter is set).  Note the value is not unescaped.  The result can be freed by calling ldap_value_free(3).

ldap_dn2ufn() is used to turn a DN as returned by ldap_get_dn(3) into a more user-friendly form, stripping off all type names.  See "Using the Directory to Achieve User Friendly
Naming" (RFC 1781) for more details on the UFN format.  Due to the ambiguous nature of the format, it is generally only used  for  display  purposes.   The  space  for  the  UFN
returned is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).

ldap_dn2dcedn() is used to turn a DN as returned by ldap_get_dn(3) into a DCE-style DN, e.g. a string with most-significant to least significant rdns separated by slashes ('/');
rdn components are separated by commas (',').  Only printable chars (e.g. LDAPv2 printable string) are allowed, at least in this implementation.   ldap_dcedn2dn()  performs  the
opposite  operation.   ldap_dn2ad_canonical() turns a DN into a AD canonical name, which is basically a DCE dn with attribute types omitted.  The trailing domain, if present, is
turned in a DNS-like domain.  The space for the returned value is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).

ERRORS
If an error occurs in ldap_get_dn(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  See ldap_error(3) for a description  of  possible
error codes.  ldap_explode_dn(), ldap_explode_rdn(), ldap_dn2ufn(), ldap_dn2dcedn(), ldap_dcedn2dn(), and ldap_dn2ad_canonical() will return NULL with errno(3) set appropriately
in case of trouble.

NOTES
These routines dynamically allocate memory that the caller must free.

SEE ALSO
ldap(3), ldap_error(3), ldap_first_entry(3), ldap_memfree(3), ldap_value_free(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_GET_DN(3)
LDAP_EXTENDED_OPERATION(3)                                                      Library Functions Manual                                                      LDAP_EXTENDED_OPERATION(3)

NAME
ldap_extended_operation, ldap_extended_operation_s - Extends the LDAP operations to the LDAP server.

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_extended_operation(
LDAP *ld,
const char *requestoid,
const struct berval *requestdata,
LDAPControl **sctrls,
LDAPControl **cctrls,
int *msgidp );

int ldap_extended_operation_s(
LDAP *ld,
const char *requestoid,
const struct berval *requestdata,
LDAPControl **sctrls,
LDAPControl **cctrls,
char **retoidp,
struct berval **retdatap );

DESCRIPTION
The  ldap_extended_operation_s() routine is used to synchronously perform an LDAP extended operation.  It takes requestoid, which points to a dotted-decimal OID string identify‐
ing the extended operation to perform. requestdata is the data required for the request, sctrls is an array of LDAPControl structures to use with this extended operation, cctrls
is an array of LDAPControl structures that list the client controls to use with this extended operation.

The output parameter retoidp points to a dotted-decimal OID string returned by the LDAP server.  The memory used by the string should be freed with the ldap_memfree(3) function.
The output parameter retdatap points to a pointer to a berval structure that contains the returned data.  If no data is returned by the server, the pointer is set this to  NULL.
The memory used by this structure should be freed with the ber_bvfree(3) function.

The  ldap_extended_operation()  works  just  like  ldap_extended_operation_s(), but the operation is asynchronous.  It provides the message id of the request it initiated in the
integer pointed to be msgidp.  The result of this operation can be obtained by calling ldap_result(3).

SEE ALSO
ber_bvfree(3), ldap_memfree(3), ldap_parse_extended_result(3), ldap_result(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                             LDAP_EXTENDED_OPERATION(3)
LDAP_EXTENDED_OPERATION(3)                                                      Library Functions Manual                                                      LDAP_EXTENDED_OPERATION(3)

NAME
ldap_extended_operation, ldap_extended_operation_s - Extends the LDAP operations to the LDAP server.

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_extended_operation(
LDAP *ld,
const char *requestoid,
const struct berval *requestdata,
LDAPControl **sctrls,
LDAPControl **cctrls,
int *msgidp );

int ldap_extended_operation_s(
LDAP *ld,
const char *requestoid,
const struct berval *requestdata,
LDAPControl **sctrls,
LDAPControl **cctrls,
char **retoidp,
struct berval **retdatap );

DESCRIPTION
The  ldap_extended_operation_s() routine is used to synchronously perform an LDAP extended operation.  It takes requestoid, which points to a dotted-decimal OID string identify‐
ing the extended operation to perform. requestdata is the data required for the request, sctrls is an array of LDAPControl structures to use with this extended operation, cctrls
is an array of LDAPControl structures that list the client controls to use with this extended operation.

The output parameter retoidp points to a dotted-decimal OID string returned by the LDAP server.  The memory used by the string should be freed with the ldap_memfree(3) function.
The output parameter retdatap points to a pointer to a berval structure that contains the returned data.  If no data is returned by the server, the pointer is set this to  NULL.
The memory used by this structure should be freed with the ber_bvfree(3) function.

The  ldap_extended_operation()  works  just  like  ldap_extended_operation_s(), but the operation is asynchronous.  It provides the message id of the request it initiated in the
integer pointed to be msgidp.  The result of this operation can be obtained by calling ldap_result(3).

SEE ALSO
ber_bvfree(3), ldap_memfree(3), ldap_parse_extended_result(3), ldap_result(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                             LDAP_EXTENDED_OPERATION(3)
LDAP_FIRST_ATTRIBUTE(3)                                                         Library Functions Manual                                                         LDAP_FIRST_ATTRIBUTE(3)

NAME
ldap_first_attribute, ldap_next_attribute - step through LDAP entry attributes

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

char *ldap_first_attribute(
LDAP *ld, LDAPMessage *entry, BerElement **berptr )

char *ldap_next_attribute(
LDAP *ld, LDAPMessage *entry, BerElement *ber )

DESCRIPTION
The  ldap_first_attribute()  and  ldap_next_attribute()  routines are used to step through the attributes in an LDAP entry.  ldap_first_attribute() takes an entry as returned by
ldap_first_entry(3) or ldap_next_entry(3) and returns a pointer to character string containing the first attribute description in the entry.  ldap_next_attribute()  returns  the
next attribute description in the entry.

It  also  returns,  in  berptr,  a  pointer  to  a  BerElement  it  has  allocated  to  keep track of its current position.  This pointer should be passed to subsequent calls to
ldap_next_attribute() and is used to effectively step through the entry's attributes.  The caller is solely responsible for freeing the BerElement pointed to by berptr  when  it
is no longer needed by calling ber_free(3).  When calling ber_free(3) in this instance, be sure the second argument is 0.

The attribute names returned are suitable for inclusion in a call to ldap_get_values(3) to retrieve the attribute's values.

ERRORS
If an error occurs, NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  See ldap_error(3) for a description of possible error codes.

NOTES
The ldap_first_attribute() and ldap_next_attribute() return dynamically allocated memory that must be freed by the caller via ldap_memfree(3).

SEE ALSO
ldap(3), ldap_first_entry(3), ldap_get_values(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                LDAP_FIRST_ATTRIBUTE(3)
LDAP_FIRST_ENTRY(3)                                                             Library Functions Manual                                                             LDAP_FIRST_ENTRY(3)

NAME
ldap_first_entry, ldap_next_entry, ldap_count_entries - LDAP result entry parsing and counting routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_count_entries( LDAP *ld, LDAPMessage *result )

LDAPMessage *ldap_first_entry( LDAP *ld, LDAPMessage *result )

LDAPMessage *ldap_next_entry( LDAP *ld, LDAPMessage *entry )

DESCRIPTION
These routines are used to parse results received from ldap_result(3) or the synchronous LDAP search operation routines ldap_search_s(3) and ldap_search_st(3).

The ldap_first_entry() routine is used to retrieve the first entry in a chain of search results.  It takes the result as returned by a call to ldap_result(3) or ldap_search_s(3)
or ldap_search_st(3) and returns a pointer to the first entry in the result.

This pointer should be supplied on a subsequent call to ldap_next_entry() to get the next entry, the result of which should be supplied to the next  call  to  ldap_next_entry(),
etc.   ldap_next_entry()  will  return NULL when there are no more entries.  The entries returned from these calls are used in calls to the routines described in ldap_get_dn(3),
ldap_first_attribute(3), ldap_get_values(3), etc.

A count of the number of entries in the search result can be obtained by calling ldap_count_entries().

ERRORS
If an error occurs in ldap_first_entry() or ldap_next_entry(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  If an error  occurs  in
ldap_count_entries(), -1 is returned, and ld_errno is set appropriately.  See ldap_error(3) for a description of possible error codes.

SEE ALSO
ldap(3), ldap_result(3), ldap_search(3), ldap_first_attribute(3), ldap_get_values(3), ldap_get_dn(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                    LDAP_FIRST_ENTRY(3)
LDAP_FIRST_MESSAGE(3)                                                           Library Functions Manual                                                           LDAP_FIRST_MESSAGE(3)

NAME
ldap_first_message, ldap_next_message, ldap_count_messages - Stepping through messages in a result chain

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_count_messages( LDAP *ld, LDAPMessage *result )

LDAPMessage *ldap_first_message( LDAP *ld, LDAPMessage *result )

LDAPMessage *ldap_next_message( LDAP *ld, LDAPMessage *message )

DESCRIPTION
These  routines  are  used  to step through the messages in a result chain received from ldap_result(3).  For search operations, the result chain can contain referral, entry and
result messages. The ldap_msgtype(3) function can be used to distinguish between the different message types.

The ldap_first_message() routine is used to retrieve the first message in a result chain.  It takes the result as returned by  a  call  to  ldap_result(3),  ldap_search_s(3)  or
ldap_search_st(3) and returns a pointer to the first message in the result chain.

This  pointer  should  be supplied on a subsequent call to ldap_next_message() to get the next message, the result of which should be supplied to the next call to ldap_next_mes‐
sage(), etc.  ldap_next_message() will return NULL when there are no more messages.

These functions are useful when using routines like ldap_parse_result(3) that only operate on the first result in the chain.

A count of the number of messages in the result chain can be obtained by calling ldap_count_messages().  It can also be used to count the number of remaining messages in a chain
if  called  with  a  message,  entry  or  reference  returned  by  ldap_first_message() , ldap_next_message() , ldap_first_entry(3), ldap_next_entry(3), ldap_first_reference(3),
ldap_next_reference(3).

ERRORS
If an error occurs in ldap_first_message() or ldap_next_message(), NULL is returned.  If an error occurs in ldap_count_messages(), -1 is returned.

SEE ALSO
ldap(3), ldap_search(3), ldap_result(3), ldap_parse_result(3), ldap_first_entry(3), ldap_first_reference(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                  LDAP_FIRST_MESSAGE(3)
LDAP_FIRST_REFERENCE(3)                                                         Library Functions Manual                                                         LDAP_FIRST_REFERENCE(3)

NAME
ldap_first_reference, ldap_next_reference, ldap_count_references - Stepping through continuation references in a result chain

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_count_references( LDAP *ld, LDAPMessage *result )

LDAPMessage *ldap_first_reference( LDAP *ld, LDAPMessage *result )

LDAPMessage *ldap_next_reference( LDAP *ld, LDAPMessage *reference )

DESCRIPTION
These routines are used to step through the continuation references in a result chain received from ldap_result(3) or the synchronous LDAP search operation routines.

The  ldap_first_reference()  routine  is  used  to  retrieve  the  first  reference  message  in  a  result  chain.  It takes the result as returned by a call to ldap_result(3),
ldap_search_s(3) or ldap_search_st(3) and returns a pointer to the first reference message in the result chain.

This pointer should be supplied on a subsequent call to ldap_next_reference() to get the next reference message, the result of which should be  supplied  to  the  next  call  to
ldap_next_reference(),  etc.   ldap_next_reference()  will  return  NULL when there are no more reference messages.  The reference messages returned from these calls are used by
ldap_parse_reference(3) to extract referrals and controls.

A count of the number of reference messages in the search result can be obtained by calling ldap_count_references().  It can also be used to count the number of  reference  mes‐
sages remaining in a result chain.

ERRORS
If an error occurs in ldap_first_reference() or ldap_next_reference(), NULL is returned.  If an error occurs in ldap_count_references(), -1 is returned.

SEE ALSO
ldap(3), ldap_result(3), ldap_search(3), ldap_parse_reference(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                LDAP_FIRST_REFERENCE(3)
LDAP_URL(3)                                                                     Library Functions Manual                                                                     LDAP_URL(3)

NAME
ldap_is_ldap_url, ldap_url_parse, ldap_free_urldesc - LDAP Uniform Resource Locator routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_is_ldap_url( const char *url )

int ldap_url_parse( const char *url, LDAPURLDesc **ludpp )

typedef struct ldap_url_desc {
char *      lud_scheme;     /* URI scheme */
char *      lud_host;       /* LDAP host to contact */
int         lud_port;       /* port on host */
char *      lud_dn;         /* base for search */
char **     lud_attrs;      /* list of attributes */
int         lud_scope;      /* a LDAP_SCOPE_... value */
char *      lud_filter;     /* LDAP search filter */
char **     lud_exts;       /* LDAP extensions */
int         lud_crit_exts;  /* true if any extension is critical */
/* may contain additional fields for internal use */
} LDAPURLDesc;

void ldap_free_urldesc( LDAPURLDesc *ludp );

DESCRIPTION
These routines support the use of LDAP URLs (Uniform Resource Locators) as detailed in RFC 4516.  LDAP URLs look like this:

ldap://hostport/dn[?attrs[?scope[?filter[?exts]]]]

where:
hostport is a host name with an optional ":portnumber"
dn is the search base
attrs is a comma separated list of attributes to request
scope is one of these three strings:
base one sub (default=base)
filter is filter
exts are recognized set of LDAP and/or API extensions.

Example:
ldap://ldap.example.net/dc=example,dc=net?cn,sn?sub?(cn=*)

URLs  that are wrapped in angle-brackets and/or preceded by "URL:" are also tolerated.  Alternative LDAP schemes such as ldaps:// and ldapi:// may be parsed using the below rou‐
tines as well.

ldap_is_ldap_url() returns a non-zero value if url looks like an LDAP URL (as opposed to some other kind of URL).  It can be  used  as  a  quick  check  for  an  LDAP  URL;  the
ldap_url_parse() routine should be used if a more thorough check is needed.

ldap_url_parse() breaks down an LDAP URL passed in url into its component pieces.  If successful, zero is returned, an LDAP URL description is allocated, filled in, and ludpp is
set to point to it.  If an error occurs, a non-zero URL error code is returned.

ldap_free_urldesc() should be called to free an LDAP URL description that was obtained from a call to ldap_url_parse().

SEE ALSO
ldap(3)
RFC 4516 &amp;lt;http://www.rfc-editor.org/rfc/rfc4516.txt&amp;gt;

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                            LDAP_URL(3)
LDAP_GET_DN(3)                                                                  Library Functions Manual                                                                  LDAP_GET_DN(3)

NAME
ldap_get_dn, ldap_explode_dn, ldap_explode_rdn, ldap_dn2ufn - LDAP DN handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

char *ldap_get_dn( LDAP *ld, LDAPMessage *entry )

int ldap_str2dn( const char *str, LDAPDN *dn, unsigned flags )

void ldap_dnfree( LDAPDN dn )

int ldap_dn2str( LDAPDN dn, char **str, unsigned flags )

char **ldap_explode_dn( const char *dn, int notypes )

char **ldap_explode_rdn( const char *rdn, int notypes )

char *ldap_dn2ufn( const char * dn )

char *ldap_dn2dcedn( const char * dn )

char *ldap_dcedn2dn( const char * dn )

char *ldap_dn2ad_canonical( const char * dn )

DESCRIPTION
These  routines  allow  LDAP entry names (Distinguished Names, or DNs) to be obtained, parsed, converted to a user-friendly form, and tested.  A DN has the form described in RFC
4414 "Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names".

The ldap_get_dn() routine takes an entry as returned by ldap_first_entry(3) or ldap_next_entry(3) and returns a copy of the entry's DN.  Space for the DN will be obtained dynam‐
ically and should be freed by the caller using ldap_memfree(3).

ldap_str2dn()  parses  a  string representation of a distinguished name contained in str into its components, which are stored in dn as ldap_ava structures, arranged in LDAPAVA,
LDAPRDN, and LDAPDN terms.  Space for dn will be obtained dynamically and should be freed by the caller using ldap_dnfree(3).  The LDAPDN is defined as:

typedef struct ldap_ava {
struct berval la_attr;
struct berval la_value;
unsigned la_flags;
} LDAPAVA;

typedef LDAPAVA** LDAPRDN;
typedef LDAPRDN* LDAPDN;

The attribute types and the attribute values are not normalized.  The la_flags can be either LDAP_AVA_STRING or LDAP_AVA_BINARY, the latter meaning that  the  value  is  BER/DER
encoded  and  thus must be represented as, quoting from RFC 4514, " ... an octothorpe character ('#' ASCII 35) followed by the hexadecimal representation of each of the bytes of
the BER encoding of the X.500 AttributeValue."  The flags parameter to ldap_str2dn() can be

LDAP_DN_FORMAT_LDAPV3
LDAP_DN_FORMAT_LDAPV2
LDAP_DN_FORMAT_DCE

which defines what DN syntax is expected (according to RFC 4514, RFC 1779 and DCE, respectively).  The format can be ORed to the flags

LDAP_DN_P_NO_SPACES
LDAP_DN_P_NO_SPACE_AFTER_RDN
...
LDAP_DN_PEDANTIC

The latter is a shortcut for all the previous limitations.

LDAP_DN_P_NO_SPACES does not allow extra spaces in the dn; the default is to  silently  eliminate  spaces  around  AVA  separators  ('='),  RDN  component  separators  ('+'  for
LDAPv3/LDAPv2 or ',' for DCE) and RDN separators (',' LDAPv3/LDAPv2 or '/' for DCE).

LDAP_DN_P_NO_SPACE_AFTER_RDN does not allow a single space after RDN separators.

ldap_dn2str() performs the inverse operation, yielding in str a string representation of dn.  It allows the same values for flags as ldap_str2dn(), plus

LDAP_DN_FORMAT_UFN
LDAP_DN_FORMAT_AD_CANONICAL

for user-friendly naming (RFC 1781) and AD canonical.

The following routines are viewed as deprecated in favor of ldap_str2dn() and ldap_dn2str().  They are provided to support legacy applications.

The  ldap_explode_dn()  routine  takes a DN as returned by ldap_get_dn() and breaks it up into its component parts.  Each part is known as a Relative Distinguished Name, or RDN.
ldap_explode_dn() returns a NULL-terminated array, each component of which contains an RDN from the DN.  The notypes parameter is used to request that only  the  RDN  values  be
returned,  not their types.  For example, the DN "cn=Bob, c=US" would return as either { "cn=Bob", "c=US", NULL } or { "Bob", "US", NULL }, depending on whether notypes was 0 or
1, respectively.  Assertion values in RDN strings may included escaped characters.  The result can be freed by calling ldap_value_free(3).

Similarly, the ldap_explode_rdn() routine takes an RDN as returned by ldap_explode_dn(dn,0) and breaks it up into its "type=value" component  parts  (or  just  "value",  if  the
notypes parameter is set).  Note the value is not unescaped.  The result can be freed by calling ldap_value_free(3).

ldap_dn2ufn() is used to turn a DN as returned by ldap_get_dn(3) into a more user-friendly form, stripping off all type names.  See "Using the Directory to Achieve User Friendly
Naming" (RFC 1781) for more details on the UFN format.  Due to the ambiguous nature of the format, it is generally only used  for  display  purposes.   The  space  for  the  UFN
returned is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).

ldap_dn2dcedn() is used to turn a DN as returned by ldap_get_dn(3) into a DCE-style DN, e.g. a string with most-significant to least significant rdns separated by slashes ('/');
rdn components are separated by commas (',').  Only printable chars (e.g. LDAPv2 printable string) are allowed, at least in this implementation.   ldap_dcedn2dn()  performs  the
opposite  operation.   ldap_dn2ad_canonical() turns a DN into a AD canonical name, which is basically a DCE dn with attribute types omitted.  The trailing domain, if present, is
turned in a DNS-like domain.  The space for the returned value is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).

ERRORS
If an error occurs in ldap_get_dn(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  See ldap_error(3) for a description  of  possible
error codes.  ldap_explode_dn(), ldap_explode_rdn(), ldap_dn2ufn(), ldap_dn2dcedn(), ldap_dcedn2dn(), and ldap_dn2ad_canonical() will return NULL with errno(3) set appropriately
in case of trouble.

NOTES
These routines dynamically allocate memory that the caller must free.

SEE ALSO
ldap(3), ldap_error(3), ldap_first_entry(3), ldap_memfree(3), ldap_value_free(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_GET_DN(3)
LDAP_GET_OPTION(3)                                                              Library Functions Manual                                                              LDAP_GET_OPTION(3)

NAME
ldap_get_option, ldap_set_option - LDAP option handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_get_option(LDAP *ld, int option, void *outvalue);

int ldap_set_option(LDAP *ld, int option, const void *invalue);

DESCRIPTION
These  routines  provide  access  to  options stored either in a LDAP handle or as global options, where applicable.  They make use of a neutral interface, where the type of the
value either retrieved by ldap_get_option(3) or set by ldap_set_option(3) is cast to void *.  The actual type is determined based on the value of the  option  argument.   Global
options are set/retrieved by passing a NULL LDAP handle. LDAP handles inherit their default settings from the global options in effect at the time the handle is created.

LDAP_OPT_API_FEATURE_INFO
Fills-in  a  LDAPAPIFeatureInfo;  outvalue  must be a LDAPAPIFeatureInfo *, pointing to an already allocated struct.  The ldapaif_info_version field of the struct must be
initialized to LDAP_FEATURE_INFO_VERSION before making the call. The ldapaif_name field must be set to the name of a feature to query.  This is a read-only option.

LDAP_OPT_API_INFO
Fills-in a LDAPAPIInfo; outvalue must be a LDAPAPIInfo *, pointing to an already allocated struct. The ldapai_info_version field of the  struct  must  be  initialized  to
LDAP_API_INFO_VERSION  before  making  the  call.   If the version passed in does not match the current library version, the expected version number will be stored in the
struct and the call will fail.  The caller is responsible for freeing the elements of the ldapai_extensions array and the array itself using ldap_memfree(3).  The  caller
must also free the ldapi_vendor_name.  This is a read-only option.

LDAP_OPT_CLIENT_CONTROLS
Sets/gets the client-side controls to be used for all operations.  This is now deprecated as modern LDAP C API provides replacements for all main operations which accepts
client-side controls as explicit arguments; see for example ldap_search_ext(3), ldap_add_ext(3), ldap_modify_ext(3) and so on.  outvalue must be LDAPControl ***, and  the
caller  is  responsible of freeing the returned controls, if any, by calling ldap_controls_free(3), while invalue must be LDAPControl *const *; the library duplicates the
controls passed via invalue.

LDAP_OPT_CONNECT_ASYNC
Sets/gets the status of the asynchronous connect flag.  invalue should either be LDAP_OPT_OFF or LDAP_OPT_ON; outvalue must be int *.  When set,  the  library  will  call
connect(2)  and return, without waiting for response.  This leaves the handle in a connecting state.  Subsequent calls to library routines will poll for completion of the
connect before performing further operations.  As a consequence, library calls that need to establish a connection with a DSA do not block even for  the  network  timeout
(option LDAP_OPT_NETWORK_TIMEOUT).  This option is OpenLDAP specific.

LDAP_OPT_CONNECT_CB
This option allows to set a connect callback.  invalue must be a const struct ldap_conncb *.  Callbacks are executed in last in-first served order.  Handle-specific call‐
backs are executed first, followed by global ones.  Right before freeing the callback  structure,  the  lc_del  callback  handler  is  passed  a  NULL  Sockbuf.   Calling
ldap_get_option(3) for this option removes the callback whose pointer matches outvalue.  This option is OpenLDAP specific.

LDAP_OPT_DEBUG_LEVEL
Sets/gets  the  debug  level  of  the  client  library.  invalue must be a const int *; outvalue must be a int *.  Valid debug levels are LDAP_DEBUG_ANY, LDAP_DEBUG_ARGS,
LDAP_DEBUG_BER, LDAP_DEBUG_CONNS, LDAP_DEBUG_NONE, LDAP_DEBUG_PACKETS, LDAP_DEBUG_PARSE, and LDAP_DEBUG_TRACE.  This option is OpenLDAP specific.

LDAP_OPT_DEFBASE
Sets/gets a string containing the DN to be used as default base for search operations.  outvalue must be a char **, and the caller is responsible of freeing the  returned
string by calling ldap_memfree(3), while invalue must be a const char *; the library duplicates the corresponding string.  This option is OpenLDAP specific.

LDAP_OPT_DEREF
Sets/gets  the  value that defines when alias dereferencing must occur.  invalue must be const int *; outvalue must be int *.  They cannot be NULL.  The value of *invalue
should be one of LDAP_DEREF_NEVER (the default), LDAP_DEREF_SEARCHING, LDAP_DEREF_FINDING, or LDAP_DEREF_ALWAYS.  Note that this has ever been the only means to determine
alias dereferencing within search operations.

LDAP_OPT_DESC
Returns the file descriptor associated to the socket buffer of the LDAP handle passed in as ld; outvalue must be a int *.  This is a read-only, handle-specific option.

LDAP_OPT_DIAGNOSTIC_MESSAGE
Sets/gets  a  string containing the error string associated to the LDAP handle.  This option was formerly known as LDAP_OPT_ERROR_STRING.  outvalue must be a char **, and
the caller is responsible of freeing the returned string by calling ldap_memfree(3), while invalue must be a char *; the library duplicates the corresponding string.

LDAP_OPT_HOST_NAME
Sets/gets a space-separated list of hosts to be contacted by the library when trying to establish a connection.  This is now deprecated in favor  of  LDAP_OPT_URI.   out‐
value  must  be  a  char  **,  and the caller is responsible of freeing the resulting string by calling ldap_memfree(3), while invalue must be a const char *; the library
duplicates the corresponding string.

LDAP_OPT_MATCHED_DN
Sets/gets a string containing the matched DN associated to the LDAP handle.  outvalue must be a char **, and the caller is responsible of freeing the returned  string  by
calling ldap_memfree(3), while invalue must be a const char *; the library duplicates the corresponding string.

LDAP_OPT_NETWORK_TIMEOUT
Sets/gets the network timeout value after which poll(2)/select(2) following a connect(2) returns in case of no activity.  outvalue must be a struct timeval ** (the caller
has to free *outvalue), and invalue must be a const struct timeval *.  They cannot be NULL. Using a struct with seconds set to -1 results in an infinite timeout, which is
the default.  This option is OpenLDAP specific.

LDAP_OPT_PROTOCOL_VERSION
Sets/gets the protocol version.  outvalue and invalue must be int *.

LDAP_OPT_REFERRAL_URLS
Sets/gets  an array containing the referral URIs associated to the LDAP handle.  outvalue must be a char ***, and the caller is responsible of freeing the returned string
by calling ldap_memvfree(3), while invalue must be a NULL-terminated char *const *; the library duplicates the corresponding string.  This option is OpenLDAP specific.

LDAP_OPT_REFERRALS
Determines whether the library should implicitly chase referrals or not.  invalue must be const int *; its value should either be LDAP_OPT_OFF or  LDAP_OPT_ON.   outvalue
must be int *.

LDAP_OPT_RESTART
Determines  whether the library should implicitly restart connections (FIXME).  invalue must be const int *; its value should either be LDAP_OPT_OFF or LDAP_OPT_ON.  out‐
value must be int *.

LDAP_OPT_RESULT_CODE
Sets/gets the LDAP result code associated to the handle.  This option was formerly known as LDAP_OPT_ERROR_NUMBER.  invalue must be a const int *.  outvalue must be a int
*.

LDAP_OPT_SERVER_CONTROLS
Sets/gets the server-side controls to be used for all operations.  This is now deprecated as modern LDAP C API provides replacements for all main operations which accepts
server-side controls as explicit arguments; see for example ldap_search_ext(3), ldap_add_ext(3), ldap_modify_ext(3) and so on.  outvalue must be LDAPControl ***, and  the
caller  is  responsible of freeing the returned controls, if any, by calling ldap_controls_free(3), while invalue must be LDAPControl *const *; the library duplicates the
controls passed via invalue.

LDAP_OPT_SESSION_REFCNT
Returns the reference count associated with the LDAP handle passed in as ld; outvalue must be a int *.  This is a  read-only,  handle-specific  option.   This  option  is
OpenLDAP specific.

LDAP_OPT_SIZELIMIT
Sets/gets the value that defines the maximum number of entries to be returned by a search operation.  invalue must be const int *, while outvalue must be int *; They can‐
not be NULL.

LDAP_OPT_SOCKBUF
Returns a pointer to the socket buffer of the LDAP handle passed in as ld; outvalue must be a Sockbuf **.  This is a read-only, handle-specific option.   This  option  is
OpenLDAP specific.

LDAP_OPT_TIMELIMIT
Sets/gets  the  value  that defines the time limit after which a search operation should be terminated by the server.  invalue must be const int *, while outvalue must be
int *, and they cannot be NULL.

LDAP_OPT_TIMEOUT
Sets/gets a timeout value for the synchronous API calls.  outvalue must be a struct timeval ** (the caller has to free *outvalue), and invalue must be a struct timeval *,
and they cannot be NULL. Using a struct with seconds set to -1 results in an infinite timeout, which is the default.  This option is OpenLDAP specific.

LDAP_OPT_URI
Sets/gets  a  comma-  or space-separated list of URIs to be contacted by the library when trying to establish a connection.  outvalue must be a char **, and the caller is
responsible of freeing the resulting string by calling ldap_memfree(3), while invalue must be a const char *; the library parses the string into  a  list  of  LDAPURLDesc
structures,  so  the  invocation  of  ldap_set_option(3)  may fail if URL parsing fails.  URIs may only contain the schema, the host, and the port fields.  This option is
OpenLDAP specific.

SASL OPTIONS
The SASL options are OpenLDAP specific.

LDAP_OPT_X_SASL_AUTHCID
Gets the SASL authentication identity; outvalue must be a char **, its content needs to be freed by the caller using ldap_memfree(3).

LDAP_OPT_X_SASL_AUTHZID
Gets the SASL authorization identity; outvalue must be a char **, its content needs to be freed by the caller using ldap_memfree(3).

LDAP_OPT_X_SASL_MAXBUFSIZE
Gets/sets SASL maximum buffer size; invalue must be const ber_len_t *, while outvalue must be ber_len_t *.  See also LDAP_OPT_X_SASL_SECPROPS.

LDAP_OPT_X_SASL_MECH
Gets the SASL mechanism; outvalue must be a char **, its content needs to be freed by the caller using ldap_memfree(3).

LDAP_OPT_X_SASL_MECHLIST
Gets the list of the available mechanisms, in form of a NULL-terminated array of strings; outvalue must be char ***.  The caller must not free or otherwise muck with it.

LDAP_OPT_X_SASL_NOCANON
Sets/gets the NOCANON flag.  When unset, the hostname is canonicalized.  invalue must be const int *; its value should either be LDAP_OPT_OFF  or  LDAP_OPT_ON.   outvalue
must be int *.

LDAP_OPT_X_SASL_REALM
Gets the SASL realm; outvalue must be a char **, its content needs to be freed by the caller using ldap_memfree(3).

LDAP_OPT_X_SASL_SECPROPS
Sets  the SASL secprops; invalue must be a char *, containing a comma-separated list of properties.  Legal values are: none, nodict, noplain, noactive, passcred, forward‐
sec, noanonymous, minssf=&amp;lt;minssf&amp;gt;, maxssf=&amp;lt;maxssf&amp;gt;, maxbufsize=&amp;lt;maxbufsize&amp;gt;.

LDAP_OPT_X_SASL_SSF
Gets the SASL SSF; outvalue must be a ber_len_t *.

LDAP_OPT_X_SASL_SSF_EXTERNAL
Sets the SASL SSF value related to an authentication performed using an EXTERNAL mechanism; invalue must be a const ber_len_t *.

LDAP_OPT_X_SASL_SSF_MAX
Gets/sets SASL maximum SSF; invalue must be const ber_len_t *, while outvalue must be ber_len_t *.  See also LDAP_OPT_X_SASL_SECPROPS.

LDAP_OPT_X_SASL_SSF_MIN
Gets/sets SASL minimum SSF; invalue must be const ber_len_t *, while outvalue must be ber_len_t *.  See also LDAP_OPT_X_SASL_SECPROPS.

LDAP_OPT_X_SASL_USERNAME
Gets the SASL username; outvalue must be a char **.  Its content needs to be freed by the caller using ldap_memfree(3).

TCP OPTIONS
The TCP options are OpenLDAP specific.  Mainly intended for use with Linux, they may not be portable.

LDAP_OPT_X_KEEPALIVE_IDLE
Sets/gets the number of seconds a connection needs to remain idle before TCP starts sending keepalive probes.  invalue must be const int *; outvalue must be int *.

LDAP_OPT_X_KEEPALIVE_PROBES
Sets/gets the maximum number of keepalive probes TCP should send before dropping the connection.  invalue must be const int *; outvalue must be int *.

LDAP_OPT_X_KEEPALIVE_INTERVAL
Sets/gets the interval in seconds between individual keepalive probes.  invalue must be const int *; outvalue must be int *.

TLS OPTIONS
The TLS options are OpenLDAP specific.

LDAP_OPT_X_TLS_CACERTDIR
Sets/gets the path of the directory containing CA certificates.  invalue must be const char *; outvalue must be char **, and its contents need to be freed by  the  caller
using ldap_memfree(3).

LDAP_OPT_X_TLS_CACERTFILE
Sets/gets  the  full-path  of  the  CA  certificate  file.   invalue must be const char *; outvalue must be char **, and its contents need to be freed by the caller using
ldap_memfree(3).

LDAP_OPT_X_TLS_CERTFILE
Sets/gets the full-path of the certificate file.  invalue must be const char *; outvalue must be char **, and its contents need to be freed by the caller using  ldap_mem‐
free(3).

LDAP_OPT_X_TLS_CIPHER_SUITE
Sets/gets the allowed cipher suite.  invalue must be const char *; outvalue must be char **, and its contents need to be freed by the caller using ldap_memfree(3).

LDAP_OPT_X_TLS_CONNECT_ARG
Sets/gets the connection callback argument.  invalue must be const void *; outvalue must be void **.

LDAP_OPT_X_TLS_CONNECT_CB
Sets/gets the connection callback handle.  invalue must be const LDAP_TLS_CONNECT_CB *; outvalue must be LDAP_TLS_CONNECT_CB **.

LDAP_OPT_X_TLS_CRLCHECK
Sets/gets  the CRL evaluation strategy, one of LDAP_OPT_X_TLS_CRL_NONE, LDAP_OPT_X_TLS_CRL_PEER, or LDAP_OPT_X_TLS_CRL_ALL.  invalue must be const int *; outvalue must be
int *.  Requires OpenSSL.

LDAP_OPT_X_TLS_CRLFILE
Sets/gets the full-path of the CRL file.  invalue must be const char *; outvalue must be char **, and its contents need to be freed by the caller  using  ldap_memfree(3).
This option is only valid for GnuTLS.

LDAP_OPT_X_TLS_CTX
Sets/gets  the  TLS  library context. New TLS sessions will inherit their default settings from this library context.  invalue must be const void *; outvalue must be void
**.  When using the OpenSSL library this is an SSL_CTX*. When using other crypto libraries this is a pointer to an OpenLDAP  private  structure.   Applications  generally
should not use this option or attempt to manipulate this structure.

LDAP_OPT_X_TLS_DHFILE
Gets/sets  the full-path of the file containing the parameters for Diffie-Hellman ephemeral key exchange.  invalue must be const char *; outvalue must be char **, and its
contents need to be freed by the caller using ldap_memfree(3).  Ignored by GnuTLS and Mozilla NSS.

LDAP_OPT_X_TLS_KEYFILE
Sets/gets the full-path of the certificate key file.  invalue must be const char *; outvalue must be char **, and its contents need  to  be  freed  by  the  caller  using
ldap_memfree(3).

LDAP_OPT_X_TLS_NEWCTX
Instructs the library to create a new TLS library context.  invalue must be const int *.  A non-zero value pointed to by invalue tells the library to create a context for
a server.

LDAP_OPT_X_TLS_PROTOCOL_MIN
Sets/gets the minimum protocol version.  invalue must be const int *; outvalue must be int *.

LDAP_OPT_X_TLS_RANDOM_FILE
Sets/gets the random file when /dev/random and /dev/urandom are not available.  invalue must be const char *; outvalue must be char **, and its contents need to be  freed
by the caller using ldap_memfree(3).  Ignored by GnuTLS older than version 2.2.  Ignored by Mozilla NSS.

LDAP_OPT_X_TLS_REQUIRE_CERT
Sets/gets the peer certificate checking strategy, one of LDAP_OPT_X_TLS_NEVER, LDAP_OPT_X_TLS_HARD, LDAP_OPT_X_TLS_DEMAND, LDAP_OPT_X_TLS_ALLOW, LDAP_OPT_X_TLS_TRY.

LDAP_OPT_X_TLS_SSL_CTX
Gets  the  TLS  session context associated with this handle.  outvalue must be void **.  When using the OpenSSL library this is an SSL*. When using other crypto libraries
this is a pointer to an OpenLDAP private structure.  Applications generally should not use this option.

ERRORS
On success, the functions return LDAP_OPT_SUCCESS, while they may return LDAP_OPT_ERROR to indicate a generic option handling error.  Occasionally, more specific errors  can  be
returned, like LDAP_NO_MEMORY to indicate a failure in memory allocation.

NOTES
The  LDAP  libraries  with  the  LDAP_OPT_REFERRALS option set to LDAP_OPT_ON (default value) automatically follow referrals using an anonymous bind.  Application developers are
encouraged to either implement consistent referral chasing features, or explicitly disable referral chasing by setting that option to LDAP_OPT_OFF.

The protocol version used by the library defaults to LDAPv2 (now historic), which corresponds to the LDAP_VERSION2 macro.  Application developers are  encouraged  to  explicitly
set LDAP_OPT_PROTOCOL_VERSION to LDAPv3, using the LDAP_VERSION3 macro, or to allow users to select the protocol version.

SEE ALSO
ldap(3), ldap_error(3), RFC 4422 (http://www.rfc-editor.org),

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                     LDAP_GET_OPTION(3)
LDAP_GET_VALUES(3)                                                              Library Functions Manual                                                              LDAP_GET_VALUES(3)

NAME
ldap_get_values, ldap_get_values_len, ldap_count_values - LDAP attribute value handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

char **ldap_get_values(ld, entry, attr)
LDAP *ld;
LDAPMessage *entry;
char *attr;

struct berval **ldap_get_values_len(ld, entry, attr)
LDAP *ld;
LDAPMessage *entry;
char *attr;

int ldap_count_values(vals)
char **vals;

int ldap_count_values_len(vals)
struct berval **vals;

void ldap_value_free(vals)
char **vals;

void ldap_value_free_len(vals)
struct berval **vals;

DESCRIPTION
These  routines  are  used  to retrieve and manipulate attribute values from an LDAP entry as returned by ldap_first_entry(3) or ldap_next_entry(3).  ldap_get_values() takes the
entry and the attribute attr whose values are desired and returns a NULL-terminated array  of  the  attribute's  values.   attr  may  be  an  attribute  type  as  returned  from
ldap_first_attribute(3) or ldap_next_attribute(3), or if the attribute type is known it can simply be given.

The number of values in the array can be counted by calling ldap_count_values().  The array of values returned can be freed by calling ldap_value_free().

If  the attribute values are binary in nature, and thus not suitable to be returned as an array of char *'s, the ldap_get_values_len() routine can be used instead.  It takes the
same parameters as ldap_get_values(), but returns a NULL-terminated array of pointers to berval structures, each containing the length of and a pointer to a value.

The number of values in the array can be counted by calling ldap_count_values_len().  The array of values returned can be freed by calling ldap_value_free_len().

ERRORS
If an error occurs in ldap_get_values() or ldap_get_values_len(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the  error.   See  ldap_error(3)
for a description of possible error codes.

NOTES
These routines dynamically allocate memory which the caller must free using the supplied routines.

SEE ALSO
ldap(3), ldap_first_entry(3), ldap_first_attribute(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                     LDAP_GET_VALUES(3)
LDAP_GET_VALUES(3)                                                              Library Functions Manual                                                              LDAP_GET_VALUES(3)

NAME
ldap_get_values, ldap_get_values_len, ldap_count_values - LDAP attribute value handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

char **ldap_get_values(ld, entry, attr)
LDAP *ld;
LDAPMessage *entry;
char *attr;

struct berval **ldap_get_values_len(ld, entry, attr)
LDAP *ld;
LDAPMessage *entry;
char *attr;

int ldap_count_values(vals)
char **vals;

int ldap_count_values_len(vals)
struct berval **vals;

void ldap_value_free(vals)
char **vals;

void ldap_value_free_len(vals)
struct berval **vals;

DESCRIPTION
These  routines  are  used  to retrieve and manipulate attribute values from an LDAP entry as returned by ldap_first_entry(3) or ldap_next_entry(3).  ldap_get_values() takes the
entry and the attribute attr whose values are desired and returns a NULL-terminated array  of  the  attribute's  values.   attr  may  be  an  attribute  type  as  returned  from
ldap_first_attribute(3) or ldap_next_attribute(3), or if the attribute type is known it can simply be given.

The number of values in the array can be counted by calling ldap_count_values().  The array of values returned can be freed by calling ldap_value_free().

If  the attribute values are binary in nature, and thus not suitable to be returned as an array of char *'s, the ldap_get_values_len() routine can be used instead.  It takes the
same parameters as ldap_get_values(), but returns a NULL-terminated array of pointers to berval structures, each containing the length of and a pointer to a value.

The number of values in the array can be counted by calling ldap_count_values_len().  The array of values returned can be freed by calling ldap_value_free_len().

ERRORS
If an error occurs in ldap_get_values() or ldap_get_values_len(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the  error.   See  ldap_error(3)
for a description of possible error codes.

NOTES
These routines dynamically allocate memory which the caller must free using the supplied routines.

SEE ALSO
ldap(3), ldap_first_entry(3), ldap_first_attribute(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                     LDAP_GET_VALUES(3)
LDAP_OPEN(3)                                                                    Library Functions Manual                                                                    LDAP_OPEN(3)

NAME
ldap_init, ldap_initialize, ldap_open - Initialize the LDAP library and open a connection to an LDAP server

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

LDAP *ldap_open(host, port)
char *host;
int port;

LDAP *ldap_init(host, port)
char *host;
int port;

int ldap_initialize(ldp, uri)
LDAP **ldp;
char *uri;

int ldap_set_urllist_proc(ld, proc, params)
LDAP *ld;
LDAP_URLLIST_PROC *proc;
void *params;

int (LDAP_URLLIST_PROC)(ld, urllist, url, params);
LDAP *ld;
LDAPURLDesc **urllist;
LDAPURLDesc **url;
void *params;

#include &amp;lt;ldap_pvt.h&amp;gt;

int ldap_init_fd(fd, proto, uri, ldp)
ber_socket_t fd;
int proto;
char *uri;
LDAP **ldp;

DESCRIPTION
ldap_open()  opens  a  connection  to  an  LDAP  server  and  allocates  an  LDAP  structure which is used to identify the connection and to maintain per-connection information.
ldap_init() allocates an LDAP structure but does not open an initial connection.  ldap_initialize() allocates an  LDAP  structure  but  does  not  open  an  initial  connection.
ldap_init_fd() allocates an LDAP structure using an existing connection on the provided socket.  One of these routines must be called before any operations are attempted.

ldap_open()  takes  host,  the hostname on which the LDAP server is running, and port, the port number to which to connect.  If the default IANA-assigned port of 389 is desired,
LDAP_PORT should be specified for port.  The host parameter may contain a blank-separated list of hosts to try to connect to, and  each  host  may  optionally  by  of  the  form
host:port.   If  present,  the  :port  overrides the port parameter to ldap_open().  Upon successfully making a connection to an LDAP server, ldap_open() returns a pointer to an
opaque LDAP structure, which should be passed to subsequent calls to ldap_bind(), ldap_search(), etc. Certain fields in the LDAP structure can be set  to  indicate  size  limit,
time  limit,  and  how aliases are handled during operations; read and write access to those fields must occur by calling ldap_get_option(3) and ldap_set_option(3) respectively,
whenever possible.

ldap_init() acts just like ldap_open(), but does not open a connection to the LDAP server.  The actual connection open will occur when the first operation is attempted.

ldap_initialize() acts like ldap_init(), but it returns an integer indicating either success or the failure reason, and it allows to specify details for the  connection  in  the
schema  portion  of the URI.  The uri parameter may be a comma- or whitespace-separated list of URIs containing only the schema, the host, and the port fields.  Apart from ldap,
other (non-standard) recognized values of the schema field are ldaps (LDAP over TLS), ldapi (LDAP over IPC), and cldap (connectionless LDAP).  If other fields are  present,  the
behavior is undefined.

At  this  time,  ldap_open() and ldap_init() are deprecated in favor of ldap_initialize(), essentially because the latter allows to specify a schema in the URI and it explicitly
returns an error code.

ldap_init_fd() allows an LDAP structure to be initialized using an  already-opened  connection.  The  proto  parameter  should  be  one  of  LDAP_PROTO_TCP,  LDAP_PROTO_UDP,  or
LDAP_PROTO_IPC for a connection using TCP, UDP, or IPC, respectively. The value LDAP_PROTO_EXT may also be specified if user-supplied sockbuf handlers are going to be used. Note
that support for UDP is not implemented unless libldap was built with LDAP_CONNECTIONLESS defined.  The uri parameter may optionally be provided for informational purposes.

ldap_set_urllist_proc() allows to set a function proc of type LDAP_URLLIST_PROC that is called when a successful connection can be established.  This function receives the  list
of  URIs  parsed  from the uri string originally passed to ldap_initialize(), and the one that successfully connected.  The function may manipulate the URI list; the typical use
consists in moving the successful URI to the head of the list, so that subsequent attempts to connect to one of the URIs using the same LDAP handle will try it first.  If ld  is
null,  proc  is  set  as  a  global  parameter  that  is inherited by all handlers within the process that are created after the call to ldap_set_urllist_proc().  By default, no
LDAP_URLLIST_PROC is set.  In a multithreaded environment, ldap_set_urllist_proc() must be called before any concurrent operation using the LDAP handle is started.

Note: the first call into the LDAP library also initializes the global options for the library. As such the first call should be single-threaded or otherwise protected to insure
that  only one call is active. It is recommended that ldap_get_option() or ldap_set_option() be used in the program's main thread before any additional threads are created.  See
ldap_get_option(3).

ERRORS
If an error occurs, ldap_open() and ldap_init() will return NULL and errno should be set appropriately.  ldap_initialize() and ldap_init_fd() will directly return the LDAP  code
associated  to  the  error  (or LDAP_SUCCESS in case of success); errno should be set as well whenever appropriate.  ldap_set_urllist_proc() returns LDAP_OPT_ERROR on error, and
LDAP_OPT_SUCCESS on success.

SEE ALSO
ldap(3), ldap_bind(3), ldap_get_option(3), ldap_set_option(3), lber-sockbuf(3), errno(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                           LDAP_OPEN(3)
LDAP_OPEN(3)                                                                    Library Functions Manual                                                                    LDAP_OPEN(3)

NAME
ldap_init, ldap_initialize, ldap_open - Initialize the LDAP library and open a connection to an LDAP server

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

LDAP *ldap_open(host, port)
char *host;
int port;

LDAP *ldap_init(host, port)
char *host;
int port;

int ldap_initialize(ldp, uri)
LDAP **ldp;
char *uri;

int ldap_set_urllist_proc(ld, proc, params)
LDAP *ld;
LDAP_URLLIST_PROC *proc;
void *params;

int (LDAP_URLLIST_PROC)(ld, urllist, url, params);
LDAP *ld;
LDAPURLDesc **urllist;
LDAPURLDesc **url;
void *params;

#include &amp;lt;ldap_pvt.h&amp;gt;

int ldap_init_fd(fd, proto, uri, ldp)
ber_socket_t fd;
int proto;
char *uri;
LDAP **ldp;

DESCRIPTION
ldap_open()  opens  a  connection  to  an  LDAP  server  and  allocates  an  LDAP  structure which is used to identify the connection and to maintain per-connection information.
ldap_init() allocates an LDAP structure but does not open an initial connection.  ldap_initialize() allocates an  LDAP  structure  but  does  not  open  an  initial  connection.
ldap_init_fd() allocates an LDAP structure using an existing connection on the provided socket.  One of these routines must be called before any operations are attempted.

ldap_open()  takes  host,  the hostname on which the LDAP server is running, and port, the port number to which to connect.  If the default IANA-assigned port of 389 is desired,
LDAP_PORT should be specified for port.  The host parameter may contain a blank-separated list of hosts to try to connect to, and  each  host  may  optionally  by  of  the  form
host:port.   If  present,  the  :port  overrides the port parameter to ldap_open().  Upon successfully making a connection to an LDAP server, ldap_open() returns a pointer to an
opaque LDAP structure, which should be passed to subsequent calls to ldap_bind(), ldap_search(), etc. Certain fields in the LDAP structure can be set  to  indicate  size  limit,
time  limit,  and  how aliases are handled during operations; read and write access to those fields must occur by calling ldap_get_option(3) and ldap_set_option(3) respectively,
whenever possible.

ldap_init() acts just like ldap_open(), but does not open a connection to the LDAP server.  The actual connection open will occur when the first operation is attempted.

ldap_initialize() acts like ldap_init(), but it returns an integer indicating either success or the failure reason, and it allows to specify details for the  connection  in  the
schema  portion  of the URI.  The uri parameter may be a comma- or whitespace-separated list of URIs containing only the schema, the host, and the port fields.  Apart from ldap,
other (non-standard) recognized values of the schema field are ldaps (LDAP over TLS), ldapi (LDAP over IPC), and cldap (connectionless LDAP).  If other fields are  present,  the
behavior is undefined.

At  this  time,  ldap_open() and ldap_init() are deprecated in favor of ldap_initialize(), essentially because the latter allows to specify a schema in the URI and it explicitly
returns an error code.

ldap_init_fd() allows an LDAP structure to be initialized using an  already-opened  connection.  The  proto  parameter  should  be  one  of  LDAP_PROTO_TCP,  LDAP_PROTO_UDP,  or
LDAP_PROTO_IPC for a connection using TCP, UDP, or IPC, respectively. The value LDAP_PROTO_EXT may also be specified if user-supplied sockbuf handlers are going to be used. Note
that support for UDP is not implemented unless libldap was built with LDAP_CONNECTIONLESS defined.  The uri parameter may optionally be provided for informational purposes.

ldap_set_urllist_proc() allows to set a function proc of type LDAP_URLLIST_PROC that is called when a successful connection can be established.  This function receives the  list
of  URIs  parsed  from the uri string originally passed to ldap_initialize(), and the one that successfully connected.  The function may manipulate the URI list; the typical use
consists in moving the successful URI to the head of the list, so that subsequent attempts to connect to one of the URIs using the same LDAP handle will try it first.  If ld  is
null,  proc  is  set  as  a  global  parameter  that  is inherited by all handlers within the process that are created after the call to ldap_set_urllist_proc().  By default, no
LDAP_URLLIST_PROC is set.  In a multithreaded environment, ldap_set_urllist_proc() must be called before any concurrent operation using the LDAP handle is started.

Note: the first call into the LDAP library also initializes the global options for the library. As such the first call should be single-threaded or otherwise protected to insure
that  only one call is active. It is recommended that ldap_get_option() or ldap_set_option() be used in the program's main thread before any additional threads are created.  See
ldap_get_option(3).

ERRORS
If an error occurs, ldap_open() and ldap_init() will return NULL and errno should be set appropriately.  ldap_initialize() and ldap_init_fd() will directly return the LDAP  code
associated  to  the  error  (or LDAP_SUCCESS in case of success); errno should be set as well whenever appropriate.  ldap_set_urllist_proc() returns LDAP_OPT_ERROR on error, and
LDAP_OPT_SUCCESS on success.

SEE ALSO
ldap(3), ldap_bind(3), ldap_get_option(3), ldap_set_option(3), lber-sockbuf(3), errno(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                           LDAP_OPEN(3)
LDAP_OPEN(3)                                                                    Library Functions Manual                                                                    LDAP_OPEN(3)

NAME
ldap_init, ldap_initialize, ldap_open - Initialize the LDAP library and open a connection to an LDAP server

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

LDAP *ldap_open(host, port)
char *host;
int port;

LDAP *ldap_init(host, port)
char *host;
int port;

int ldap_initialize(ldp, uri)
LDAP **ldp;
char *uri;

int ldap_set_urllist_proc(ld, proc, params)
LDAP *ld;
LDAP_URLLIST_PROC *proc;
void *params;

int (LDAP_URLLIST_PROC)(ld, urllist, url, params);
LDAP *ld;
LDAPURLDesc **urllist;
LDAPURLDesc **url;
void *params;

#include &amp;lt;ldap_pvt.h&amp;gt;

int ldap_init_fd(fd, proto, uri, ldp)
ber_socket_t fd;
int proto;
char *uri;
LDAP **ldp;

DESCRIPTION
ldap_open()  opens  a  connection  to  an  LDAP  server  and  allocates  an  LDAP  structure which is used to identify the connection and to maintain per-connection information.
ldap_init() allocates an LDAP structure but does not open an initial connection.  ldap_initialize() allocates an  LDAP  structure  but  does  not  open  an  initial  connection.
ldap_init_fd() allocates an LDAP structure using an existing connection on the provided socket.  One of these routines must be called before any operations are attempted.

ldap_open()  takes  host,  the hostname on which the LDAP server is running, and port, the port number to which to connect.  If the default IANA-assigned port of 389 is desired,
LDAP_PORT should be specified for port.  The host parameter may contain a blank-separated list of hosts to try to connect to, and  each  host  may  optionally  by  of  the  form
host:port.   If  present,  the  :port  overrides the port parameter to ldap_open().  Upon successfully making a connection to an LDAP server, ldap_open() returns a pointer to an
opaque LDAP structure, which should be passed to subsequent calls to ldap_bind(), ldap_search(), etc. Certain fields in the LDAP structure can be set  to  indicate  size  limit,
time  limit,  and  how aliases are handled during operations; read and write access to those fields must occur by calling ldap_get_option(3) and ldap_set_option(3) respectively,
whenever possible.

ldap_init() acts just like ldap_open(), but does not open a connection to the LDAP server.  The actual connection open will occur when the first operation is attempted.

ldap_initialize() acts like ldap_init(), but it returns an integer indicating either success or the failure reason, and it allows to specify details for the  connection  in  the
schema  portion  of the URI.  The uri parameter may be a comma- or whitespace-separated list of URIs containing only the schema, the host, and the port fields.  Apart from ldap,
other (non-standard) recognized values of the schema field are ldaps (LDAP over TLS), ldapi (LDAP over IPC), and cldap (connectionless LDAP).  If other fields are  present,  the
behavior is undefined.

At  this  time,  ldap_open() and ldap_init() are deprecated in favor of ldap_initialize(), essentially because the latter allows to specify a schema in the URI and it explicitly
returns an error code.

ldap_init_fd() allows an LDAP structure to be initialized using an  already-opened  connection.  The  proto  parameter  should  be  one  of  LDAP_PROTO_TCP,  LDAP_PROTO_UDP,  or
LDAP_PROTO_IPC for a connection using TCP, UDP, or IPC, respectively. The value LDAP_PROTO_EXT may also be specified if user-supplied sockbuf handlers are going to be used. Note
that support for UDP is not implemented unless libldap was built with LDAP_CONNECTIONLESS defined.  The uri parameter may optionally be provided for informational purposes.

ldap_set_urllist_proc() allows to set a function proc of type LDAP_URLLIST_PROC that is called when a successful connection can be established.  This function receives the  list
of  URIs  parsed  from the uri string originally passed to ldap_initialize(), and the one that successfully connected.  The function may manipulate the URI list; the typical use
consists in moving the successful URI to the head of the list, so that subsequent attempts to connect to one of the URIs using the same LDAP handle will try it first.  If ld  is
null,  proc  is  set  as  a  global  parameter  that  is inherited by all handlers within the process that are created after the call to ldap_set_urllist_proc().  By default, no
LDAP_URLLIST_PROC is set.  In a multithreaded environment, ldap_set_urllist_proc() must be called before any concurrent operation using the LDAP handle is started.

Note: the first call into the LDAP library also initializes the global options for the library. As such the first call should be single-threaded or otherwise protected to insure
that  only one call is active. It is recommended that ldap_get_option() or ldap_set_option() be used in the program's main thread before any additional threads are created.  See
ldap_get_option(3).

ERRORS
If an error occurs, ldap_open() and ldap_init() will return NULL and errno should be set appropriately.  ldap_initialize() and ldap_init_fd() will directly return the LDAP  code
associated  to  the  error  (or LDAP_SUCCESS in case of success); errno should be set as well whenever appropriate.  ldap_set_urllist_proc() returns LDAP_OPT_ERROR on error, and
LDAP_OPT_SUCCESS on success.

SEE ALSO
ldap(3), ldap_bind(3), ldap_get_option(3), ldap_set_option(3), lber-sockbuf(3), errno(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                           LDAP_OPEN(3)
LDAP_TLS(3)                                                                     Library Functions Manual                                                                     LDAP_TLS(3)

NAME
ldap_start_tls, ldap_start_tls_s, ldap_tls_inplace, ldap_install_tls - LDAP TLS initialization routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_start_tls(LDAP *ld);

int ldap_start_tls_s(LDAP *ld, LDAPControl **serverctrls, LDAPControl **clientctrls);

int ldap_tls_inplace(LDAP *ld);

int ldap_install_tls(LDAP *ld);

DESCRIPTION
These  routines are used to initiate TLS processing on an LDAP session.  ldap_start_tls_s() sends a StartTLS request to a server, waits for the reply, and then installs TLS han‐
dlers on the session if the request succeeded. The routine returns LDAP_SUCCESS if everything succeeded, otherwise it returns an  LDAP  error  code.   ldap_start_tls()  sends  a
StartTLS  request  to  a  server  and  does  nothing  else. It returns LDAP_SUCCESS if the request was sent successfully.  ldap_tls_inplace() returns 1 if TLS handlers have been
installed on the specified session, 0 otherwise.  ldap_install_tls() installs the TLS handlers on the given session. It returns LDAP_LOCAL_ERROR if TLS is already installed.

SEE ALSO
ldap(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                            LDAP_TLS(3)
LDAP_URL(3)                                                                     Library Functions Manual                                                                     LDAP_URL(3)

NAME
ldap_is_ldap_url, ldap_url_parse, ldap_free_urldesc - LDAP Uniform Resource Locator routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_is_ldap_url( const char *url )

int ldap_url_parse( const char *url, LDAPURLDesc **ludpp )

typedef struct ldap_url_desc {
char *      lud_scheme;     /* URI scheme */
char *      lud_host;       /* LDAP host to contact */
int         lud_port;       /* port on host */
char *      lud_dn;         /* base for search */
char **     lud_attrs;      /* list of attributes */
int         lud_scope;      /* a LDAP_SCOPE_... value */
char *      lud_filter;     /* LDAP search filter */
char **     lud_exts;       /* LDAP extensions */
int         lud_crit_exts;  /* true if any extension is critical */
/* may contain additional fields for internal use */
} LDAPURLDesc;

void ldap_free_urldesc( LDAPURLDesc *ludp );

DESCRIPTION
These routines support the use of LDAP URLs (Uniform Resource Locators) as detailed in RFC 4516.  LDAP URLs look like this:

ldap://hostport/dn[?attrs[?scope[?filter[?exts]]]]

where:
hostport is a host name with an optional ":portnumber"
dn is the search base
attrs is a comma separated list of attributes to request
scope is one of these three strings:
base one sub (default=base)
filter is filter
exts are recognized set of LDAP and/or API extensions.

Example:
ldap://ldap.example.net/dc=example,dc=net?cn,sn?sub?(cn=*)

URLs  that are wrapped in angle-brackets and/or preceded by "URL:" are also tolerated.  Alternative LDAP schemes such as ldaps:// and ldapi:// may be parsed using the below rou‐
tines as well.

ldap_is_ldap_url() returns a non-zero value if url looks like an LDAP URL (as opposed to some other kind of URL).  It can be  used  as  a  quick  check  for  an  LDAP  URL;  the
ldap_url_parse() routine should be used if a more thorough check is needed.

ldap_url_parse() breaks down an LDAP URL passed in url into its component pieces.  If successful, zero is returned, an LDAP URL description is allocated, filled in, and ludpp is
set to point to it.  If an error occurs, a non-zero URL error code is returned.

ldap_free_urldesc() should be called to free an LDAP URL description that was obtained from a call to ldap_url_parse().

SEE ALSO
ldap(3)
RFC 4516 &amp;lt;http://www.rfc-editor.org/rfc/rfc4516.txt&amp;gt;

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                            LDAP_URL(3)
LDAP_SCHEMA(3)                                                                  Library Functions Manual                                                                  LDAP_SCHEMA(3)

NAME
ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,
ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object‐
class_free, ldap_scherr2str - Schema definition handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;
#include &amp;lt;ldap_schema.h&amp;gt;

LDAPSyntax * ldap_str2syntax(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_syntax2str(syn)
const LDAPSyntax * syn;

const char * ldap_syntax2name(syn)
LDAPSyntax * syn;

ldap_syntax_free(syn)
LDAPSyntax * syn;

LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_matchingrule2str(mr);
const LDAPMatchingRule * mr;

const char * ldap_matchingrule2name(mr)
LDAPMatchingRule * mr;

ldap_matchingrule_free(mr)
LDAPMatchingRule * mr;

LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_attributetype2str(at)
const LDAPAttributeType * at;

const char * ldap_attributetype2name(at)
LDAPAttributeType * at;

ldap_attributetype_free(at)
LDAPAttributeType * at;

LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_objectclass2str(oc)
const LDAPObjectClass * oc;

const char * ldap_objectclass2name(oc)
LDAPObjectClass * oc;

ldap_objectclass_free(oc)
LDAPObjectClass * oc;

char * ldap_scherr2str(code)
int code;

DESCRIPTION
These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:
syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.

ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate
kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,
the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter‐
minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a
bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:

LDAP_SCHEMA_ALLOW_NONE
strict parsing according to RFC 4512.

LDAP_SCHEMA_ALLOW_NO_OID
permit definitions that do not contain an initial OID.

LDAP_SCHEMA_ALLOW_QUOTED
permit quotes around some items that should not have them.

LDAP_SCHEMA_ALLOW_DESCR
permit a descr instead of a numeric OID in places where the syntax expect the latter.

LDAP_SCHEMA_ALLOW_DESCR_PREFIX
permit that the initial numeric OID contains a prefix in descr format.

LDAP_SCHEMA_ALLOW_ALL
be very liberal, include all options.

The structures returned are as follows:

typedef struct ldap_schema_extension_item {
char *lsei_name;        /* Extension name */
char **lsei_values;     /* Extension values */
} LDAPSchemaExtensionItem;

typedef struct ldap_syntax {
char *syn_oid;          /* OID */
char **syn_names;       /* Names */
char *syn_desc;         /* Description */
LDAPSchemaExtensionItem **syn_extensions; /* Extension */
} LDAPSyntax;

typedef struct ldap_matchingrule {
char *mr_oid;           /* OID */
char **mr_names;        /* Names */
char *mr_desc;          /* Description */
int  mr_obsolete;       /* Is obsolete? */
char *mr_syntax_oid;    /* Syntax of asserted values */
LDAPSchemaExtensionItem **mr_extensions; /* Extensions */
} LDAPMatchingRule;

typedef struct ldap_attributetype {
char *at_oid;           /* OID */
char **at_names;        /* Names */
char *at_desc;          /* Description */
int  at_obsolete;       /* Is obsolete? */
char *at_sup_oid;       /* OID of superior type */
char *at_equality_oid;  /* OID of equality matching rule */
char *at_ordering_oid;  /* OID of ordering matching rule */
char *at_substr_oid;    /* OID of substrings matching rule */
char *at_syntax_oid;    /* OID of syntax of values */
int  at_syntax_len;     /* Suggested minimum maximum length */
int  at_single_value;   /* Is single-valued?  */
int  at_collective;     /* Is collective? */
int  at_no_user_mod;    /* Are changes forbidden through LDAP? */
int  at_usage;          /* Usage, see below */
LDAPSchemaExtensionItem **at_extensions; /* Extensions */
} LDAPAttributeType;

typedef struct ldap_objectclass {
char *oc_oid;           /* OID */
char **oc_names;        /* Names */
char *oc_desc;          /* Description */
int  oc_obsolete;       /* Is obsolete? */
char **oc_sup_oids;     /* OIDs of superior classes */
int  oc_kind;           /* Kind, see below */
char **oc_at_oids_must; /* OIDs of required attribute types */
char **oc_at_oids_may;  /* OIDs of optional attribute types */
LDAPSchemaExtensionItem **oc_extensions; /* Extensions */
} LDAPObjectClass;

Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:

LDAP_SCHEMA_NO
The answer to the question is no.

LDAP_SCHEMA_YES
The answer to the question is yes.

For attribute types, the following usages are possible:

LDAP_SCHEMA_USER_APPLICATIONS
the attribute type is non-operational.

LDAP_SCHEMA_DIRECTORY_OPERATION
the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute
type.

LDAP_SCHEMA_DISTRIBUTED_OPERATION
the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.

LDAP_SCHEMA_DSA_OPERATION
the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different
servers that master the entry.

Object classes can be of three kinds:

LDAP_SCHEMA_ABSTRACT
the object class is abstract, i.e. there cannot be entries of this class alone.

LDAP_SCHEMA_STRUCTURAL
the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned
cannot be changed: none of those present can be removed and none other can be added.

LDAP_SCHEMA_AUXILIARY
the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added
or removed at the same time as needed by the set of object classes resulting from the operation.

Routines ldap_xxx2name() return a canonical name for the definition.

Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that
must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.

ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The
argument code comes from one of the parsing routines and can adopt the following values:

LDAP_SCHERR_OUTOFMEM
Out of memory.

LDAP_SCHERR_UNEXPTOKEN
Unexpected token.

LDAP_SCHERR_NOLEFTPAREN
Missing opening parenthesis.

LDAP_SCHERR_NORIGHTPAREN
Missing closing parenthesis.

LDAP_SCHERR_NODIGIT
Expecting digit.

LDAP_SCHERR_BADNAME
Expecting a name.

LDAP_SCHERR_BADDESC
Bad description.

LDAP_SCHERR_BADSUP
Bad superiors.

LDAP_SCHERR_DUPOPT
Duplicate option.

LDAP_SCHERR_EMPTY
Unexpected end of data.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_SCHEMA(3)
LDAP_SCHEMA(3)                                                                  Library Functions Manual                                                                  LDAP_SCHEMA(3)

NAME
ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,
ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object‐
class_free, ldap_scherr2str - Schema definition handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;
#include &amp;lt;ldap_schema.h&amp;gt;

LDAPSyntax * ldap_str2syntax(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_syntax2str(syn)
const LDAPSyntax * syn;

const char * ldap_syntax2name(syn)
LDAPSyntax * syn;

ldap_syntax_free(syn)
LDAPSyntax * syn;

LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_matchingrule2str(mr);
const LDAPMatchingRule * mr;

const char * ldap_matchingrule2name(mr)
LDAPMatchingRule * mr;

ldap_matchingrule_free(mr)
LDAPMatchingRule * mr;

LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_attributetype2str(at)
const LDAPAttributeType * at;

const char * ldap_attributetype2name(at)
LDAPAttributeType * at;

ldap_attributetype_free(at)
LDAPAttributeType * at;

LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_objectclass2str(oc)
const LDAPObjectClass * oc;

const char * ldap_objectclass2name(oc)
LDAPObjectClass * oc;

ldap_objectclass_free(oc)
LDAPObjectClass * oc;

char * ldap_scherr2str(code)
int code;

DESCRIPTION
These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:
syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.

ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate
kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,
the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter‐
minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a
bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:

LDAP_SCHEMA_ALLOW_NONE
strict parsing according to RFC 4512.

LDAP_SCHEMA_ALLOW_NO_OID
permit definitions that do not contain an initial OID.

LDAP_SCHEMA_ALLOW_QUOTED
permit quotes around some items that should not have them.

LDAP_SCHEMA_ALLOW_DESCR
permit a descr instead of a numeric OID in places where the syntax expect the latter.

LDAP_SCHEMA_ALLOW_DESCR_PREFIX
permit that the initial numeric OID contains a prefix in descr format.

LDAP_SCHEMA_ALLOW_ALL
be very liberal, include all options.

The structures returned are as follows:

typedef struct ldap_schema_extension_item {
char *lsei_name;        /* Extension name */
char **lsei_values;     /* Extension values */
} LDAPSchemaExtensionItem;

typedef struct ldap_syntax {
char *syn_oid;          /* OID */
char **syn_names;       /* Names */
char *syn_desc;         /* Description */
LDAPSchemaExtensionItem **syn_extensions; /* Extension */
} LDAPSyntax;

typedef struct ldap_matchingrule {
char *mr_oid;           /* OID */
char **mr_names;        /* Names */
char *mr_desc;          /* Description */
int  mr_obsolete;       /* Is obsolete? */
char *mr_syntax_oid;    /* Syntax of asserted values */
LDAPSchemaExtensionItem **mr_extensions; /* Extensions */
} LDAPMatchingRule;

typedef struct ldap_attributetype {
char *at_oid;           /* OID */
char **at_names;        /* Names */
char *at_desc;          /* Description */
int  at_obsolete;       /* Is obsolete? */
char *at_sup_oid;       /* OID of superior type */
char *at_equality_oid;  /* OID of equality matching rule */
char *at_ordering_oid;  /* OID of ordering matching rule */
char *at_substr_oid;    /* OID of substrings matching rule */
char *at_syntax_oid;    /* OID of syntax of values */
int  at_syntax_len;     /* Suggested minimum maximum length */
int  at_single_value;   /* Is single-valued?  */
int  at_collective;     /* Is collective? */
int  at_no_user_mod;    /* Are changes forbidden through LDAP? */
int  at_usage;          /* Usage, see below */
LDAPSchemaExtensionItem **at_extensions; /* Extensions */
} LDAPAttributeType;

typedef struct ldap_objectclass {
char *oc_oid;           /* OID */
char **oc_names;        /* Names */
char *oc_desc;          /* Description */
int  oc_obsolete;       /* Is obsolete? */
char **oc_sup_oids;     /* OIDs of superior classes */
int  oc_kind;           /* Kind, see below */
char **oc_at_oids_must; /* OIDs of required attribute types */
char **oc_at_oids_may;  /* OIDs of optional attribute types */
LDAPSchemaExtensionItem **oc_extensions; /* Extensions */
} LDAPObjectClass;

Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:

LDAP_SCHEMA_NO
The answer to the question is no.

LDAP_SCHEMA_YES
The answer to the question is yes.

For attribute types, the following usages are possible:

LDAP_SCHEMA_USER_APPLICATIONS
the attribute type is non-operational.

LDAP_SCHEMA_DIRECTORY_OPERATION
the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute
type.

LDAP_SCHEMA_DISTRIBUTED_OPERATION
the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.

LDAP_SCHEMA_DSA_OPERATION
the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different
servers that master the entry.

Object classes can be of three kinds:

LDAP_SCHEMA_ABSTRACT
the object class is abstract, i.e. there cannot be entries of this class alone.

LDAP_SCHEMA_STRUCTURAL
the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned
cannot be changed: none of those present can be removed and none other can be added.

LDAP_SCHEMA_AUXILIARY
the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added
or removed at the same time as needed by the set of object classes resulting from the operation.

Routines ldap_xxx2name() return a canonical name for the definition.

Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that
must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.

ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The
argument code comes from one of the parsing routines and can adopt the following values:

LDAP_SCHERR_OUTOFMEM
Out of memory.

LDAP_SCHERR_UNEXPTOKEN
Unexpected token.

LDAP_SCHERR_NOLEFTPAREN
Missing opening parenthesis.

LDAP_SCHERR_NORIGHTPAREN
Missing closing parenthesis.

LDAP_SCHERR_NODIGIT
Expecting digit.

LDAP_SCHERR_BADNAME
Expecting a name.

LDAP_SCHERR_BADDESC
Bad description.

LDAP_SCHERR_BADSUP
Bad superiors.

LDAP_SCHERR_DUPOPT
Duplicate option.

LDAP_SCHERR_EMPTY
Unexpected end of data.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_SCHEMA(3)
LDAP_SCHEMA(3)                                                                  Library Functions Manual                                                                  LDAP_SCHEMA(3)

NAME
ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,
ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object‐
class_free, ldap_scherr2str - Schema definition handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;
#include &amp;lt;ldap_schema.h&amp;gt;

LDAPSyntax * ldap_str2syntax(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_syntax2str(syn)
const LDAPSyntax * syn;

const char * ldap_syntax2name(syn)
LDAPSyntax * syn;

ldap_syntax_free(syn)
LDAPSyntax * syn;

LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_matchingrule2str(mr);
const LDAPMatchingRule * mr;

const char * ldap_matchingrule2name(mr)
LDAPMatchingRule * mr;

ldap_matchingrule_free(mr)
LDAPMatchingRule * mr;

LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_attributetype2str(at)
const LDAPAttributeType * at;

const char * ldap_attributetype2name(at)
LDAPAttributeType * at;

ldap_attributetype_free(at)
LDAPAttributeType * at;

LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_objectclass2str(oc)
const LDAPObjectClass * oc;

const char * ldap_objectclass2name(oc)
LDAPObjectClass * oc;

ldap_objectclass_free(oc)
LDAPObjectClass * oc;

char * ldap_scherr2str(code)
int code;

DESCRIPTION
These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:
syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.

ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate
kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,
the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter‐
minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a
bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:

LDAP_SCHEMA_ALLOW_NONE
strict parsing according to RFC 4512.

LDAP_SCHEMA_ALLOW_NO_OID
permit definitions that do not contain an initial OID.

LDAP_SCHEMA_ALLOW_QUOTED
permit quotes around some items that should not have them.

LDAP_SCHEMA_ALLOW_DESCR
permit a descr instead of a numeric OID in places where the syntax expect the latter.

LDAP_SCHEMA_ALLOW_DESCR_PREFIX
permit that the initial numeric OID contains a prefix in descr format.

LDAP_SCHEMA_ALLOW_ALL
be very liberal, include all options.

The structures returned are as follows:

typedef struct ldap_schema_extension_item {
char *lsei_name;        /* Extension name */
char **lsei_values;     /* Extension values */
} LDAPSchemaExtensionItem;

typedef struct ldap_syntax {
char *syn_oid;          /* OID */
char **syn_names;       /* Names */
char *syn_desc;         /* Description */
LDAPSchemaExtensionItem **syn_extensions; /* Extension */
} LDAPSyntax;

typedef struct ldap_matchingrule {
char *mr_oid;           /* OID */
char **mr_names;        /* Names */
char *mr_desc;          /* Description */
int  mr_obsolete;       /* Is obsolete? */
char *mr_syntax_oid;    /* Syntax of asserted values */
LDAPSchemaExtensionItem **mr_extensions; /* Extensions */
} LDAPMatchingRule;

typedef struct ldap_attributetype {
char *at_oid;           /* OID */
char **at_names;        /* Names */
char *at_desc;          /* Description */
int  at_obsolete;       /* Is obsolete? */
char *at_sup_oid;       /* OID of superior type */
char *at_equality_oid;  /* OID of equality matching rule */
char *at_ordering_oid;  /* OID of ordering matching rule */
char *at_substr_oid;    /* OID of substrings matching rule */
char *at_syntax_oid;    /* OID of syntax of values */
int  at_syntax_len;     /* Suggested minimum maximum length */
int  at_single_value;   /* Is single-valued?  */
int  at_collective;     /* Is collective? */
int  at_no_user_mod;    /* Are changes forbidden through LDAP? */
int  at_usage;          /* Usage, see below */
LDAPSchemaExtensionItem **at_extensions; /* Extensions */
} LDAPAttributeType;

typedef struct ldap_objectclass {
char *oc_oid;           /* OID */
char **oc_names;        /* Names */
char *oc_desc;          /* Description */
int  oc_obsolete;       /* Is obsolete? */
char **oc_sup_oids;     /* OIDs of superior classes */
int  oc_kind;           /* Kind, see below */
char **oc_at_oids_must; /* OIDs of required attribute types */
char **oc_at_oids_may;  /* OIDs of optional attribute types */
LDAPSchemaExtensionItem **oc_extensions; /* Extensions */
} LDAPObjectClass;

Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:

LDAP_SCHEMA_NO
The answer to the question is no.

LDAP_SCHEMA_YES
The answer to the question is yes.

For attribute types, the following usages are possible:

LDAP_SCHEMA_USER_APPLICATIONS
the attribute type is non-operational.

LDAP_SCHEMA_DIRECTORY_OPERATION
the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute
type.

LDAP_SCHEMA_DISTRIBUTED_OPERATION
the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.

LDAP_SCHEMA_DSA_OPERATION
the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different
servers that master the entry.

Object classes can be of three kinds:

LDAP_SCHEMA_ABSTRACT
the object class is abstract, i.e. there cannot be entries of this class alone.

LDAP_SCHEMA_STRUCTURAL
the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned
cannot be changed: none of those present can be removed and none other can be added.

LDAP_SCHEMA_AUXILIARY
the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added
or removed at the same time as needed by the set of object classes resulting from the operation.

Routines ldap_xxx2name() return a canonical name for the definition.

Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that
must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.

ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The
argument code comes from one of the parsing routines and can adopt the following values:

LDAP_SCHERR_OUTOFMEM
Out of memory.

LDAP_SCHERR_UNEXPTOKEN
Unexpected token.

LDAP_SCHERR_NOLEFTPAREN
Missing opening parenthesis.

LDAP_SCHERR_NORIGHTPAREN
Missing closing parenthesis.

LDAP_SCHERR_NODIGIT
Expecting digit.

LDAP_SCHERR_BADNAME
Expecting a name.

LDAP_SCHERR_BADDESC
Bad description.

LDAP_SCHERR_BADSUP
Bad superiors.

LDAP_SCHERR_DUPOPT
Duplicate option.

LDAP_SCHERR_EMPTY
Unexpected end of data.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_SCHEMA(3)
LDAP_MEMORY(3)                                                                  Library Functions Manual                                                                  LDAP_MEMORY(3)

NAME
ldap_memfree, ldap_memvfree, ldap_memalloc, ldap_memcalloc, ldap_memrealloc, ldap_strdup - LDAP memory allocation routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

void ldap_memfree(void *p);

void ldap_memvfree(void **v);

void *ldap_memalloc(ber_len_t s);

void *ldap_memcalloc(ber_len_t n, ber_len_t s);

void *ldap_memrealloc(void *p, ber_len_t s);

char *ldap_strdup(LDAP_CONST char *p);

DESCRIPTION
These  routines  are  used  to  allocate/deallocate  memory used/returned by the LDAP library.  ldap_memalloc(), ldap_memcalloc(), ldap_memrealloc(), and ldap_memfree() are used
exactly like the standard malloc(3), calloc(3), realloc(3), and free(3) routines, respectively.  The ldap_memvfree() routine is used to free a  dynamically  allocated  array  of
pointers to arbitrary dynamically allocated objects.  The ldap_strdup() routine is used exactly like the standard strdup(3) routine.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_MEMORY(3)
LDAP_MEMORY(3)                                                                  Library Functions Manual                                                                  LDAP_MEMORY(3)

NAME
ldap_memfree, ldap_memvfree, ldap_memalloc, ldap_memcalloc, ldap_memrealloc, ldap_strdup - LDAP memory allocation routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

void ldap_memfree(void *p);

void ldap_memvfree(void **v);

void *ldap_memalloc(ber_len_t s);

void *ldap_memcalloc(ber_len_t n, ber_len_t s);

void *ldap_memrealloc(void *p, ber_len_t s);

char *ldap_strdup(LDAP_CONST char *p);

DESCRIPTION
These  routines  are  used  to  allocate/deallocate  memory used/returned by the LDAP library.  ldap_memalloc(), ldap_memcalloc(), ldap_memrealloc(), and ldap_memfree() are used
exactly like the standard malloc(3), calloc(3), realloc(3), and free(3) routines, respectively.  The ldap_memvfree() routine is used to free a  dynamically  allocated  array  of
pointers to arbitrary dynamically allocated objects.  The ldap_strdup() routine is used exactly like the standard strdup(3) routine.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_MEMORY(3)
LDAP_MEMORY(3)                                                                  Library Functions Manual                                                                  LDAP_MEMORY(3)

NAME
ldap_memfree, ldap_memvfree, ldap_memalloc, ldap_memcalloc, ldap_memrealloc, ldap_strdup - LDAP memory allocation routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

void ldap_memfree(void *p);

void ldap_memvfree(void **v);

void *ldap_memalloc(ber_len_t s);

void *ldap_memcalloc(ber_len_t n, ber_len_t s);

void *ldap_memrealloc(void *p, ber_len_t s);

char *ldap_strdup(LDAP_CONST char *p);

DESCRIPTION
These  routines  are  used  to  allocate/deallocate  memory used/returned by the LDAP library.  ldap_memalloc(), ldap_memcalloc(), ldap_memrealloc(), and ldap_memfree() are used
exactly like the standard malloc(3), calloc(3), realloc(3), and free(3) routines, respectively.  The ldap_memvfree() routine is used to free a  dynamically  allocated  array  of
pointers to arbitrary dynamically allocated objects.  The ldap_strdup() routine is used exactly like the standard strdup(3) routine.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_MEMORY(3)
LDAP_MEMORY(3)                                                                  Library Functions Manual                                                                  LDAP_MEMORY(3)

NAME
ldap_memfree, ldap_memvfree, ldap_memalloc, ldap_memcalloc, ldap_memrealloc, ldap_strdup - LDAP memory allocation routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

void ldap_memfree(void *p);

void ldap_memvfree(void **v);

void *ldap_memalloc(ber_len_t s);

void *ldap_memcalloc(ber_len_t n, ber_len_t s);

void *ldap_memrealloc(void *p, ber_len_t s);

char *ldap_strdup(LDAP_CONST char *p);

DESCRIPTION
These  routines  are  used  to  allocate/deallocate  memory used/returned by the LDAP library.  ldap_memalloc(), ldap_memcalloc(), ldap_memrealloc(), and ldap_memfree() are used
exactly like the standard malloc(3), calloc(3), realloc(3), and free(3) routines, respectively.  The ldap_memvfree() routine is used to free a  dynamically  allocated  array  of
pointers to arbitrary dynamically allocated objects.  The ldap_strdup() routine is used exactly like the standard strdup(3) routine.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_MEMORY(3)
LDAP_MEMORY(3)                                                                  Library Functions Manual                                                                  LDAP_MEMORY(3)

NAME
ldap_memfree, ldap_memvfree, ldap_memalloc, ldap_memcalloc, ldap_memrealloc, ldap_strdup - LDAP memory allocation routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

void ldap_memfree(void *p);

void ldap_memvfree(void **v);

void *ldap_memalloc(ber_len_t s);

void *ldap_memcalloc(ber_len_t n, ber_len_t s);

void *ldap_memrealloc(void *p, ber_len_t s);

char *ldap_strdup(LDAP_CONST char *p);

DESCRIPTION
These  routines  are  used  to  allocate/deallocate  memory used/returned by the LDAP library.  ldap_memalloc(), ldap_memcalloc(), ldap_memrealloc(), and ldap_memfree() are used
exactly like the standard malloc(3), calloc(3), realloc(3), and free(3) routines, respectively.  The ldap_memvfree() routine is used to free a  dynamically  allocated  array  of
pointers to arbitrary dynamically allocated objects.  The ldap_strdup() routine is used exactly like the standard strdup(3) routine.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_MEMORY(3)
LDAP_MEMORY(3)                                                                  Library Functions Manual                                                                  LDAP_MEMORY(3)

NAME
ldap_memfree, ldap_memvfree, ldap_memalloc, ldap_memcalloc, ldap_memrealloc, ldap_strdup - LDAP memory allocation routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

void ldap_memfree(void *p);

void ldap_memvfree(void **v);

void *ldap_memalloc(ber_len_t s);

void *ldap_memcalloc(ber_len_t n, ber_len_t s);

void *ldap_memrealloc(void *p, ber_len_t s);

char *ldap_strdup(LDAP_CONST char *p);

DESCRIPTION
These  routines  are  used  to  allocate/deallocate  memory used/returned by the LDAP library.  ldap_memalloc(), ldap_memcalloc(), ldap_memrealloc(), and ldap_memfree() are used
exactly like the standard malloc(3), calloc(3), realloc(3), and free(3) routines, respectively.  The ldap_memvfree() routine is used to free a  dynamically  allocated  array  of
pointers to arbitrary dynamically allocated objects.  The ldap_strdup() routine is used exactly like the standard strdup(3) routine.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_MEMORY(3)
LDAP_MODIFY(3)                                                                  Library Functions Manual                                                                  LDAP_MODIFY(3)

NAME
ldap_modify_ext, ldap_modify_ext_s - Perform an LDAP modify operation

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_modify_ext(
LDAP *ld,
char *dn,
LDAPMod *mods[],
LDAPControl **sctrls,
LDAPControl **cctrls,
int *msgidp );

int ldap_modify_ext_s(
LDAP *ld,
char *dn,
LDAPMod *mods[],
LDAPControl **sctrls,
LDAPControl **cctrls );

void ldap_mods_free(
LDAPMod **mods,
int freemods );

DESCRIPTION
The  routine  ldap_modify_ext_s() is used to perform an LDAP modify operation.  dn is the DN of the entry to modify, and mods is a null-terminated array of modifications to make
to the entry.  Each element of the mods array is a pointer to an LDAPMod structure, which is defined below.

typedef struct ldapmod {
int mod_op;
char *mod_type;
union {
char **modv_strvals;
struct berval **modv_bvals;
} mod_vals;
struct ldapmod *mod_next;
} LDAPMod;
#define mod_values mod_vals.modv_strvals
#define mod_bvalues mod_vals.modv_bvals

The mod_op field is used to specify the type of modification to perform and should be one of LDAP_MOD_ADD, LDAP_MOD_DELETE, or LDAP_MOD_REPLACE.   The  mod_type  and  mod_values
fields  specify  the  attribute type to modify and a null-terminated array of values to add, delete, or replace respectively.  The mod_next field is used only by the LDAP server
and may be ignored by the client.

If you need to specify a non-string value (e.g., to add a photo or audio attribute value),  you  should  set  mod_op  to  the  logical  OR  of  the  operation  as  above  (e.g.,
LDAP_MOD_REPLACE)  and  the  constant LDAP_MOD_BVALUES.  In this case, mod_bvalues should be used instead of mod_values, and it should point to a null-terminated array of struct
bervals, as defined in &amp;lt;lber.h&amp;gt;.

For LDAP_MOD_ADD modifications, the given values are added to the entry, creating the attribute if necessary.  For LDAP_MOD_DELETE modifications, the given  values  are  deleted
from  the entry, removing the attribute if no values remain.  If the entire attribute is to be deleted, the mod_values field should be set to NULL.  For LDAP_MOD_REPLACE modifi‐
cations, the attribute will have the listed values after the modification, having been created if necessary.  All modifications are performed in the  order  in  which  they  are
listed.

ldap_mods_free() can be used to free each element of a NULL-terminated array of mod structures.  If freemods is non-zero, the mods pointer itself is freed as well.

ldap_modify_ext_s() returns a code indicating success or, in the case of failure, indicating the nature of the failure.  See ldap_error(3) for details

The ldap_modify_ext() operation works the same way as ldap_modify_ext_s(), except that it is asynchronous. The integer that msgidp points to is set to the message id of the mod‐
ify request.  The result of the operation can be obtained by calling ldap_result(3).

Both ldap_modify_ext() and ldap_modify_ext_s() allows server and client controls to be passed in via the sctrls and cctrls parameters, respectively.

DEPRECATED INTERFACES
The ldap_modify() and ldap_modify_s() routines are deprecated in favor of the ldap_modify_ext() and ldap_modify_ext_s() routines, respectively.

Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed
to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3), ldap_error(3),

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_MODIFY(3)
LDAP_MODIFY(3)                                                                  Library Functions Manual                                                                  LDAP_MODIFY(3)

NAME
ldap_modify_ext, ldap_modify_ext_s - Perform an LDAP modify operation

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_modify_ext(
LDAP *ld,
char *dn,
LDAPMod *mods[],
LDAPControl **sctrls,
LDAPControl **cctrls,
int *msgidp );

int ldap_modify_ext_s(
LDAP *ld,
char *dn,
LDAPMod *mods[],
LDAPControl **sctrls,
LDAPControl **cctrls );

void ldap_mods_free(
LDAPMod **mods,
int freemods );

DESCRIPTION
The  routine  ldap_modify_ext_s() is used to perform an LDAP modify operation.  dn is the DN of the entry to modify, and mods is a null-terminated array of modifications to make
to the entry.  Each element of the mods array is a pointer to an LDAPMod structure, which is defined below.

typedef struct ldapmod {
int mod_op;
char *mod_type;
union {
char **modv_strvals;
struct berval **modv_bvals;
} mod_vals;
struct ldapmod *mod_next;
} LDAPMod;
#define mod_values mod_vals.modv_strvals
#define mod_bvalues mod_vals.modv_bvals

The mod_op field is used to specify the type of modification to perform and should be one of LDAP_MOD_ADD, LDAP_MOD_DELETE, or LDAP_MOD_REPLACE.   The  mod_type  and  mod_values
fields  specify  the  attribute type to modify and a null-terminated array of values to add, delete, or replace respectively.  The mod_next field is used only by the LDAP server
and may be ignored by the client.

If you need to specify a non-string value (e.g., to add a photo or audio attribute value),  you  should  set  mod_op  to  the  logical  OR  of  the  operation  as  above  (e.g.,
LDAP_MOD_REPLACE)  and  the  constant LDAP_MOD_BVALUES.  In this case, mod_bvalues should be used instead of mod_values, and it should point to a null-terminated array of struct
bervals, as defined in &amp;lt;lber.h&amp;gt;.

For LDAP_MOD_ADD modifications, the given values are added to the entry, creating the attribute if necessary.  For LDAP_MOD_DELETE modifications, the given  values  are  deleted
from  the entry, removing the attribute if no values remain.  If the entire attribute is to be deleted, the mod_values field should be set to NULL.  For LDAP_MOD_REPLACE modifi‐
cations, the attribute will have the listed values after the modification, having been created if necessary.  All modifications are performed in the  order  in  which  they  are
listed.

ldap_mods_free() can be used to free each element of a NULL-terminated array of mod structures.  If freemods is non-zero, the mods pointer itself is freed as well.

ldap_modify_ext_s() returns a code indicating success or, in the case of failure, indicating the nature of the failure.  See ldap_error(3) for details

The ldap_modify_ext() operation works the same way as ldap_modify_ext_s(), except that it is asynchronous. The integer that msgidp points to is set to the message id of the mod‐
ify request.  The result of the operation can be obtained by calling ldap_result(3).

Both ldap_modify_ext() and ldap_modify_ext_s() allows server and client controls to be passed in via the sctrls and cctrls parameters, respectively.

DEPRECATED INTERFACES
The ldap_modify() and ldap_modify_s() routines are deprecated in favor of the ldap_modify_ext() and ldap_modify_ext_s() routines, respectively.

Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed
to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3), ldap_error(3),

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_MODIFY(3)
LDAP_MODIFY(3)                                                                  Library Functions Manual                                                                  LDAP_MODIFY(3)

NAME
ldap_modify_ext, ldap_modify_ext_s - Perform an LDAP modify operation

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_modify_ext(
LDAP *ld,
char *dn,
LDAPMod *mods[],
LDAPControl **sctrls,
LDAPControl **cctrls,
int *msgidp );

int ldap_modify_ext_s(
LDAP *ld,
char *dn,
LDAPMod *mods[],
LDAPControl **sctrls,
LDAPControl **cctrls );

void ldap_mods_free(
LDAPMod **mods,
int freemods );

DESCRIPTION
The  routine  ldap_modify_ext_s() is used to perform an LDAP modify operation.  dn is the DN of the entry to modify, and mods is a null-terminated array of modifications to make
to the entry.  Each element of the mods array is a pointer to an LDAPMod structure, which is defined below.

typedef struct ldapmod {
int mod_op;
char *mod_type;
union {
char **modv_strvals;
struct berval **modv_bvals;
} mod_vals;
struct ldapmod *mod_next;
} LDAPMod;
#define mod_values mod_vals.modv_strvals
#define mod_bvalues mod_vals.modv_bvals

The mod_op field is used to specify the type of modification to perform and should be one of LDAP_MOD_ADD, LDAP_MOD_DELETE, or LDAP_MOD_REPLACE.   The  mod_type  and  mod_values
fields  specify  the  attribute type to modify and a null-terminated array of values to add, delete, or replace respectively.  The mod_next field is used only by the LDAP server
and may be ignored by the client.

If you need to specify a non-string value (e.g., to add a photo or audio attribute value),  you  should  set  mod_op  to  the  logical  OR  of  the  operation  as  above  (e.g.,
LDAP_MOD_REPLACE)  and  the  constant LDAP_MOD_BVALUES.  In this case, mod_bvalues should be used instead of mod_values, and it should point to a null-terminated array of struct
bervals, as defined in &amp;lt;lber.h&amp;gt;.

For LDAP_MOD_ADD modifications, the given values are added to the entry, creating the attribute if necessary.  For LDAP_MOD_DELETE modifications, the given  values  are  deleted
from  the entry, removing the attribute if no values remain.  If the entire attribute is to be deleted, the mod_values field should be set to NULL.  For LDAP_MOD_REPLACE modifi‐
cations, the attribute will have the listed values after the modification, having been created if necessary.  All modifications are performed in the  order  in  which  they  are
listed.

ldap_mods_free() can be used to free each element of a NULL-terminated array of mod structures.  If freemods is non-zero, the mods pointer itself is freed as well.

ldap_modify_ext_s() returns a code indicating success or, in the case of failure, indicating the nature of the failure.  See ldap_error(3) for details

The ldap_modify_ext() operation works the same way as ldap_modify_ext_s(), except that it is asynchronous. The integer that msgidp points to is set to the message id of the mod‐
ify request.  The result of the operation can be obtained by calling ldap_result(3).

Both ldap_modify_ext() and ldap_modify_ext_s() allows server and client controls to be passed in via the sctrls and cctrls parameters, respectively.

DEPRECATED INTERFACES
The ldap_modify() and ldap_modify_s() routines are deprecated in favor of the ldap_modify_ext() and ldap_modify_ext_s() routines, respectively.

Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed
to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3), ldap_error(3),

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_MODIFY(3)
LDAP_MODIFY(3)                                                                  Library Functions Manual                                                                  LDAP_MODIFY(3)

NAME
ldap_modify_ext, ldap_modify_ext_s - Perform an LDAP modify operation

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_modify_ext(
LDAP *ld,
char *dn,
LDAPMod *mods[],
LDAPControl **sctrls,
LDAPControl **cctrls,
int *msgidp );

int ldap_modify_ext_s(
LDAP *ld,
char *dn,
LDAPMod *mods[],
LDAPControl **sctrls,
LDAPControl **cctrls );

void ldap_mods_free(
LDAPMod **mods,
int freemods );

DESCRIPTION
The  routine  ldap_modify_ext_s() is used to perform an LDAP modify operation.  dn is the DN of the entry to modify, and mods is a null-terminated array of modifications to make
to the entry.  Each element of the mods array is a pointer to an LDAPMod structure, which is defined below.

typedef struct ldapmod {
int mod_op;
char *mod_type;
union {
char **modv_strvals;
struct berval **modv_bvals;
} mod_vals;
struct ldapmod *mod_next;
} LDAPMod;
#define mod_values mod_vals.modv_strvals
#define mod_bvalues mod_vals.modv_bvals

The mod_op field is used to specify the type of modification to perform and should be one of LDAP_MOD_ADD, LDAP_MOD_DELETE, or LDAP_MOD_REPLACE.   The  mod_type  and  mod_values
fields  specify  the  attribute type to modify and a null-terminated array of values to add, delete, or replace respectively.  The mod_next field is used only by the LDAP server
and may be ignored by the client.

If you need to specify a non-string value (e.g., to add a photo or audio attribute value),  you  should  set  mod_op  to  the  logical  OR  of  the  operation  as  above  (e.g.,
LDAP_MOD_REPLACE)  and  the  constant LDAP_MOD_BVALUES.  In this case, mod_bvalues should be used instead of mod_values, and it should point to a null-terminated array of struct
bervals, as defined in &amp;lt;lber.h&amp;gt;.

For LDAP_MOD_ADD modifications, the given values are added to the entry, creating the attribute if necessary.  For LDAP_MOD_DELETE modifications, the given  values  are  deleted
from  the entry, removing the attribute if no values remain.  If the entire attribute is to be deleted, the mod_values field should be set to NULL.  For LDAP_MOD_REPLACE modifi‐
cations, the attribute will have the listed values after the modification, having been created if necessary.  All modifications are performed in the  order  in  which  they  are
listed.

ldap_mods_free() can be used to free each element of a NULL-terminated array of mod structures.  If freemods is non-zero, the mods pointer itself is freed as well.

ldap_modify_ext_s() returns a code indicating success or, in the case of failure, indicating the nature of the failure.  See ldap_error(3) for details

The ldap_modify_ext() operation works the same way as ldap_modify_ext_s(), except that it is asynchronous. The integer that msgidp points to is set to the message id of the mod‐
ify request.  The result of the operation can be obtained by calling ldap_result(3).

Both ldap_modify_ext() and ldap_modify_ext_s() allows server and client controls to be passed in via the sctrls and cctrls parameters, respectively.

DEPRECATED INTERFACES
The ldap_modify() and ldap_modify_s() routines are deprecated in favor of the ldap_modify_ext() and ldap_modify_ext_s() routines, respectively.

Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed
to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3), ldap_error(3),

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_MODIFY(3)
LDAP_MODRDN(3)                                                                  Library Functions Manual                                                                  LDAP_MODRDN(3)

NAME
ldap_modrdn, ldap_modrdn_s, ldap_modrdn2, ldap_modrdn2_s - Perform an LDAP modify RDN operation

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_modrdn(ld, dn, newrdn)
LDAP ∗ld;
char ∗dn, ∗newrdn;

int ldap_modrdn_s(ld, dn, newrdn)
LDAP ∗ld;
char ∗dn, ∗newrdn;

int ldap_modrdn2(ld, dn, newrdn, deleteoldrdn)
LDAP ∗ld;
char ∗dn, ∗newrdn;
int deleteoldrdn;

int ldap_modrdn2_s(ld, dn, newrdn, deleteoldrdn)
LDAP ∗ld;
char ∗dn, ∗newrdn;
int deleteoldrdn;

DESCRIPTION
The  ldap_modrdn() and ldap_modrdn_s() routines perform an LDAP modify RDN operation.  They both take dn, the DN of the entry whose RDN is to be changed, and newrdn, the new RDN
to give the entry.  The old RDN of the entry is never kept as an attribute of the entry.  ldap_modrdn() is asynchronous, returning the message id of the operation it  initiates.
ldap_modrdn_s()  is  synchronous,  returning  the  LDAP  error  code  indicating the success or failure of the operation.  Use of these routines is deprecated.  Use the versions
described below instead.

The ldap_modrdn2() and ldap_modrdn2_s() routines also perform an LDAP modify RDN operation, taking the same parameters as above.  In addition, they both  take  the  deleteoldrdn
parameter which is used as a boolean value to indicate whether the old RDN values should be deleted from the entry or not.

ERRORS
The  synchronous (_s) versions of these routines return an LDAP error code, either LDAP_SUCCESS or an error if there was trouble.  The asynchronous versions return -1 in case of
trouble, setting the ld_errno field of ld.  See ldap_error(3) for more details.

SEE ALSO
ldap(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_MODRDN(3)
LDAP_MODRDN(3)                                                                  Library Functions Manual                                                                  LDAP_MODRDN(3)

NAME
ldap_modrdn, ldap_modrdn_s, ldap_modrdn2, ldap_modrdn2_s - Perform an LDAP modify RDN operation

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_modrdn(ld, dn, newrdn)
LDAP ∗ld;
char ∗dn, ∗newrdn;

int ldap_modrdn_s(ld, dn, newrdn)
LDAP ∗ld;
char ∗dn, ∗newrdn;

int ldap_modrdn2(ld, dn, newrdn, deleteoldrdn)
LDAP ∗ld;
char ∗dn, ∗newrdn;
int deleteoldrdn;

int ldap_modrdn2_s(ld, dn, newrdn, deleteoldrdn)
LDAP ∗ld;
char ∗dn, ∗newrdn;
int deleteoldrdn;

DESCRIPTION
The  ldap_modrdn() and ldap_modrdn_s() routines perform an LDAP modify RDN operation.  They both take dn, the DN of the entry whose RDN is to be changed, and newrdn, the new RDN
to give the entry.  The old RDN of the entry is never kept as an attribute of the entry.  ldap_modrdn() is asynchronous, returning the message id of the operation it  initiates.
ldap_modrdn_s()  is  synchronous,  returning  the  LDAP  error  code  indicating the success or failure of the operation.  Use of these routines is deprecated.  Use the versions
described below instead.

The ldap_modrdn2() and ldap_modrdn2_s() routines also perform an LDAP modify RDN operation, taking the same parameters as above.  In addition, they both  take  the  deleteoldrdn
parameter which is used as a boolean value to indicate whether the old RDN values should be deleted from the entry or not.

ERRORS
The  synchronous (_s) versions of these routines return an LDAP error code, either LDAP_SUCCESS or an error if there was trouble.  The asynchronous versions return -1 in case of
trouble, setting the ld_errno field of ld.  See ldap_error(3) for more details.

SEE ALSO
ldap(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_MODRDN(3)
LDAP_MODRDN(3)                                                                  Library Functions Manual                                                                  LDAP_MODRDN(3)

NAME
ldap_modrdn, ldap_modrdn_s, ldap_modrdn2, ldap_modrdn2_s - Perform an LDAP modify RDN operation

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_modrdn(ld, dn, newrdn)
LDAP ∗ld;
char ∗dn, ∗newrdn;

int ldap_modrdn_s(ld, dn, newrdn)
LDAP ∗ld;
char ∗dn, ∗newrdn;

int ldap_modrdn2(ld, dn, newrdn, deleteoldrdn)
LDAP ∗ld;
char ∗dn, ∗newrdn;
int deleteoldrdn;

int ldap_modrdn2_s(ld, dn, newrdn, deleteoldrdn)
LDAP ∗ld;
char ∗dn, ∗newrdn;
int deleteoldrdn;

DESCRIPTION
The  ldap_modrdn() and ldap_modrdn_s() routines perform an LDAP modify RDN operation.  They both take dn, the DN of the entry whose RDN is to be changed, and newrdn, the new RDN
to give the entry.  The old RDN of the entry is never kept as an attribute of the entry.  ldap_modrdn() is asynchronous, returning the message id of the operation it  initiates.
ldap_modrdn_s()  is  synchronous,  returning  the  LDAP  error  code  indicating the success or failure of the operation.  Use of these routines is deprecated.  Use the versions
described below instead.

The ldap_modrdn2() and ldap_modrdn2_s() routines also perform an LDAP modify RDN operation, taking the same parameters as above.  In addition, they both  take  the  deleteoldrdn
parameter which is used as a boolean value to indicate whether the old RDN values should be deleted from the entry or not.

ERRORS
The  synchronous (_s) versions of these routines return an LDAP error code, either LDAP_SUCCESS or an error if there was trouble.  The asynchronous versions return -1 in case of
trouble, setting the ld_errno field of ld.  See ldap_error(3) for more details.

SEE ALSO
ldap(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_MODRDN(3)
LDAP_MODRDN(3)                                                                  Library Functions Manual                                                                  LDAP_MODRDN(3)

NAME
ldap_modrdn, ldap_modrdn_s, ldap_modrdn2, ldap_modrdn2_s - Perform an LDAP modify RDN operation

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_modrdn(ld, dn, newrdn)
LDAP ∗ld;
char ∗dn, ∗newrdn;

int ldap_modrdn_s(ld, dn, newrdn)
LDAP ∗ld;
char ∗dn, ∗newrdn;

int ldap_modrdn2(ld, dn, newrdn, deleteoldrdn)
LDAP ∗ld;
char ∗dn, ∗newrdn;
int deleteoldrdn;

int ldap_modrdn2_s(ld, dn, newrdn, deleteoldrdn)
LDAP ∗ld;
char ∗dn, ∗newrdn;
int deleteoldrdn;

DESCRIPTION
The  ldap_modrdn() and ldap_modrdn_s() routines perform an LDAP modify RDN operation.  They both take dn, the DN of the entry whose RDN is to be changed, and newrdn, the new RDN
to give the entry.  The old RDN of the entry is never kept as an attribute of the entry.  ldap_modrdn() is asynchronous, returning the message id of the operation it  initiates.
ldap_modrdn_s()  is  synchronous,  returning  the  LDAP  error  code  indicating the success or failure of the operation.  Use of these routines is deprecated.  Use the versions
described below instead.

The ldap_modrdn2() and ldap_modrdn2_s() routines also perform an LDAP modify RDN operation, taking the same parameters as above.  In addition, they both  take  the  deleteoldrdn
parameter which is used as a boolean value to indicate whether the old RDN values should be deleted from the entry or not.

ERRORS
The  synchronous (_s) versions of these routines return an LDAP error code, either LDAP_SUCCESS or an error if there was trouble.  The asynchronous versions return -1 in case of
trouble, setting the ld_errno field of ld.  See ldap_error(3) for more details.

SEE ALSO
ldap(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_MODRDN(3)
LDAP_MODIFY(3)                                                                  Library Functions Manual                                                                  LDAP_MODIFY(3)

NAME
ldap_modify_ext, ldap_modify_ext_s - Perform an LDAP modify operation

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_modify_ext(
LDAP *ld,
char *dn,
LDAPMod *mods[],
LDAPControl **sctrls,
LDAPControl **cctrls,
int *msgidp );

int ldap_modify_ext_s(
LDAP *ld,
char *dn,
LDAPMod *mods[],
LDAPControl **sctrls,
LDAPControl **cctrls );

void ldap_mods_free(
LDAPMod **mods,
int freemods );

DESCRIPTION
The  routine  ldap_modify_ext_s() is used to perform an LDAP modify operation.  dn is the DN of the entry to modify, and mods is a null-terminated array of modifications to make
to the entry.  Each element of the mods array is a pointer to an LDAPMod structure, which is defined below.

typedef struct ldapmod {
int mod_op;
char *mod_type;
union {
char **modv_strvals;
struct berval **modv_bvals;
} mod_vals;
struct ldapmod *mod_next;
} LDAPMod;
#define mod_values mod_vals.modv_strvals
#define mod_bvalues mod_vals.modv_bvals

The mod_op field is used to specify the type of modification to perform and should be one of LDAP_MOD_ADD, LDAP_MOD_DELETE, or LDAP_MOD_REPLACE.   The  mod_type  and  mod_values
fields  specify  the  attribute type to modify and a null-terminated array of values to add, delete, or replace respectively.  The mod_next field is used only by the LDAP server
and may be ignored by the client.

If you need to specify a non-string value (e.g., to add a photo or audio attribute value),  you  should  set  mod_op  to  the  logical  OR  of  the  operation  as  above  (e.g.,
LDAP_MOD_REPLACE)  and  the  constant LDAP_MOD_BVALUES.  In this case, mod_bvalues should be used instead of mod_values, and it should point to a null-terminated array of struct
bervals, as defined in &amp;lt;lber.h&amp;gt;.

For LDAP_MOD_ADD modifications, the given values are added to the entry, creating the attribute if necessary.  For LDAP_MOD_DELETE modifications, the given  values  are  deleted
from  the entry, removing the attribute if no values remain.  If the entire attribute is to be deleted, the mod_values field should be set to NULL.  For LDAP_MOD_REPLACE modifi‐
cations, the attribute will have the listed values after the modification, having been created if necessary.  All modifications are performed in the  order  in  which  they  are
listed.

ldap_mods_free() can be used to free each element of a NULL-terminated array of mod structures.  If freemods is non-zero, the mods pointer itself is freed as well.

ldap_modify_ext_s() returns a code indicating success or, in the case of failure, indicating the nature of the failure.  See ldap_error(3) for details

The ldap_modify_ext() operation works the same way as ldap_modify_ext_s(), except that it is asynchronous. The integer that msgidp points to is set to the message id of the mod‐
ify request.  The result of the operation can be obtained by calling ldap_result(3).

Both ldap_modify_ext() and ldap_modify_ext_s() allows server and client controls to be passed in via the sctrls and cctrls parameters, respectively.

DEPRECATED INTERFACES
The ldap_modify() and ldap_modify_s() routines are deprecated in favor of the ldap_modify_ext() and ldap_modify_ext_s() routines, respectively.

Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed
to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3), ldap_error(3),

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_MODIFY(3)
LDAP_RESULT(3)                                                                  Library Functions Manual                                                                  LDAP_RESULT(3)

NAME
ldap_result - Wait for the result of an LDAP operation

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_result( LDAP *ld, int msgid, int all,
struct timeval *timeout, LDAPMessage **result );

int ldap_msgfree( LDAPMessage *msg );

int ldap_msgtype( LDAPMessage *msg );

int ldap_msgid( LDAPMessage *msg );

DESCRIPTION
The  ldap_result()  routine  is  used  to  wait  for  and  return  the  result  of  an  operation  previously initiated by one of the LDAP asynchronous operation routines (e.g.,
ldap_search_ext(3), ldap_modify_ext(3), etc.).  Those routines all return -1 in case of error, and an invocation identifier upon successful  initiation  of  the  operation.  The
invocation  identifier  is  picked  by  the  library  and  is guaranteed to be unique across the LDAP session.  It can be used to request the result of a specific operation from
ldap_result() through the msgid parameter.

The ldap_result() routine will block or not, depending upon the setting of the timeout parameter.  If timeout is not a NULL pointer,  it  specifies  a  maximum interval  to wait
for  the  selection  to  complete.   If  timeout  is a NULL  pointer, the LDAP_OPT_TIMEOUT value set by ldap_set_option(3) is used. With the default setting, the  select  blocks
indefinitely.   To effect  a  poll,  the  timeout argument should be a non-NULL pointer, pointing to a zero-valued timeval structure.  To obtain the behavior of the default set‐
ting, bypassing any value set by ldap_set_option(3), set to -1 the tv_sec field of the timeout parameter.  See select(2) for further details.

If  the  result  of  a  specific  operation  is  required,  msgid should be set to the invocation identifier returned when the operation was initiated, otherwise LDAP_RES_ANY or
LDAP_RES_UNSOLICITED should be supplied to wait for any or unsolicited response.

The all parameter, if non-zero, causes ldap_result() to return all responses with msgid, otherwise only the next response is returned.  This is commonly used to obtain  all  the
responses of a search operation.

A  search response is made up of zero or more search entries, zero or more search references, and zero or more extended partial responses followed by a search result.  If all is
set to 0, search entries will be returned one at a time as they come in, via separate calls to ldap_result().  If it's set to 1, the search response will only be returned in its
entirety, i.e., after all entries, all references, all extended partial responses, and the final search result have been received.

RETURN VALUE
Upon  success, the type of the result received is returned and the result parameter will contain the result of the operation; otherwise, the result parameter is undefined.  This
result should be passed to the LDAP parsing routines, ldap_first_message(3) and friends, for interpretation.

The possible result types returned are:

LDAP_RES_BIND (0x61)
LDAP_RES_SEARCH_ENTRY (0x64)
LDAP_RES_SEARCH_REFERENCE (0x73)
LDAP_RES_SEARCH_RESULT (0x65)
LDAP_RES_MODIFY (0x67)
LDAP_RES_ADD (0x69)
LDAP_RES_DELETE (0x6b)
LDAP_RES_MODDN (0x6d)
LDAP_RES_COMPARE (0x6f)
LDAP_RES_EXTENDED (0x78)
LDAP_RES_INTERMEDIATE (0x79)

The ldap_msgfree() routine is used to free the memory allocated for result(s) by ldap_result() or ldap_search_ext_s(3) and friends.  It takes a pointer to the result  or  result
chain to be freed and returns the type of the last message in the chain.  If the parameter is NULL, the function does nothing and returns zero.

The ldap_msgtype() routine returns the type of a message.

The ldap_msgid() routine returns the message id of a message.

ERRORS
ldap_result() returns -1 if something bad happens, and zero if the timeout specified was exceeded.  ldap_msgtype() and ldap_msgid() return -1 on error.

SEE ALSO
ldap(3), ldap_first_message(3), select(2)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_RESULT(3)
LDAP_RESULT(3)                                                                  Library Functions Manual                                                                  LDAP_RESULT(3)

NAME
ldap_result - Wait for the result of an LDAP operation

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_result( LDAP *ld, int msgid, int all,
struct timeval *timeout, LDAPMessage **result );

int ldap_msgfree( LDAPMessage *msg );

int ldap_msgtype( LDAPMessage *msg );

int ldap_msgid( LDAPMessage *msg );

DESCRIPTION
The  ldap_result()  routine  is  used  to  wait  for  and  return  the  result  of  an  operation  previously initiated by one of the LDAP asynchronous operation routines (e.g.,
ldap_search_ext(3), ldap_modify_ext(3), etc.).  Those routines all return -1 in case of error, and an invocation identifier upon successful  initiation  of  the  operation.  The
invocation  identifier  is  picked  by  the  library  and  is guaranteed to be unique across the LDAP session.  It can be used to request the result of a specific operation from
ldap_result() through the msgid parameter.

The ldap_result() routine will block or not, depending upon the setting of the timeout parameter.  If timeout is not a NULL pointer,  it  specifies  a  maximum interval  to wait
for  the  selection  to  complete.   If  timeout  is a NULL  pointer, the LDAP_OPT_TIMEOUT value set by ldap_set_option(3) is used. With the default setting, the  select  blocks
indefinitely.   To effect  a  poll,  the  timeout argument should be a non-NULL pointer, pointing to a zero-valued timeval structure.  To obtain the behavior of the default set‐
ting, bypassing any value set by ldap_set_option(3), set to -1 the tv_sec field of the timeout parameter.  See select(2) for further details.

If  the  result  of  a  specific  operation  is  required,  msgid should be set to the invocation identifier returned when the operation was initiated, otherwise LDAP_RES_ANY or
LDAP_RES_UNSOLICITED should be supplied to wait for any or unsolicited response.

The all parameter, if non-zero, causes ldap_result() to return all responses with msgid, otherwise only the next response is returned.  This is commonly used to obtain  all  the
responses of a search operation.

A  search response is made up of zero or more search entries, zero or more search references, and zero or more extended partial responses followed by a search result.  If all is
set to 0, search entries will be returned one at a time as they come in, via separate calls to ldap_result().  If it's set to 1, the search response will only be returned in its
entirety, i.e., after all entries, all references, all extended partial responses, and the final search result have been received.

RETURN VALUE
Upon  success, the type of the result received is returned and the result parameter will contain the result of the operation; otherwise, the result parameter is undefined.  This
result should be passed to the LDAP parsing routines, ldap_first_message(3) and friends, for interpretation.

The possible result types returned are:

LDAP_RES_BIND (0x61)
LDAP_RES_SEARCH_ENTRY (0x64)
LDAP_RES_SEARCH_REFERENCE (0x73)
LDAP_RES_SEARCH_RESULT (0x65)
LDAP_RES_MODIFY (0x67)
LDAP_RES_ADD (0x69)
LDAP_RES_DELETE (0x6b)
LDAP_RES_MODDN (0x6d)
LDAP_RES_COMPARE (0x6f)
LDAP_RES_EXTENDED (0x78)
LDAP_RES_INTERMEDIATE (0x79)

The ldap_msgfree() routine is used to free the memory allocated for result(s) by ldap_result() or ldap_search_ext_s(3) and friends.  It takes a pointer to the result  or  result
chain to be freed and returns the type of the last message in the chain.  If the parameter is NULL, the function does nothing and returns zero.

The ldap_msgtype() routine returns the type of a message.

The ldap_msgid() routine returns the message id of a message.

ERRORS
ldap_result() returns -1 if something bad happens, and zero if the timeout specified was exceeded.  ldap_msgtype() and ldap_msgid() return -1 on error.

SEE ALSO
ldap(3), ldap_first_message(3), select(2)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_RESULT(3)
LDAP_RESULT(3)                                                                  Library Functions Manual                                                                  LDAP_RESULT(3)

NAME
ldap_result - Wait for the result of an LDAP operation

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_result( LDAP *ld, int msgid, int all,
struct timeval *timeout, LDAPMessage **result );

int ldap_msgfree( LDAPMessage *msg );

int ldap_msgtype( LDAPMessage *msg );

int ldap_msgid( LDAPMessage *msg );

DESCRIPTION
The  ldap_result()  routine  is  used  to  wait  for  and  return  the  result  of  an  operation  previously initiated by one of the LDAP asynchronous operation routines (e.g.,
ldap_search_ext(3), ldap_modify_ext(3), etc.).  Those routines all return -1 in case of error, and an invocation identifier upon successful  initiation  of  the  operation.  The
invocation  identifier  is  picked  by  the  library  and  is guaranteed to be unique across the LDAP session.  It can be used to request the result of a specific operation from
ldap_result() through the msgid parameter.

The ldap_result() routine will block or not, depending upon the setting of the timeout parameter.  If timeout is not a NULL pointer,  it  specifies  a  maximum interval  to wait
for  the  selection  to  complete.   If  timeout  is a NULL  pointer, the LDAP_OPT_TIMEOUT value set by ldap_set_option(3) is used. With the default setting, the  select  blocks
indefinitely.   To effect  a  poll,  the  timeout argument should be a non-NULL pointer, pointing to a zero-valued timeval structure.  To obtain the behavior of the default set‐
ting, bypassing any value set by ldap_set_option(3), set to -1 the tv_sec field of the timeout parameter.  See select(2) for further details.

If  the  result  of  a  specific  operation  is  required,  msgid should be set to the invocation identifier returned when the operation was initiated, otherwise LDAP_RES_ANY or
LDAP_RES_UNSOLICITED should be supplied to wait for any or unsolicited response.

The all parameter, if non-zero, causes ldap_result() to return all responses with msgid, otherwise only the next response is returned.  This is commonly used to obtain  all  the
responses of a search operation.

A  search response is made up of zero or more search entries, zero or more search references, and zero or more extended partial responses followed by a search result.  If all is
set to 0, search entries will be returned one at a time as they come in, via separate calls to ldap_result().  If it's set to 1, the search response will only be returned in its
entirety, i.e., after all entries, all references, all extended partial responses, and the final search result have been received.

RETURN VALUE
Upon  success, the type of the result received is returned and the result parameter will contain the result of the operation; otherwise, the result parameter is undefined.  This
result should be passed to the LDAP parsing routines, ldap_first_message(3) and friends, for interpretation.

The possible result types returned are:

LDAP_RES_BIND (0x61)
LDAP_RES_SEARCH_ENTRY (0x64)
LDAP_RES_SEARCH_REFERENCE (0x73)
LDAP_RES_SEARCH_RESULT (0x65)
LDAP_RES_MODIFY (0x67)
LDAP_RES_ADD (0x69)
LDAP_RES_DELETE (0x6b)
LDAP_RES_MODDN (0x6d)
LDAP_RES_COMPARE (0x6f)
LDAP_RES_EXTENDED (0x78)
LDAP_RES_INTERMEDIATE (0x79)

The ldap_msgfree() routine is used to free the memory allocated for result(s) by ldap_result() or ldap_search_ext_s(3) and friends.  It takes a pointer to the result  or  result
chain to be freed and returns the type of the last message in the chain.  If the parameter is NULL, the function does nothing and returns zero.

The ldap_msgtype() routine returns the type of a message.

The ldap_msgid() routine returns the message id of a message.

ERRORS
ldap_result() returns -1 if something bad happens, and zero if the timeout specified was exceeded.  ldap_msgtype() and ldap_msgid() return -1 on error.

SEE ALSO
ldap(3), ldap_first_message(3), select(2)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_RESULT(3)
LDAP_FIRST_ATTRIBUTE(3)                                                         Library Functions Manual                                                         LDAP_FIRST_ATTRIBUTE(3)

NAME
ldap_first_attribute, ldap_next_attribute - step through LDAP entry attributes

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

char *ldap_first_attribute(
LDAP *ld, LDAPMessage *entry, BerElement **berptr )

char *ldap_next_attribute(
LDAP *ld, LDAPMessage *entry, BerElement *ber )

DESCRIPTION
The  ldap_first_attribute()  and  ldap_next_attribute()  routines are used to step through the attributes in an LDAP entry.  ldap_first_attribute() takes an entry as returned by
ldap_first_entry(3) or ldap_next_entry(3) and returns a pointer to character string containing the first attribute description in the entry.  ldap_next_attribute()  returns  the
next attribute description in the entry.

It  also  returns,  in  berptr,  a  pointer  to  a  BerElement  it  has  allocated  to  keep track of its current position.  This pointer should be passed to subsequent calls to
ldap_next_attribute() and is used to effectively step through the entry's attributes.  The caller is solely responsible for freeing the BerElement pointed to by berptr  when  it
is no longer needed by calling ber_free(3).  When calling ber_free(3) in this instance, be sure the second argument is 0.

The attribute names returned are suitable for inclusion in a call to ldap_get_values(3) to retrieve the attribute's values.

ERRORS
If an error occurs, NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  See ldap_error(3) for a description of possible error codes.

NOTES
The ldap_first_attribute() and ldap_next_attribute() return dynamically allocated memory that must be freed by the caller via ldap_memfree(3).

SEE ALSO
ldap(3), ldap_first_entry(3), ldap_get_values(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                LDAP_FIRST_ATTRIBUTE(3)
LDAP_FIRST_ENTRY(3)                                                             Library Functions Manual                                                             LDAP_FIRST_ENTRY(3)

NAME
ldap_first_entry, ldap_next_entry, ldap_count_entries - LDAP result entry parsing and counting routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_count_entries( LDAP *ld, LDAPMessage *result )

LDAPMessage *ldap_first_entry( LDAP *ld, LDAPMessage *result )

LDAPMessage *ldap_next_entry( LDAP *ld, LDAPMessage *entry )

DESCRIPTION
These routines are used to parse results received from ldap_result(3) or the synchronous LDAP search operation routines ldap_search_s(3) and ldap_search_st(3).

The ldap_first_entry() routine is used to retrieve the first entry in a chain of search results.  It takes the result as returned by a call to ldap_result(3) or ldap_search_s(3)
or ldap_search_st(3) and returns a pointer to the first entry in the result.

This pointer should be supplied on a subsequent call to ldap_next_entry() to get the next entry, the result of which should be supplied to the next  call  to  ldap_next_entry(),
etc.   ldap_next_entry()  will  return NULL when there are no more entries.  The entries returned from these calls are used in calls to the routines described in ldap_get_dn(3),
ldap_first_attribute(3), ldap_get_values(3), etc.

A count of the number of entries in the search result can be obtained by calling ldap_count_entries().

ERRORS
If an error occurs in ldap_first_entry() or ldap_next_entry(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  If an error  occurs  in
ldap_count_entries(), -1 is returned, and ld_errno is set appropriately.  See ldap_error(3) for a description of possible error codes.

SEE ALSO
ldap(3), ldap_result(3), ldap_search(3), ldap_first_attribute(3), ldap_get_values(3), ldap_get_dn(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                    LDAP_FIRST_ENTRY(3)
LDAP_FIRST_MESSAGE(3)                                                           Library Functions Manual                                                           LDAP_FIRST_MESSAGE(3)

NAME
ldap_first_message, ldap_next_message, ldap_count_messages - Stepping through messages in a result chain

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_count_messages( LDAP *ld, LDAPMessage *result )

LDAPMessage *ldap_first_message( LDAP *ld, LDAPMessage *result )

LDAPMessage *ldap_next_message( LDAP *ld, LDAPMessage *message )

DESCRIPTION
These  routines  are  used  to step through the messages in a result chain received from ldap_result(3).  For search operations, the result chain can contain referral, entry and
result messages. The ldap_msgtype(3) function can be used to distinguish between the different message types.

The ldap_first_message() routine is used to retrieve the first message in a result chain.  It takes the result as returned by  a  call  to  ldap_result(3),  ldap_search_s(3)  or
ldap_search_st(3) and returns a pointer to the first message in the result chain.

This  pointer  should  be supplied on a subsequent call to ldap_next_message() to get the next message, the result of which should be supplied to the next call to ldap_next_mes‐
sage(), etc.  ldap_next_message() will return NULL when there are no more messages.

These functions are useful when using routines like ldap_parse_result(3) that only operate on the first result in the chain.

A count of the number of messages in the result chain can be obtained by calling ldap_count_messages().  It can also be used to count the number of remaining messages in a chain
if  called  with  a  message,  entry  or  reference  returned  by  ldap_first_message() , ldap_next_message() , ldap_first_entry(3), ldap_next_entry(3), ldap_first_reference(3),
ldap_next_reference(3).

ERRORS
If an error occurs in ldap_first_message() or ldap_next_message(), NULL is returned.  If an error occurs in ldap_count_messages(), -1 is returned.

SEE ALSO
ldap(3), ldap_search(3), ldap_result(3), ldap_parse_result(3), ldap_first_entry(3), ldap_first_reference(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                  LDAP_FIRST_MESSAGE(3)
LDAP_FIRST_REFERENCE(3)                                                         Library Functions Manual                                                         LDAP_FIRST_REFERENCE(3)

NAME
ldap_first_reference, ldap_next_reference, ldap_count_references - Stepping through continuation references in a result chain

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_count_references( LDAP *ld, LDAPMessage *result )

LDAPMessage *ldap_first_reference( LDAP *ld, LDAPMessage *result )

LDAPMessage *ldap_next_reference( LDAP *ld, LDAPMessage *reference )

DESCRIPTION
These routines are used to step through the continuation references in a result chain received from ldap_result(3) or the synchronous LDAP search operation routines.

The  ldap_first_reference()  routine  is  used  to  retrieve  the  first  reference  message  in  a  result  chain.  It takes the result as returned by a call to ldap_result(3),
ldap_search_s(3) or ldap_search_st(3) and returns a pointer to the first reference message in the result chain.

This pointer should be supplied on a subsequent call to ldap_next_reference() to get the next reference message, the result of which should be  supplied  to  the  next  call  to
ldap_next_reference(),  etc.   ldap_next_reference()  will  return  NULL when there are no more reference messages.  The reference messages returned from these calls are used by
ldap_parse_reference(3) to extract referrals and controls.

A count of the number of reference messages in the search result can be obtained by calling ldap_count_references().  It can also be used to count the number of  reference  mes‐
sages remaining in a result chain.

ERRORS
If an error occurs in ldap_first_reference() or ldap_next_reference(), NULL is returned.  If an error occurs in ldap_count_references(), -1 is returned.

SEE ALSO
ldap(3), ldap_result(3), ldap_search(3), ldap_parse_reference(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                LDAP_FIRST_REFERENCE(3)
LDAP_SCHEMA(3)                                                                  Library Functions Manual                                                                  LDAP_SCHEMA(3)

NAME
ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,
ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object‐
class_free, ldap_scherr2str - Schema definition handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;
#include &amp;lt;ldap_schema.h&amp;gt;

LDAPSyntax * ldap_str2syntax(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_syntax2str(syn)
const LDAPSyntax * syn;

const char * ldap_syntax2name(syn)
LDAPSyntax * syn;

ldap_syntax_free(syn)
LDAPSyntax * syn;

LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_matchingrule2str(mr);
const LDAPMatchingRule * mr;

const char * ldap_matchingrule2name(mr)
LDAPMatchingRule * mr;

ldap_matchingrule_free(mr)
LDAPMatchingRule * mr;

LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_attributetype2str(at)
const LDAPAttributeType * at;

const char * ldap_attributetype2name(at)
LDAPAttributeType * at;

ldap_attributetype_free(at)
LDAPAttributeType * at;

LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_objectclass2str(oc)
const LDAPObjectClass * oc;

const char * ldap_objectclass2name(oc)
LDAPObjectClass * oc;

ldap_objectclass_free(oc)
LDAPObjectClass * oc;

char * ldap_scherr2str(code)
int code;

DESCRIPTION
These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:
syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.

ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate
kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,
the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter‐
minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a
bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:

LDAP_SCHEMA_ALLOW_NONE
strict parsing according to RFC 4512.

LDAP_SCHEMA_ALLOW_NO_OID
permit definitions that do not contain an initial OID.

LDAP_SCHEMA_ALLOW_QUOTED
permit quotes around some items that should not have them.

LDAP_SCHEMA_ALLOW_DESCR
permit a descr instead of a numeric OID in places where the syntax expect the latter.

LDAP_SCHEMA_ALLOW_DESCR_PREFIX
permit that the initial numeric OID contains a prefix in descr format.

LDAP_SCHEMA_ALLOW_ALL
be very liberal, include all options.

The structures returned are as follows:

typedef struct ldap_schema_extension_item {
char *lsei_name;        /* Extension name */
char **lsei_values;     /* Extension values */
} LDAPSchemaExtensionItem;

typedef struct ldap_syntax {
char *syn_oid;          /* OID */
char **syn_names;       /* Names */
char *syn_desc;         /* Description */
LDAPSchemaExtensionItem **syn_extensions; /* Extension */
} LDAPSyntax;

typedef struct ldap_matchingrule {
char *mr_oid;           /* OID */
char **mr_names;        /* Names */
char *mr_desc;          /* Description */
int  mr_obsolete;       /* Is obsolete? */
char *mr_syntax_oid;    /* Syntax of asserted values */
LDAPSchemaExtensionItem **mr_extensions; /* Extensions */
} LDAPMatchingRule;

typedef struct ldap_attributetype {
char *at_oid;           /* OID */
char **at_names;        /* Names */
char *at_desc;          /* Description */
int  at_obsolete;       /* Is obsolete? */
char *at_sup_oid;       /* OID of superior type */
char *at_equality_oid;  /* OID of equality matching rule */
char *at_ordering_oid;  /* OID of ordering matching rule */
char *at_substr_oid;    /* OID of substrings matching rule */
char *at_syntax_oid;    /* OID of syntax of values */
int  at_syntax_len;     /* Suggested minimum maximum length */
int  at_single_value;   /* Is single-valued?  */
int  at_collective;     /* Is collective? */
int  at_no_user_mod;    /* Are changes forbidden through LDAP? */
int  at_usage;          /* Usage, see below */
LDAPSchemaExtensionItem **at_extensions; /* Extensions */
} LDAPAttributeType;

typedef struct ldap_objectclass {
char *oc_oid;           /* OID */
char **oc_names;        /* Names */
char *oc_desc;          /* Description */
int  oc_obsolete;       /* Is obsolete? */
char **oc_sup_oids;     /* OIDs of superior classes */
int  oc_kind;           /* Kind, see below */
char **oc_at_oids_must; /* OIDs of required attribute types */
char **oc_at_oids_may;  /* OIDs of optional attribute types */
LDAPSchemaExtensionItem **oc_extensions; /* Extensions */
} LDAPObjectClass;

Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:

LDAP_SCHEMA_NO
The answer to the question is no.

LDAP_SCHEMA_YES
The answer to the question is yes.

For attribute types, the following usages are possible:

LDAP_SCHEMA_USER_APPLICATIONS
the attribute type is non-operational.

LDAP_SCHEMA_DIRECTORY_OPERATION
the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute
type.

LDAP_SCHEMA_DISTRIBUTED_OPERATION
the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.

LDAP_SCHEMA_DSA_OPERATION
the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different
servers that master the entry.

Object classes can be of three kinds:

LDAP_SCHEMA_ABSTRACT
the object class is abstract, i.e. there cannot be entries of this class alone.

LDAP_SCHEMA_STRUCTURAL
the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned
cannot be changed: none of those present can be removed and none other can be added.

LDAP_SCHEMA_AUXILIARY
the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added
or removed at the same time as needed by the set of object classes resulting from the operation.

Routines ldap_xxx2name() return a canonical name for the definition.

Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that
must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.

ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The
argument code comes from one of the parsing routines and can adopt the following values:

LDAP_SCHERR_OUTOFMEM
Out of memory.

LDAP_SCHERR_UNEXPTOKEN
Unexpected token.

LDAP_SCHERR_NOLEFTPAREN
Missing opening parenthesis.

LDAP_SCHERR_NORIGHTPAREN
Missing closing parenthesis.

LDAP_SCHERR_NODIGIT
Expecting digit.

LDAP_SCHERR_BADNAME
Expecting a name.

LDAP_SCHERR_BADDESC
Bad description.

LDAP_SCHERR_BADSUP
Bad superiors.

LDAP_SCHERR_DUPOPT
Duplicate option.

LDAP_SCHERR_EMPTY
Unexpected end of data.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_SCHEMA(3)
LDAP_SCHEMA(3)                                                                  Library Functions Manual                                                                  LDAP_SCHEMA(3)

NAME
ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,
ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object‐
class_free, ldap_scherr2str - Schema definition handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;
#include &amp;lt;ldap_schema.h&amp;gt;

LDAPSyntax * ldap_str2syntax(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_syntax2str(syn)
const LDAPSyntax * syn;

const char * ldap_syntax2name(syn)
LDAPSyntax * syn;

ldap_syntax_free(syn)
LDAPSyntax * syn;

LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_matchingrule2str(mr);
const LDAPMatchingRule * mr;

const char * ldap_matchingrule2name(mr)
LDAPMatchingRule * mr;

ldap_matchingrule_free(mr)
LDAPMatchingRule * mr;

LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_attributetype2str(at)
const LDAPAttributeType * at;

const char * ldap_attributetype2name(at)
LDAPAttributeType * at;

ldap_attributetype_free(at)
LDAPAttributeType * at;

LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_objectclass2str(oc)
const LDAPObjectClass * oc;

const char * ldap_objectclass2name(oc)
LDAPObjectClass * oc;

ldap_objectclass_free(oc)
LDAPObjectClass * oc;

char * ldap_scherr2str(code)
int code;

DESCRIPTION
These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:
syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.

ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate
kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,
the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter‐
minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a
bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:

LDAP_SCHEMA_ALLOW_NONE
strict parsing according to RFC 4512.

LDAP_SCHEMA_ALLOW_NO_OID
permit definitions that do not contain an initial OID.

LDAP_SCHEMA_ALLOW_QUOTED
permit quotes around some items that should not have them.

LDAP_SCHEMA_ALLOW_DESCR
permit a descr instead of a numeric OID in places where the syntax expect the latter.

LDAP_SCHEMA_ALLOW_DESCR_PREFIX
permit that the initial numeric OID contains a prefix in descr format.

LDAP_SCHEMA_ALLOW_ALL
be very liberal, include all options.

The structures returned are as follows:

typedef struct ldap_schema_extension_item {
char *lsei_name;        /* Extension name */
char **lsei_values;     /* Extension values */
} LDAPSchemaExtensionItem;

typedef struct ldap_syntax {
char *syn_oid;          /* OID */
char **syn_names;       /* Names */
char *syn_desc;         /* Description */
LDAPSchemaExtensionItem **syn_extensions; /* Extension */
} LDAPSyntax;

typedef struct ldap_matchingrule {
char *mr_oid;           /* OID */
char **mr_names;        /* Names */
char *mr_desc;          /* Description */
int  mr_obsolete;       /* Is obsolete? */
char *mr_syntax_oid;    /* Syntax of asserted values */
LDAPSchemaExtensionItem **mr_extensions; /* Extensions */
} LDAPMatchingRule;

typedef struct ldap_attributetype {
char *at_oid;           /* OID */
char **at_names;        /* Names */
char *at_desc;          /* Description */
int  at_obsolete;       /* Is obsolete? */
char *at_sup_oid;       /* OID of superior type */
char *at_equality_oid;  /* OID of equality matching rule */
char *at_ordering_oid;  /* OID of ordering matching rule */
char *at_substr_oid;    /* OID of substrings matching rule */
char *at_syntax_oid;    /* OID of syntax of values */
int  at_syntax_len;     /* Suggested minimum maximum length */
int  at_single_value;   /* Is single-valued?  */
int  at_collective;     /* Is collective? */
int  at_no_user_mod;    /* Are changes forbidden through LDAP? */
int  at_usage;          /* Usage, see below */
LDAPSchemaExtensionItem **at_extensions; /* Extensions */
} LDAPAttributeType;

typedef struct ldap_objectclass {
char *oc_oid;           /* OID */
char **oc_names;        /* Names */
char *oc_desc;          /* Description */
int  oc_obsolete;       /* Is obsolete? */
char **oc_sup_oids;     /* OIDs of superior classes */
int  oc_kind;           /* Kind, see below */
char **oc_at_oids_must; /* OIDs of required attribute types */
char **oc_at_oids_may;  /* OIDs of optional attribute types */
LDAPSchemaExtensionItem **oc_extensions; /* Extensions */
} LDAPObjectClass;

Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:

LDAP_SCHEMA_NO
The answer to the question is no.

LDAP_SCHEMA_YES
The answer to the question is yes.

For attribute types, the following usages are possible:

LDAP_SCHEMA_USER_APPLICATIONS
the attribute type is non-operational.

LDAP_SCHEMA_DIRECTORY_OPERATION
the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute
type.

LDAP_SCHEMA_DISTRIBUTED_OPERATION
the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.

LDAP_SCHEMA_DSA_OPERATION
the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different
servers that master the entry.

Object classes can be of three kinds:

LDAP_SCHEMA_ABSTRACT
the object class is abstract, i.e. there cannot be entries of this class alone.

LDAP_SCHEMA_STRUCTURAL
the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned
cannot be changed: none of those present can be removed and none other can be added.

LDAP_SCHEMA_AUXILIARY
the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added
or removed at the same time as needed by the set of object classes resulting from the operation.

Routines ldap_xxx2name() return a canonical name for the definition.

Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that
must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.

ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The
argument code comes from one of the parsing routines and can adopt the following values:

LDAP_SCHERR_OUTOFMEM
Out of memory.

LDAP_SCHERR_UNEXPTOKEN
Unexpected token.

LDAP_SCHERR_NOLEFTPAREN
Missing opening parenthesis.

LDAP_SCHERR_NORIGHTPAREN
Missing closing parenthesis.

LDAP_SCHERR_NODIGIT
Expecting digit.

LDAP_SCHERR_BADNAME
Expecting a name.

LDAP_SCHERR_BADDESC
Bad description.

LDAP_SCHERR_BADSUP
Bad superiors.

LDAP_SCHERR_DUPOPT
Duplicate option.

LDAP_SCHERR_EMPTY
Unexpected end of data.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_SCHEMA(3)
LDAP_SCHEMA(3)                                                                  Library Functions Manual                                                                  LDAP_SCHEMA(3)

NAME
ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,
ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object‐
class_free, ldap_scherr2str - Schema definition handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;
#include &amp;lt;ldap_schema.h&amp;gt;

LDAPSyntax * ldap_str2syntax(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_syntax2str(syn)
const LDAPSyntax * syn;

const char * ldap_syntax2name(syn)
LDAPSyntax * syn;

ldap_syntax_free(syn)
LDAPSyntax * syn;

LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_matchingrule2str(mr);
const LDAPMatchingRule * mr;

const char * ldap_matchingrule2name(mr)
LDAPMatchingRule * mr;

ldap_matchingrule_free(mr)
LDAPMatchingRule * mr;

LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_attributetype2str(at)
const LDAPAttributeType * at;

const char * ldap_attributetype2name(at)
LDAPAttributeType * at;

ldap_attributetype_free(at)
LDAPAttributeType * at;

LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_objectclass2str(oc)
const LDAPObjectClass * oc;

const char * ldap_objectclass2name(oc)
LDAPObjectClass * oc;

ldap_objectclass_free(oc)
LDAPObjectClass * oc;

char * ldap_scherr2str(code)
int code;

DESCRIPTION
These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:
syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.

ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate
kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,
the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter‐
minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a
bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:

LDAP_SCHEMA_ALLOW_NONE
strict parsing according to RFC 4512.

LDAP_SCHEMA_ALLOW_NO_OID
permit definitions that do not contain an initial OID.

LDAP_SCHEMA_ALLOW_QUOTED
permit quotes around some items that should not have them.

LDAP_SCHEMA_ALLOW_DESCR
permit a descr instead of a numeric OID in places where the syntax expect the latter.

LDAP_SCHEMA_ALLOW_DESCR_PREFIX
permit that the initial numeric OID contains a prefix in descr format.

LDAP_SCHEMA_ALLOW_ALL
be very liberal, include all options.

The structures returned are as follows:

typedef struct ldap_schema_extension_item {
char *lsei_name;        /* Extension name */
char **lsei_values;     /* Extension values */
} LDAPSchemaExtensionItem;

typedef struct ldap_syntax {
char *syn_oid;          /* OID */
char **syn_names;       /* Names */
char *syn_desc;         /* Description */
LDAPSchemaExtensionItem **syn_extensions; /* Extension */
} LDAPSyntax;

typedef struct ldap_matchingrule {
char *mr_oid;           /* OID */
char **mr_names;        /* Names */
char *mr_desc;          /* Description */
int  mr_obsolete;       /* Is obsolete? */
char *mr_syntax_oid;    /* Syntax of asserted values */
LDAPSchemaExtensionItem **mr_extensions; /* Extensions */
} LDAPMatchingRule;

typedef struct ldap_attributetype {
char *at_oid;           /* OID */
char **at_names;        /* Names */
char *at_desc;          /* Description */
int  at_obsolete;       /* Is obsolete? */
char *at_sup_oid;       /* OID of superior type */
char *at_equality_oid;  /* OID of equality matching rule */
char *at_ordering_oid;  /* OID of ordering matching rule */
char *at_substr_oid;    /* OID of substrings matching rule */
char *at_syntax_oid;    /* OID of syntax of values */
int  at_syntax_len;     /* Suggested minimum maximum length */
int  at_single_value;   /* Is single-valued?  */
int  at_collective;     /* Is collective? */
int  at_no_user_mod;    /* Are changes forbidden through LDAP? */
int  at_usage;          /* Usage, see below */
LDAPSchemaExtensionItem **at_extensions; /* Extensions */
} LDAPAttributeType;

typedef struct ldap_objectclass {
char *oc_oid;           /* OID */
char **oc_names;        /* Names */
char *oc_desc;          /* Description */
int  oc_obsolete;       /* Is obsolete? */
char **oc_sup_oids;     /* OIDs of superior classes */
int  oc_kind;           /* Kind, see below */
char **oc_at_oids_must; /* OIDs of required attribute types */
char **oc_at_oids_may;  /* OIDs of optional attribute types */
LDAPSchemaExtensionItem **oc_extensions; /* Extensions */
} LDAPObjectClass;

Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:

LDAP_SCHEMA_NO
The answer to the question is no.

LDAP_SCHEMA_YES
The answer to the question is yes.

For attribute types, the following usages are possible:

LDAP_SCHEMA_USER_APPLICATIONS
the attribute type is non-operational.

LDAP_SCHEMA_DIRECTORY_OPERATION
the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute
type.

LDAP_SCHEMA_DISTRIBUTED_OPERATION
the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.

LDAP_SCHEMA_DSA_OPERATION
the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different
servers that master the entry.

Object classes can be of three kinds:

LDAP_SCHEMA_ABSTRACT
the object class is abstract, i.e. there cannot be entries of this class alone.

LDAP_SCHEMA_STRUCTURAL
the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned
cannot be changed: none of those present can be removed and none other can be added.

LDAP_SCHEMA_AUXILIARY
the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added
or removed at the same time as needed by the set of object classes resulting from the operation.

Routines ldap_xxx2name() return a canonical name for the definition.

Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that
must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.

ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The
argument code comes from one of the parsing routines and can adopt the following values:

LDAP_SCHERR_OUTOFMEM
Out of memory.

LDAP_SCHERR_UNEXPTOKEN
Unexpected token.

LDAP_SCHERR_NOLEFTPAREN
Missing opening parenthesis.

LDAP_SCHERR_NORIGHTPAREN
Missing closing parenthesis.

LDAP_SCHERR_NODIGIT
Expecting digit.

LDAP_SCHERR_BADNAME
Expecting a name.

LDAP_SCHERR_BADDESC
Bad description.

LDAP_SCHERR_BADSUP
Bad superiors.

LDAP_SCHERR_DUPOPT
Duplicate option.

LDAP_SCHERR_EMPTY
Unexpected end of data.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_SCHEMA(3)
LDAP_OPEN(3)                                                                    Library Functions Manual                                                                    LDAP_OPEN(3)

NAME
ldap_init, ldap_initialize, ldap_open - Initialize the LDAP library and open a connection to an LDAP server

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

LDAP *ldap_open(host, port)
char *host;
int port;

LDAP *ldap_init(host, port)
char *host;
int port;

int ldap_initialize(ldp, uri)
LDAP **ldp;
char *uri;

int ldap_set_urllist_proc(ld, proc, params)
LDAP *ld;
LDAP_URLLIST_PROC *proc;
void *params;

int (LDAP_URLLIST_PROC)(ld, urllist, url, params);
LDAP *ld;
LDAPURLDesc **urllist;
LDAPURLDesc **url;
void *params;

#include &amp;lt;ldap_pvt.h&amp;gt;

int ldap_init_fd(fd, proto, uri, ldp)
ber_socket_t fd;
int proto;
char *uri;
LDAP **ldp;

DESCRIPTION
ldap_open()  opens  a  connection  to  an  LDAP  server  and  allocates  an  LDAP  structure which is used to identify the connection and to maintain per-connection information.
ldap_init() allocates an LDAP structure but does not open an initial connection.  ldap_initialize() allocates an  LDAP  structure  but  does  not  open  an  initial  connection.
ldap_init_fd() allocates an LDAP structure using an existing connection on the provided socket.  One of these routines must be called before any operations are attempted.

ldap_open()  takes  host,  the hostname on which the LDAP server is running, and port, the port number to which to connect.  If the default IANA-assigned port of 389 is desired,
LDAP_PORT should be specified for port.  The host parameter may contain a blank-separated list of hosts to try to connect to, and  each  host  may  optionally  by  of  the  form
host:port.   If  present,  the  :port  overrides the port parameter to ldap_open().  Upon successfully making a connection to an LDAP server, ldap_open() returns a pointer to an
opaque LDAP structure, which should be passed to subsequent calls to ldap_bind(), ldap_search(), etc. Certain fields in the LDAP structure can be set  to  indicate  size  limit,
time  limit,  and  how aliases are handled during operations; read and write access to those fields must occur by calling ldap_get_option(3) and ldap_set_option(3) respectively,
whenever possible.

ldap_init() acts just like ldap_open(), but does not open a connection to the LDAP server.  The actual connection open will occur when the first operation is attempted.

ldap_initialize() acts like ldap_init(), but it returns an integer indicating either success or the failure reason, and it allows to specify details for the  connection  in  the
schema  portion  of the URI.  The uri parameter may be a comma- or whitespace-separated list of URIs containing only the schema, the host, and the port fields.  Apart from ldap,
other (non-standard) recognized values of the schema field are ldaps (LDAP over TLS), ldapi (LDAP over IPC), and cldap (connectionless LDAP).  If other fields are  present,  the
behavior is undefined.

At  this  time,  ldap_open() and ldap_init() are deprecated in favor of ldap_initialize(), essentially because the latter allows to specify a schema in the URI and it explicitly
returns an error code.

ldap_init_fd() allows an LDAP structure to be initialized using an  already-opened  connection.  The  proto  parameter  should  be  one  of  LDAP_PROTO_TCP,  LDAP_PROTO_UDP,  or
LDAP_PROTO_IPC for a connection using TCP, UDP, or IPC, respectively. The value LDAP_PROTO_EXT may also be specified if user-supplied sockbuf handlers are going to be used. Note
that support for UDP is not implemented unless libldap was built with LDAP_CONNECTIONLESS defined.  The uri parameter may optionally be provided for informational purposes.

ldap_set_urllist_proc() allows to set a function proc of type LDAP_URLLIST_PROC that is called when a successful connection can be established.  This function receives the  list
of  URIs  parsed  from the uri string originally passed to ldap_initialize(), and the one that successfully connected.  The function may manipulate the URI list; the typical use
consists in moving the successful URI to the head of the list, so that subsequent attempts to connect to one of the URIs using the same LDAP handle will try it first.  If ld  is
null,  proc  is  set  as  a  global  parameter  that  is inherited by all handlers within the process that are created after the call to ldap_set_urllist_proc().  By default, no
LDAP_URLLIST_PROC is set.  In a multithreaded environment, ldap_set_urllist_proc() must be called before any concurrent operation using the LDAP handle is started.

Note: the first call into the LDAP library also initializes the global options for the library. As such the first call should be single-threaded or otherwise protected to insure
that  only one call is active. It is recommended that ldap_get_option() or ldap_set_option() be used in the program's main thread before any additional threads are created.  See
ldap_get_option(3).

ERRORS
If an error occurs, ldap_open() and ldap_init() will return NULL and errno should be set appropriately.  ldap_initialize() and ldap_init_fd() will directly return the LDAP  code
associated  to  the  error  (or LDAP_SUCCESS in case of success); errno should be set as well whenever appropriate.  ldap_set_urllist_proc() returns LDAP_OPT_ERROR on error, and
LDAP_OPT_SUCCESS on success.

SEE ALSO
ldap(3), ldap_bind(3), ldap_get_option(3), ldap_set_option(3), lber-sockbuf(3), errno(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                           LDAP_OPEN(3)
LDAP_PARSE_RESULT(3)                                                            Library Functions Manual                                                            LDAP_PARSE_RESULT(3)

NAME
ldap_parse_result - Parsing results

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_parse_result( LDAP *ld, LDAPMessage *result,
int *errcodep, char **matcheddnp, char **errmsgp,
char ***referralsp, LDAPControl ***serverctrlsp,
int freeit )

int ldap_parse_sasl_bind_result( LDAP *ld, LDAPMessage *result,
struct berval **servercredp, int freeit )

int ldap_parse_extended_result( LDAP *ld, LDAPMessage *result,
char **retoidp, struct berval **retdatap, int freeit )

DESCRIPTION
These  routines  are  used to extract information from a result message.  They will operate on the first result message in a chain of search results (skipping past other message
types). They  take  the  result  as  returned  by  a  call  to  ldap_result(3),  ldap_search_s(3)  or  ldap_search_st(3).   In  addition  to  ldap_parse_result(),  the  routines
ldap_parse_sasl_bind_result() and ldap_parse_extended_result() are used to get all the result information from SASL bind and extended operations.

The errcodep parameter will be filled in with the result code from the result message.

The server might supply a matched DN string in the message indicating how much of a name in a request was recognized. The matcheddnp parameter will be filled in with this string
if supplied, else it will be NULL. If a string is returned, it should be freed using ldap_memfree(3).

The errmsgp parameter will be filled in with the error message field from the parsed message. This string should be freed using ldap_memfree(3).

The referralsp parameter will be filled in with an allocated array of referral strings from the parsed message. This array should be freed using ldap_memvfree(3).  If no  refer‐
rals were returned, *referralsp is set to NULL.

The  serverctrlsp  parameter  will be filled in with an allocated array of controls copied from the parsed message. The array should be freed using ldap_controls_free(3).  If no
controls were returned, *serverctrlsp is set to NULL.

The freeit parameter determines whether the parsed message is freed or not after the extraction. Any non-zero value will make it free the message.  The  ldap_msgfree(3)  routine
can also be used to free the message later.

For SASL bind results, the servercredp parameter will be filled in with an allocated berval structure containing the credentials from the server if present. The structure should
be freed using ber_bvfree(3).

For extended results, the retoidp parameter will be filled in with the dotted-OID text representation of the name of the extended operation response. The string should be  freed
using ldap_memfree(3).  If no OID was returned, *retoidp is set to NULL.

For  extended  results,  the  retdatap  parameter  will be filled in with a pointer to a berval structure containing the data from the extended operation response. The structure
should be freed using ber_bvfree(3).  If no data were returned, *retdatap is set to NULL.

For all the above result parameters, NULL values can be used in calls in order to ignore certain fields.

ERRORS
Upon success LDAP_SUCCESS is returned. Otherwise the values of the result parameters are undefined.

SEE ALSO
ldap(3), ldap_result(3), ldap_search(3), ldap_memfree(3), ldap_memvfree(3), ldap_get_values(3), ldap_controls_free(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                   LDAP_PARSE_RESULT(3)
LDAP_PARSE_REFERENCE(3)                                                         Library Functions Manual                                                         LDAP_PARSE_REFERENCE(3)

NAME
ldap_parse_reference - Extract referrals and controls from a reference message

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_parse_reference( LDAP *ld, LDAPMessage *reference,
char ***referralsp, LDAPControl ***serverctrlsp,
int freeit )

DESCRIPTION
The  ldap_parse_reference()  routine is used to extract referrals and controls from a reference message.  The reference parameter is a reference message as returned by a call to
ldap_first_reference(3), ldap_next_reference(3), ldap_first_message(3), ldap_next_message(3), or ldap_result(3).

The referralsp parameter will be filled in with an allocated array of character strings. The strings are copies of the referrals contained  in  the  parsed  message.  The  array
should be freed by calling ldap_value_free(3).  If referralsp is NULL, no referrals are returned.  If no referrals were returned, *referralsp is set to NULL.

The  serverctrlsp parameter will be filled in with an allocated array of controls copied from the parsed message. The array should be freed by calling ldap_controls_free(3).  If
serverctrlsp is NULL, no controls are returned.  If no controls were returned, *serverctrlsp is set to NULL.

The freeit parameter determines whether the parsed message is freed or not after the extraction. Any non-zero value will make it free the message.  The  ldap_msgfree(3)  routine
can also be used to free the message later.

ERRORS
Upon success LDAP_SUCCESS is returned. Otherwise the values of the referralsp and serverctrlsp parameters are undefined.

SEE ALSO
ldap(3), ldap_first_reference(3), ldap_first_message(3), ldap_result(3), ldap_get_values(3), ldap_controls_free(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                LDAP_PARSE_REFERENCE(3)
LDAP_PARSE_RESULT(3)                                                            Library Functions Manual                                                            LDAP_PARSE_RESULT(3)

NAME
ldap_parse_result - Parsing results

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_parse_result( LDAP *ld, LDAPMessage *result,
int *errcodep, char **matcheddnp, char **errmsgp,
char ***referralsp, LDAPControl ***serverctrlsp,
int freeit )

int ldap_parse_sasl_bind_result( LDAP *ld, LDAPMessage *result,
struct berval **servercredp, int freeit )

int ldap_parse_extended_result( LDAP *ld, LDAPMessage *result,
char **retoidp, struct berval **retdatap, int freeit )

DESCRIPTION
These  routines  are  used to extract information from a result message.  They will operate on the first result message in a chain of search results (skipping past other message
types). They  take  the  result  as  returned  by  a  call  to  ldap_result(3),  ldap_search_s(3)  or  ldap_search_st(3).   In  addition  to  ldap_parse_result(),  the  routines
ldap_parse_sasl_bind_result() and ldap_parse_extended_result() are used to get all the result information from SASL bind and extended operations.

The errcodep parameter will be filled in with the result code from the result message.

The server might supply a matched DN string in the message indicating how much of a name in a request was recognized. The matcheddnp parameter will be filled in with this string
if supplied, else it will be NULL. If a string is returned, it should be freed using ldap_memfree(3).

The errmsgp parameter will be filled in with the error message field from the parsed message. This string should be freed using ldap_memfree(3).

The referralsp parameter will be filled in with an allocated array of referral strings from the parsed message. This array should be freed using ldap_memvfree(3).  If no  refer‐
rals were returned, *referralsp is set to NULL.

The  serverctrlsp  parameter  will be filled in with an allocated array of controls copied from the parsed message. The array should be freed using ldap_controls_free(3).  If no
controls were returned, *serverctrlsp is set to NULL.

The freeit parameter determines whether the parsed message is freed or not after the extraction. Any non-zero value will make it free the message.  The  ldap_msgfree(3)  routine
can also be used to free the message later.

For SASL bind results, the servercredp parameter will be filled in with an allocated berval structure containing the credentials from the server if present. The structure should
be freed using ber_bvfree(3).

For extended results, the retoidp parameter will be filled in with the dotted-OID text representation of the name of the extended operation response. The string should be  freed
using ldap_memfree(3).  If no OID was returned, *retoidp is set to NULL.

For  extended  results,  the  retdatap  parameter  will be filled in with a pointer to a berval structure containing the data from the extended operation response. The structure
should be freed using ber_bvfree(3).  If no data were returned, *retdatap is set to NULL.

For all the above result parameters, NULL values can be used in calls in order to ignore certain fields.

ERRORS
Upon success LDAP_SUCCESS is returned. Otherwise the values of the result parameters are undefined.

SEE ALSO
ldap(3), ldap_result(3), ldap_search(3), ldap_memfree(3), ldap_memvfree(3), ldap_get_values(3), ldap_controls_free(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                   LDAP_PARSE_RESULT(3)
LDAP_PARSE_RESULT(3)                                                            Library Functions Manual                                                            LDAP_PARSE_RESULT(3)

NAME
ldap_parse_result - Parsing results

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_parse_result( LDAP *ld, LDAPMessage *result,
int *errcodep, char **matcheddnp, char **errmsgp,
char ***referralsp, LDAPControl ***serverctrlsp,
int freeit )

int ldap_parse_sasl_bind_result( LDAP *ld, LDAPMessage *result,
struct berval **servercredp, int freeit )

int ldap_parse_extended_result( LDAP *ld, LDAPMessage *result,
char **retoidp, struct berval **retdatap, int freeit )

DESCRIPTION
These  routines  are  used to extract information from a result message.  They will operate on the first result message in a chain of search results (skipping past other message
types). They  take  the  result  as  returned  by  a  call  to  ldap_result(3),  ldap_search_s(3)  or  ldap_search_st(3).   In  addition  to  ldap_parse_result(),  the  routines
ldap_parse_sasl_bind_result() and ldap_parse_extended_result() are used to get all the result information from SASL bind and extended operations.

The errcodep parameter will be filled in with the result code from the result message.

The server might supply a matched DN string in the message indicating how much of a name in a request was recognized. The matcheddnp parameter will be filled in with this string
if supplied, else it will be NULL. If a string is returned, it should be freed using ldap_memfree(3).

The errmsgp parameter will be filled in with the error message field from the parsed message. This string should be freed using ldap_memfree(3).

The referralsp parameter will be filled in with an allocated array of referral strings from the parsed message. This array should be freed using ldap_memvfree(3).  If no  refer‐
rals were returned, *referralsp is set to NULL.

The  serverctrlsp  parameter  will be filled in with an allocated array of controls copied from the parsed message. The array should be freed using ldap_controls_free(3).  If no
controls were returned, *serverctrlsp is set to NULL.

The freeit parameter determines whether the parsed message is freed or not after the extraction. Any non-zero value will make it free the message.  The  ldap_msgfree(3)  routine
can also be used to free the message later.

For SASL bind results, the servercredp parameter will be filled in with an allocated berval structure containing the credentials from the server if present. The structure should
be freed using ber_bvfree(3).

For extended results, the retoidp parameter will be filled in with the dotted-OID text representation of the name of the extended operation response. The string should be  freed
using ldap_memfree(3).  If no OID was returned, *retoidp is set to NULL.

For  extended  results,  the  retdatap  parameter  will be filled in with a pointer to a berval structure containing the data from the extended operation response. The structure
should be freed using ber_bvfree(3).  If no data were returned, *retdatap is set to NULL.

For all the above result parameters, NULL values can be used in calls in order to ignore certain fields.

ERRORS
Upon success LDAP_SUCCESS is returned. Otherwise the values of the result parameters are undefined.

SEE ALSO
ldap(3), ldap_result(3), ldap_search(3), ldap_memfree(3), ldap_memvfree(3), ldap_get_values(3), ldap_controls_free(3), lber-types(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                   LDAP_PARSE_RESULT(3)
LDAP_PARSE_SORT-CONTROL(3)                                                      Library Functions Manual                                                      LDAP_PARSE_SORT-CONTROL(3)

NAME
ldap_parse_sort_control - Decode the information returned from a search operation that used a server-side sort control

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_parse_sort_control(ld, ctrls, returnCode, attribute)
LDAP *ld;
LDAPControl **ctrls;
unsigned long *returnCode;
char **attribute;

DESCRIPTION
This function is used to parse the results returned in a search operation that uses a server-side sort control.

It  takes  a  null  terminated array of LDAPControl structures usually obtained by a call to the ldap_parse_result function. A returncode which points to the sort control result
code,and an array of LDAPControl structures that list the client controls to use with the search.  The function also takes an out parameter attribute and if the  sort  operation
fails,  the  server  may  return  a string that indicates the first attribute in the sortKey list that caused the failure. If this parameter is NULL, no string is returned. If a
string is returned, the memory should be freed by calling the ldap_memfree function.

NOTES
SEE ALSO
ldap_result(3), ldap_controls_free(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                             LDAP_PARSE_SORT-CONTROL(3)
LDAP_PARSE_VLV_CONTROL(3)                                                       Library Functions Manual                                                       LDAP_PARSE_VLV_CONTROL(3)

NAME
ldap_parse_vlv_control - Decode the information returned from a search operation that used a VLV (virtual list view) control

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_parse_vlv_control( ld, ctrlp, target_posp, list_countp, contextp, errcodep )
LDAP *ld;
LDAPControl **ctrlp;
unsigned long *target_posp, *list_countp;
struct berval **contextp;
int *errcodep;

DESCRIPTION
The  ldap_parse_vlv_control  is  used  to decode the information returned from a search operation that used a VLV (virtual list view)control. It takes a null terminated array of
LDAPControl structures, usually obtained by a call to the ldap_parse_resultfunction, a target_pos which points to the list index of the target entry. If this parameter is  NULL,
the  target  position  is  not  returned. The index returned is an approximation of the position of the target entry. It is not guaranteed to be exact. The parameter list_countp
points to the server's estimate of the size of the list. If this parameter is NULL, the size is not returned. contextp is a pointer to the address of  a  berval  structure  that
contains a server-generated context identifier if server returns one. If server does not return a context identifier, the server returns a NULL in this parameter. If this param‐
eter is set to NULL, the context identifier is not returned. You should use this returned context in the next call to create a VLV control.  When  the  berval  structure  is  no
longer  needed,  you should free the memory by calling the ber_bvfree function.e errcodep is an output parameter, which points to the result code returned by the server. If this
parameter is NULL, the result code is not returned.

See ldap.h for a list of possible return codes.

SEE ALSO
ldap_search(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                              LDAP_PARSE_VLV_CONTROL(3)
LDAP_ERROR(3)                                                                   Library Functions Manual                                                                   LDAP_ERROR(3)

NAME
ldap_perror, ld_errno, ldap_result2error, ldap_errlist, ldap_err2string - LDAP protocol error handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

char *ldap_err2string( int err );

DESCRIPTION
The  ldap_err2string()  routine  provides  short  description  of the various codes returned by routines in this library.  The returned string is a pointer to a static area that
should not be modified.

These codes are either negative, indicating an API error code; positive, indicating an LDAP resultCode other than 'success' (0), or - zero, indicating both successful use of the
API and the LDAP resultCode 'success' (0).

The   code  associated  with  an  LDAP  session  is  accessible  using  ldap_get_option(3)  and  ldap_set_option(3)  with  the  LDAP_OPT_RESULT_CODE  option  (previously  called
LDAP_OPT_ERROR_NUMBER).

PROTOCOL RESULT CODES
This section provides a partial list of protocol codes recognized by the library.  As LDAP is extensible, additional values may be returned.  A complete  listing  of  registered
LDAP result codes can be obtained from the Internet Assigned Numbers Authority &amp;lt;http://www.iana.org&amp;gt;.

LDAP_SUCCESS        The request was successful.

LDAP_OPERATIONS_ERROR
An operations error occurred.

LDAP_PROTOCOL_ERROR A protocol violation was detected.

LDAP_TIMELIMIT_EXCEEDED
An LDAP time limit was exceeded.

LDAP_SIZELIMIT_EXCEEDED
An LDAP size limit was exceeded.

LDAP_COMPARE_FALSE  A compare operation returned false.

LDAP_COMPARE_TRUE   A compare operation returned true.

LDAP_STRONG_AUTH_NOT_SUPPORTED
The LDAP server does not support strong authentication.

LDAP_STRONG_AUTH_REQUIRED
Strong authentication is required for the operation.

LDAP_PARTIAL_RESULTS
Partial results only returned.

LDAP_NO_SUCH_ATTRIBUTE
The attribute type specified does not exist in the entry.

LDAP_UNDEFINED_TYPE The attribute type specified is invalid.

LDAP_INAPPROPRIATE_MATCHING
Filter type not supported for the specified attribute.

LDAP_CONSTRAINT_VIOLATION
An attribute value specified violates some constraint (e.g., a postalAddress has too many lines, or a line that is too long).

LDAP_TYPE_OR_VALUE_EXISTS
An attribute type or attribute value specified already exists in the entry.

LDAP_INVALID_SYNTAX An invalid attribute value was specified.

LDAP_NO_SUCH_OBJECT The specified object does not exist in The Directory.

LDAP_ALIAS_PROBLEM  An alias in The Directory points to a nonexistent entry.

LDAP_INVALID_DN_SYNTAX
A syntactically invalid DN was specified.

LDAP_IS_LEAF        The object specified is a leaf.

LDAP_ALIAS_DEREF_PROBLEM
A problem was encountered when dereferencing an alias.

LDAP_INAPPROPRIATE_AUTH
Inappropriate authentication was specified (e.g., LDAP_AUTH_SIMPLE was specified and the entry does not have a userPassword attribute).

LDAP_INVALID_CREDENTIALS
Invalid credentials were presented (e.g., the wrong password).

LDAP_INSUFFICIENT_ACCESS
The user has insufficient access to perform the operation.

LDAP_BUSY           The DSA is busy.

LDAP_UNAVAILABLE    The DSA is unavailable.

LDAP_UNWILLING_TO_PERFORM
The DSA is unwilling to perform the operation.

LDAP_LOOP_DETECT    A loop was detected.

LDAP_NAMING_VIOLATION
A naming violation occurred.

LDAP_OBJECT_CLASS_VIOLATION
An object class violation occurred (e.g., a "must" attribute was missing from the entry).

LDAP_NOT_ALLOWED_ON_NONLEAF
The operation is not allowed on a nonleaf object.

LDAP_NOT_ALLOWED_ON_RDN
The operation is not allowed on an RDN.

LDAP_ALREADY_EXISTS The entry already exists.

LDAP_NO_OBJECT_CLASS_MODS
Object class modifications are not allowed.

LDAP_OTHER          An unknown error occurred.

API ERROR CODES
This  section  provides  a  complete list of API error codes recognized by the library.   Note that LDAP_SUCCESS indicates success of an API call in addition to representing the
return of the LDAP 'success' resultCode.

LDAP_SERVER_DOWN    The LDAP library can't contact the LDAP server.

LDAP_LOCAL_ERROR    Some local error occurred.  This is usually a failed dynamic memory allocation.

LDAP_ENCODING_ERROR An error was encountered encoding parameters to send to the LDAP server.

LDAP_DECODING_ERROR An error was encountered decoding a result from the LDAP server.

LDAP_TIMEOUT        A timelimit was exceeded while waiting for a result.

LDAP_AUTH_UNKNOWN   The authentication method specified to ldap_bind() is not known.

LDAP_FILTER_ERROR   An invalid filter was supplied to ldap_search() (e.g., unbalanced parentheses).

LDAP_PARAM_ERROR    An ldap routine was called with a bad parameter.

LDAP_NO_MEMORY      An memory allocation (e.g., malloc(3) or other dynamic memory allocator) call failed in an ldap library routine.

LDAP_USER_CANCELED  Indicates the user cancelled the operation.

LDAP_CONNECT_ERROR  Indicates a connection problem.

LDAP_NOT_SUPPORTED  Indicates the routine was called in a manner not supported by the library.

LDAP_CONTROL_NOT_FOUND
Indicates the control provided is unknown to the client library.

LDAP_NO_RESULTS_RETURNED
Indicates no results returned.

LDAP_MORE_RESULTS_TO_RETURN
Indicates more results could be returned.

LDAP_CLIENT_LOOP    Indicates the library has detected a loop in its processing.

LDAP_REFERRAL_LIMIT_EXCEEDED
Indicates the referral limit has been exceeded.

DEPRECATED
Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed
to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3),

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                          LDAP_ERROR(3)
LDAP_RENAME(3)                                                                  Library Functions Manual                                                                  LDAP_RENAME(3)

NAME
ldap_rename, ldap_rename_s - Renames the specified entry.

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_rename( ld, dn, newrdn, newparent, deleteoldrdn, sctrls[], cctrls[], msgidp );
LDAP *ld;
const char *dn, *newrdn, *newparent;
int deleteoldrdn;
LDAPControl *sctrls[], *cctrls[];
int *msgidp);

int ldap_rename_s( ld, dn, newrdn, newparent, deleteoldrdn, sctrls[], cctrls[] );
LDAP *ld;
const char *dn, *newrdn, *newparent;
int deleteoldrdn;
LDAPControl *sctrls[], *cctrls[];

DESCRIPTION
These  routines  are  used to perform a LDAP rename operation.  The function changes the leaf component of an entry's distinguished name and  optionally moves the entry to a new
parent container. The ldap_rename_s performs a rename operation synchronously.  The method takes dn, which points to the distinguished name of the entry whose attribute is being
compared,  newparent,the  distinguished  name  of  the entry's new parent. If this parameter is NULL, only the RDN is changed.  The root DN is specified by passing a zero length
string, "".  deleteoldrdn specifies whether the old RDN should be retained or deleted.  Zero indicates that the old RDN should be  retained.  If  you  choose  this  option,  the
attribute  will  contain both names (the old and the new).  Non-zero indicates that the old RDN should be deleted.  serverctrls points to an array of LDAPControl structures that
list the client controls to use with this extended operation. Use NULL to specify no client controls. clientctrls points to an array of  LDAPControl  structures  that  list  the
client controls to use with the search.

ldap_rename works just like ldap_rename_s, but the operation is asynchronous. It returns the message id of the request it initiated. The result of this operation can be obtained
by calling ldap_result(3).

ERRORS
ldap_rename() returns -1 in case of error initiating the request, and will set the ld_errno field in the ld parameter to indicate the error.  ldap_rename_s()  returns  the  LDAP
error code resulting from the rename operation.

SEE ALSO
ldap(3), ldap_modify(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_RENAME(3)
LDAP_RENAME(3)                                                                  Library Functions Manual                                                                  LDAP_RENAME(3)

NAME
ldap_rename, ldap_rename_s - Renames the specified entry.

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_rename( ld, dn, newrdn, newparent, deleteoldrdn, sctrls[], cctrls[], msgidp );
LDAP *ld;
const char *dn, *newrdn, *newparent;
int deleteoldrdn;
LDAPControl *sctrls[], *cctrls[];
int *msgidp);

int ldap_rename_s( ld, dn, newrdn, newparent, deleteoldrdn, sctrls[], cctrls[] );
LDAP *ld;
const char *dn, *newrdn, *newparent;
int deleteoldrdn;
LDAPControl *sctrls[], *cctrls[];

DESCRIPTION
These  routines  are  used to perform a LDAP rename operation.  The function changes the leaf component of an entry's distinguished name and  optionally moves the entry to a new
parent container. The ldap_rename_s performs a rename operation synchronously.  The method takes dn, which points to the distinguished name of the entry whose attribute is being
compared,  newparent,the  distinguished  name  of  the entry's new parent. If this parameter is NULL, only the RDN is changed.  The root DN is specified by passing a zero length
string, "".  deleteoldrdn specifies whether the old RDN should be retained or deleted.  Zero indicates that the old RDN should be  retained.  If  you  choose  this  option,  the
attribute  will  contain both names (the old and the new).  Non-zero indicates that the old RDN should be deleted.  serverctrls points to an array of LDAPControl structures that
list the client controls to use with this extended operation. Use NULL to specify no client controls. clientctrls points to an array of  LDAPControl  structures  that  list  the
client controls to use with the search.

ldap_rename works just like ldap_rename_s, but the operation is asynchronous. It returns the message id of the request it initiated. The result of this operation can be obtained
by calling ldap_result(3).

ERRORS
ldap_rename() returns -1 in case of error initiating the request, and will set the ld_errno field in the ld parameter to indicate the error.  ldap_rename_s()  returns  the  LDAP
error code resulting from the rename operation.

SEE ALSO
ldap(3), ldap_modify(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_RENAME(3)
LDAP_RESULT(3)                                                                  Library Functions Manual                                                                  LDAP_RESULT(3)

NAME
ldap_result - Wait for the result of an LDAP operation

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_result( LDAP *ld, int msgid, int all,
struct timeval *timeout, LDAPMessage **result );

int ldap_msgfree( LDAPMessage *msg );

int ldap_msgtype( LDAPMessage *msg );

int ldap_msgid( LDAPMessage *msg );

DESCRIPTION
The  ldap_result()  routine  is  used  to  wait  for  and  return  the  result  of  an  operation  previously initiated by one of the LDAP asynchronous operation routines (e.g.,
ldap_search_ext(3), ldap_modify_ext(3), etc.).  Those routines all return -1 in case of error, and an invocation identifier upon successful  initiation  of  the  operation.  The
invocation  identifier  is  picked  by  the  library  and  is guaranteed to be unique across the LDAP session.  It can be used to request the result of a specific operation from
ldap_result() through the msgid parameter.

The ldap_result() routine will block or not, depending upon the setting of the timeout parameter.  If timeout is not a NULL pointer,  it  specifies  a  maximum interval  to wait
for  the  selection  to  complete.   If  timeout  is a NULL  pointer, the LDAP_OPT_TIMEOUT value set by ldap_set_option(3) is used. With the default setting, the  select  blocks
indefinitely.   To effect  a  poll,  the  timeout argument should be a non-NULL pointer, pointing to a zero-valued timeval structure.  To obtain the behavior of the default set‐
ting, bypassing any value set by ldap_set_option(3), set to -1 the tv_sec field of the timeout parameter.  See select(2) for further details.

If  the  result  of  a  specific  operation  is  required,  msgid should be set to the invocation identifier returned when the operation was initiated, otherwise LDAP_RES_ANY or
LDAP_RES_UNSOLICITED should be supplied to wait for any or unsolicited response.

The all parameter, if non-zero, causes ldap_result() to return all responses with msgid, otherwise only the next response is returned.  This is commonly used to obtain  all  the
responses of a search operation.

A  search response is made up of zero or more search entries, zero or more search references, and zero or more extended partial responses followed by a search result.  If all is
set to 0, search entries will be returned one at a time as they come in, via separate calls to ldap_result().  If it's set to 1, the search response will only be returned in its
entirety, i.e., after all entries, all references, all extended partial responses, and the final search result have been received.

RETURN VALUE
Upon  success, the type of the result received is returned and the result parameter will contain the result of the operation; otherwise, the result parameter is undefined.  This
result should be passed to the LDAP parsing routines, ldap_first_message(3) and friends, for interpretation.

The possible result types returned are:

LDAP_RES_BIND (0x61)
LDAP_RES_SEARCH_ENTRY (0x64)
LDAP_RES_SEARCH_REFERENCE (0x73)
LDAP_RES_SEARCH_RESULT (0x65)
LDAP_RES_MODIFY (0x67)
LDAP_RES_ADD (0x69)
LDAP_RES_DELETE (0x6b)
LDAP_RES_MODDN (0x6d)
LDAP_RES_COMPARE (0x6f)
LDAP_RES_EXTENDED (0x78)
LDAP_RES_INTERMEDIATE (0x79)

The ldap_msgfree() routine is used to free the memory allocated for result(s) by ldap_result() or ldap_search_ext_s(3) and friends.  It takes a pointer to the result  or  result
chain to be freed and returns the type of the last message in the chain.  If the parameter is NULL, the function does nothing and returns zero.

The ldap_msgtype() routine returns the type of a message.

The ldap_msgid() routine returns the message id of a message.

ERRORS
ldap_result() returns -1 if something bad happens, and zero if the timeout specified was exceeded.  ldap_msgtype() and ldap_msgid() return -1 on error.

SEE ALSO
ldap(3), ldap_first_message(3), select(2)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_RESULT(3)
LDAP_ERROR(3)                                                                   Library Functions Manual                                                                   LDAP_ERROR(3)

NAME
ldap_perror, ld_errno, ldap_result2error, ldap_errlist, ldap_err2string - LDAP protocol error handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

char *ldap_err2string( int err );

DESCRIPTION
The  ldap_err2string()  routine  provides  short  description  of the various codes returned by routines in this library.  The returned string is a pointer to a static area that
should not be modified.

These codes are either negative, indicating an API error code; positive, indicating an LDAP resultCode other than 'success' (0), or - zero, indicating both successful use of the
API and the LDAP resultCode 'success' (0).

The   code  associated  with  an  LDAP  session  is  accessible  using  ldap_get_option(3)  and  ldap_set_option(3)  with  the  LDAP_OPT_RESULT_CODE  option  (previously  called
LDAP_OPT_ERROR_NUMBER).

PROTOCOL RESULT CODES
This section provides a partial list of protocol codes recognized by the library.  As LDAP is extensible, additional values may be returned.  A complete  listing  of  registered
LDAP result codes can be obtained from the Internet Assigned Numbers Authority &amp;lt;http://www.iana.org&amp;gt;.

LDAP_SUCCESS        The request was successful.

LDAP_OPERATIONS_ERROR
An operations error occurred.

LDAP_PROTOCOL_ERROR A protocol violation was detected.

LDAP_TIMELIMIT_EXCEEDED
An LDAP time limit was exceeded.

LDAP_SIZELIMIT_EXCEEDED
An LDAP size limit was exceeded.

LDAP_COMPARE_FALSE  A compare operation returned false.

LDAP_COMPARE_TRUE   A compare operation returned true.

LDAP_STRONG_AUTH_NOT_SUPPORTED
The LDAP server does not support strong authentication.

LDAP_STRONG_AUTH_REQUIRED
Strong authentication is required for the operation.

LDAP_PARTIAL_RESULTS
Partial results only returned.

LDAP_NO_SUCH_ATTRIBUTE
The attribute type specified does not exist in the entry.

LDAP_UNDEFINED_TYPE The attribute type specified is invalid.

LDAP_INAPPROPRIATE_MATCHING
Filter type not supported for the specified attribute.

LDAP_CONSTRAINT_VIOLATION
An attribute value specified violates some constraint (e.g., a postalAddress has too many lines, or a line that is too long).

LDAP_TYPE_OR_VALUE_EXISTS
An attribute type or attribute value specified already exists in the entry.

LDAP_INVALID_SYNTAX An invalid attribute value was specified.

LDAP_NO_SUCH_OBJECT The specified object does not exist in The Directory.

LDAP_ALIAS_PROBLEM  An alias in The Directory points to a nonexistent entry.

LDAP_INVALID_DN_SYNTAX
A syntactically invalid DN was specified.

LDAP_IS_LEAF        The object specified is a leaf.

LDAP_ALIAS_DEREF_PROBLEM
A problem was encountered when dereferencing an alias.

LDAP_INAPPROPRIATE_AUTH
Inappropriate authentication was specified (e.g., LDAP_AUTH_SIMPLE was specified and the entry does not have a userPassword attribute).

LDAP_INVALID_CREDENTIALS
Invalid credentials were presented (e.g., the wrong password).

LDAP_INSUFFICIENT_ACCESS
The user has insufficient access to perform the operation.

LDAP_BUSY           The DSA is busy.

LDAP_UNAVAILABLE    The DSA is unavailable.

LDAP_UNWILLING_TO_PERFORM
The DSA is unwilling to perform the operation.

LDAP_LOOP_DETECT    A loop was detected.

LDAP_NAMING_VIOLATION
A naming violation occurred.

LDAP_OBJECT_CLASS_VIOLATION
An object class violation occurred (e.g., a "must" attribute was missing from the entry).

LDAP_NOT_ALLOWED_ON_NONLEAF
The operation is not allowed on a nonleaf object.

LDAP_NOT_ALLOWED_ON_RDN
The operation is not allowed on an RDN.

LDAP_ALREADY_EXISTS The entry already exists.

LDAP_NO_OBJECT_CLASS_MODS
Object class modifications are not allowed.

LDAP_OTHER          An unknown error occurred.

API ERROR CODES
This  section  provides  a  complete list of API error codes recognized by the library.   Note that LDAP_SUCCESS indicates success of an API call in addition to representing the
return of the LDAP 'success' resultCode.

LDAP_SERVER_DOWN    The LDAP library can't contact the LDAP server.

LDAP_LOCAL_ERROR    Some local error occurred.  This is usually a failed dynamic memory allocation.

LDAP_ENCODING_ERROR An error was encountered encoding parameters to send to the LDAP server.

LDAP_DECODING_ERROR An error was encountered decoding a result from the LDAP server.

LDAP_TIMEOUT        A timelimit was exceeded while waiting for a result.

LDAP_AUTH_UNKNOWN   The authentication method specified to ldap_bind() is not known.

LDAP_FILTER_ERROR   An invalid filter was supplied to ldap_search() (e.g., unbalanced parentheses).

LDAP_PARAM_ERROR    An ldap routine was called with a bad parameter.

LDAP_NO_MEMORY      An memory allocation (e.g., malloc(3) or other dynamic memory allocator) call failed in an ldap library routine.

LDAP_USER_CANCELED  Indicates the user cancelled the operation.

LDAP_CONNECT_ERROR  Indicates a connection problem.

LDAP_NOT_SUPPORTED  Indicates the routine was called in a manner not supported by the library.

LDAP_CONTROL_NOT_FOUND
Indicates the control provided is unknown to the client library.

LDAP_NO_RESULTS_RETURNED
Indicates no results returned.

LDAP_MORE_RESULTS_TO_RETURN
Indicates more results could be returned.

LDAP_CLIENT_LOOP    Indicates the library has detected a loop in its processing.

LDAP_REFERRAL_LIMIT_EXCEEDED
Indicates the referral limit has been exceeded.

DEPRECATED
Deprecated interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program  designed
to  use  deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it is expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3),

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                          LDAP_ERROR(3)
LDAP_BIND(3)                                                                    Library Functions Manual                                                                    LDAP_BIND(3)

NAME
ldap_bind,   ldap_bind_s,   ldap_simple_bind,  ldap_simple_bind_s,  ldap_sasl_bind,  ldap_sasl_bind_s,  ldap_sasl_interactive_bind_s,  ldap_parse_sasl_bind_result,  ldap_unbind,
ldap_unbind_s, ldap_unbind_ext, ldap_unbind_ext_s, ldap_set_rebind_proc - LDAP bind routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_bind(LDAP *ld, const char *who, const char *cred,
int method);

int ldap_bind_s(LDAP *ld, const char *who, const char *cred,
int method);

int ldap_simple_bind(LDAP *ld, const char *who, const char *passwd);

int ldap_simple_bind_s(LDAP *ld, const char *who, const char *passwd);

int ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,
struct berval *cred, LDAPControl *sctrls[],
LDAPControl *cctrls[], int *msgidp);

int ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,
struct berval *cred, LDAPControl *sctrls[],
LDAPControl *cctrls[], struct berval **servercredp);

int ldap_parse_sasl_bind_result(LDAP *ld, LDAPMessage *res,
struct berval **servercredp, int freeit);

int ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn,
const char *mechs,
LDAPControl *sctrls[], LDAPControl *cctrls[],
unsigned flags, LDAP_SASL_INTERACT_PROC *interact,
void *defaults);

int ldap_sasl_interactive_bind(LDAP *ld, const char *dn,
const char *mechs,
LDAPControl *sctrls[], LDAPControl *cctrls[],
unsigned flags, LDAP_SASL_INTERACT_PROC *interact,
void *defaults, LDAPMessage *result,
const char **rmechp, int *msgidp);

int (LDAP_SASL_INTERACT_PROC)(LDAP *ld, unsigned flags, void *defaults, void *sasl_interact);

int ldap_unbind(LDAP *ld);

int ldap_unbind_s(LDAP *ld);

int ldap_unbind_ext(LDAP *ld, LDAPControl *sctrls[],
LDAPControl *cctrls[]);

int ldap_unbind_ext_s(LDAP *ld, LDAPControl *sctrls[],
LDAPControl *cctrls[]);

int ldap_set_rebind_proc (LDAP *ld, LDAP_REBIND_PROC *ldap_proc, void *params);

int (LDAP_REBIND_PROC)(LDAP *ld, LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *params);

DESCRIPTION
These routines provide various interfaces to the LDAP bind operation.  After an association with an LDAP server is made using ldap_init(3), an LDAP bind operation should be per‐
formed  before  other operations are attempted over the connection.  An LDAP bind is required when using Version 2 of the LDAP protocol; it is optional for Version 3 but is usu‐
ally needed due to security considerations.

There are three types of bind calls, ones providing simple authentication, ones providing SASL authentication, and general routines  capable  of  doing  either  simple  or  SASL
authentication.

SASL  (Simple  Authentication and Security Layer) can negotiate one of many different kinds of authentication.  Both synchronous and asynchronous versions of each variant of the
bind call are provided.  All routines take ld as their first parameter, as returned from ldap_init(3).

SIMPLE AUTHENTICATION
The simplest form of the bind call is ldap_simple_bind_s().  It takes the DN to bind as in who, and the userPassword associated with the entry in passwd.   It  returns  an  LDAP
error  indication  (see ldap_error(3)).  The ldap_simple_bind() call is asynchronous, taking the same parameters but only initiating the bind operation and returning the message
id of the request it sent.  The result of the operation can be obtained by a subsequent call to ldap_result(3).

GENERAL AUTHENTICATION
The ldap_bind() and ldap_bind_s() routines can be used when the authentication method to use needs to be selected at runtime.  They both take an extra method parameter selecting
the  authentication  method  to  use.   It  should  be  set to LDAP_AUTH_SIMPLE to select simple authentication.  ldap_bind() returns the message id of the request it initiates.
ldap_bind_s() returns an LDAP error indication.

SASL AUTHENTICATION
For SASL binds the server always ignores any provided DN, so the dn parameter should always be NULL.  ldap_sasl_bind_s() sends a single SASL bind request  with  the  given  SASL
mechanism and credentials in the cred parameter. The format of the credentials depends on the particular SASL mechanism in use. For mechanisms that provide mutual authentication
the server's credentials will be returned in the servercredp parameter.  The routine returns an LDAP error indication (see ldap_error(3)).  The ldap_sasl_bind()  call  is  asyn‐
chronous,  taking  the  same parameters but only sending the request and returning the message id of the request it sent. The result of the operation can be obtained by a subse‐
quent call to ldap_result(3).  The result must be additionally parsed by ldap_parse_sasl_bind_result() to obtain any server credentials sent from the server.

Many SASL mechanisms require multiple message exchanges to perform a complete authentication. Applications should generally use ldap_sasl_interactive_bind_s() rather than  call‐
ing  the  basic ldap_sasl_bind() functions directly. The mechs parameter should contain a space-separated list of candidate mechanisms to use. If this parameter is NULL or empty
the library will query the supportedSASLMechanisms attribute from the server's rootDSE for the list of SASL mechanisms the server supports.  The  flags  parameter  controls  the
interaction used to retrieve any necessary SASL authentication parameters and should be one of:

LDAP_SASL_AUTOMATIC
use defaults if available, prompt otherwise

LDAP_SASL_INTERACTIVE
always prompt

LDAP_SASL_QUIET
never prompt

The  interact  function uses the provided defaults to handle requests from the SASL library for particular authentication parameters. There is no defined format for the defaults
information; it is up to the caller to use whatever format is appropriate for the supplied interact function.   The  sasl_interact  parameter  comes  from  the  underlying  SASL
library. When used with Cyrus SASL this is an array of sasl_interact_t structures. The Cyrus SASL library will prompt for a variety of inputs, including:

SASL_CB_GETREALM
the realm for the authentication attempt

SASL_CB_AUTHNAME
the username to authenticate

SASL_CB_PASS
the password for the provided username

SASL_CB_USER
the username to use for proxy authorization

SASL_CB_NOECHOPROMPT
generic prompt for input with input echoing disabled

SASL_CB_ECHOPROMPT
generic prompt for input with input echoing enabled

SASL_CB_LIST_END
indicates the end of the array of prompts

See the Cyrus SASL documentation for more details.

Applications  which need to manage connections asynchronously may use ldap_sasl_interactive_bind() instead of the synchronous version.  A valid mechs parameter must be supplied,
otherwise the library will be forced to query the server for a list of supported mechanisms, and this query will be performed synchronously.  The other parameters are  the  same
as  for  the  synchronous function, with three additional parameters.  The actual SASL mechanism that was used, and the message ID for use with ldap_result() will be returned in
rmechp and msgidp, respectively.  The value in rmechp must not be modified by the caller and must be passed back on each subsequent call. The message obtained from ldap_result()
must  be  passed  in the result parameter.  This parameter must be NULL when initiating a new Bind. The caller must free the result message after each call using ldap_msgfree().
The ldap_sasl_interactive_bind() function returns an LDAP result code. If the code is LDAP_SASL_BIND_IN_PROGRESS then the Bind is not complete yet, and  this  function  must  be
called again with the next result from the server.

REBINDING
The  ldap_set_rebind_proc function() sets the process to use for binding when an operation returns a referral. This function is used when an application needs to bind to another
server in order to follow a referral or search continuation reference.

The function takes ld, the rebind function, and the params, the arbitrary data like state information which the client might need to  properly  rebind.   The  LDAP_OPT_REFERRALS
option in the ld must be set to ON for the libraries to use the rebind function. Use the ldap_set_option function to set the value.

The rebind function parameters are as follows:

The ld parameter must be used by the application when binding to the referred server if the application wants the libraries to follow the referral.

The url parameter points to the URL referral string received from the LDAP server.  The LDAP application can use the ldap_url_parse(3) function to parse the string into its com‐
ponents.

The request parameter specifies the type of request that generated the referral.

The msgid parameter specifies the message ID of the request generating the referral.

The params parameter is the same value as passed originally to the ldap_set_rebind_proc() function.

The LDAP libraries set all the parameters when they call the rebind function. The application should not attempt to free either the ld or the url structures in the rebind  func‐
tion.

The  application  must  supply to the rebind function the required authentication information such as, user name, password, and certificates. The rebind function must use a syn‐
chronous bind method.

UNBINDING
The ldap_unbind() call is used to unbind from the directory, terminate the current association, and free the resources contained in the ld structure.  Once  it  is  called,  the
connection  to  the LDAP server is closed, and the ld structure is invalid.  The ldap_unbind_s() call is just another name for ldap_unbind(); both of these calls are synchronous
in nature.

The ldap_unbind_ext() and ldap_unbind_ext_s() allows the operations to specify  controls.

ERRORS
Asynchronous routines will return -1 in case of error, setting the ld_errno parameter of the ld structure.  Synchronous  routines  return  whatever  ld_errno  is  set  to.   See
ldap_error(3) for more information.

NOTES
If  an anonymous bind is sufficient for the application, the rebind process need not be provided. The LDAP libraries with the LDAP_OPT_REFERRALS option set to ON (default value)
will automatically follow referrals using an anonymous bind.

If the application needs stronger authentication than an anonymous bind, you need to provide a rebind process for that authentication method.  The bind method must  be  synchro‐
nous.

SEE ALSO
ldap(3), ldap_error(3), ldap_open(3), ldap_set_option(3), ldap_url_parse(3) RFC 4422 (http://www.rfc-editor.org), Cyrus SASL (http://asg.web.cmu.edu/sasl/)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                           LDAP_BIND(3)
LDAP_BIND(3)                                                                    Library Functions Manual                                                                    LDAP_BIND(3)

NAME
ldap_bind,   ldap_bind_s,   ldap_simple_bind,  ldap_simple_bind_s,  ldap_sasl_bind,  ldap_sasl_bind_s,  ldap_sasl_interactive_bind_s,  ldap_parse_sasl_bind_result,  ldap_unbind,
ldap_unbind_s, ldap_unbind_ext, ldap_unbind_ext_s, ldap_set_rebind_proc - LDAP bind routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_bind(LDAP *ld, const char *who, const char *cred,
int method);

int ldap_bind_s(LDAP *ld, const char *who, const char *cred,
int method);

int ldap_simple_bind(LDAP *ld, const char *who, const char *passwd);

int ldap_simple_bind_s(LDAP *ld, const char *who, const char *passwd);

int ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,
struct berval *cred, LDAPControl *sctrls[],
LDAPControl *cctrls[], int *msgidp);

int ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,
struct berval *cred, LDAPControl *sctrls[],
LDAPControl *cctrls[], struct berval **servercredp);

int ldap_parse_sasl_bind_result(LDAP *ld, LDAPMessage *res,
struct berval **servercredp, int freeit);

int ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn,
const char *mechs,
LDAPControl *sctrls[], LDAPControl *cctrls[],
unsigned flags, LDAP_SASL_INTERACT_PROC *interact,
void *defaults);

int ldap_sasl_interactive_bind(LDAP *ld, const char *dn,
const char *mechs,
LDAPControl *sctrls[], LDAPControl *cctrls[],
unsigned flags, LDAP_SASL_INTERACT_PROC *interact,
void *defaults, LDAPMessage *result,
const char **rmechp, int *msgidp);

int (LDAP_SASL_INTERACT_PROC)(LDAP *ld, unsigned flags, void *defaults, void *sasl_interact);

int ldap_unbind(LDAP *ld);

int ldap_unbind_s(LDAP *ld);

int ldap_unbind_ext(LDAP *ld, LDAPControl *sctrls[],
LDAPControl *cctrls[]);

int ldap_unbind_ext_s(LDAP *ld, LDAPControl *sctrls[],
LDAPControl *cctrls[]);

int ldap_set_rebind_proc (LDAP *ld, LDAP_REBIND_PROC *ldap_proc, void *params);

int (LDAP_REBIND_PROC)(LDAP *ld, LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *params);

DESCRIPTION
These routines provide various interfaces to the LDAP bind operation.  After an association with an LDAP server is made using ldap_init(3), an LDAP bind operation should be per‐
formed  before  other operations are attempted over the connection.  An LDAP bind is required when using Version 2 of the LDAP protocol; it is optional for Version 3 but is usu‐
ally needed due to security considerations.

There are three types of bind calls, ones providing simple authentication, ones providing SASL authentication, and general routines  capable  of  doing  either  simple  or  SASL
authentication.

SASL  (Simple  Authentication and Security Layer) can negotiate one of many different kinds of authentication.  Both synchronous and asynchronous versions of each variant of the
bind call are provided.  All routines take ld as their first parameter, as returned from ldap_init(3).

SIMPLE AUTHENTICATION
The simplest form of the bind call is ldap_simple_bind_s().  It takes the DN to bind as in who, and the userPassword associated with the entry in passwd.   It  returns  an  LDAP
error  indication  (see ldap_error(3)).  The ldap_simple_bind() call is asynchronous, taking the same parameters but only initiating the bind operation and returning the message
id of the request it sent.  The result of the operation can be obtained by a subsequent call to ldap_result(3).

GENERAL AUTHENTICATION
The ldap_bind() and ldap_bind_s() routines can be used when the authentication method to use needs to be selected at runtime.  They both take an extra method parameter selecting
the  authentication  method  to  use.   It  should  be  set to LDAP_AUTH_SIMPLE to select simple authentication.  ldap_bind() returns the message id of the request it initiates.
ldap_bind_s() returns an LDAP error indication.

SASL AUTHENTICATION
For SASL binds the server always ignores any provided DN, so the dn parameter should always be NULL.  ldap_sasl_bind_s() sends a single SASL bind request  with  the  given  SASL
mechanism and credentials in the cred parameter. The format of the credentials depends on the particular SASL mechanism in use. For mechanisms that provide mutual authentication
the server's credentials will be returned in the servercredp parameter.  The routine returns an LDAP error indication (see ldap_error(3)).  The ldap_sasl_bind()  call  is  asyn‐
chronous,  taking  the  same parameters but only sending the request and returning the message id of the request it sent. The result of the operation can be obtained by a subse‐
quent call to ldap_result(3).  The result must be additionally parsed by ldap_parse_sasl_bind_result() to obtain any server credentials sent from the server.

Many SASL mechanisms require multiple message exchanges to perform a complete authentication. Applications should generally use ldap_sasl_interactive_bind_s() rather than  call‐
ing  the  basic ldap_sasl_bind() functions directly. The mechs parameter should contain a space-separated list of candidate mechanisms to use. If this parameter is NULL or empty
the library will query the supportedSASLMechanisms attribute from the server's rootDSE for the list of SASL mechanisms the server supports.  The  flags  parameter  controls  the
interaction used to retrieve any necessary SASL authentication parameters and should be one of:

LDAP_SASL_AUTOMATIC
use defaults if available, prompt otherwise

LDAP_SASL_INTERACTIVE
always prompt

LDAP_SASL_QUIET
never prompt

The  interact  function uses the provided defaults to handle requests from the SASL library for particular authentication parameters. There is no defined format for the defaults
information; it is up to the caller to use whatever format is appropriate for the supplied interact function.   The  sasl_interact  parameter  comes  from  the  underlying  SASL
library. When used with Cyrus SASL this is an array of sasl_interact_t structures. The Cyrus SASL library will prompt for a variety of inputs, including:

SASL_CB_GETREALM
the realm for the authentication attempt

SASL_CB_AUTHNAME
the username to authenticate

SASL_CB_PASS
the password for the provided username

SASL_CB_USER
the username to use for proxy authorization

SASL_CB_NOECHOPROMPT
generic prompt for input with input echoing disabled

SASL_CB_ECHOPROMPT
generic prompt for input with input echoing enabled

SASL_CB_LIST_END
indicates the end of the array of prompts

See the Cyrus SASL documentation for more details.

Applications  which need to manage connections asynchronously may use ldap_sasl_interactive_bind() instead of the synchronous version.  A valid mechs parameter must be supplied,
otherwise the library will be forced to query the server for a list of supported mechanisms, and this query will be performed synchronously.  The other parameters are  the  same
as  for  the  synchronous function, with three additional parameters.  The actual SASL mechanism that was used, and the message ID for use with ldap_result() will be returned in
rmechp and msgidp, respectively.  The value in rmechp must not be modified by the caller and must be passed back on each subsequent call. The message obtained from ldap_result()
must  be  passed  in the result parameter.  This parameter must be NULL when initiating a new Bind. The caller must free the result message after each call using ldap_msgfree().
The ldap_sasl_interactive_bind() function returns an LDAP result code. If the code is LDAP_SASL_BIND_IN_PROGRESS then the Bind is not complete yet, and  this  function  must  be
called again with the next result from the server.

REBINDING
The  ldap_set_rebind_proc function() sets the process to use for binding when an operation returns a referral. This function is used when an application needs to bind to another
server in order to follow a referral or search continuation reference.

The function takes ld, the rebind function, and the params, the arbitrary data like state information which the client might need to  properly  rebind.   The  LDAP_OPT_REFERRALS
option in the ld must be set to ON for the libraries to use the rebind function. Use the ldap_set_option function to set the value.

The rebind function parameters are as follows:

The ld parameter must be used by the application when binding to the referred server if the application wants the libraries to follow the referral.

The url parameter points to the URL referral string received from the LDAP server.  The LDAP application can use the ldap_url_parse(3) function to parse the string into its com‐
ponents.

The request parameter specifies the type of request that generated the referral.

The msgid parameter specifies the message ID of the request generating the referral.

The params parameter is the same value as passed originally to the ldap_set_rebind_proc() function.

The LDAP libraries set all the parameters when they call the rebind function. The application should not attempt to free either the ld or the url structures in the rebind  func‐
tion.

The  application  must  supply to the rebind function the required authentication information such as, user name, password, and certificates. The rebind function must use a syn‐
chronous bind method.

UNBINDING
The ldap_unbind() call is used to unbind from the directory, terminate the current association, and free the resources contained in the ld structure.  Once  it  is  called,  the
connection  to  the LDAP server is closed, and the ld structure is invalid.  The ldap_unbind_s() call is just another name for ldap_unbind(); both of these calls are synchronous
in nature.

The ldap_unbind_ext() and ldap_unbind_ext_s() allows the operations to specify  controls.

ERRORS
Asynchronous routines will return -1 in case of error, setting the ld_errno parameter of the ld structure.  Synchronous  routines  return  whatever  ld_errno  is  set  to.   See
ldap_error(3) for more information.

NOTES
If  an anonymous bind is sufficient for the application, the rebind process need not be provided. The LDAP libraries with the LDAP_OPT_REFERRALS option set to ON (default value)
will automatically follow referrals using an anonymous bind.

If the application needs stronger authentication than an anonymous bind, you need to provide a rebind process for that authentication method.  The bind method must  be  synchro‐
nous.

SEE ALSO
ldap(3), ldap_error(3), ldap_open(3), ldap_set_option(3), ldap_url_parse(3) RFC 4422 (http://www.rfc-editor.org), Cyrus SASL (http://asg.web.cmu.edu/sasl/)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                           LDAP_BIND(3)
LDAP_SCHEMA(3)                                                                  Library Functions Manual                                                                  LDAP_SCHEMA(3)

NAME
ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,
ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object‐
class_free, ldap_scherr2str - Schema definition handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;
#include &amp;lt;ldap_schema.h&amp;gt;

LDAPSyntax * ldap_str2syntax(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_syntax2str(syn)
const LDAPSyntax * syn;

const char * ldap_syntax2name(syn)
LDAPSyntax * syn;

ldap_syntax_free(syn)
LDAPSyntax * syn;

LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_matchingrule2str(mr);
const LDAPMatchingRule * mr;

const char * ldap_matchingrule2name(mr)
LDAPMatchingRule * mr;

ldap_matchingrule_free(mr)
LDAPMatchingRule * mr;

LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_attributetype2str(at)
const LDAPAttributeType * at;

const char * ldap_attributetype2name(at)
LDAPAttributeType * at;

ldap_attributetype_free(at)
LDAPAttributeType * at;

LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_objectclass2str(oc)
const LDAPObjectClass * oc;

const char * ldap_objectclass2name(oc)
LDAPObjectClass * oc;

ldap_objectclass_free(oc)
LDAPObjectClass * oc;

char * ldap_scherr2str(code)
int code;

DESCRIPTION
These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:
syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.

ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate
kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,
the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter‐
minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a
bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:

LDAP_SCHEMA_ALLOW_NONE
strict parsing according to RFC 4512.

LDAP_SCHEMA_ALLOW_NO_OID
permit definitions that do not contain an initial OID.

LDAP_SCHEMA_ALLOW_QUOTED
permit quotes around some items that should not have them.

LDAP_SCHEMA_ALLOW_DESCR
permit a descr instead of a numeric OID in places where the syntax expect the latter.

LDAP_SCHEMA_ALLOW_DESCR_PREFIX
permit that the initial numeric OID contains a prefix in descr format.

LDAP_SCHEMA_ALLOW_ALL
be very liberal, include all options.

The structures returned are as follows:

typedef struct ldap_schema_extension_item {
char *lsei_name;        /* Extension name */
char **lsei_values;     /* Extension values */
} LDAPSchemaExtensionItem;

typedef struct ldap_syntax {
char *syn_oid;          /* OID */
char **syn_names;       /* Names */
char *syn_desc;         /* Description */
LDAPSchemaExtensionItem **syn_extensions; /* Extension */
} LDAPSyntax;

typedef struct ldap_matchingrule {
char *mr_oid;           /* OID */
char **mr_names;        /* Names */
char *mr_desc;          /* Description */
int  mr_obsolete;       /* Is obsolete? */
char *mr_syntax_oid;    /* Syntax of asserted values */
LDAPSchemaExtensionItem **mr_extensions; /* Extensions */
} LDAPMatchingRule;

typedef struct ldap_attributetype {
char *at_oid;           /* OID */
char **at_names;        /* Names */
char *at_desc;          /* Description */
int  at_obsolete;       /* Is obsolete? */
char *at_sup_oid;       /* OID of superior type */
char *at_equality_oid;  /* OID of equality matching rule */
char *at_ordering_oid;  /* OID of ordering matching rule */
char *at_substr_oid;    /* OID of substrings matching rule */
char *at_syntax_oid;    /* OID of syntax of values */
int  at_syntax_len;     /* Suggested minimum maximum length */
int  at_single_value;   /* Is single-valued?  */
int  at_collective;     /* Is collective? */
int  at_no_user_mod;    /* Are changes forbidden through LDAP? */
int  at_usage;          /* Usage, see below */
LDAPSchemaExtensionItem **at_extensions; /* Extensions */
} LDAPAttributeType;

typedef struct ldap_objectclass {
char *oc_oid;           /* OID */
char **oc_names;        /* Names */
char *oc_desc;          /* Description */
int  oc_obsolete;       /* Is obsolete? */
char **oc_sup_oids;     /* OIDs of superior classes */
int  oc_kind;           /* Kind, see below */
char **oc_at_oids_must; /* OIDs of required attribute types */
char **oc_at_oids_may;  /* OIDs of optional attribute types */
LDAPSchemaExtensionItem **oc_extensions; /* Extensions */
} LDAPObjectClass;

Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:

LDAP_SCHEMA_NO
The answer to the question is no.

LDAP_SCHEMA_YES
The answer to the question is yes.

For attribute types, the following usages are possible:

LDAP_SCHEMA_USER_APPLICATIONS
the attribute type is non-operational.

LDAP_SCHEMA_DIRECTORY_OPERATION
the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute
type.

LDAP_SCHEMA_DISTRIBUTED_OPERATION
the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.

LDAP_SCHEMA_DSA_OPERATION
the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different
servers that master the entry.

Object classes can be of three kinds:

LDAP_SCHEMA_ABSTRACT
the object class is abstract, i.e. there cannot be entries of this class alone.

LDAP_SCHEMA_STRUCTURAL
the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned
cannot be changed: none of those present can be removed and none other can be added.

LDAP_SCHEMA_AUXILIARY
the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added
or removed at the same time as needed by the set of object classes resulting from the operation.

Routines ldap_xxx2name() return a canonical name for the definition.

Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that
must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.

ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The
argument code comes from one of the parsing routines and can adopt the following values:

LDAP_SCHERR_OUTOFMEM
Out of memory.

LDAP_SCHERR_UNEXPTOKEN
Unexpected token.

LDAP_SCHERR_NOLEFTPAREN
Missing opening parenthesis.

LDAP_SCHERR_NORIGHTPAREN
Missing closing parenthesis.

LDAP_SCHERR_NODIGIT
Expecting digit.

LDAP_SCHERR_BADNAME
Expecting a name.

LDAP_SCHERR_BADDESC
Bad description.

LDAP_SCHERR_BADSUP
Bad superiors.

LDAP_SCHERR_DUPOPT
Duplicate option.

LDAP_SCHERR_EMPTY
Unexpected end of data.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_SCHEMA(3)
LDAP_SCHEMA(3)                                                                  Library Functions Manual                                                                  LDAP_SCHEMA(3)

NAME
ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,
ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object‐
class_free, ldap_scherr2str - Schema definition handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;
#include &amp;lt;ldap_schema.h&amp;gt;

LDAPSyntax * ldap_str2syntax(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_syntax2str(syn)
const LDAPSyntax * syn;

const char * ldap_syntax2name(syn)
LDAPSyntax * syn;

ldap_syntax_free(syn)
LDAPSyntax * syn;

LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_matchingrule2str(mr);
const LDAPMatchingRule * mr;

const char * ldap_matchingrule2name(mr)
LDAPMatchingRule * mr;

ldap_matchingrule_free(mr)
LDAPMatchingRule * mr;

LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_attributetype2str(at)
const LDAPAttributeType * at;

const char * ldap_attributetype2name(at)
LDAPAttributeType * at;

ldap_attributetype_free(at)
LDAPAttributeType * at;

LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_objectclass2str(oc)
const LDAPObjectClass * oc;

const char * ldap_objectclass2name(oc)
LDAPObjectClass * oc;

ldap_objectclass_free(oc)
LDAPObjectClass * oc;

char * ldap_scherr2str(code)
int code;

DESCRIPTION
These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:
syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.

ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate
kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,
the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter‐
minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a
bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:

LDAP_SCHEMA_ALLOW_NONE
strict parsing according to RFC 4512.

LDAP_SCHEMA_ALLOW_NO_OID
permit definitions that do not contain an initial OID.

LDAP_SCHEMA_ALLOW_QUOTED
permit quotes around some items that should not have them.

LDAP_SCHEMA_ALLOW_DESCR
permit a descr instead of a numeric OID in places where the syntax expect the latter.

LDAP_SCHEMA_ALLOW_DESCR_PREFIX
permit that the initial numeric OID contains a prefix in descr format.

LDAP_SCHEMA_ALLOW_ALL
be very liberal, include all options.

The structures returned are as follows:

typedef struct ldap_schema_extension_item {
char *lsei_name;        /* Extension name */
char **lsei_values;     /* Extension values */
} LDAPSchemaExtensionItem;

typedef struct ldap_syntax {
char *syn_oid;          /* OID */
char **syn_names;       /* Names */
char *syn_desc;         /* Description */
LDAPSchemaExtensionItem **syn_extensions; /* Extension */
} LDAPSyntax;

typedef struct ldap_matchingrule {
char *mr_oid;           /* OID */
char **mr_names;        /* Names */
char *mr_desc;          /* Description */
int  mr_obsolete;       /* Is obsolete? */
char *mr_syntax_oid;    /* Syntax of asserted values */
LDAPSchemaExtensionItem **mr_extensions; /* Extensions */
} LDAPMatchingRule;

typedef struct ldap_attributetype {
char *at_oid;           /* OID */
char **at_names;        /* Names */
char *at_desc;          /* Description */
int  at_obsolete;       /* Is obsolete? */
char *at_sup_oid;       /* OID of superior type */
char *at_equality_oid;  /* OID of equality matching rule */
char *at_ordering_oid;  /* OID of ordering matching rule */
char *at_substr_oid;    /* OID of substrings matching rule */
char *at_syntax_oid;    /* OID of syntax of values */
int  at_syntax_len;     /* Suggested minimum maximum length */
int  at_single_value;   /* Is single-valued?  */
int  at_collective;     /* Is collective? */
int  at_no_user_mod;    /* Are changes forbidden through LDAP? */
int  at_usage;          /* Usage, see below */
LDAPSchemaExtensionItem **at_extensions; /* Extensions */
} LDAPAttributeType;

typedef struct ldap_objectclass {
char *oc_oid;           /* OID */
char **oc_names;        /* Names */
char *oc_desc;          /* Description */
int  oc_obsolete;       /* Is obsolete? */
char **oc_sup_oids;     /* OIDs of superior classes */
int  oc_kind;           /* Kind, see below */
char **oc_at_oids_must; /* OIDs of required attribute types */
char **oc_at_oids_may;  /* OIDs of optional attribute types */
LDAPSchemaExtensionItem **oc_extensions; /* Extensions */
} LDAPObjectClass;

Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:

LDAP_SCHEMA_NO
The answer to the question is no.

LDAP_SCHEMA_YES
The answer to the question is yes.

For attribute types, the following usages are possible:

LDAP_SCHEMA_USER_APPLICATIONS
the attribute type is non-operational.

LDAP_SCHEMA_DIRECTORY_OPERATION
the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute
type.

LDAP_SCHEMA_DISTRIBUTED_OPERATION
the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.

LDAP_SCHEMA_DSA_OPERATION
the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different
servers that master the entry.

Object classes can be of three kinds:

LDAP_SCHEMA_ABSTRACT
the object class is abstract, i.e. there cannot be entries of this class alone.

LDAP_SCHEMA_STRUCTURAL
the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned
cannot be changed: none of those present can be removed and none other can be added.

LDAP_SCHEMA_AUXILIARY
the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added
or removed at the same time as needed by the set of object classes resulting from the operation.

Routines ldap_xxx2name() return a canonical name for the definition.

Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that
must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.

ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The
argument code comes from one of the parsing routines and can adopt the following values:

LDAP_SCHERR_OUTOFMEM
Out of memory.

LDAP_SCHERR_UNEXPTOKEN
Unexpected token.

LDAP_SCHERR_NOLEFTPAREN
Missing opening parenthesis.

LDAP_SCHERR_NORIGHTPAREN
Missing closing parenthesis.

LDAP_SCHERR_NODIGIT
Expecting digit.

LDAP_SCHERR_BADNAME
Expecting a name.

LDAP_SCHERR_BADDESC
Bad description.

LDAP_SCHERR_BADSUP
Bad superiors.

LDAP_SCHERR_DUPOPT
Duplicate option.

LDAP_SCHERR_EMPTY
Unexpected end of data.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_SCHEMA(3)
LDAP_SEARCH(3)                                                                  Library Functions Manual                                                                  LDAP_SEARCH(3)

NAME
ldap_search, ldap_search_s, ldap_search_st, ldap_search_ext, ldap_search_ext_s - Perform an LDAP search operation

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;ldap.h&amp;gt;

int ldap_search_ext(
LDAP *ld,
char *base,
int scope,
char *filter,
char *attrs[],
int attrsonly,
LDAPControl **serverctrls,
LDAPControl **clientctrls,
struct timeval *timeout,
int sizelimit,
int *msgidp );

int ldap_search_ext_s(
LDAP *ld,
char *base,
int scope,
char *filter,
char *attrs[],
int attrsonly,
LDAPControl **serverctrls,
LDAPControl **clientctrls,
struct timeval *timeout,
int sizelimit,
LDAPMessage **res );

DESCRIPTION
These  routines  are  used to perform LDAP search operations.  The ldap_search_ext_s() routine does the search synchronously (i.e., not returning until the operation completes),
providing a pointer to the resulting LDAP messages at the location pointed to by the res parameter.

The ldap_search_ext() routine is the asynchronous version, initiating the search and returning the message id of the operation it initiated in the  integer  pointed  to  by  the
msgidp parameter.

The base parameter is the DN of the entry at which to start the search.

The scope parameter is the scope of the search and should be one of LDAP_SCOPE_BASE, to search the object itself, LDAP_SCOPE_ONELEVEL, to search the object's immediate children,
LDAP_SCOPE_SUBTREE, to search the object and all its descendants, or LDAP_SCOPE_CHILDREN, to search all of the descendants.   Note that the latter requires  the  server  support
the LDAP Subordinates Search Scope extension.

The  filter  is  a  string  representation  of  the  filter  to apply in the search.  The string should conform to the format specified in RFC 4515 as extended by RFC 4526.  For
instance, "(cn=Jane Doe)".  Note that use of the extension requires the server to support the LDAP Absolute True/False Filter extension.  NULL may be specified to  indicate  the
library should send the filter (objectClass=*).

The  attrs parameter is a null-terminated array of attribute descriptions to return from matching entries.  If NULL is specified, the return of all user attributes is requested.
The description "*" (LDAP_ALL_USER_ATTRIBUTES) may be used to request all user attributes to be returned.  The description "+"(LDAP_ALL_OPERATIONAL_ATTRIBUTES) may  be  used  to
request  all  operational  attributes to be returned.  Note that this requires the server to support the LDAP All Operational Attribute extension.  To request no attributes, the
description "1.1" (LDAP_NO_ATTRS) should be listed by itself.

The attrsonly parameter should be set to a non-zero value if only attribute descriptions are wanted.  It should be set to zero (0) if both attributes descriptions and  attribute
values are wanted.

The serverctrls and clientctrls parameters may be used to specify server and client controls, respectively.

The ldap_search_ext_s() routine is the synchronous version of ldap_search_ext().

It also returns a code indicating success or, in the case of failure, indicating the nature of the failure of the operation.  See ldap_error(3) for details.

NOTES
Note  that  both  read  and  list  functionality  are  subsumed  by  these routines, by using a filter like "(objectclass=*)" and a scope of LDAP_SCOPE_BASE (to emulate read) or
LDAP_SCOPE_ONELEVEL (to emulate list).

These routines may dynamically allocate memory. The caller is responsible for freeing such memory using supplied deallocation routines. Return values are contained in &amp;lt;ldap.h&amp;gt;.

Note that res parameter of ldap_search_ext_s() and ldap_search_s() should be freed with ldap_msgfree() regardless of return value of these functions.

DEPRECATED INTERFACES
The ldap_search() routine is deprecated in favor of the  ldap_search_ext()  routine.   The  ldap_search_s()  and  ldap_search_st()  routines  are  deprecated  in  favor  of  the
ldap_search_ext_s() routine.

Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed
to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3), ldap_result(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_SEARCH(3)
LDAP_SEARCH(3)                                                                  Library Functions Manual                                                                  LDAP_SEARCH(3)

NAME
ldap_search, ldap_search_s, ldap_search_st, ldap_search_ext, ldap_search_ext_s - Perform an LDAP search operation

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;ldap.h&amp;gt;

int ldap_search_ext(
LDAP *ld,
char *base,
int scope,
char *filter,
char *attrs[],
int attrsonly,
LDAPControl **serverctrls,
LDAPControl **clientctrls,
struct timeval *timeout,
int sizelimit,
int *msgidp );

int ldap_search_ext_s(
LDAP *ld,
char *base,
int scope,
char *filter,
char *attrs[],
int attrsonly,
LDAPControl **serverctrls,
LDAPControl **clientctrls,
struct timeval *timeout,
int sizelimit,
LDAPMessage **res );

DESCRIPTION
These  routines  are  used to perform LDAP search operations.  The ldap_search_ext_s() routine does the search synchronously (i.e., not returning until the operation completes),
providing a pointer to the resulting LDAP messages at the location pointed to by the res parameter.

The ldap_search_ext() routine is the asynchronous version, initiating the search and returning the message id of the operation it initiated in the  integer  pointed  to  by  the
msgidp parameter.

The base parameter is the DN of the entry at which to start the search.

The scope parameter is the scope of the search and should be one of LDAP_SCOPE_BASE, to search the object itself, LDAP_SCOPE_ONELEVEL, to search the object's immediate children,
LDAP_SCOPE_SUBTREE, to search the object and all its descendants, or LDAP_SCOPE_CHILDREN, to search all of the descendants.   Note that the latter requires  the  server  support
the LDAP Subordinates Search Scope extension.

The  filter  is  a  string  representation  of  the  filter  to apply in the search.  The string should conform to the format specified in RFC 4515 as extended by RFC 4526.  For
instance, "(cn=Jane Doe)".  Note that use of the extension requires the server to support the LDAP Absolute True/False Filter extension.  NULL may be specified to  indicate  the
library should send the filter (objectClass=*).

The  attrs parameter is a null-terminated array of attribute descriptions to return from matching entries.  If NULL is specified, the return of all user attributes is requested.
The description "*" (LDAP_ALL_USER_ATTRIBUTES) may be used to request all user attributes to be returned.  The description "+"(LDAP_ALL_OPERATIONAL_ATTRIBUTES) may  be  used  to
request  all  operational  attributes to be returned.  Note that this requires the server to support the LDAP All Operational Attribute extension.  To request no attributes, the
description "1.1" (LDAP_NO_ATTRS) should be listed by itself.

The attrsonly parameter should be set to a non-zero value if only attribute descriptions are wanted.  It should be set to zero (0) if both attributes descriptions and  attribute
values are wanted.

The serverctrls and clientctrls parameters may be used to specify server and client controls, respectively.

The ldap_search_ext_s() routine is the synchronous version of ldap_search_ext().

It also returns a code indicating success or, in the case of failure, indicating the nature of the failure of the operation.  See ldap_error(3) for details.

NOTES
Note  that  both  read  and  list  functionality  are  subsumed  by  these routines, by using a filter like "(objectclass=*)" and a scope of LDAP_SCOPE_BASE (to emulate read) or
LDAP_SCOPE_ONELEVEL (to emulate list).

These routines may dynamically allocate memory. The caller is responsible for freeing such memory using supplied deallocation routines. Return values are contained in &amp;lt;ldap.h&amp;gt;.

Note that res parameter of ldap_search_ext_s() and ldap_search_s() should be freed with ldap_msgfree() regardless of return value of these functions.

DEPRECATED INTERFACES
The ldap_search() routine is deprecated in favor of the  ldap_search_ext()  routine.   The  ldap_search_s()  and  ldap_search_st()  routines  are  deprecated  in  favor  of  the
ldap_search_ext_s() routine.

Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed
to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3), ldap_result(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_SEARCH(3)
LDAP_SEARCH(3)                                                                  Library Functions Manual                                                                  LDAP_SEARCH(3)

NAME
ldap_search, ldap_search_s, ldap_search_st, ldap_search_ext, ldap_search_ext_s - Perform an LDAP search operation

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;ldap.h&amp;gt;

int ldap_search_ext(
LDAP *ld,
char *base,
int scope,
char *filter,
char *attrs[],
int attrsonly,
LDAPControl **serverctrls,
LDAPControl **clientctrls,
struct timeval *timeout,
int sizelimit,
int *msgidp );

int ldap_search_ext_s(
LDAP *ld,
char *base,
int scope,
char *filter,
char *attrs[],
int attrsonly,
LDAPControl **serverctrls,
LDAPControl **clientctrls,
struct timeval *timeout,
int sizelimit,
LDAPMessage **res );

DESCRIPTION
These  routines  are  used to perform LDAP search operations.  The ldap_search_ext_s() routine does the search synchronously (i.e., not returning until the operation completes),
providing a pointer to the resulting LDAP messages at the location pointed to by the res parameter.

The ldap_search_ext() routine is the asynchronous version, initiating the search and returning the message id of the operation it initiated in the  integer  pointed  to  by  the
msgidp parameter.

The base parameter is the DN of the entry at which to start the search.

The scope parameter is the scope of the search and should be one of LDAP_SCOPE_BASE, to search the object itself, LDAP_SCOPE_ONELEVEL, to search the object's immediate children,
LDAP_SCOPE_SUBTREE, to search the object and all its descendants, or LDAP_SCOPE_CHILDREN, to search all of the descendants.   Note that the latter requires  the  server  support
the LDAP Subordinates Search Scope extension.

The  filter  is  a  string  representation  of  the  filter  to apply in the search.  The string should conform to the format specified in RFC 4515 as extended by RFC 4526.  For
instance, "(cn=Jane Doe)".  Note that use of the extension requires the server to support the LDAP Absolute True/False Filter extension.  NULL may be specified to  indicate  the
library should send the filter (objectClass=*).

The  attrs parameter is a null-terminated array of attribute descriptions to return from matching entries.  If NULL is specified, the return of all user attributes is requested.
The description "*" (LDAP_ALL_USER_ATTRIBUTES) may be used to request all user attributes to be returned.  The description "+"(LDAP_ALL_OPERATIONAL_ATTRIBUTES) may  be  used  to
request  all  operational  attributes to be returned.  Note that this requires the server to support the LDAP All Operational Attribute extension.  To request no attributes, the
description "1.1" (LDAP_NO_ATTRS) should be listed by itself.

The attrsonly parameter should be set to a non-zero value if only attribute descriptions are wanted.  It should be set to zero (0) if both attributes descriptions and  attribute
values are wanted.

The serverctrls and clientctrls parameters may be used to specify server and client controls, respectively.

The ldap_search_ext_s() routine is the synchronous version of ldap_search_ext().

It also returns a code indicating success or, in the case of failure, indicating the nature of the failure of the operation.  See ldap_error(3) for details.

NOTES
Note  that  both  read  and  list  functionality  are  subsumed  by  these routines, by using a filter like "(objectclass=*)" and a scope of LDAP_SCOPE_BASE (to emulate read) or
LDAP_SCOPE_ONELEVEL (to emulate list).

These routines may dynamically allocate memory. The caller is responsible for freeing such memory using supplied deallocation routines. Return values are contained in &amp;lt;ldap.h&amp;gt;.

Note that res parameter of ldap_search_ext_s() and ldap_search_s() should be freed with ldap_msgfree() regardless of return value of these functions.

DEPRECATED INTERFACES
The ldap_search() routine is deprecated in favor of the  ldap_search_ext()  routine.   The  ldap_search_s()  and  ldap_search_st()  routines  are  deprecated  in  favor  of  the
ldap_search_ext_s() routine.

Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed
to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3), ldap_result(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_SEARCH(3)
LDAP_SEARCH(3)                                                                  Library Functions Manual                                                                  LDAP_SEARCH(3)

NAME
ldap_search, ldap_search_s, ldap_search_st, ldap_search_ext, ldap_search_ext_s - Perform an LDAP search operation

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;ldap.h&amp;gt;

int ldap_search_ext(
LDAP *ld,
char *base,
int scope,
char *filter,
char *attrs[],
int attrsonly,
LDAPControl **serverctrls,
LDAPControl **clientctrls,
struct timeval *timeout,
int sizelimit,
int *msgidp );

int ldap_search_ext_s(
LDAP *ld,
char *base,
int scope,
char *filter,
char *attrs[],
int attrsonly,
LDAPControl **serverctrls,
LDAPControl **clientctrls,
struct timeval *timeout,
int sizelimit,
LDAPMessage **res );

DESCRIPTION
These  routines  are  used to perform LDAP search operations.  The ldap_search_ext_s() routine does the search synchronously (i.e., not returning until the operation completes),
providing a pointer to the resulting LDAP messages at the location pointed to by the res parameter.

The ldap_search_ext() routine is the asynchronous version, initiating the search and returning the message id of the operation it initiated in the  integer  pointed  to  by  the
msgidp parameter.

The base parameter is the DN of the entry at which to start the search.

The scope parameter is the scope of the search and should be one of LDAP_SCOPE_BASE, to search the object itself, LDAP_SCOPE_ONELEVEL, to search the object's immediate children,
LDAP_SCOPE_SUBTREE, to search the object and all its descendants, or LDAP_SCOPE_CHILDREN, to search all of the descendants.   Note that the latter requires  the  server  support
the LDAP Subordinates Search Scope extension.

The  filter  is  a  string  representation  of  the  filter  to apply in the search.  The string should conform to the format specified in RFC 4515 as extended by RFC 4526.  For
instance, "(cn=Jane Doe)".  Note that use of the extension requires the server to support the LDAP Absolute True/False Filter extension.  NULL may be specified to  indicate  the
library should send the filter (objectClass=*).

The  attrs parameter is a null-terminated array of attribute descriptions to return from matching entries.  If NULL is specified, the return of all user attributes is requested.
The description "*" (LDAP_ALL_USER_ATTRIBUTES) may be used to request all user attributes to be returned.  The description "+"(LDAP_ALL_OPERATIONAL_ATTRIBUTES) may  be  used  to
request  all  operational  attributes to be returned.  Note that this requires the server to support the LDAP All Operational Attribute extension.  To request no attributes, the
description "1.1" (LDAP_NO_ATTRS) should be listed by itself.

The attrsonly parameter should be set to a non-zero value if only attribute descriptions are wanted.  It should be set to zero (0) if both attributes descriptions and  attribute
values are wanted.

The serverctrls and clientctrls parameters may be used to specify server and client controls, respectively.

The ldap_search_ext_s() routine is the synchronous version of ldap_search_ext().

It also returns a code indicating success or, in the case of failure, indicating the nature of the failure of the operation.  See ldap_error(3) for details.

NOTES
Note  that  both  read  and  list  functionality  are  subsumed  by  these routines, by using a filter like "(objectclass=*)" and a scope of LDAP_SCOPE_BASE (to emulate read) or
LDAP_SCOPE_ONELEVEL (to emulate list).

These routines may dynamically allocate memory. The caller is responsible for freeing such memory using supplied deallocation routines. Return values are contained in &amp;lt;ldap.h&amp;gt;.

Note that res parameter of ldap_search_ext_s() and ldap_search_s() should be freed with ldap_msgfree() regardless of return value of these functions.

DEPRECATED INTERFACES
The ldap_search() routine is deprecated in favor of the  ldap_search_ext()  routine.   The  ldap_search_s()  and  ldap_search_st()  routines  are  deprecated  in  favor  of  the
ldap_search_ext_s() routine.

Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed
to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3), ldap_result(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_SEARCH(3)
LDAP_SEARCH(3)                                                                  Library Functions Manual                                                                  LDAP_SEARCH(3)

NAME
ldap_search, ldap_search_s, ldap_search_st, ldap_search_ext, ldap_search_ext_s - Perform an LDAP search operation

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;ldap.h&amp;gt;

int ldap_search_ext(
LDAP *ld,
char *base,
int scope,
char *filter,
char *attrs[],
int attrsonly,
LDAPControl **serverctrls,
LDAPControl **clientctrls,
struct timeval *timeout,
int sizelimit,
int *msgidp );

int ldap_search_ext_s(
LDAP *ld,
char *base,
int scope,
char *filter,
char *attrs[],
int attrsonly,
LDAPControl **serverctrls,
LDAPControl **clientctrls,
struct timeval *timeout,
int sizelimit,
LDAPMessage **res );

DESCRIPTION
These  routines  are  used to perform LDAP search operations.  The ldap_search_ext_s() routine does the search synchronously (i.e., not returning until the operation completes),
providing a pointer to the resulting LDAP messages at the location pointed to by the res parameter.

The ldap_search_ext() routine is the asynchronous version, initiating the search and returning the message id of the operation it initiated in the  integer  pointed  to  by  the
msgidp parameter.

The base parameter is the DN of the entry at which to start the search.

The scope parameter is the scope of the search and should be one of LDAP_SCOPE_BASE, to search the object itself, LDAP_SCOPE_ONELEVEL, to search the object's immediate children,
LDAP_SCOPE_SUBTREE, to search the object and all its descendants, or LDAP_SCOPE_CHILDREN, to search all of the descendants.   Note that the latter requires  the  server  support
the LDAP Subordinates Search Scope extension.

The  filter  is  a  string  representation  of  the  filter  to apply in the search.  The string should conform to the format specified in RFC 4515 as extended by RFC 4526.  For
instance, "(cn=Jane Doe)".  Note that use of the extension requires the server to support the LDAP Absolute True/False Filter extension.  NULL may be specified to  indicate  the
library should send the filter (objectClass=*).

The  attrs parameter is a null-terminated array of attribute descriptions to return from matching entries.  If NULL is specified, the return of all user attributes is requested.
The description "*" (LDAP_ALL_USER_ATTRIBUTES) may be used to request all user attributes to be returned.  The description "+"(LDAP_ALL_OPERATIONAL_ATTRIBUTES) may  be  used  to
request  all  operational  attributes to be returned.  Note that this requires the server to support the LDAP All Operational Attribute extension.  To request no attributes, the
description "1.1" (LDAP_NO_ATTRS) should be listed by itself.

The attrsonly parameter should be set to a non-zero value if only attribute descriptions are wanted.  It should be set to zero (0) if both attributes descriptions and  attribute
values are wanted.

The serverctrls and clientctrls parameters may be used to specify server and client controls, respectively.

The ldap_search_ext_s() routine is the synchronous version of ldap_search_ext().

It also returns a code indicating success or, in the case of failure, indicating the nature of the failure of the operation.  See ldap_error(3) for details.

NOTES
Note  that  both  read  and  list  functionality  are  subsumed  by  these routines, by using a filter like "(objectclass=*)" and a scope of LDAP_SCOPE_BASE (to emulate read) or
LDAP_SCOPE_ONELEVEL (to emulate list).

These routines may dynamically allocate memory. The caller is responsible for freeing such memory using supplied deallocation routines. Return values are contained in &amp;lt;ldap.h&amp;gt;.

Note that res parameter of ldap_search_ext_s() and ldap_search_s() should be freed with ldap_msgfree() regardless of return value of these functions.

DEPRECATED INTERFACES
The ldap_search() routine is deprecated in favor of the  ldap_search_ext()  routine.   The  ldap_search_s()  and  ldap_search_st()  routines  are  deprecated  in  favor  of  the
ldap_search_ext_s() routine.

Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed
to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3), ldap_result(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_SEARCH(3)
LDAP_GET_OPTION(3)                                                              Library Functions Manual                                                              LDAP_GET_OPTION(3)

NAME
ldap_get_option, ldap_set_option - LDAP option handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_get_option(LDAP *ld, int option, void *outvalue);

int ldap_set_option(LDAP *ld, int option, const void *invalue);

DESCRIPTION
These  routines  provide  access  to  options stored either in a LDAP handle or as global options, where applicable.  They make use of a neutral interface, where the type of the
value either retrieved by ldap_get_option(3) or set by ldap_set_option(3) is cast to void *.  The actual type is determined based on the value of the  option  argument.   Global
options are set/retrieved by passing a NULL LDAP handle. LDAP handles inherit their default settings from the global options in effect at the time the handle is created.

LDAP_OPT_API_FEATURE_INFO
Fills-in  a  LDAPAPIFeatureInfo;  outvalue  must be a LDAPAPIFeatureInfo *, pointing to an already allocated struct.  The ldapaif_info_version field of the struct must be
initialized to LDAP_FEATURE_INFO_VERSION before making the call. The ldapaif_name field must be set to the name of a feature to query.  This is a read-only option.

LDAP_OPT_API_INFO
Fills-in a LDAPAPIInfo; outvalue must be a LDAPAPIInfo *, pointing to an already allocated struct. The ldapai_info_version field of the  struct  must  be  initialized  to
LDAP_API_INFO_VERSION  before  making  the  call.   If the version passed in does not match the current library version, the expected version number will be stored in the
struct and the call will fail.  The caller is responsible for freeing the elements of the ldapai_extensions array and the array itself using ldap_memfree(3).  The  caller
must also free the ldapi_vendor_name.  This is a read-only option.

LDAP_OPT_CLIENT_CONTROLS
Sets/gets the client-side controls to be used for all operations.  This is now deprecated as modern LDAP C API provides replacements for all main operations which accepts
client-side controls as explicit arguments; see for example ldap_search_ext(3), ldap_add_ext(3), ldap_modify_ext(3) and so on.  outvalue must be LDAPControl ***, and  the
caller  is  responsible of freeing the returned controls, if any, by calling ldap_controls_free(3), while invalue must be LDAPControl *const *; the library duplicates the
controls passed via invalue.

LDAP_OPT_CONNECT_ASYNC
Sets/gets the status of the asynchronous connect flag.  invalue should either be LDAP_OPT_OFF or LDAP_OPT_ON; outvalue must be int *.  When set,  the  library  will  call
connect(2)  and return, without waiting for response.  This leaves the handle in a connecting state.  Subsequent calls to library routines will poll for completion of the
connect before performing further operations.  As a consequence, library calls that need to establish a connection with a DSA do not block even for  the  network  timeout
(option LDAP_OPT_NETWORK_TIMEOUT).  This option is OpenLDAP specific.

LDAP_OPT_CONNECT_CB
This option allows to set a connect callback.  invalue must be a const struct ldap_conncb *.  Callbacks are executed in last in-first served order.  Handle-specific call‐
backs are executed first, followed by global ones.  Right before freeing the callback  structure,  the  lc_del  callback  handler  is  passed  a  NULL  Sockbuf.   Calling
ldap_get_option(3) for this option removes the callback whose pointer matches outvalue.  This option is OpenLDAP specific.

LDAP_OPT_DEBUG_LEVEL
Sets/gets  the  debug  level  of  the  client  library.  invalue must be a const int *; outvalue must be a int *.  Valid debug levels are LDAP_DEBUG_ANY, LDAP_DEBUG_ARGS,
LDAP_DEBUG_BER, LDAP_DEBUG_CONNS, LDAP_DEBUG_NONE, LDAP_DEBUG_PACKETS, LDAP_DEBUG_PARSE, and LDAP_DEBUG_TRACE.  This option is OpenLDAP specific.

LDAP_OPT_DEFBASE
Sets/gets a string containing the DN to be used as default base for search operations.  outvalue must be a char **, and the caller is responsible of freeing the  returned
string by calling ldap_memfree(3), while invalue must be a const char *; the library duplicates the corresponding string.  This option is OpenLDAP specific.

LDAP_OPT_DEREF
Sets/gets  the  value that defines when alias dereferencing must occur.  invalue must be const int *; outvalue must be int *.  They cannot be NULL.  The value of *invalue
should be one of LDAP_DEREF_NEVER (the default), LDAP_DEREF_SEARCHING, LDAP_DEREF_FINDING, or LDAP_DEREF_ALWAYS.  Note that this has ever been the only means to determine
alias dereferencing within search operations.

LDAP_OPT_DESC
Returns the file descriptor associated to the socket buffer of the LDAP handle passed in as ld; outvalue must be a int *.  This is a read-only, handle-specific option.

LDAP_OPT_DIAGNOSTIC_MESSAGE
Sets/gets  a  string containing the error string associated to the LDAP handle.  This option was formerly known as LDAP_OPT_ERROR_STRING.  outvalue must be a char **, and
the caller is responsible of freeing the returned string by calling ldap_memfree(3), while invalue must be a char *; the library duplicates the corresponding string.

LDAP_OPT_HOST_NAME
Sets/gets a space-separated list of hosts to be contacted by the library when trying to establish a connection.  This is now deprecated in favor  of  LDAP_OPT_URI.   out‐
value  must  be  a  char  **,  and the caller is responsible of freeing the resulting string by calling ldap_memfree(3), while invalue must be a const char *; the library
duplicates the corresponding string.

LDAP_OPT_MATCHED_DN
Sets/gets a string containing the matched DN associated to the LDAP handle.  outvalue must be a char **, and the caller is responsible of freeing the returned  string  by
calling ldap_memfree(3), while invalue must be a const char *; the library duplicates the corresponding string.

LDAP_OPT_NETWORK_TIMEOUT
Sets/gets the network timeout value after which poll(2)/select(2) following a connect(2) returns in case of no activity.  outvalue must be a struct timeval ** (the caller
has to free *outvalue), and invalue must be a const struct timeval *.  They cannot be NULL. Using a struct with seconds set to -1 results in an infinite timeout, which is
the default.  This option is OpenLDAP specific.

LDAP_OPT_PROTOCOL_VERSION
Sets/gets the protocol version.  outvalue and invalue must be int *.

LDAP_OPT_REFERRAL_URLS
Sets/gets  an array containing the referral URIs associated to the LDAP handle.  outvalue must be a char ***, and the caller is responsible of freeing the returned string
by calling ldap_memvfree(3), while invalue must be a NULL-terminated char *const *; the library duplicates the corresponding string.  This option is OpenLDAP specific.

LDAP_OPT_REFERRALS
Determines whether the library should implicitly chase referrals or not.  invalue must be const int *; its value should either be LDAP_OPT_OFF or  LDAP_OPT_ON.   outvalue
must be int *.

LDAP_OPT_RESTART
Determines  whether the library should implicitly restart connections (FIXME).  invalue must be const int *; its value should either be LDAP_OPT_OFF or LDAP_OPT_ON.  out‐
value must be int *.

LDAP_OPT_RESULT_CODE
Sets/gets the LDAP result code associated to the handle.  This option was formerly known as LDAP_OPT_ERROR_NUMBER.  invalue must be a const int *.  outvalue must be a int
*.

LDAP_OPT_SERVER_CONTROLS
Sets/gets the server-side controls to be used for all operations.  This is now deprecated as modern LDAP C API provides replacements for all main operations which accepts
server-side controls as explicit arguments; see for example ldap_search_ext(3), ldap_add_ext(3), ldap_modify_ext(3) and so on.  outvalue must be LDAPControl ***, and  the
caller  is  responsible of freeing the returned controls, if any, by calling ldap_controls_free(3), while invalue must be LDAPControl *const *; the library duplicates the
controls passed via invalue.

LDAP_OPT_SESSION_REFCNT
Returns the reference count associated with the LDAP handle passed in as ld; outvalue must be a int *.  This is a  read-only,  handle-specific  option.   This  option  is
OpenLDAP specific.

LDAP_OPT_SIZELIMIT
Sets/gets the value that defines the maximum number of entries to be returned by a search operation.  invalue must be const int *, while outvalue must be int *; They can‐
not be NULL.

LDAP_OPT_SOCKBUF
Returns a pointer to the socket buffer of the LDAP handle passed in as ld; outvalue must be a Sockbuf **.  This is a read-only, handle-specific option.   This  option  is
OpenLDAP specific.

LDAP_OPT_TIMELIMIT
Sets/gets  the  value  that defines the time limit after which a search operation should be terminated by the server.  invalue must be const int *, while outvalue must be
int *, and they cannot be NULL.

LDAP_OPT_TIMEOUT
Sets/gets a timeout value for the synchronous API calls.  outvalue must be a struct timeval ** (the caller has to free *outvalue), and invalue must be a struct timeval *,
and they cannot be NULL. Using a struct with seconds set to -1 results in an infinite timeout, which is the default.  This option is OpenLDAP specific.

LDAP_OPT_URI
Sets/gets  a  comma-  or space-separated list of URIs to be contacted by the library when trying to establish a connection.  outvalue must be a char **, and the caller is
responsible of freeing the resulting string by calling ldap_memfree(3), while invalue must be a const char *; the library parses the string into  a  list  of  LDAPURLDesc
structures,  so  the  invocation  of  ldap_set_option(3)  may fail if URL parsing fails.  URIs may only contain the schema, the host, and the port fields.  This option is
OpenLDAP specific.

SASL OPTIONS
The SASL options are OpenLDAP specific.

LDAP_OPT_X_SASL_AUTHCID
Gets the SASL authentication identity; outvalue must be a char **, its content needs to be freed by the caller using ldap_memfree(3).

LDAP_OPT_X_SASL_AUTHZID
Gets the SASL authorization identity; outvalue must be a char **, its content needs to be freed by the caller using ldap_memfree(3).

LDAP_OPT_X_SASL_MAXBUFSIZE
Gets/sets SASL maximum buffer size; invalue must be const ber_len_t *, while outvalue must be ber_len_t *.  See also LDAP_OPT_X_SASL_SECPROPS.

LDAP_OPT_X_SASL_MECH
Gets the SASL mechanism; outvalue must be a char **, its content needs to be freed by the caller using ldap_memfree(3).

LDAP_OPT_X_SASL_MECHLIST
Gets the list of the available mechanisms, in form of a NULL-terminated array of strings; outvalue must be char ***.  The caller must not free or otherwise muck with it.

LDAP_OPT_X_SASL_NOCANON
Sets/gets the NOCANON flag.  When unset, the hostname is canonicalized.  invalue must be const int *; its value should either be LDAP_OPT_OFF  or  LDAP_OPT_ON.   outvalue
must be int *.

LDAP_OPT_X_SASL_REALM
Gets the SASL realm; outvalue must be a char **, its content needs to be freed by the caller using ldap_memfree(3).

LDAP_OPT_X_SASL_SECPROPS
Sets  the SASL secprops; invalue must be a char *, containing a comma-separated list of properties.  Legal values are: none, nodict, noplain, noactive, passcred, forward‐
sec, noanonymous, minssf=&amp;lt;minssf&amp;gt;, maxssf=&amp;lt;maxssf&amp;gt;, maxbufsize=&amp;lt;maxbufsize&amp;gt;.

LDAP_OPT_X_SASL_SSF
Gets the SASL SSF; outvalue must be a ber_len_t *.

LDAP_OPT_X_SASL_SSF_EXTERNAL
Sets the SASL SSF value related to an authentication performed using an EXTERNAL mechanism; invalue must be a const ber_len_t *.

LDAP_OPT_X_SASL_SSF_MAX
Gets/sets SASL maximum SSF; invalue must be const ber_len_t *, while outvalue must be ber_len_t *.  See also LDAP_OPT_X_SASL_SECPROPS.

LDAP_OPT_X_SASL_SSF_MIN
Gets/sets SASL minimum SSF; invalue must be const ber_len_t *, while outvalue must be ber_len_t *.  See also LDAP_OPT_X_SASL_SECPROPS.

LDAP_OPT_X_SASL_USERNAME
Gets the SASL username; outvalue must be a char **.  Its content needs to be freed by the caller using ldap_memfree(3).

TCP OPTIONS
The TCP options are OpenLDAP specific.  Mainly intended for use with Linux, they may not be portable.

LDAP_OPT_X_KEEPALIVE_IDLE
Sets/gets the number of seconds a connection needs to remain idle before TCP starts sending keepalive probes.  invalue must be const int *; outvalue must be int *.

LDAP_OPT_X_KEEPALIVE_PROBES
Sets/gets the maximum number of keepalive probes TCP should send before dropping the connection.  invalue must be const int *; outvalue must be int *.

LDAP_OPT_X_KEEPALIVE_INTERVAL
Sets/gets the interval in seconds between individual keepalive probes.  invalue must be const int *; outvalue must be int *.

TLS OPTIONS
The TLS options are OpenLDAP specific.

LDAP_OPT_X_TLS_CACERTDIR
Sets/gets the path of the directory containing CA certificates.  invalue must be const char *; outvalue must be char **, and its contents need to be freed by  the  caller
using ldap_memfree(3).

LDAP_OPT_X_TLS_CACERTFILE
Sets/gets  the  full-path  of  the  CA  certificate  file.   invalue must be const char *; outvalue must be char **, and its contents need to be freed by the caller using
ldap_memfree(3).

LDAP_OPT_X_TLS_CERTFILE
Sets/gets the full-path of the certificate file.  invalue must be const char *; outvalue must be char **, and its contents need to be freed by the caller using  ldap_mem‐
free(3).

LDAP_OPT_X_TLS_CIPHER_SUITE
Sets/gets the allowed cipher suite.  invalue must be const char *; outvalue must be char **, and its contents need to be freed by the caller using ldap_memfree(3).

LDAP_OPT_X_TLS_CONNECT_ARG
Sets/gets the connection callback argument.  invalue must be const void *; outvalue must be void **.

LDAP_OPT_X_TLS_CONNECT_CB
Sets/gets the connection callback handle.  invalue must be const LDAP_TLS_CONNECT_CB *; outvalue must be LDAP_TLS_CONNECT_CB **.

LDAP_OPT_X_TLS_CRLCHECK
Sets/gets  the CRL evaluation strategy, one of LDAP_OPT_X_TLS_CRL_NONE, LDAP_OPT_X_TLS_CRL_PEER, or LDAP_OPT_X_TLS_CRL_ALL.  invalue must be const int *; outvalue must be
int *.  Requires OpenSSL.

LDAP_OPT_X_TLS_CRLFILE
Sets/gets the full-path of the CRL file.  invalue must be const char *; outvalue must be char **, and its contents need to be freed by the caller  using  ldap_memfree(3).
This option is only valid for GnuTLS.

LDAP_OPT_X_TLS_CTX
Sets/gets  the  TLS  library context. New TLS sessions will inherit their default settings from this library context.  invalue must be const void *; outvalue must be void
**.  When using the OpenSSL library this is an SSL_CTX*. When using other crypto libraries this is a pointer to an OpenLDAP  private  structure.   Applications  generally
should not use this option or attempt to manipulate this structure.

LDAP_OPT_X_TLS_DHFILE
Gets/sets  the full-path of the file containing the parameters for Diffie-Hellman ephemeral key exchange.  invalue must be const char *; outvalue must be char **, and its
contents need to be freed by the caller using ldap_memfree(3).  Ignored by GnuTLS and Mozilla NSS.

LDAP_OPT_X_TLS_KEYFILE
Sets/gets the full-path of the certificate key file.  invalue must be const char *; outvalue must be char **, and its contents need  to  be  freed  by  the  caller  using
ldap_memfree(3).

LDAP_OPT_X_TLS_NEWCTX
Instructs the library to create a new TLS library context.  invalue must be const int *.  A non-zero value pointed to by invalue tells the library to create a context for
a server.

LDAP_OPT_X_TLS_PROTOCOL_MIN
Sets/gets the minimum protocol version.  invalue must be const int *; outvalue must be int *.

LDAP_OPT_X_TLS_RANDOM_FILE
Sets/gets the random file when /dev/random and /dev/urandom are not available.  invalue must be const char *; outvalue must be char **, and its contents need to be  freed
by the caller using ldap_memfree(3).  Ignored by GnuTLS older than version 2.2.  Ignored by Mozilla NSS.

LDAP_OPT_X_TLS_REQUIRE_CERT
Sets/gets the peer certificate checking strategy, one of LDAP_OPT_X_TLS_NEVER, LDAP_OPT_X_TLS_HARD, LDAP_OPT_X_TLS_DEMAND, LDAP_OPT_X_TLS_ALLOW, LDAP_OPT_X_TLS_TRY.

LDAP_OPT_X_TLS_SSL_CTX
Gets  the  TLS  session context associated with this handle.  outvalue must be void **.  When using the OpenSSL library this is an SSL*. When using other crypto libraries
this is a pointer to an OpenLDAP private structure.  Applications generally should not use this option.

ERRORS
On success, the functions return LDAP_OPT_SUCCESS, while they may return LDAP_OPT_ERROR to indicate a generic option handling error.  Occasionally, more specific errors  can  be
returned, like LDAP_NO_MEMORY to indicate a failure in memory allocation.

NOTES
The  LDAP  libraries  with  the  LDAP_OPT_REFERRALS option set to LDAP_OPT_ON (default value) automatically follow referrals using an anonymous bind.  Application developers are
encouraged to either implement consistent referral chasing features, or explicitly disable referral chasing by setting that option to LDAP_OPT_OFF.

The protocol version used by the library defaults to LDAPv2 (now historic), which corresponds to the LDAP_VERSION2 macro.  Application developers are  encouraged  to  explicitly
set LDAP_OPT_PROTOCOL_VERSION to LDAPv3, using the LDAP_VERSION3 macro, or to allow users to select the protocol version.

SEE ALSO
ldap(3), ldap_error(3), RFC 4422 (http://www.rfc-editor.org),

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                     LDAP_GET_OPTION(3)
LDAP_BIND(3)                                                                    Library Functions Manual                                                                    LDAP_BIND(3)

NAME
ldap_bind,   ldap_bind_s,   ldap_simple_bind,  ldap_simple_bind_s,  ldap_sasl_bind,  ldap_sasl_bind_s,  ldap_sasl_interactive_bind_s,  ldap_parse_sasl_bind_result,  ldap_unbind,
ldap_unbind_s, ldap_unbind_ext, ldap_unbind_ext_s, ldap_set_rebind_proc - LDAP bind routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_bind(LDAP *ld, const char *who, const char *cred,
int method);

int ldap_bind_s(LDAP *ld, const char *who, const char *cred,
int method);

int ldap_simple_bind(LDAP *ld, const char *who, const char *passwd);

int ldap_simple_bind_s(LDAP *ld, const char *who, const char *passwd);

int ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,
struct berval *cred, LDAPControl *sctrls[],
LDAPControl *cctrls[], int *msgidp);

int ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,
struct berval *cred, LDAPControl *sctrls[],
LDAPControl *cctrls[], struct berval **servercredp);

int ldap_parse_sasl_bind_result(LDAP *ld, LDAPMessage *res,
struct berval **servercredp, int freeit);

int ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn,
const char *mechs,
LDAPControl *sctrls[], LDAPControl *cctrls[],
unsigned flags, LDAP_SASL_INTERACT_PROC *interact,
void *defaults);

int ldap_sasl_interactive_bind(LDAP *ld, const char *dn,
const char *mechs,
LDAPControl *sctrls[], LDAPControl *cctrls[],
unsigned flags, LDAP_SASL_INTERACT_PROC *interact,
void *defaults, LDAPMessage *result,
const char **rmechp, int *msgidp);

int (LDAP_SASL_INTERACT_PROC)(LDAP *ld, unsigned flags, void *defaults, void *sasl_interact);

int ldap_unbind(LDAP *ld);

int ldap_unbind_s(LDAP *ld);

int ldap_unbind_ext(LDAP *ld, LDAPControl *sctrls[],
LDAPControl *cctrls[]);

int ldap_unbind_ext_s(LDAP *ld, LDAPControl *sctrls[],
LDAPControl *cctrls[]);

int ldap_set_rebind_proc (LDAP *ld, LDAP_REBIND_PROC *ldap_proc, void *params);

int (LDAP_REBIND_PROC)(LDAP *ld, LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *params);

DESCRIPTION
These routines provide various interfaces to the LDAP bind operation.  After an association with an LDAP server is made using ldap_init(3), an LDAP bind operation should be per‐
formed  before  other operations are attempted over the connection.  An LDAP bind is required when using Version 2 of the LDAP protocol; it is optional for Version 3 but is usu‐
ally needed due to security considerations.

There are three types of bind calls, ones providing simple authentication, ones providing SASL authentication, and general routines  capable  of  doing  either  simple  or  SASL
authentication.

SASL  (Simple  Authentication and Security Layer) can negotiate one of many different kinds of authentication.  Both synchronous and asynchronous versions of each variant of the
bind call are provided.  All routines take ld as their first parameter, as returned from ldap_init(3).

SIMPLE AUTHENTICATION
The simplest form of the bind call is ldap_simple_bind_s().  It takes the DN to bind as in who, and the userPassword associated with the entry in passwd.   It  returns  an  LDAP
error  indication  (see ldap_error(3)).  The ldap_simple_bind() call is asynchronous, taking the same parameters but only initiating the bind operation and returning the message
id of the request it sent.  The result of the operation can be obtained by a subsequent call to ldap_result(3).

GENERAL AUTHENTICATION
The ldap_bind() and ldap_bind_s() routines can be used when the authentication method to use needs to be selected at runtime.  They both take an extra method parameter selecting
the  authentication  method  to  use.   It  should  be  set to LDAP_AUTH_SIMPLE to select simple authentication.  ldap_bind() returns the message id of the request it initiates.
ldap_bind_s() returns an LDAP error indication.

SASL AUTHENTICATION
For SASL binds the server always ignores any provided DN, so the dn parameter should always be NULL.  ldap_sasl_bind_s() sends a single SASL bind request  with  the  given  SASL
mechanism and credentials in the cred parameter. The format of the credentials depends on the particular SASL mechanism in use. For mechanisms that provide mutual authentication
the server's credentials will be returned in the servercredp parameter.  The routine returns an LDAP error indication (see ldap_error(3)).  The ldap_sasl_bind()  call  is  asyn‐
chronous,  taking  the  same parameters but only sending the request and returning the message id of the request it sent. The result of the operation can be obtained by a subse‐
quent call to ldap_result(3).  The result must be additionally parsed by ldap_parse_sasl_bind_result() to obtain any server credentials sent from the server.

Many SASL mechanisms require multiple message exchanges to perform a complete authentication. Applications should generally use ldap_sasl_interactive_bind_s() rather than  call‐
ing  the  basic ldap_sasl_bind() functions directly. The mechs parameter should contain a space-separated list of candidate mechanisms to use. If this parameter is NULL or empty
the library will query the supportedSASLMechanisms attribute from the server's rootDSE for the list of SASL mechanisms the server supports.  The  flags  parameter  controls  the
interaction used to retrieve any necessary SASL authentication parameters and should be one of:

LDAP_SASL_AUTOMATIC
use defaults if available, prompt otherwise

LDAP_SASL_INTERACTIVE
always prompt

LDAP_SASL_QUIET
never prompt

The  interact  function uses the provided defaults to handle requests from the SASL library for particular authentication parameters. There is no defined format for the defaults
information; it is up to the caller to use whatever format is appropriate for the supplied interact function.   The  sasl_interact  parameter  comes  from  the  underlying  SASL
library. When used with Cyrus SASL this is an array of sasl_interact_t structures. The Cyrus SASL library will prompt for a variety of inputs, including:

SASL_CB_GETREALM
the realm for the authentication attempt

SASL_CB_AUTHNAME
the username to authenticate

SASL_CB_PASS
the password for the provided username

SASL_CB_USER
the username to use for proxy authorization

SASL_CB_NOECHOPROMPT
generic prompt for input with input echoing disabled

SASL_CB_ECHOPROMPT
generic prompt for input with input echoing enabled

SASL_CB_LIST_END
indicates the end of the array of prompts

See the Cyrus SASL documentation for more details.

Applications  which need to manage connections asynchronously may use ldap_sasl_interactive_bind() instead of the synchronous version.  A valid mechs parameter must be supplied,
otherwise the library will be forced to query the server for a list of supported mechanisms, and this query will be performed synchronously.  The other parameters are  the  same
as  for  the  synchronous function, with three additional parameters.  The actual SASL mechanism that was used, and the message ID for use with ldap_result() will be returned in
rmechp and msgidp, respectively.  The value in rmechp must not be modified by the caller and must be passed back on each subsequent call. The message obtained from ldap_result()
must  be  passed  in the result parameter.  This parameter must be NULL when initiating a new Bind. The caller must free the result message after each call using ldap_msgfree().
The ldap_sasl_interactive_bind() function returns an LDAP result code. If the code is LDAP_SASL_BIND_IN_PROGRESS then the Bind is not complete yet, and  this  function  must  be
called again with the next result from the server.

REBINDING
The  ldap_set_rebind_proc function() sets the process to use for binding when an operation returns a referral. This function is used when an application needs to bind to another
server in order to follow a referral or search continuation reference.

The function takes ld, the rebind function, and the params, the arbitrary data like state information which the client might need to  properly  rebind.   The  LDAP_OPT_REFERRALS
option in the ld must be set to ON for the libraries to use the rebind function. Use the ldap_set_option function to set the value.

The rebind function parameters are as follows:

The ld parameter must be used by the application when binding to the referred server if the application wants the libraries to follow the referral.

The url parameter points to the URL referral string received from the LDAP server.  The LDAP application can use the ldap_url_parse(3) function to parse the string into its com‐
ponents.

The request parameter specifies the type of request that generated the referral.

The msgid parameter specifies the message ID of the request generating the referral.

The params parameter is the same value as passed originally to the ldap_set_rebind_proc() function.

The LDAP libraries set all the parameters when they call the rebind function. The application should not attempt to free either the ld or the url structures in the rebind  func‐
tion.

The  application  must  supply to the rebind function the required authentication information such as, user name, password, and certificates. The rebind function must use a syn‐
chronous bind method.

UNBINDING
The ldap_unbind() call is used to unbind from the directory, terminate the current association, and free the resources contained in the ld structure.  Once  it  is  called,  the
connection  to  the LDAP server is closed, and the ld structure is invalid.  The ldap_unbind_s() call is just another name for ldap_unbind(); both of these calls are synchronous
in nature.

The ldap_unbind_ext() and ldap_unbind_ext_s() allows the operations to specify  controls.

ERRORS
Asynchronous routines will return -1 in case of error, setting the ld_errno parameter of the ld structure.  Synchronous  routines  return  whatever  ld_errno  is  set  to.   See
ldap_error(3) for more information.

NOTES
If  an anonymous bind is sufficient for the application, the rebind process need not be provided. The LDAP libraries with the LDAP_OPT_REFERRALS option set to ON (default value)
will automatically follow referrals using an anonymous bind.

If the application needs stronger authentication than an anonymous bind, you need to provide a rebind process for that authentication method.  The bind method must  be  synchro‐
nous.

SEE ALSO
ldap(3), ldap_error(3), ldap_open(3), ldap_set_option(3), ldap_url_parse(3) RFC 4422 (http://www.rfc-editor.org), Cyrus SASL (http://asg.web.cmu.edu/sasl/)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                           LDAP_BIND(3)
LDAP_OPEN(3)                                                                    Library Functions Manual                                                                    LDAP_OPEN(3)

NAME
ldap_init, ldap_initialize, ldap_open - Initialize the LDAP library and open a connection to an LDAP server

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

LDAP *ldap_open(host, port)
char *host;
int port;

LDAP *ldap_init(host, port)
char *host;
int port;

int ldap_initialize(ldp, uri)
LDAP **ldp;
char *uri;

int ldap_set_urllist_proc(ld, proc, params)
LDAP *ld;
LDAP_URLLIST_PROC *proc;
void *params;

int (LDAP_URLLIST_PROC)(ld, urllist, url, params);
LDAP *ld;
LDAPURLDesc **urllist;
LDAPURLDesc **url;
void *params;

#include &amp;lt;ldap_pvt.h&amp;gt;

int ldap_init_fd(fd, proto, uri, ldp)
ber_socket_t fd;
int proto;
char *uri;
LDAP **ldp;

DESCRIPTION
ldap_open()  opens  a  connection  to  an  LDAP  server  and  allocates  an  LDAP  structure which is used to identify the connection and to maintain per-connection information.
ldap_init() allocates an LDAP structure but does not open an initial connection.  ldap_initialize() allocates an  LDAP  structure  but  does  not  open  an  initial  connection.
ldap_init_fd() allocates an LDAP structure using an existing connection on the provided socket.  One of these routines must be called before any operations are attempted.

ldap_open()  takes  host,  the hostname on which the LDAP server is running, and port, the port number to which to connect.  If the default IANA-assigned port of 389 is desired,
LDAP_PORT should be specified for port.  The host parameter may contain a blank-separated list of hosts to try to connect to, and  each  host  may  optionally  by  of  the  form
host:port.   If  present,  the  :port  overrides the port parameter to ldap_open().  Upon successfully making a connection to an LDAP server, ldap_open() returns a pointer to an
opaque LDAP structure, which should be passed to subsequent calls to ldap_bind(), ldap_search(), etc. Certain fields in the LDAP structure can be set  to  indicate  size  limit,
time  limit,  and  how aliases are handled during operations; read and write access to those fields must occur by calling ldap_get_option(3) and ldap_set_option(3) respectively,
whenever possible.

ldap_init() acts just like ldap_open(), but does not open a connection to the LDAP server.  The actual connection open will occur when the first operation is attempted.

ldap_initialize() acts like ldap_init(), but it returns an integer indicating either success or the failure reason, and it allows to specify details for the  connection  in  the
schema  portion  of the URI.  The uri parameter may be a comma- or whitespace-separated list of URIs containing only the schema, the host, and the port fields.  Apart from ldap,
other (non-standard) recognized values of the schema field are ldaps (LDAP over TLS), ldapi (LDAP over IPC), and cldap (connectionless LDAP).  If other fields are  present,  the
behavior is undefined.

At  this  time,  ldap_open() and ldap_init() are deprecated in favor of ldap_initialize(), essentially because the latter allows to specify a schema in the URI and it explicitly
returns an error code.

ldap_init_fd() allows an LDAP structure to be initialized using an  already-opened  connection.  The  proto  parameter  should  be  one  of  LDAP_PROTO_TCP,  LDAP_PROTO_UDP,  or
LDAP_PROTO_IPC for a connection using TCP, UDP, or IPC, respectively. The value LDAP_PROTO_EXT may also be specified if user-supplied sockbuf handlers are going to be used. Note
that support for UDP is not implemented unless libldap was built with LDAP_CONNECTIONLESS defined.  The uri parameter may optionally be provided for informational purposes.

ldap_set_urllist_proc() allows to set a function proc of type LDAP_URLLIST_PROC that is called when a successful connection can be established.  This function receives the  list
of  URIs  parsed  from the uri string originally passed to ldap_initialize(), and the one that successfully connected.  The function may manipulate the URI list; the typical use
consists in moving the successful URI to the head of the list, so that subsequent attempts to connect to one of the URIs using the same LDAP handle will try it first.  If ld  is
null,  proc  is  set  as  a  global  parameter  that  is inherited by all handlers within the process that are created after the call to ldap_set_urllist_proc().  By default, no
LDAP_URLLIST_PROC is set.  In a multithreaded environment, ldap_set_urllist_proc() must be called before any concurrent operation using the LDAP handle is started.

Note: the first call into the LDAP library also initializes the global options for the library. As such the first call should be single-threaded or otherwise protected to insure
that  only one call is active. It is recommended that ldap_get_option() or ldap_set_option() be used in the program's main thread before any additional threads are created.  See
ldap_get_option(3).

ERRORS
If an error occurs, ldap_open() and ldap_init() will return NULL and errno should be set appropriately.  ldap_initialize() and ldap_init_fd() will directly return the LDAP  code
associated  to  the  error  (or LDAP_SUCCESS in case of success); errno should be set as well whenever appropriate.  ldap_set_urllist_proc() returns LDAP_OPT_ERROR on error, and
LDAP_OPT_SUCCESS on success.

SEE ALSO
ldap(3), ldap_bind(3), ldap_get_option(3), ldap_set_option(3), lber-sockbuf(3), errno(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                           LDAP_OPEN(3)
LDAP_BIND(3)                                                                    Library Functions Manual                                                                    LDAP_BIND(3)

NAME
ldap_bind,   ldap_bind_s,   ldap_simple_bind,  ldap_simple_bind_s,  ldap_sasl_bind,  ldap_sasl_bind_s,  ldap_sasl_interactive_bind_s,  ldap_parse_sasl_bind_result,  ldap_unbind,
ldap_unbind_s, ldap_unbind_ext, ldap_unbind_ext_s, ldap_set_rebind_proc - LDAP bind routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_bind(LDAP *ld, const char *who, const char *cred,
int method);

int ldap_bind_s(LDAP *ld, const char *who, const char *cred,
int method);

int ldap_simple_bind(LDAP *ld, const char *who, const char *passwd);

int ldap_simple_bind_s(LDAP *ld, const char *who, const char *passwd);

int ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,
struct berval *cred, LDAPControl *sctrls[],
LDAPControl *cctrls[], int *msgidp);

int ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,
struct berval *cred, LDAPControl *sctrls[],
LDAPControl *cctrls[], struct berval **servercredp);

int ldap_parse_sasl_bind_result(LDAP *ld, LDAPMessage *res,
struct berval **servercredp, int freeit);

int ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn,
const char *mechs,
LDAPControl *sctrls[], LDAPControl *cctrls[],
unsigned flags, LDAP_SASL_INTERACT_PROC *interact,
void *defaults);

int ldap_sasl_interactive_bind(LDAP *ld, const char *dn,
const char *mechs,
LDAPControl *sctrls[], LDAPControl *cctrls[],
unsigned flags, LDAP_SASL_INTERACT_PROC *interact,
void *defaults, LDAPMessage *result,
const char **rmechp, int *msgidp);

int (LDAP_SASL_INTERACT_PROC)(LDAP *ld, unsigned flags, void *defaults, void *sasl_interact);

int ldap_unbind(LDAP *ld);

int ldap_unbind_s(LDAP *ld);

int ldap_unbind_ext(LDAP *ld, LDAPControl *sctrls[],
LDAPControl *cctrls[]);

int ldap_unbind_ext_s(LDAP *ld, LDAPControl *sctrls[],
LDAPControl *cctrls[]);

int ldap_set_rebind_proc (LDAP *ld, LDAP_REBIND_PROC *ldap_proc, void *params);

int (LDAP_REBIND_PROC)(LDAP *ld, LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *params);

DESCRIPTION
These routines provide various interfaces to the LDAP bind operation.  After an association with an LDAP server is made using ldap_init(3), an LDAP bind operation should be per‐
formed  before  other operations are attempted over the connection.  An LDAP bind is required when using Version 2 of the LDAP protocol; it is optional for Version 3 but is usu‐
ally needed due to security considerations.

There are three types of bind calls, ones providing simple authentication, ones providing SASL authentication, and general routines  capable  of  doing  either  simple  or  SASL
authentication.

SASL  (Simple  Authentication and Security Layer) can negotiate one of many different kinds of authentication.  Both synchronous and asynchronous versions of each variant of the
bind call are provided.  All routines take ld as their first parameter, as returned from ldap_init(3).

SIMPLE AUTHENTICATION
The simplest form of the bind call is ldap_simple_bind_s().  It takes the DN to bind as in who, and the userPassword associated with the entry in passwd.   It  returns  an  LDAP
error  indication  (see ldap_error(3)).  The ldap_simple_bind() call is asynchronous, taking the same parameters but only initiating the bind operation and returning the message
id of the request it sent.  The result of the operation can be obtained by a subsequent call to ldap_result(3).

GENERAL AUTHENTICATION
The ldap_bind() and ldap_bind_s() routines can be used when the authentication method to use needs to be selected at runtime.  They both take an extra method parameter selecting
the  authentication  method  to  use.   It  should  be  set to LDAP_AUTH_SIMPLE to select simple authentication.  ldap_bind() returns the message id of the request it initiates.
ldap_bind_s() returns an LDAP error indication.

SASL AUTHENTICATION
For SASL binds the server always ignores any provided DN, so the dn parameter should always be NULL.  ldap_sasl_bind_s() sends a single SASL bind request  with  the  given  SASL
mechanism and credentials in the cred parameter. The format of the credentials depends on the particular SASL mechanism in use. For mechanisms that provide mutual authentication
the server's credentials will be returned in the servercredp parameter.  The routine returns an LDAP error indication (see ldap_error(3)).  The ldap_sasl_bind()  call  is  asyn‐
chronous,  taking  the  same parameters but only sending the request and returning the message id of the request it sent. The result of the operation can be obtained by a subse‐
quent call to ldap_result(3).  The result must be additionally parsed by ldap_parse_sasl_bind_result() to obtain any server credentials sent from the server.

Many SASL mechanisms require multiple message exchanges to perform a complete authentication. Applications should generally use ldap_sasl_interactive_bind_s() rather than  call‐
ing  the  basic ldap_sasl_bind() functions directly. The mechs parameter should contain a space-separated list of candidate mechanisms to use. If this parameter is NULL or empty
the library will query the supportedSASLMechanisms attribute from the server's rootDSE for the list of SASL mechanisms the server supports.  The  flags  parameter  controls  the
interaction used to retrieve any necessary SASL authentication parameters and should be one of:

LDAP_SASL_AUTOMATIC
use defaults if available, prompt otherwise

LDAP_SASL_INTERACTIVE
always prompt

LDAP_SASL_QUIET
never prompt

The  interact  function uses the provided defaults to handle requests from the SASL library for particular authentication parameters. There is no defined format for the defaults
information; it is up to the caller to use whatever format is appropriate for the supplied interact function.   The  sasl_interact  parameter  comes  from  the  underlying  SASL
library. When used with Cyrus SASL this is an array of sasl_interact_t structures. The Cyrus SASL library will prompt for a variety of inputs, including:

SASL_CB_GETREALM
the realm for the authentication attempt

SASL_CB_AUTHNAME
the username to authenticate

SASL_CB_PASS
the password for the provided username

SASL_CB_USER
the username to use for proxy authorization

SASL_CB_NOECHOPROMPT
generic prompt for input with input echoing disabled

SASL_CB_ECHOPROMPT
generic prompt for input with input echoing enabled

SASL_CB_LIST_END
indicates the end of the array of prompts

See the Cyrus SASL documentation for more details.

Applications  which need to manage connections asynchronously may use ldap_sasl_interactive_bind() instead of the synchronous version.  A valid mechs parameter must be supplied,
otherwise the library will be forced to query the server for a list of supported mechanisms, and this query will be performed synchronously.  The other parameters are  the  same
as  for  the  synchronous function, with three additional parameters.  The actual SASL mechanism that was used, and the message ID for use with ldap_result() will be returned in
rmechp and msgidp, respectively.  The value in rmechp must not be modified by the caller and must be passed back on each subsequent call. The message obtained from ldap_result()
must  be  passed  in the result parameter.  This parameter must be NULL when initiating a new Bind. The caller must free the result message after each call using ldap_msgfree().
The ldap_sasl_interactive_bind() function returns an LDAP result code. If the code is LDAP_SASL_BIND_IN_PROGRESS then the Bind is not complete yet, and  this  function  must  be
called again with the next result from the server.

REBINDING
The  ldap_set_rebind_proc function() sets the process to use for binding when an operation returns a referral. This function is used when an application needs to bind to another
server in order to follow a referral or search continuation reference.

The function takes ld, the rebind function, and the params, the arbitrary data like state information which the client might need to  properly  rebind.   The  LDAP_OPT_REFERRALS
option in the ld must be set to ON for the libraries to use the rebind function. Use the ldap_set_option function to set the value.

The rebind function parameters are as follows:

The ld parameter must be used by the application when binding to the referred server if the application wants the libraries to follow the referral.

The url parameter points to the URL referral string received from the LDAP server.  The LDAP application can use the ldap_url_parse(3) function to parse the string into its com‐
ponents.

The request parameter specifies the type of request that generated the referral.

The msgid parameter specifies the message ID of the request generating the referral.

The params parameter is the same value as passed originally to the ldap_set_rebind_proc() function.

The LDAP libraries set all the parameters when they call the rebind function. The application should not attempt to free either the ld or the url structures in the rebind  func‐
tion.

The  application  must  supply to the rebind function the required authentication information such as, user name, password, and certificates. The rebind function must use a syn‐
chronous bind method.

UNBINDING
The ldap_unbind() call is used to unbind from the directory, terminate the current association, and free the resources contained in the ld structure.  Once  it  is  called,  the
connection  to  the LDAP server is closed, and the ld structure is invalid.  The ldap_unbind_s() call is just another name for ldap_unbind(); both of these calls are synchronous
in nature.

The ldap_unbind_ext() and ldap_unbind_ext_s() allows the operations to specify  controls.

ERRORS
Asynchronous routines will return -1 in case of error, setting the ld_errno parameter of the ld structure.  Synchronous  routines  return  whatever  ld_errno  is  set  to.   See
ldap_error(3) for more information.

NOTES
If  an anonymous bind is sufficient for the application, the rebind process need not be provided. The LDAP libraries with the LDAP_OPT_REFERRALS option set to ON (default value)
will automatically follow referrals using an anonymous bind.

If the application needs stronger authentication than an anonymous bind, you need to provide a rebind process for that authentication method.  The bind method must  be  synchro‐
nous.

SEE ALSO
ldap(3), ldap_error(3), ldap_open(3), ldap_set_option(3), ldap_url_parse(3) RFC 4422 (http://www.rfc-editor.org), Cyrus SASL (http://asg.web.cmu.edu/sasl/)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                           LDAP_BIND(3)
LDAP_BIND(3)                                                                    Library Functions Manual                                                                    LDAP_BIND(3)

NAME
ldap_bind,   ldap_bind_s,   ldap_simple_bind,  ldap_simple_bind_s,  ldap_sasl_bind,  ldap_sasl_bind_s,  ldap_sasl_interactive_bind_s,  ldap_parse_sasl_bind_result,  ldap_unbind,
ldap_unbind_s, ldap_unbind_ext, ldap_unbind_ext_s, ldap_set_rebind_proc - LDAP bind routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_bind(LDAP *ld, const char *who, const char *cred,
int method);

int ldap_bind_s(LDAP *ld, const char *who, const char *cred,
int method);

int ldap_simple_bind(LDAP *ld, const char *who, const char *passwd);

int ldap_simple_bind_s(LDAP *ld, const char *who, const char *passwd);

int ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,
struct berval *cred, LDAPControl *sctrls[],
LDAPControl *cctrls[], int *msgidp);

int ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,
struct berval *cred, LDAPControl *sctrls[],
LDAPControl *cctrls[], struct berval **servercredp);

int ldap_parse_sasl_bind_result(LDAP *ld, LDAPMessage *res,
struct berval **servercredp, int freeit);

int ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn,
const char *mechs,
LDAPControl *sctrls[], LDAPControl *cctrls[],
unsigned flags, LDAP_SASL_INTERACT_PROC *interact,
void *defaults);

int ldap_sasl_interactive_bind(LDAP *ld, const char *dn,
const char *mechs,
LDAPControl *sctrls[], LDAPControl *cctrls[],
unsigned flags, LDAP_SASL_INTERACT_PROC *interact,
void *defaults, LDAPMessage *result,
const char **rmechp, int *msgidp);

int (LDAP_SASL_INTERACT_PROC)(LDAP *ld, unsigned flags, void *defaults, void *sasl_interact);

int ldap_unbind(LDAP *ld);

int ldap_unbind_s(LDAP *ld);

int ldap_unbind_ext(LDAP *ld, LDAPControl *sctrls[],
LDAPControl *cctrls[]);

int ldap_unbind_ext_s(LDAP *ld, LDAPControl *sctrls[],
LDAPControl *cctrls[]);

int ldap_set_rebind_proc (LDAP *ld, LDAP_REBIND_PROC *ldap_proc, void *params);

int (LDAP_REBIND_PROC)(LDAP *ld, LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *params);

DESCRIPTION
These routines provide various interfaces to the LDAP bind operation.  After an association with an LDAP server is made using ldap_init(3), an LDAP bind operation should be per‐
formed  before  other operations are attempted over the connection.  An LDAP bind is required when using Version 2 of the LDAP protocol; it is optional for Version 3 but is usu‐
ally needed due to security considerations.

There are three types of bind calls, ones providing simple authentication, ones providing SASL authentication, and general routines  capable  of  doing  either  simple  or  SASL
authentication.

SASL  (Simple  Authentication and Security Layer) can negotiate one of many different kinds of authentication.  Both synchronous and asynchronous versions of each variant of the
bind call are provided.  All routines take ld as their first parameter, as returned from ldap_init(3).

SIMPLE AUTHENTICATION
The simplest form of the bind call is ldap_simple_bind_s().  It takes the DN to bind as in who, and the userPassword associated with the entry in passwd.   It  returns  an  LDAP
error  indication  (see ldap_error(3)).  The ldap_simple_bind() call is asynchronous, taking the same parameters but only initiating the bind operation and returning the message
id of the request it sent.  The result of the operation can be obtained by a subsequent call to ldap_result(3).

GENERAL AUTHENTICATION
The ldap_bind() and ldap_bind_s() routines can be used when the authentication method to use needs to be selected at runtime.  They both take an extra method parameter selecting
the  authentication  method  to  use.   It  should  be  set to LDAP_AUTH_SIMPLE to select simple authentication.  ldap_bind() returns the message id of the request it initiates.
ldap_bind_s() returns an LDAP error indication.

SASL AUTHENTICATION
For SASL binds the server always ignores any provided DN, so the dn parameter should always be NULL.  ldap_sasl_bind_s() sends a single SASL bind request  with  the  given  SASL
mechanism and credentials in the cred parameter. The format of the credentials depends on the particular SASL mechanism in use. For mechanisms that provide mutual authentication
the server's credentials will be returned in the servercredp parameter.  The routine returns an LDAP error indication (see ldap_error(3)).  The ldap_sasl_bind()  call  is  asyn‐
chronous,  taking  the  same parameters but only sending the request and returning the message id of the request it sent. The result of the operation can be obtained by a subse‐
quent call to ldap_result(3).  The result must be additionally parsed by ldap_parse_sasl_bind_result() to obtain any server credentials sent from the server.

Many SASL mechanisms require multiple message exchanges to perform a complete authentication. Applications should generally use ldap_sasl_interactive_bind_s() rather than  call‐
ing  the  basic ldap_sasl_bind() functions directly. The mechs parameter should contain a space-separated list of candidate mechanisms to use. If this parameter is NULL or empty
the library will query the supportedSASLMechanisms attribute from the server's rootDSE for the list of SASL mechanisms the server supports.  The  flags  parameter  controls  the
interaction used to retrieve any necessary SASL authentication parameters and should be one of:

LDAP_SASL_AUTOMATIC
use defaults if available, prompt otherwise

LDAP_SASL_INTERACTIVE
always prompt

LDAP_SASL_QUIET
never prompt

The  interact  function uses the provided defaults to handle requests from the SASL library for particular authentication parameters. There is no defined format for the defaults
information; it is up to the caller to use whatever format is appropriate for the supplied interact function.   The  sasl_interact  parameter  comes  from  the  underlying  SASL
library. When used with Cyrus SASL this is an array of sasl_interact_t structures. The Cyrus SASL library will prompt for a variety of inputs, including:

SASL_CB_GETREALM
the realm for the authentication attempt

SASL_CB_AUTHNAME
the username to authenticate

SASL_CB_PASS
the password for the provided username

SASL_CB_USER
the username to use for proxy authorization

SASL_CB_NOECHOPROMPT
generic prompt for input with input echoing disabled

SASL_CB_ECHOPROMPT
generic prompt for input with input echoing enabled

SASL_CB_LIST_END
indicates the end of the array of prompts

See the Cyrus SASL documentation for more details.

Applications  which need to manage connections asynchronously may use ldap_sasl_interactive_bind() instead of the synchronous version.  A valid mechs parameter must be supplied,
otherwise the library will be forced to query the server for a list of supported mechanisms, and this query will be performed synchronously.  The other parameters are  the  same
as  for  the  synchronous function, with three additional parameters.  The actual SASL mechanism that was used, and the message ID for use with ldap_result() will be returned in
rmechp and msgidp, respectively.  The value in rmechp must not be modified by the caller and must be passed back on each subsequent call. The message obtained from ldap_result()
must  be  passed  in the result parameter.  This parameter must be NULL when initiating a new Bind. The caller must free the result message after each call using ldap_msgfree().
The ldap_sasl_interactive_bind() function returns an LDAP result code. If the code is LDAP_SASL_BIND_IN_PROGRESS then the Bind is not complete yet, and  this  function  must  be
called again with the next result from the server.

REBINDING
The  ldap_set_rebind_proc function() sets the process to use for binding when an operation returns a referral. This function is used when an application needs to bind to another
server in order to follow a referral or search continuation reference.

The function takes ld, the rebind function, and the params, the arbitrary data like state information which the client might need to  properly  rebind.   The  LDAP_OPT_REFERRALS
option in the ld must be set to ON for the libraries to use the rebind function. Use the ldap_set_option function to set the value.

The rebind function parameters are as follows:

The ld parameter must be used by the application when binding to the referred server if the application wants the libraries to follow the referral.

The url parameter points to the URL referral string received from the LDAP server.  The LDAP application can use the ldap_url_parse(3) function to parse the string into its com‐
ponents.

The request parameter specifies the type of request that generated the referral.

The msgid parameter specifies the message ID of the request generating the referral.

The params parameter is the same value as passed originally to the ldap_set_rebind_proc() function.

The LDAP libraries set all the parameters when they call the rebind function. The application should not attempt to free either the ld or the url structures in the rebind  func‐
tion.

The  application  must  supply to the rebind function the required authentication information such as, user name, password, and certificates. The rebind function must use a syn‐
chronous bind method.

UNBINDING
The ldap_unbind() call is used to unbind from the directory, terminate the current association, and free the resources contained in the ld structure.  Once  it  is  called,  the
connection  to  the LDAP server is closed, and the ld structure is invalid.  The ldap_unbind_s() call is just another name for ldap_unbind(); both of these calls are synchronous
in nature.

The ldap_unbind_ext() and ldap_unbind_ext_s() allows the operations to specify  controls.

ERRORS
Asynchronous routines will return -1 in case of error, setting the ld_errno parameter of the ld structure.  Synchronous  routines  return  whatever  ld_errno  is  set  to.   See
ldap_error(3) for more information.

NOTES
If  an anonymous bind is sufficient for the application, the rebind process need not be provided. The LDAP libraries with the LDAP_OPT_REFERRALS option set to ON (default value)
will automatically follow referrals using an anonymous bind.

If the application needs stronger authentication than an anonymous bind, you need to provide a rebind process for that authentication method.  The bind method must  be  synchro‐
nous.

SEE ALSO
ldap(3), ldap_error(3), ldap_open(3), ldap_set_option(3), ldap_url_parse(3) RFC 4422 (http://www.rfc-editor.org), Cyrus SASL (http://asg.web.cmu.edu/sasl/)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                           LDAP_BIND(3)
LDAP_SORT(3)                                                                    Library Functions Manual                                                                    LDAP_SORT(3)

NAME
ldap_sort_entries, ldap_sort_values, ldap_sort_strcasecmp - LDAP sorting routines (deprecated)

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

DESCRIPTION
The ldap_sort_entries(), ldap_sort_values(), and ldap_sort_strcasecmp() are deprecated.

Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed
to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                           LDAP_SORT(3)
LDAP_SORT(3)                                                                    Library Functions Manual                                                                    LDAP_SORT(3)

NAME
ldap_sort_entries, ldap_sort_values, ldap_sort_strcasecmp - LDAP sorting routines (deprecated)

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

DESCRIPTION
The ldap_sort_entries(), ldap_sort_values(), and ldap_sort_strcasecmp() are deprecated.

Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed
to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                           LDAP_SORT(3)
LDAP_SORT(3)                                                                    Library Functions Manual                                                                    LDAP_SORT(3)

NAME
ldap_sort_entries, ldap_sort_values, ldap_sort_strcasecmp - LDAP sorting routines (deprecated)

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

DESCRIPTION
The ldap_sort_entries(), ldap_sort_values(), and ldap_sort_strcasecmp() are deprecated.

Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed
to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                           LDAP_SORT(3)
LDAP_SORT(3)                                                                    Library Functions Manual                                                                    LDAP_SORT(3)

NAME
ldap_sort_entries, ldap_sort_values, ldap_sort_strcasecmp - LDAP sorting routines (deprecated)

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

DESCRIPTION
The ldap_sort_entries(), ldap_sort_values(), and ldap_sort_strcasecmp() are deprecated.

Deprecated  interfaces generally remain in the library.  The macro LDAP_DEPRECATED can be defined to a non-zero value (e.g., -DLDAP_DEPRECATED=1) when compiling program designed
to use deprecated interfaces.  It is recommended that developers writing new programs, or updating old programs, avoid use of deprecated interfaces.  Over time, it  is  expected
that documentation (and, eventually, support) for deprecated interfaces to be eliminated.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                           LDAP_SORT(3)
LDAP_TLS(3)                                                                     Library Functions Manual                                                                     LDAP_TLS(3)

NAME
ldap_start_tls, ldap_start_tls_s, ldap_tls_inplace, ldap_install_tls - LDAP TLS initialization routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_start_tls(LDAP *ld);

int ldap_start_tls_s(LDAP *ld, LDAPControl **serverctrls, LDAPControl **clientctrls);

int ldap_tls_inplace(LDAP *ld);

int ldap_install_tls(LDAP *ld);

DESCRIPTION
These  routines are used to initiate TLS processing on an LDAP session.  ldap_start_tls_s() sends a StartTLS request to a server, waits for the reply, and then installs TLS han‐
dlers on the session if the request succeeded. The routine returns LDAP_SUCCESS if everything succeeded, otherwise it returns an  LDAP  error  code.   ldap_start_tls()  sends  a
StartTLS  request  to  a  server  and  does  nothing  else. It returns LDAP_SUCCESS if the request was sent successfully.  ldap_tls_inplace() returns 1 if TLS handlers have been
installed on the specified session, 0 otherwise.  ldap_install_tls() installs the TLS handlers on the given session. It returns LDAP_LOCAL_ERROR if TLS is already installed.

SEE ALSO
ldap(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                            LDAP_TLS(3)
LDAP_TLS(3)                                                                     Library Functions Manual                                                                     LDAP_TLS(3)

NAME
ldap_start_tls, ldap_start_tls_s, ldap_tls_inplace, ldap_install_tls - LDAP TLS initialization routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_start_tls(LDAP *ld);

int ldap_start_tls_s(LDAP *ld, LDAPControl **serverctrls, LDAPControl **clientctrls);

int ldap_tls_inplace(LDAP *ld);

int ldap_install_tls(LDAP *ld);

DESCRIPTION
These  routines are used to initiate TLS processing on an LDAP session.  ldap_start_tls_s() sends a StartTLS request to a server, waits for the reply, and then installs TLS han‐
dlers on the session if the request succeeded. The routine returns LDAP_SUCCESS if everything succeeded, otherwise it returns an  LDAP  error  code.   ldap_start_tls()  sends  a
StartTLS  request  to  a  server  and  does  nothing  else. It returns LDAP_SUCCESS if the request was sent successfully.  ldap_tls_inplace() returns 1 if TLS handlers have been
installed on the specified session, 0 otherwise.  ldap_install_tls() installs the TLS handlers on the given session. It returns LDAP_LOCAL_ERROR if TLS is already installed.

SEE ALSO
ldap(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                            LDAP_TLS(3)
LDAP_SCHEMA(3)                                                                  Library Functions Manual                                                                  LDAP_SCHEMA(3)

NAME
ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,
ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object‐
class_free, ldap_scherr2str - Schema definition handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;
#include &amp;lt;ldap_schema.h&amp;gt;

LDAPSyntax * ldap_str2syntax(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_syntax2str(syn)
const LDAPSyntax * syn;

const char * ldap_syntax2name(syn)
LDAPSyntax * syn;

ldap_syntax_free(syn)
LDAPSyntax * syn;

LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_matchingrule2str(mr);
const LDAPMatchingRule * mr;

const char * ldap_matchingrule2name(mr)
LDAPMatchingRule * mr;

ldap_matchingrule_free(mr)
LDAPMatchingRule * mr;

LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_attributetype2str(at)
const LDAPAttributeType * at;

const char * ldap_attributetype2name(at)
LDAPAttributeType * at;

ldap_attributetype_free(at)
LDAPAttributeType * at;

LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_objectclass2str(oc)
const LDAPObjectClass * oc;

const char * ldap_objectclass2name(oc)
LDAPObjectClass * oc;

ldap_objectclass_free(oc)
LDAPObjectClass * oc;

char * ldap_scherr2str(code)
int code;

DESCRIPTION
These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:
syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.

ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate
kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,
the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter‐
minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a
bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:

LDAP_SCHEMA_ALLOW_NONE
strict parsing according to RFC 4512.

LDAP_SCHEMA_ALLOW_NO_OID
permit definitions that do not contain an initial OID.

LDAP_SCHEMA_ALLOW_QUOTED
permit quotes around some items that should not have them.

LDAP_SCHEMA_ALLOW_DESCR
permit a descr instead of a numeric OID in places where the syntax expect the latter.

LDAP_SCHEMA_ALLOW_DESCR_PREFIX
permit that the initial numeric OID contains a prefix in descr format.

LDAP_SCHEMA_ALLOW_ALL
be very liberal, include all options.

The structures returned are as follows:

typedef struct ldap_schema_extension_item {
char *lsei_name;        /* Extension name */
char **lsei_values;     /* Extension values */
} LDAPSchemaExtensionItem;

typedef struct ldap_syntax {
char *syn_oid;          /* OID */
char **syn_names;       /* Names */
char *syn_desc;         /* Description */
LDAPSchemaExtensionItem **syn_extensions; /* Extension */
} LDAPSyntax;

typedef struct ldap_matchingrule {
char *mr_oid;           /* OID */
char **mr_names;        /* Names */
char *mr_desc;          /* Description */
int  mr_obsolete;       /* Is obsolete? */
char *mr_syntax_oid;    /* Syntax of asserted values */
LDAPSchemaExtensionItem **mr_extensions; /* Extensions */
} LDAPMatchingRule;

typedef struct ldap_attributetype {
char *at_oid;           /* OID */
char **at_names;        /* Names */
char *at_desc;          /* Description */
int  at_obsolete;       /* Is obsolete? */
char *at_sup_oid;       /* OID of superior type */
char *at_equality_oid;  /* OID of equality matching rule */
char *at_ordering_oid;  /* OID of ordering matching rule */
char *at_substr_oid;    /* OID of substrings matching rule */
char *at_syntax_oid;    /* OID of syntax of values */
int  at_syntax_len;     /* Suggested minimum maximum length */
int  at_single_value;   /* Is single-valued?  */
int  at_collective;     /* Is collective? */
int  at_no_user_mod;    /* Are changes forbidden through LDAP? */
int  at_usage;          /* Usage, see below */
LDAPSchemaExtensionItem **at_extensions; /* Extensions */
} LDAPAttributeType;

typedef struct ldap_objectclass {
char *oc_oid;           /* OID */
char **oc_names;        /* Names */
char *oc_desc;          /* Description */
int  oc_obsolete;       /* Is obsolete? */
char **oc_sup_oids;     /* OIDs of superior classes */
int  oc_kind;           /* Kind, see below */
char **oc_at_oids_must; /* OIDs of required attribute types */
char **oc_at_oids_may;  /* OIDs of optional attribute types */
LDAPSchemaExtensionItem **oc_extensions; /* Extensions */
} LDAPObjectClass;

Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:

LDAP_SCHEMA_NO
The answer to the question is no.

LDAP_SCHEMA_YES
The answer to the question is yes.

For attribute types, the following usages are possible:

LDAP_SCHEMA_USER_APPLICATIONS
the attribute type is non-operational.

LDAP_SCHEMA_DIRECTORY_OPERATION
the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute
type.

LDAP_SCHEMA_DISTRIBUTED_OPERATION
the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.

LDAP_SCHEMA_DSA_OPERATION
the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different
servers that master the entry.

Object classes can be of three kinds:

LDAP_SCHEMA_ABSTRACT
the object class is abstract, i.e. there cannot be entries of this class alone.

LDAP_SCHEMA_STRUCTURAL
the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned
cannot be changed: none of those present can be removed and none other can be added.

LDAP_SCHEMA_AUXILIARY
the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added
or removed at the same time as needed by the set of object classes resulting from the operation.

Routines ldap_xxx2name() return a canonical name for the definition.

Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that
must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.

ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The
argument code comes from one of the parsing routines and can adopt the following values:

LDAP_SCHERR_OUTOFMEM
Out of memory.

LDAP_SCHERR_UNEXPTOKEN
Unexpected token.

LDAP_SCHERR_NOLEFTPAREN
Missing opening parenthesis.

LDAP_SCHERR_NORIGHTPAREN
Missing closing parenthesis.

LDAP_SCHERR_NODIGIT
Expecting digit.

LDAP_SCHERR_BADNAME
Expecting a name.

LDAP_SCHERR_BADDESC
Bad description.

LDAP_SCHERR_BADSUP
Bad superiors.

LDAP_SCHERR_DUPOPT
Duplicate option.

LDAP_SCHERR_EMPTY
Unexpected end of data.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_SCHEMA(3)
LDAP_GET_DN(3)                                                                  Library Functions Manual                                                                  LDAP_GET_DN(3)

NAME
ldap_get_dn, ldap_explode_dn, ldap_explode_rdn, ldap_dn2ufn - LDAP DN handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

char *ldap_get_dn( LDAP *ld, LDAPMessage *entry )

int ldap_str2dn( const char *str, LDAPDN *dn, unsigned flags )

void ldap_dnfree( LDAPDN dn )

int ldap_dn2str( LDAPDN dn, char **str, unsigned flags )

char **ldap_explode_dn( const char *dn, int notypes )

char **ldap_explode_rdn( const char *rdn, int notypes )

char *ldap_dn2ufn( const char * dn )

char *ldap_dn2dcedn( const char * dn )

char *ldap_dcedn2dn( const char * dn )

char *ldap_dn2ad_canonical( const char * dn )

DESCRIPTION
These  routines  allow  LDAP entry names (Distinguished Names, or DNs) to be obtained, parsed, converted to a user-friendly form, and tested.  A DN has the form described in RFC
4414 "Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names".

The ldap_get_dn() routine takes an entry as returned by ldap_first_entry(3) or ldap_next_entry(3) and returns a copy of the entry's DN.  Space for the DN will be obtained dynam‐
ically and should be freed by the caller using ldap_memfree(3).

ldap_str2dn()  parses  a  string representation of a distinguished name contained in str into its components, which are stored in dn as ldap_ava structures, arranged in LDAPAVA,
LDAPRDN, and LDAPDN terms.  Space for dn will be obtained dynamically and should be freed by the caller using ldap_dnfree(3).  The LDAPDN is defined as:

typedef struct ldap_ava {
struct berval la_attr;
struct berval la_value;
unsigned la_flags;
} LDAPAVA;

typedef LDAPAVA** LDAPRDN;
typedef LDAPRDN* LDAPDN;

The attribute types and the attribute values are not normalized.  The la_flags can be either LDAP_AVA_STRING or LDAP_AVA_BINARY, the latter meaning that  the  value  is  BER/DER
encoded  and  thus must be represented as, quoting from RFC 4514, " ... an octothorpe character ('#' ASCII 35) followed by the hexadecimal representation of each of the bytes of
the BER encoding of the X.500 AttributeValue."  The flags parameter to ldap_str2dn() can be

LDAP_DN_FORMAT_LDAPV3
LDAP_DN_FORMAT_LDAPV2
LDAP_DN_FORMAT_DCE

which defines what DN syntax is expected (according to RFC 4514, RFC 1779 and DCE, respectively).  The format can be ORed to the flags

LDAP_DN_P_NO_SPACES
LDAP_DN_P_NO_SPACE_AFTER_RDN
...
LDAP_DN_PEDANTIC

The latter is a shortcut for all the previous limitations.

LDAP_DN_P_NO_SPACES does not allow extra spaces in the dn; the default is to  silently  eliminate  spaces  around  AVA  separators  ('='),  RDN  component  separators  ('+'  for
LDAPv3/LDAPv2 or ',' for DCE) and RDN separators (',' LDAPv3/LDAPv2 or '/' for DCE).

LDAP_DN_P_NO_SPACE_AFTER_RDN does not allow a single space after RDN separators.

ldap_dn2str() performs the inverse operation, yielding in str a string representation of dn.  It allows the same values for flags as ldap_str2dn(), plus

LDAP_DN_FORMAT_UFN
LDAP_DN_FORMAT_AD_CANONICAL

for user-friendly naming (RFC 1781) and AD canonical.

The following routines are viewed as deprecated in favor of ldap_str2dn() and ldap_dn2str().  They are provided to support legacy applications.

The  ldap_explode_dn()  routine  takes a DN as returned by ldap_get_dn() and breaks it up into its component parts.  Each part is known as a Relative Distinguished Name, or RDN.
ldap_explode_dn() returns a NULL-terminated array, each component of which contains an RDN from the DN.  The notypes parameter is used to request that only  the  RDN  values  be
returned,  not their types.  For example, the DN "cn=Bob, c=US" would return as either { "cn=Bob", "c=US", NULL } or { "Bob", "US", NULL }, depending on whether notypes was 0 or
1, respectively.  Assertion values in RDN strings may included escaped characters.  The result can be freed by calling ldap_value_free(3).

Similarly, the ldap_explode_rdn() routine takes an RDN as returned by ldap_explode_dn(dn,0) and breaks it up into its "type=value" component  parts  (or  just  "value",  if  the
notypes parameter is set).  Note the value is not unescaped.  The result can be freed by calling ldap_value_free(3).

ldap_dn2ufn() is used to turn a DN as returned by ldap_get_dn(3) into a more user-friendly form, stripping off all type names.  See "Using the Directory to Achieve User Friendly
Naming" (RFC 1781) for more details on the UFN format.  Due to the ambiguous nature of the format, it is generally only used  for  display  purposes.   The  space  for  the  UFN
returned is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).

ldap_dn2dcedn() is used to turn a DN as returned by ldap_get_dn(3) into a DCE-style DN, e.g. a string with most-significant to least significant rdns separated by slashes ('/');
rdn components are separated by commas (',').  Only printable chars (e.g. LDAPv2 printable string) are allowed, at least in this implementation.   ldap_dcedn2dn()  performs  the
opposite  operation.   ldap_dn2ad_canonical() turns a DN into a AD canonical name, which is basically a DCE dn with attribute types omitted.  The trailing domain, if present, is
turned in a DNS-like domain.  The space for the returned value is obtained dynamically and the user is responsible for freeing it via a call to ldap_memfree(3).

ERRORS
If an error occurs in ldap_get_dn(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the error.  See ldap_error(3) for a description  of  possible
error codes.  ldap_explode_dn(), ldap_explode_rdn(), ldap_dn2ufn(), ldap_dn2dcedn(), ldap_dcedn2dn(), and ldap_dn2ad_canonical() will return NULL with errno(3) set appropriately
in case of trouble.

NOTES
These routines dynamically allocate memory that the caller must free.

SEE ALSO
ldap(3), ldap_error(3), ldap_first_entry(3), ldap_memfree(3), ldap_value_free(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_GET_DN(3)
LDAP_SCHEMA(3)                                                                  Library Functions Manual                                                                  LDAP_SCHEMA(3)

NAME
ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,
ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object‐
class_free, ldap_scherr2str - Schema definition handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;
#include &amp;lt;ldap_schema.h&amp;gt;

LDAPSyntax * ldap_str2syntax(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_syntax2str(syn)
const LDAPSyntax * syn;

const char * ldap_syntax2name(syn)
LDAPSyntax * syn;

ldap_syntax_free(syn)
LDAPSyntax * syn;

LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_matchingrule2str(mr);
const LDAPMatchingRule * mr;

const char * ldap_matchingrule2name(mr)
LDAPMatchingRule * mr;

ldap_matchingrule_free(mr)
LDAPMatchingRule * mr;

LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_attributetype2str(at)
const LDAPAttributeType * at;

const char * ldap_attributetype2name(at)
LDAPAttributeType * at;

ldap_attributetype_free(at)
LDAPAttributeType * at;

LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_objectclass2str(oc)
const LDAPObjectClass * oc;

const char * ldap_objectclass2name(oc)
LDAPObjectClass * oc;

ldap_objectclass_free(oc)
LDAPObjectClass * oc;

char * ldap_scherr2str(code)
int code;

DESCRIPTION
These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:
syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.

ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate
kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,
the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter‐
minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a
bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:

LDAP_SCHEMA_ALLOW_NONE
strict parsing according to RFC 4512.

LDAP_SCHEMA_ALLOW_NO_OID
permit definitions that do not contain an initial OID.

LDAP_SCHEMA_ALLOW_QUOTED
permit quotes around some items that should not have them.

LDAP_SCHEMA_ALLOW_DESCR
permit a descr instead of a numeric OID in places where the syntax expect the latter.

LDAP_SCHEMA_ALLOW_DESCR_PREFIX
permit that the initial numeric OID contains a prefix in descr format.

LDAP_SCHEMA_ALLOW_ALL
be very liberal, include all options.

The structures returned are as follows:

typedef struct ldap_schema_extension_item {
char *lsei_name;        /* Extension name */
char **lsei_values;     /* Extension values */
} LDAPSchemaExtensionItem;

typedef struct ldap_syntax {
char *syn_oid;          /* OID */
char **syn_names;       /* Names */
char *syn_desc;         /* Description */
LDAPSchemaExtensionItem **syn_extensions; /* Extension */
} LDAPSyntax;

typedef struct ldap_matchingrule {
char *mr_oid;           /* OID */
char **mr_names;        /* Names */
char *mr_desc;          /* Description */
int  mr_obsolete;       /* Is obsolete? */
char *mr_syntax_oid;    /* Syntax of asserted values */
LDAPSchemaExtensionItem **mr_extensions; /* Extensions */
} LDAPMatchingRule;

typedef struct ldap_attributetype {
char *at_oid;           /* OID */
char **at_names;        /* Names */
char *at_desc;          /* Description */
int  at_obsolete;       /* Is obsolete? */
char *at_sup_oid;       /* OID of superior type */
char *at_equality_oid;  /* OID of equality matching rule */
char *at_ordering_oid;  /* OID of ordering matching rule */
char *at_substr_oid;    /* OID of substrings matching rule */
char *at_syntax_oid;    /* OID of syntax of values */
int  at_syntax_len;     /* Suggested minimum maximum length */
int  at_single_value;   /* Is single-valued?  */
int  at_collective;     /* Is collective? */
int  at_no_user_mod;    /* Are changes forbidden through LDAP? */
int  at_usage;          /* Usage, see below */
LDAPSchemaExtensionItem **at_extensions; /* Extensions */
} LDAPAttributeType;

typedef struct ldap_objectclass {
char *oc_oid;           /* OID */
char **oc_names;        /* Names */
char *oc_desc;          /* Description */
int  oc_obsolete;       /* Is obsolete? */
char **oc_sup_oids;     /* OIDs of superior classes */
int  oc_kind;           /* Kind, see below */
char **oc_at_oids_must; /* OIDs of required attribute types */
char **oc_at_oids_may;  /* OIDs of optional attribute types */
LDAPSchemaExtensionItem **oc_extensions; /* Extensions */
} LDAPObjectClass;

Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:

LDAP_SCHEMA_NO
The answer to the question is no.

LDAP_SCHEMA_YES
The answer to the question is yes.

For attribute types, the following usages are possible:

LDAP_SCHEMA_USER_APPLICATIONS
the attribute type is non-operational.

LDAP_SCHEMA_DIRECTORY_OPERATION
the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute
type.

LDAP_SCHEMA_DISTRIBUTED_OPERATION
the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.

LDAP_SCHEMA_DSA_OPERATION
the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different
servers that master the entry.

Object classes can be of three kinds:

LDAP_SCHEMA_ABSTRACT
the object class is abstract, i.e. there cannot be entries of this class alone.

LDAP_SCHEMA_STRUCTURAL
the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned
cannot be changed: none of those present can be removed and none other can be added.

LDAP_SCHEMA_AUXILIARY
the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added
or removed at the same time as needed by the set of object classes resulting from the operation.

Routines ldap_xxx2name() return a canonical name for the definition.

Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that
must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.

ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The
argument code comes from one of the parsing routines and can adopt the following values:

LDAP_SCHERR_OUTOFMEM
Out of memory.

LDAP_SCHERR_UNEXPTOKEN
Unexpected token.

LDAP_SCHERR_NOLEFTPAREN
Missing opening parenthesis.

LDAP_SCHERR_NORIGHTPAREN
Missing closing parenthesis.

LDAP_SCHERR_NODIGIT
Expecting digit.

LDAP_SCHERR_BADNAME
Expecting a name.

LDAP_SCHERR_BADDESC
Bad description.

LDAP_SCHERR_BADSUP
Bad superiors.

LDAP_SCHERR_DUPOPT
Duplicate option.

LDAP_SCHERR_EMPTY
Unexpected end of data.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_SCHEMA(3)
LDAP_SCHEMA(3)                                                                  Library Functions Manual                                                                  LDAP_SCHEMA(3)

NAME
ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,
ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object‐
class_free, ldap_scherr2str - Schema definition handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;
#include &amp;lt;ldap_schema.h&amp;gt;

LDAPSyntax * ldap_str2syntax(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_syntax2str(syn)
const LDAPSyntax * syn;

const char * ldap_syntax2name(syn)
LDAPSyntax * syn;

ldap_syntax_free(syn)
LDAPSyntax * syn;

LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_matchingrule2str(mr);
const LDAPMatchingRule * mr;

const char * ldap_matchingrule2name(mr)
LDAPMatchingRule * mr;

ldap_matchingrule_free(mr)
LDAPMatchingRule * mr;

LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_attributetype2str(at)
const LDAPAttributeType * at;

const char * ldap_attributetype2name(at)
LDAPAttributeType * at;

ldap_attributetype_free(at)
LDAPAttributeType * at;

LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_objectclass2str(oc)
const LDAPObjectClass * oc;

const char * ldap_objectclass2name(oc)
LDAPObjectClass * oc;

ldap_objectclass_free(oc)
LDAPObjectClass * oc;

char * ldap_scherr2str(code)
int code;

DESCRIPTION
These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:
syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.

ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate
kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,
the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter‐
minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a
bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:

LDAP_SCHEMA_ALLOW_NONE
strict parsing according to RFC 4512.

LDAP_SCHEMA_ALLOW_NO_OID
permit definitions that do not contain an initial OID.

LDAP_SCHEMA_ALLOW_QUOTED
permit quotes around some items that should not have them.

LDAP_SCHEMA_ALLOW_DESCR
permit a descr instead of a numeric OID in places where the syntax expect the latter.

LDAP_SCHEMA_ALLOW_DESCR_PREFIX
permit that the initial numeric OID contains a prefix in descr format.

LDAP_SCHEMA_ALLOW_ALL
be very liberal, include all options.

The structures returned are as follows:

typedef struct ldap_schema_extension_item {
char *lsei_name;        /* Extension name */
char **lsei_values;     /* Extension values */
} LDAPSchemaExtensionItem;

typedef struct ldap_syntax {
char *syn_oid;          /* OID */
char **syn_names;       /* Names */
char *syn_desc;         /* Description */
LDAPSchemaExtensionItem **syn_extensions; /* Extension */
} LDAPSyntax;

typedef struct ldap_matchingrule {
char *mr_oid;           /* OID */
char **mr_names;        /* Names */
char *mr_desc;          /* Description */
int  mr_obsolete;       /* Is obsolete? */
char *mr_syntax_oid;    /* Syntax of asserted values */
LDAPSchemaExtensionItem **mr_extensions; /* Extensions */
} LDAPMatchingRule;

typedef struct ldap_attributetype {
char *at_oid;           /* OID */
char **at_names;        /* Names */
char *at_desc;          /* Description */
int  at_obsolete;       /* Is obsolete? */
char *at_sup_oid;       /* OID of superior type */
char *at_equality_oid;  /* OID of equality matching rule */
char *at_ordering_oid;  /* OID of ordering matching rule */
char *at_substr_oid;    /* OID of substrings matching rule */
char *at_syntax_oid;    /* OID of syntax of values */
int  at_syntax_len;     /* Suggested minimum maximum length */
int  at_single_value;   /* Is single-valued?  */
int  at_collective;     /* Is collective? */
int  at_no_user_mod;    /* Are changes forbidden through LDAP? */
int  at_usage;          /* Usage, see below */
LDAPSchemaExtensionItem **at_extensions; /* Extensions */
} LDAPAttributeType;

typedef struct ldap_objectclass {
char *oc_oid;           /* OID */
char **oc_names;        /* Names */
char *oc_desc;          /* Description */
int  oc_obsolete;       /* Is obsolete? */
char **oc_sup_oids;     /* OIDs of superior classes */
int  oc_kind;           /* Kind, see below */
char **oc_at_oids_must; /* OIDs of required attribute types */
char **oc_at_oids_may;  /* OIDs of optional attribute types */
LDAPSchemaExtensionItem **oc_extensions; /* Extensions */
} LDAPObjectClass;

Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:

LDAP_SCHEMA_NO
The answer to the question is no.

LDAP_SCHEMA_YES
The answer to the question is yes.

For attribute types, the following usages are possible:

LDAP_SCHEMA_USER_APPLICATIONS
the attribute type is non-operational.

LDAP_SCHEMA_DIRECTORY_OPERATION
the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute
type.

LDAP_SCHEMA_DISTRIBUTED_OPERATION
the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.

LDAP_SCHEMA_DSA_OPERATION
the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different
servers that master the entry.

Object classes can be of three kinds:

LDAP_SCHEMA_ABSTRACT
the object class is abstract, i.e. there cannot be entries of this class alone.

LDAP_SCHEMA_STRUCTURAL
the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned
cannot be changed: none of those present can be removed and none other can be added.

LDAP_SCHEMA_AUXILIARY
the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added
or removed at the same time as needed by the set of object classes resulting from the operation.

Routines ldap_xxx2name() return a canonical name for the definition.

Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that
must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.

ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The
argument code comes from one of the parsing routines and can adopt the following values:

LDAP_SCHERR_OUTOFMEM
Out of memory.

LDAP_SCHERR_UNEXPTOKEN
Unexpected token.

LDAP_SCHERR_NOLEFTPAREN
Missing opening parenthesis.

LDAP_SCHERR_NORIGHTPAREN
Missing closing parenthesis.

LDAP_SCHERR_NODIGIT
Expecting digit.

LDAP_SCHERR_BADNAME
Expecting a name.

LDAP_SCHERR_BADDESC
Bad description.

LDAP_SCHERR_BADSUP
Bad superiors.

LDAP_SCHERR_DUPOPT
Duplicate option.

LDAP_SCHERR_EMPTY
Unexpected end of data.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_SCHEMA(3)
LDAP_SCHEMA(3)                                                                  Library Functions Manual                                                                  LDAP_SCHEMA(3)

NAME
ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,
ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object‐
class_free, ldap_scherr2str - Schema definition handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;
#include &amp;lt;ldap_schema.h&amp;gt;

LDAPSyntax * ldap_str2syntax(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_syntax2str(syn)
const LDAPSyntax * syn;

const char * ldap_syntax2name(syn)
LDAPSyntax * syn;

ldap_syntax_free(syn)
LDAPSyntax * syn;

LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_matchingrule2str(mr);
const LDAPMatchingRule * mr;

const char * ldap_matchingrule2name(mr)
LDAPMatchingRule * mr;

ldap_matchingrule_free(mr)
LDAPMatchingRule * mr;

LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_attributetype2str(at)
const LDAPAttributeType * at;

const char * ldap_attributetype2name(at)
LDAPAttributeType * at;

ldap_attributetype_free(at)
LDAPAttributeType * at;

LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_objectclass2str(oc)
const LDAPObjectClass * oc;

const char * ldap_objectclass2name(oc)
LDAPObjectClass * oc;

ldap_objectclass_free(oc)
LDAPObjectClass * oc;

char * ldap_scherr2str(code)
int code;

DESCRIPTION
These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:
syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.

ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate
kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,
the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter‐
minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a
bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:

LDAP_SCHEMA_ALLOW_NONE
strict parsing according to RFC 4512.

LDAP_SCHEMA_ALLOW_NO_OID
permit definitions that do not contain an initial OID.

LDAP_SCHEMA_ALLOW_QUOTED
permit quotes around some items that should not have them.

LDAP_SCHEMA_ALLOW_DESCR
permit a descr instead of a numeric OID in places where the syntax expect the latter.

LDAP_SCHEMA_ALLOW_DESCR_PREFIX
permit that the initial numeric OID contains a prefix in descr format.

LDAP_SCHEMA_ALLOW_ALL
be very liberal, include all options.

The structures returned are as follows:

typedef struct ldap_schema_extension_item {
char *lsei_name;        /* Extension name */
char **lsei_values;     /* Extension values */
} LDAPSchemaExtensionItem;

typedef struct ldap_syntax {
char *syn_oid;          /* OID */
char **syn_names;       /* Names */
char *syn_desc;         /* Description */
LDAPSchemaExtensionItem **syn_extensions; /* Extension */
} LDAPSyntax;

typedef struct ldap_matchingrule {
char *mr_oid;           /* OID */
char **mr_names;        /* Names */
char *mr_desc;          /* Description */
int  mr_obsolete;       /* Is obsolete? */
char *mr_syntax_oid;    /* Syntax of asserted values */
LDAPSchemaExtensionItem **mr_extensions; /* Extensions */
} LDAPMatchingRule;

typedef struct ldap_attributetype {
char *at_oid;           /* OID */
char **at_names;        /* Names */
char *at_desc;          /* Description */
int  at_obsolete;       /* Is obsolete? */
char *at_sup_oid;       /* OID of superior type */
char *at_equality_oid;  /* OID of equality matching rule */
char *at_ordering_oid;  /* OID of ordering matching rule */
char *at_substr_oid;    /* OID of substrings matching rule */
char *at_syntax_oid;    /* OID of syntax of values */
int  at_syntax_len;     /* Suggested minimum maximum length */
int  at_single_value;   /* Is single-valued?  */
int  at_collective;     /* Is collective? */
int  at_no_user_mod;    /* Are changes forbidden through LDAP? */
int  at_usage;          /* Usage, see below */
LDAPSchemaExtensionItem **at_extensions; /* Extensions */
} LDAPAttributeType;

typedef struct ldap_objectclass {
char *oc_oid;           /* OID */
char **oc_names;        /* Names */
char *oc_desc;          /* Description */
int  oc_obsolete;       /* Is obsolete? */
char **oc_sup_oids;     /* OIDs of superior classes */
int  oc_kind;           /* Kind, see below */
char **oc_at_oids_must; /* OIDs of required attribute types */
char **oc_at_oids_may;  /* OIDs of optional attribute types */
LDAPSchemaExtensionItem **oc_extensions; /* Extensions */
} LDAPObjectClass;

Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:

LDAP_SCHEMA_NO
The answer to the question is no.

LDAP_SCHEMA_YES
The answer to the question is yes.

For attribute types, the following usages are possible:

LDAP_SCHEMA_USER_APPLICATIONS
the attribute type is non-operational.

LDAP_SCHEMA_DIRECTORY_OPERATION
the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute
type.

LDAP_SCHEMA_DISTRIBUTED_OPERATION
the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.

LDAP_SCHEMA_DSA_OPERATION
the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different
servers that master the entry.

Object classes can be of three kinds:

LDAP_SCHEMA_ABSTRACT
the object class is abstract, i.e. there cannot be entries of this class alone.

LDAP_SCHEMA_STRUCTURAL
the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned
cannot be changed: none of those present can be removed and none other can be added.

LDAP_SCHEMA_AUXILIARY
the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added
or removed at the same time as needed by the set of object classes resulting from the operation.

Routines ldap_xxx2name() return a canonical name for the definition.

Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that
must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.

ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The
argument code comes from one of the parsing routines and can adopt the following values:

LDAP_SCHERR_OUTOFMEM
Out of memory.

LDAP_SCHERR_UNEXPTOKEN
Unexpected token.

LDAP_SCHERR_NOLEFTPAREN
Missing opening parenthesis.

LDAP_SCHERR_NORIGHTPAREN
Missing closing parenthesis.

LDAP_SCHERR_NODIGIT
Expecting digit.

LDAP_SCHERR_BADNAME
Expecting a name.

LDAP_SCHERR_BADDESC
Bad description.

LDAP_SCHERR_BADSUP
Bad superiors.

LDAP_SCHERR_DUPOPT
Duplicate option.

LDAP_SCHERR_EMPTY
Unexpected end of data.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_SCHEMA(3)
LDAP_MEMORY(3)                                                                  Library Functions Manual                                                                  LDAP_MEMORY(3)

NAME
ldap_memfree, ldap_memvfree, ldap_memalloc, ldap_memcalloc, ldap_memrealloc, ldap_strdup - LDAP memory allocation routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

void ldap_memfree(void *p);

void ldap_memvfree(void **v);

void *ldap_memalloc(ber_len_t s);

void *ldap_memcalloc(ber_len_t n, ber_len_t s);

void *ldap_memrealloc(void *p, ber_len_t s);

char *ldap_strdup(LDAP_CONST char *p);

DESCRIPTION
These  routines  are  used  to  allocate/deallocate  memory used/returned by the LDAP library.  ldap_memalloc(), ldap_memcalloc(), ldap_memrealloc(), and ldap_memfree() are used
exactly like the standard malloc(3), calloc(3), realloc(3), and free(3) routines, respectively.  The ldap_memvfree() routine is used to free a  dynamically  allocated  array  of
pointers to arbitrary dynamically allocated objects.  The ldap_strdup() routine is used exactly like the standard strdup(3) routine.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_MEMORY(3)
LDAP_SYNC(3)                                                                    Library Functions Manual                                                                    LDAP_SYNC(3)

NAME
ldap_sync_init, ldap_sync_init_refresh_only, ldap_sync_init_refresh_and_persist, ldap_sync_poll - LDAP sync routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_sync_init(ldap_sync_t *ls, int mode);

int ldap_sync_init_refresh_only(ldap_sync_t *ls);

int ldap_sync_init_refresh_and_persist(ldap_sync_t *ls);

int ldap_sync_poll(ldap_sync_t *ls);

ldap_sync_t * ldap_sync_initialize(ldap_sync_t *ls);

void ldap_sync_destroy(ldap_sync_t *ls, int freeit);

typedef int (*ldap_sync_search_entry_f)(ldap_sync_t *ls,
LDAPMessage *msg, struct berval *entryUUID,
ldap_sync_refresh_t phase);

typedef int (*ldap_sync_search_reference_f)(ldap_sync_t *ls,
LDAPMessage *msg);

typedef int (*ldap_sync_intermediate_f)(ldap_sync_t *ls,
LDAPMessage *msg, BerVarray syncUUIDs,
ldap_sync_refresh_t phase);

typedef int (*ldap_sync_search_result_f)(ldap_sync_t *ls,
LDAPMessage *msg, int refreshDeletes);

DESCRIPTION
These  routines  provide  an interface to the LDAP Content Synchronization operation (RFC 4533).  They require an ldap_sync_t structure to be set up with parameters required for
various phases of the operation; this includes setting some handlers for special events.  All handlers take a pointer to the ldap_sync_t structure as the first argument,  and  a
pointer to the LDAPMessage structure as received from the server by the client library, plus, occasionally, other specific arguments.

The members of the ldap_sync_t structure are:

char *ls_base
The search base; by default, the BASE option in ldap.conf(5).

int ls_scope
The search scope (one of LDAP_SCOPE_BASE, LDAP_SCOPE_ONELEVEL, LDAP_SCOPE_SUBORDINATE or LDAP_SCOPE_SUBTREE; see ldap.h for details).

char *ls_filter
The filter (RFC 4515); by default, (objectClass=*).

char **ls_attrs
The requested attributes; by default NULL, indicating all user attributes.

int ls_timelimit
The requested time limit (in seconds); by default 0, to indicate no limit.

int ls_sizelimit
The requested size limit (in entries); by default 0, to indicate no limit.

int ls_timeout
The  desired  timeout  during  polling  with  ldap_sync_poll(3).   A  value  of -1 means that polling is blocking, so ldap_sync_poll(3) will not return until a message is
received; a value of 0 means that polling returns  immediately,  no  matter  if  any  response  is  available  or  not;  a  positive  value  represents  the  timeout  the
ldap_sync_poll(3) function will wait for response before returning, unless a message is received; in that case, ldap_sync_poll(3) returns as soon as the message is avail‐
able.

ldap_sync_search_entry_f ls_search_entry
A function that is called whenever an entry is returned.  The msg argument is the LDAPMessage that contains the searchResultEntry; it can  be  parsed  using  the  regular
client  API  routines, like ldap_get_dn(3), ldap_first_attribute(3), and so on.  The entryUUID argument contains the entryUUID of the entry.  The phase argument indicates
the  type  of  operation:  one  of  LDAP_SYNC_CAPI_PRESENT,  LDAP_SYNC_CAPI_ADD,  LDAP_SYNC_CAPI_MODIFY,  LDAP_SYNC_CAPI_DELETE;  in  case  of  LDAP_SYNC_CAPI_PRESENT  or
LDAP_SYNC_CAPI_DELETE, only the DN is contained in the LDAPMessage; in case of LDAP_SYNC_CAPI_MODIFY, the whole entry is contained in the LDAPMessage, and the application
is responsible of determining the differences between the new view of the entry provided by the caller and the data already known.

ldap_sync_search_reference_f ls_search_reference
A function that is called whenever a search reference is returned.  The msg argument is the LDAPMessage that contains the searchResultReference; it can  be  parsed  using
the regular client API routines, like ldap_parse_reference(3).

ldap_sync_intermediate_f ls_intermediate
A  function  that  is  called whenever something relevant occurs during the refresh phase of the search, which is marked by an intermediateResponse message type.  The msg
argument is the LDAPMessage that contains the intermediate response; it can be parsed using the regular client API routines, like ldap_parse_intermediate(3).  The  syncU‐
UIDs argument contains an array of UUIDs of the entries that depends on the value of the phase argument.  In case of LDAP_SYNC_CAPI_PRESENTS, the "present" phase is being
entered; this means that the following sequence of results will consist in entries in "present" sync state.  In case of LDAP_SYNC_CAPI_DELETES,  the  "deletes"  phase  is
being  entered;  this  means that the following sequence of results will consist in entries in "delete" sync state.  In case of LDAP_SYNC_CAPI_PRESENTS_IDSET, the message
contains a set of UUIDs of entries that are present; it replaces a "presents" phase.  In case of LDAP_SYNC_CAPI_DELETES_IDSET, the message contains  a  set  of  UUIDs  of
entries  that  have been deleted; it replaces a "deletes" phase.  In case of LDAP_SYNC_CAPI_DONE, a "presents" phase with "refreshDone" set to "TRUE" has been returned to
indicate  that  the  refresh  phase  of  refreshAndPersist  is  over,  and  the  client  should  start  polling.   Except  for   the   LDAP_SYNC_CAPI_PRESENTS_IDSET   and
LDAP_SYNC_CAPI_DELETES_IDSET cases, syncUUIDs is NULL.

ldap_sync_search_result_f ls_search_result
A  function that is called whenever a searchResultDone is returned.  In refreshAndPersist this can only occur when the server decides that the search must be interrupted.
The msg argument is the LDAPMessage that contains the response; it can be parsed using the regular client API routines,  like  ldap_parse_result(3).   The  refreshDeletes
argument is not relevant in this case; it should always be -1.

void *ls_private
A pointer to private data.  The client may register here a pointer to data the handlers above may need.

LDAP *ls_ld
A  pointer  to  a  LDAP  structure  that  is used to connect to the server.  It is the responsibility of the client to initialize the structure and to provide appropriate
authentication and security in place.

GENERAL USE
A ldap_sync_t structure is initialized by calling ldap_sync_initialize(3).  This simply clears out the contents of an already existing ldap_sync_t structure, and sets  appropri‐
ate values for some members.  After that, the caller is responsible for setting up the connection (member ls_ld), eventually setting up transport security (TLS), for binding and
any other initialization.  The caller must also fill all the documented search-related fields of the ldap_sync_t structure.

At the end of a session, the structure can be cleaned up by calling ldap_sync_destroy(3), which takes care of freeing all data assuming it was  allocated  by  ldap_mem*(3)  rou‐
tines.  Otherwise, the caller should take care of destroying and zeroing out the documented search-related fields, and call ldap_sync_destroy(3) to free undocumented members set
by the API.

REFRESH ONLY
The refreshOnly functionality is obtained by periodically calling ldap_sync_init(3) with mode set to  LDAP_SYNC_REFRESH_ONLY,  or,  which  is  equivalent,  by  directly  calling
ldap_sync_init_refresh_only(3).  The state of the search, and the consistency of the search parameters, is preserved across calls by passing the ldap_sync_t structure as left by
the previous call.

REFRESH AND PERSIST
The refreshAndPersist functionality is obtained by calling ldap_sync_init(3) with mode set to  LDAP_SYNC_REFRESH_AND_PERSIST,  or,  which  is  equivalent,  by  directly  calling
ldap_sync_init_refresh_and_persist(3) and, after a successful return, by repeatedly polling with ldap_sync_poll(3) according to the desired pattern.

A client may insert a call to ldap_sync_poll(3) into an external loop to check if any modification was returned; in this case, it might be appropriate to set ls_timeout to 0, or
to set it to a finite, small value.  Otherwise, if the client's main purpose consists in waiting for responses, a timeout of -1 is most  suitable,  so  that  the  function  only
returns after some data has been received and handled.

ERRORS
All  routines  return  any  LDAP  error  resulting from a lower-level error in the API calls they are based on, or LDAP_SUCCESS in case of success.  ldap_sync_poll(3) may return
LDAP_SYNC_REFRESH_REQUIRED if a full refresh is requested by the server.  In this case, it is appropriate to call ldap_sync_init(3) again, passing the same ldap_sync_t structure
as resulted from any previous call.

NOTES
SEE ALSO
ldap(3), ldap_search_ext(3), ldap_result(3); RFC 4533 (http://www.rfc-editor.org),

AUTHOR
Designed and implemented by Pierangelo Masarati, based on RFC 4533 and loosely inspired by syncrepl code in slapd(8).

ACKNOWLEDGEMENTS
Initially  developed  by SysNet s.n.c.  OpenLDAP is developed and maintained by The OpenLDAP Project (http://www.openldap.org/).  OpenLDAP is derived from University of Michigan
LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                           LDAP_SYNC(3)
LDAP_SCHEMA(3)                                                                  Library Functions Manual                                                                  LDAP_SCHEMA(3)

NAME
ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,
ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object‐
class_free, ldap_scherr2str - Schema definition handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;
#include &amp;lt;ldap_schema.h&amp;gt;

LDAPSyntax * ldap_str2syntax(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_syntax2str(syn)
const LDAPSyntax * syn;

const char * ldap_syntax2name(syn)
LDAPSyntax * syn;

ldap_syntax_free(syn)
LDAPSyntax * syn;

LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_matchingrule2str(mr);
const LDAPMatchingRule * mr;

const char * ldap_matchingrule2name(mr)
LDAPMatchingRule * mr;

ldap_matchingrule_free(mr)
LDAPMatchingRule * mr;

LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_attributetype2str(at)
const LDAPAttributeType * at;

const char * ldap_attributetype2name(at)
LDAPAttributeType * at;

ldap_attributetype_free(at)
LDAPAttributeType * at;

LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_objectclass2str(oc)
const LDAPObjectClass * oc;

const char * ldap_objectclass2name(oc)
LDAPObjectClass * oc;

ldap_objectclass_free(oc)
LDAPObjectClass * oc;

char * ldap_scherr2str(code)
int code;

DESCRIPTION
These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:
syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.

ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate
kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,
the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter‐
minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a
bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:

LDAP_SCHEMA_ALLOW_NONE
strict parsing according to RFC 4512.

LDAP_SCHEMA_ALLOW_NO_OID
permit definitions that do not contain an initial OID.

LDAP_SCHEMA_ALLOW_QUOTED
permit quotes around some items that should not have them.

LDAP_SCHEMA_ALLOW_DESCR
permit a descr instead of a numeric OID in places where the syntax expect the latter.

LDAP_SCHEMA_ALLOW_DESCR_PREFIX
permit that the initial numeric OID contains a prefix in descr format.

LDAP_SCHEMA_ALLOW_ALL
be very liberal, include all options.

The structures returned are as follows:

typedef struct ldap_schema_extension_item {
char *lsei_name;        /* Extension name */
char **lsei_values;     /* Extension values */
} LDAPSchemaExtensionItem;

typedef struct ldap_syntax {
char *syn_oid;          /* OID */
char **syn_names;       /* Names */
char *syn_desc;         /* Description */
LDAPSchemaExtensionItem **syn_extensions; /* Extension */
} LDAPSyntax;

typedef struct ldap_matchingrule {
char *mr_oid;           /* OID */
char **mr_names;        /* Names */
char *mr_desc;          /* Description */
int  mr_obsolete;       /* Is obsolete? */
char *mr_syntax_oid;    /* Syntax of asserted values */
LDAPSchemaExtensionItem **mr_extensions; /* Extensions */
} LDAPMatchingRule;

typedef struct ldap_attributetype {
char *at_oid;           /* OID */
char **at_names;        /* Names */
char *at_desc;          /* Description */
int  at_obsolete;       /* Is obsolete? */
char *at_sup_oid;       /* OID of superior type */
char *at_equality_oid;  /* OID of equality matching rule */
char *at_ordering_oid;  /* OID of ordering matching rule */
char *at_substr_oid;    /* OID of substrings matching rule */
char *at_syntax_oid;    /* OID of syntax of values */
int  at_syntax_len;     /* Suggested minimum maximum length */
int  at_single_value;   /* Is single-valued?  */
int  at_collective;     /* Is collective? */
int  at_no_user_mod;    /* Are changes forbidden through LDAP? */
int  at_usage;          /* Usage, see below */
LDAPSchemaExtensionItem **at_extensions; /* Extensions */
} LDAPAttributeType;

typedef struct ldap_objectclass {
char *oc_oid;           /* OID */
char **oc_names;        /* Names */
char *oc_desc;          /* Description */
int  oc_obsolete;       /* Is obsolete? */
char **oc_sup_oids;     /* OIDs of superior classes */
int  oc_kind;           /* Kind, see below */
char **oc_at_oids_must; /* OIDs of required attribute types */
char **oc_at_oids_may;  /* OIDs of optional attribute types */
LDAPSchemaExtensionItem **oc_extensions; /* Extensions */
} LDAPObjectClass;

Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:

LDAP_SCHEMA_NO
The answer to the question is no.

LDAP_SCHEMA_YES
The answer to the question is yes.

For attribute types, the following usages are possible:

LDAP_SCHEMA_USER_APPLICATIONS
the attribute type is non-operational.

LDAP_SCHEMA_DIRECTORY_OPERATION
the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute
type.

LDAP_SCHEMA_DISTRIBUTED_OPERATION
the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.

LDAP_SCHEMA_DSA_OPERATION
the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different
servers that master the entry.

Object classes can be of three kinds:

LDAP_SCHEMA_ABSTRACT
the object class is abstract, i.e. there cannot be entries of this class alone.

LDAP_SCHEMA_STRUCTURAL
the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned
cannot be changed: none of those present can be removed and none other can be added.

LDAP_SCHEMA_AUXILIARY
the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added
or removed at the same time as needed by the set of object classes resulting from the operation.

Routines ldap_xxx2name() return a canonical name for the definition.

Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that
must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.

ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The
argument code comes from one of the parsing routines and can adopt the following values:

LDAP_SCHERR_OUTOFMEM
Out of memory.

LDAP_SCHERR_UNEXPTOKEN
Unexpected token.

LDAP_SCHERR_NOLEFTPAREN
Missing opening parenthesis.

LDAP_SCHERR_NORIGHTPAREN
Missing closing parenthesis.

LDAP_SCHERR_NODIGIT
Expecting digit.

LDAP_SCHERR_BADNAME
Expecting a name.

LDAP_SCHERR_BADDESC
Bad description.

LDAP_SCHERR_BADSUP
Bad superiors.

LDAP_SCHERR_DUPOPT
Duplicate option.

LDAP_SCHERR_EMPTY
Unexpected end of data.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_SCHEMA(3)
LDAP_SCHEMA(3)                                                                  Library Functions Manual                                                                  LDAP_SCHEMA(3)

NAME
ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,
ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object‐
class_free, ldap_scherr2str - Schema definition handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;
#include &amp;lt;ldap_schema.h&amp;gt;

LDAPSyntax * ldap_str2syntax(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_syntax2str(syn)
const LDAPSyntax * syn;

const char * ldap_syntax2name(syn)
LDAPSyntax * syn;

ldap_syntax_free(syn)
LDAPSyntax * syn;

LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_matchingrule2str(mr);
const LDAPMatchingRule * mr;

const char * ldap_matchingrule2name(mr)
LDAPMatchingRule * mr;

ldap_matchingrule_free(mr)
LDAPMatchingRule * mr;

LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_attributetype2str(at)
const LDAPAttributeType * at;

const char * ldap_attributetype2name(at)
LDAPAttributeType * at;

ldap_attributetype_free(at)
LDAPAttributeType * at;

LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_objectclass2str(oc)
const LDAPObjectClass * oc;

const char * ldap_objectclass2name(oc)
LDAPObjectClass * oc;

ldap_objectclass_free(oc)
LDAPObjectClass * oc;

char * ldap_scherr2str(code)
int code;

DESCRIPTION
These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:
syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.

ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate
kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,
the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter‐
minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a
bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:

LDAP_SCHEMA_ALLOW_NONE
strict parsing according to RFC 4512.

LDAP_SCHEMA_ALLOW_NO_OID
permit definitions that do not contain an initial OID.

LDAP_SCHEMA_ALLOW_QUOTED
permit quotes around some items that should not have them.

LDAP_SCHEMA_ALLOW_DESCR
permit a descr instead of a numeric OID in places where the syntax expect the latter.

LDAP_SCHEMA_ALLOW_DESCR_PREFIX
permit that the initial numeric OID contains a prefix in descr format.

LDAP_SCHEMA_ALLOW_ALL
be very liberal, include all options.

The structures returned are as follows:

typedef struct ldap_schema_extension_item {
char *lsei_name;        /* Extension name */
char **lsei_values;     /* Extension values */
} LDAPSchemaExtensionItem;

typedef struct ldap_syntax {
char *syn_oid;          /* OID */
char **syn_names;       /* Names */
char *syn_desc;         /* Description */
LDAPSchemaExtensionItem **syn_extensions; /* Extension */
} LDAPSyntax;

typedef struct ldap_matchingrule {
char *mr_oid;           /* OID */
char **mr_names;        /* Names */
char *mr_desc;          /* Description */
int  mr_obsolete;       /* Is obsolete? */
char *mr_syntax_oid;    /* Syntax of asserted values */
LDAPSchemaExtensionItem **mr_extensions; /* Extensions */
} LDAPMatchingRule;

typedef struct ldap_attributetype {
char *at_oid;           /* OID */
char **at_names;        /* Names */
char *at_desc;          /* Description */
int  at_obsolete;       /* Is obsolete? */
char *at_sup_oid;       /* OID of superior type */
char *at_equality_oid;  /* OID of equality matching rule */
char *at_ordering_oid;  /* OID of ordering matching rule */
char *at_substr_oid;    /* OID of substrings matching rule */
char *at_syntax_oid;    /* OID of syntax of values */
int  at_syntax_len;     /* Suggested minimum maximum length */
int  at_single_value;   /* Is single-valued?  */
int  at_collective;     /* Is collective? */
int  at_no_user_mod;    /* Are changes forbidden through LDAP? */
int  at_usage;          /* Usage, see below */
LDAPSchemaExtensionItem **at_extensions; /* Extensions */
} LDAPAttributeType;

typedef struct ldap_objectclass {
char *oc_oid;           /* OID */
char **oc_names;        /* Names */
char *oc_desc;          /* Description */
int  oc_obsolete;       /* Is obsolete? */
char **oc_sup_oids;     /* OIDs of superior classes */
int  oc_kind;           /* Kind, see below */
char **oc_at_oids_must; /* OIDs of required attribute types */
char **oc_at_oids_may;  /* OIDs of optional attribute types */
LDAPSchemaExtensionItem **oc_extensions; /* Extensions */
} LDAPObjectClass;

Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:

LDAP_SCHEMA_NO
The answer to the question is no.

LDAP_SCHEMA_YES
The answer to the question is yes.

For attribute types, the following usages are possible:

LDAP_SCHEMA_USER_APPLICATIONS
the attribute type is non-operational.

LDAP_SCHEMA_DIRECTORY_OPERATION
the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute
type.

LDAP_SCHEMA_DISTRIBUTED_OPERATION
the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.

LDAP_SCHEMA_DSA_OPERATION
the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different
servers that master the entry.

Object classes can be of three kinds:

LDAP_SCHEMA_ABSTRACT
the object class is abstract, i.e. there cannot be entries of this class alone.

LDAP_SCHEMA_STRUCTURAL
the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned
cannot be changed: none of those present can be removed and none other can be added.

LDAP_SCHEMA_AUXILIARY
the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added
or removed at the same time as needed by the set of object classes resulting from the operation.

Routines ldap_xxx2name() return a canonical name for the definition.

Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that
must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.

ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The
argument code comes from one of the parsing routines and can adopt the following values:

LDAP_SCHERR_OUTOFMEM
Out of memory.

LDAP_SCHERR_UNEXPTOKEN
Unexpected token.

LDAP_SCHERR_NOLEFTPAREN
Missing opening parenthesis.

LDAP_SCHERR_NORIGHTPAREN
Missing closing parenthesis.

LDAP_SCHERR_NODIGIT
Expecting digit.

LDAP_SCHERR_BADNAME
Expecting a name.

LDAP_SCHERR_BADDESC
Bad description.

LDAP_SCHERR_BADSUP
Bad superiors.

LDAP_SCHERR_DUPOPT
Duplicate option.

LDAP_SCHERR_EMPTY
Unexpected end of data.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_SCHEMA(3)
LDAP_SCHEMA(3)                                                                  Library Functions Manual                                                                  LDAP_SCHEMA(3)

NAME
ldap_str2syntax,   ldap_syntax2str,   ldap_syntax2name,   ldap_syntax_free,   ldap_str2matchingrule,   ldap_matchingrule2str,   ldap_matchingrule2name,   ldap_matchingrule_free,
ldap_str2attributetype, ldap_attributetype2str, ldap_attributetype2name, ldap_attributetype_free, ldap_str2objectclass, ldap_objectclass2str, ldap_objectclass2name, ldap_object‐
class_free, ldap_scherr2str - Schema definition handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;
#include &amp;lt;ldap_schema.h&amp;gt;

LDAPSyntax * ldap_str2syntax(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_syntax2str(syn)
const LDAPSyntax * syn;

const char * ldap_syntax2name(syn)
LDAPSyntax * syn;

ldap_syntax_free(syn)
LDAPSyntax * syn;

LDAPMatchingRule * ldap_str2matchingrule(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_matchingrule2str(mr);
const LDAPMatchingRule * mr;

const char * ldap_matchingrule2name(mr)
LDAPMatchingRule * mr;

ldap_matchingrule_free(mr)
LDAPMatchingRule * mr;

LDAPAttributeType * ldap_str2attributetype(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_attributetype2str(at)
const LDAPAttributeType * at;

const char * ldap_attributetype2name(at)
LDAPAttributeType * at;

ldap_attributetype_free(at)
LDAPAttributeType * at;

LDAPObjectClass * ldap_str2objectclass(s, code, errp, flags)
const char * s;
int * code;
const char ** errp;
const int flags;

char * ldap_objectclass2str(oc)
const LDAPObjectClass * oc;

const char * ldap_objectclass2name(oc)
LDAPObjectClass * oc;

ldap_objectclass_free(oc)
LDAPObjectClass * oc;

char * ldap_scherr2str(code)
int code;

DESCRIPTION
These  routines  are  used to parse schema definitions in the syntax defined in RFC 4512 into structs and handle these structs.  These routines handle four kinds of definitions:
syntaxes, matching rules, attribute types and object classes.  For each definition kind, four routines are provided.

ldap_str2xxx() takes a definition in RFC 4512 format in argument s as a NUL-terminated string and returns, if possible, a pointer to a newly allocated struct of the  appropriate
kind.  The caller is responsible for freeing the struct by calling ldap_xxx_free() when not needed any longer.  The routine returns NULL if some problem happened.  In this case,
the integer pointed at by argument code will receive an error code (see below the description of ldap_scherr2str() for an explanation of the values) and a pointer to a  NUL-ter‐
minated  string  will be placed where requested by argument errp , indicating where in argument s the error happened, so it must not be freed by the caller.  Argument flags is a
bit mask of parsing options controlling the relaxation of the syntax recognized.  The following values are defined:

LDAP_SCHEMA_ALLOW_NONE
strict parsing according to RFC 4512.

LDAP_SCHEMA_ALLOW_NO_OID
permit definitions that do not contain an initial OID.

LDAP_SCHEMA_ALLOW_QUOTED
permit quotes around some items that should not have them.

LDAP_SCHEMA_ALLOW_DESCR
permit a descr instead of a numeric OID in places where the syntax expect the latter.

LDAP_SCHEMA_ALLOW_DESCR_PREFIX
permit that the initial numeric OID contains a prefix in descr format.

LDAP_SCHEMA_ALLOW_ALL
be very liberal, include all options.

The structures returned are as follows:

typedef struct ldap_schema_extension_item {
char *lsei_name;        /* Extension name */
char **lsei_values;     /* Extension values */
} LDAPSchemaExtensionItem;

typedef struct ldap_syntax {
char *syn_oid;          /* OID */
char **syn_names;       /* Names */
char *syn_desc;         /* Description */
LDAPSchemaExtensionItem **syn_extensions; /* Extension */
} LDAPSyntax;

typedef struct ldap_matchingrule {
char *mr_oid;           /* OID */
char **mr_names;        /* Names */
char *mr_desc;          /* Description */
int  mr_obsolete;       /* Is obsolete? */
char *mr_syntax_oid;    /* Syntax of asserted values */
LDAPSchemaExtensionItem **mr_extensions; /* Extensions */
} LDAPMatchingRule;

typedef struct ldap_attributetype {
char *at_oid;           /* OID */
char **at_names;        /* Names */
char *at_desc;          /* Description */
int  at_obsolete;       /* Is obsolete? */
char *at_sup_oid;       /* OID of superior type */
char *at_equality_oid;  /* OID of equality matching rule */
char *at_ordering_oid;  /* OID of ordering matching rule */
char *at_substr_oid;    /* OID of substrings matching rule */
char *at_syntax_oid;    /* OID of syntax of values */
int  at_syntax_len;     /* Suggested minimum maximum length */
int  at_single_value;   /* Is single-valued?  */
int  at_collective;     /* Is collective? */
int  at_no_user_mod;    /* Are changes forbidden through LDAP? */
int  at_usage;          /* Usage, see below */
LDAPSchemaExtensionItem **at_extensions; /* Extensions */
} LDAPAttributeType;

typedef struct ldap_objectclass {
char *oc_oid;           /* OID */
char **oc_names;        /* Names */
char *oc_desc;          /* Description */
int  oc_obsolete;       /* Is obsolete? */
char **oc_sup_oids;     /* OIDs of superior classes */
int  oc_kind;           /* Kind, see below */
char **oc_at_oids_must; /* OIDs of required attribute types */
char **oc_at_oids_may;  /* OIDs of optional attribute types */
LDAPSchemaExtensionItem **oc_extensions; /* Extensions */
} LDAPObjectClass;

Some integer fields (those described with a question mark) have a truth value, for these fields the possible values are:

LDAP_SCHEMA_NO
The answer to the question is no.

LDAP_SCHEMA_YES
The answer to the question is yes.

For attribute types, the following usages are possible:

LDAP_SCHEMA_USER_APPLICATIONS
the attribute type is non-operational.

LDAP_SCHEMA_DIRECTORY_OPERATION
the attribute type is operational and is pertinent to the directory itself, i.e. it has the same value on all servers that master  the  entry  containing  this  attribute
type.

LDAP_SCHEMA_DISTRIBUTED_OPERATION
the attribute type is operational and is pertinent to replication, shadowing or other distributed directory aspect.  TBC.

LDAP_SCHEMA_DSA_OPERATION
the  attribute  type  is  operational  and is pertinent to the directory server itself, i.e. it may have different values for the same entry when retrieved from different
servers that master the entry.

Object classes can be of three kinds:

LDAP_SCHEMA_ABSTRACT
the object class is abstract, i.e. there cannot be entries of this class alone.

LDAP_SCHEMA_STRUCTURAL
the object class is structural, i.e. it describes the main role of the entry.  On some servers, once the entry is created the set of structural  object  classes  assigned
cannot be changed: none of those present can be removed and none other can be added.

LDAP_SCHEMA_AUXILIARY
the  object  class is auxiliary, i.e. it is intended to go with other, structural, object classes.  These can be added or removed at any time if attribute types are added
or removed at the same time as needed by the set of object classes resulting from the operation.

Routines ldap_xxx2name() return a canonical name for the definition.

Routines ldap_xxx2str() return a string representation in the format described by RFC 4512 of the struct passed in the argument.  The string is a  newly  allocated  string  that
must be freed by the caller.  These routines may return NULL if no memory can be allocated for the string.

ldap_scherr2str()  returns  a  NUL-terminated string with a text description of the error found.  This is a pointer to a static area, so it must not be freed by the caller.  The
argument code comes from one of the parsing routines and can adopt the following values:

LDAP_SCHERR_OUTOFMEM
Out of memory.

LDAP_SCHERR_UNEXPTOKEN
Unexpected token.

LDAP_SCHERR_NOLEFTPAREN
Missing opening parenthesis.

LDAP_SCHERR_NORIGHTPAREN
Missing closing parenthesis.

LDAP_SCHERR_NODIGIT
Expecting digit.

LDAP_SCHERR_BADNAME
Expecting a name.

LDAP_SCHERR_BADDESC
Bad description.

LDAP_SCHERR_BADSUP
Bad superiors.

LDAP_SCHERR_DUPOPT
Duplicate option.

LDAP_SCHERR_EMPTY
Unexpected end of data.

SEE ALSO
ldap(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                         LDAP_SCHEMA(3)
LDAP_TLS(3)                                                                     Library Functions Manual                                                                     LDAP_TLS(3)

NAME
ldap_start_tls, ldap_start_tls_s, ldap_tls_inplace, ldap_install_tls - LDAP TLS initialization routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_start_tls(LDAP *ld);

int ldap_start_tls_s(LDAP *ld, LDAPControl **serverctrls, LDAPControl **clientctrls);

int ldap_tls_inplace(LDAP *ld);

int ldap_install_tls(LDAP *ld);

DESCRIPTION
These  routines are used to initiate TLS processing on an LDAP session.  ldap_start_tls_s() sends a StartTLS request to a server, waits for the reply, and then installs TLS han‐
dlers on the session if the request succeeded. The routine returns LDAP_SUCCESS if everything succeeded, otherwise it returns an  LDAP  error  code.   ldap_start_tls()  sends  a
StartTLS  request  to  a  server  and  does  nothing  else. It returns LDAP_SUCCESS if the request was sent successfully.  ldap_tls_inplace() returns 1 if TLS handlers have been
installed on the specified session, 0 otherwise.  ldap_install_tls() installs the TLS handlers on the given session. It returns LDAP_LOCAL_ERROR if TLS is already installed.

SEE ALSO
ldap(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                            LDAP_TLS(3)
LDAP_TLS(3)                                                                     Library Functions Manual                                                                     LDAP_TLS(3)

NAME
ldap_start_tls, ldap_start_tls_s, ldap_tls_inplace, ldap_install_tls - LDAP TLS initialization routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_start_tls(LDAP *ld);

int ldap_start_tls_s(LDAP *ld, LDAPControl **serverctrls, LDAPControl **clientctrls);

int ldap_tls_inplace(LDAP *ld);

int ldap_install_tls(LDAP *ld);

DESCRIPTION
These  routines are used to initiate TLS processing on an LDAP session.  ldap_start_tls_s() sends a StartTLS request to a server, waits for the reply, and then installs TLS han‐
dlers on the session if the request succeeded. The routine returns LDAP_SUCCESS if everything succeeded, otherwise it returns an  LDAP  error  code.   ldap_start_tls()  sends  a
StartTLS  request  to  a  server  and  does  nothing  else. It returns LDAP_SUCCESS if the request was sent successfully.  ldap_tls_inplace() returns 1 if TLS handlers have been
installed on the specified session, 0 otherwise.  ldap_install_tls() installs the TLS handlers on the given session. It returns LDAP_LOCAL_ERROR if TLS is already installed.

SEE ALSO
ldap(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                            LDAP_TLS(3)
LDAP_BIND(3)                                                                    Library Functions Manual                                                                    LDAP_BIND(3)

NAME
ldap_bind,   ldap_bind_s,   ldap_simple_bind,  ldap_simple_bind_s,  ldap_sasl_bind,  ldap_sasl_bind_s,  ldap_sasl_interactive_bind_s,  ldap_parse_sasl_bind_result,  ldap_unbind,
ldap_unbind_s, ldap_unbind_ext, ldap_unbind_ext_s, ldap_set_rebind_proc - LDAP bind routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_bind(LDAP *ld, const char *who, const char *cred,
int method);

int ldap_bind_s(LDAP *ld, const char *who, const char *cred,
int method);

int ldap_simple_bind(LDAP *ld, const char *who, const char *passwd);

int ldap_simple_bind_s(LDAP *ld, const char *who, const char *passwd);

int ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,
struct berval *cred, LDAPControl *sctrls[],
LDAPControl *cctrls[], int *msgidp);

int ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,
struct berval *cred, LDAPControl *sctrls[],
LDAPControl *cctrls[], struct berval **servercredp);

int ldap_parse_sasl_bind_result(LDAP *ld, LDAPMessage *res,
struct berval **servercredp, int freeit);

int ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn,
const char *mechs,
LDAPControl *sctrls[], LDAPControl *cctrls[],
unsigned flags, LDAP_SASL_INTERACT_PROC *interact,
void *defaults);

int ldap_sasl_interactive_bind(LDAP *ld, const char *dn,
const char *mechs,
LDAPControl *sctrls[], LDAPControl *cctrls[],
unsigned flags, LDAP_SASL_INTERACT_PROC *interact,
void *defaults, LDAPMessage *result,
const char **rmechp, int *msgidp);

int (LDAP_SASL_INTERACT_PROC)(LDAP *ld, unsigned flags, void *defaults, void *sasl_interact);

int ldap_unbind(LDAP *ld);

int ldap_unbind_s(LDAP *ld);

int ldap_unbind_ext(LDAP *ld, LDAPControl *sctrls[],
LDAPControl *cctrls[]);

int ldap_unbind_ext_s(LDAP *ld, LDAPControl *sctrls[],
LDAPControl *cctrls[]);

int ldap_set_rebind_proc (LDAP *ld, LDAP_REBIND_PROC *ldap_proc, void *params);

int (LDAP_REBIND_PROC)(LDAP *ld, LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *params);

DESCRIPTION
These routines provide various interfaces to the LDAP bind operation.  After an association with an LDAP server is made using ldap_init(3), an LDAP bind operation should be per‐
formed  before  other operations are attempted over the connection.  An LDAP bind is required when using Version 2 of the LDAP protocol; it is optional for Version 3 but is usu‐
ally needed due to security considerations.

There are three types of bind calls, ones providing simple authentication, ones providing SASL authentication, and general routines  capable  of  doing  either  simple  or  SASL
authentication.

SASL  (Simple  Authentication and Security Layer) can negotiate one of many different kinds of authentication.  Both synchronous and asynchronous versions of each variant of the
bind call are provided.  All routines take ld as their first parameter, as returned from ldap_init(3).

SIMPLE AUTHENTICATION
The simplest form of the bind call is ldap_simple_bind_s().  It takes the DN to bind as in who, and the userPassword associated with the entry in passwd.   It  returns  an  LDAP
error  indication  (see ldap_error(3)).  The ldap_simple_bind() call is asynchronous, taking the same parameters but only initiating the bind operation and returning the message
id of the request it sent.  The result of the operation can be obtained by a subsequent call to ldap_result(3).

GENERAL AUTHENTICATION
The ldap_bind() and ldap_bind_s() routines can be used when the authentication method to use needs to be selected at runtime.  They both take an extra method parameter selecting
the  authentication  method  to  use.   It  should  be  set to LDAP_AUTH_SIMPLE to select simple authentication.  ldap_bind() returns the message id of the request it initiates.
ldap_bind_s() returns an LDAP error indication.

SASL AUTHENTICATION
For SASL binds the server always ignores any provided DN, so the dn parameter should always be NULL.  ldap_sasl_bind_s() sends a single SASL bind request  with  the  given  SASL
mechanism and credentials in the cred parameter. The format of the credentials depends on the particular SASL mechanism in use. For mechanisms that provide mutual authentication
the server's credentials will be returned in the servercredp parameter.  The routine returns an LDAP error indication (see ldap_error(3)).  The ldap_sasl_bind()  call  is  asyn‐
chronous,  taking  the  same parameters but only sending the request and returning the message id of the request it sent. The result of the operation can be obtained by a subse‐
quent call to ldap_result(3).  The result must be additionally parsed by ldap_parse_sasl_bind_result() to obtain any server credentials sent from the server.

Many SASL mechanisms require multiple message exchanges to perform a complete authentication. Applications should generally use ldap_sasl_interactive_bind_s() rather than  call‐
ing  the  basic ldap_sasl_bind() functions directly. The mechs parameter should contain a space-separated list of candidate mechanisms to use. If this parameter is NULL or empty
the library will query the supportedSASLMechanisms attribute from the server's rootDSE for the list of SASL mechanisms the server supports.  The  flags  parameter  controls  the
interaction used to retrieve any necessary SASL authentication parameters and should be one of:

LDAP_SASL_AUTOMATIC
use defaults if available, prompt otherwise

LDAP_SASL_INTERACTIVE
always prompt

LDAP_SASL_QUIET
never prompt

The  interact  function uses the provided defaults to handle requests from the SASL library for particular authentication parameters. There is no defined format for the defaults
information; it is up to the caller to use whatever format is appropriate for the supplied interact function.   The  sasl_interact  parameter  comes  from  the  underlying  SASL
library. When used with Cyrus SASL this is an array of sasl_interact_t structures. The Cyrus SASL library will prompt for a variety of inputs, including:

SASL_CB_GETREALM
the realm for the authentication attempt

SASL_CB_AUTHNAME
the username to authenticate

SASL_CB_PASS
the password for the provided username

SASL_CB_USER
the username to use for proxy authorization

SASL_CB_NOECHOPROMPT
generic prompt for input with input echoing disabled

SASL_CB_ECHOPROMPT
generic prompt for input with input echoing enabled

SASL_CB_LIST_END
indicates the end of the array of prompts

See the Cyrus SASL documentation for more details.

Applications  which need to manage connections asynchronously may use ldap_sasl_interactive_bind() instead of the synchronous version.  A valid mechs parameter must be supplied,
otherwise the library will be forced to query the server for a list of supported mechanisms, and this query will be performed synchronously.  The other parameters are  the  same
as  for  the  synchronous function, with three additional parameters.  The actual SASL mechanism that was used, and the message ID for use with ldap_result() will be returned in
rmechp and msgidp, respectively.  The value in rmechp must not be modified by the caller and must be passed back on each subsequent call. The message obtained from ldap_result()
must  be  passed  in the result parameter.  This parameter must be NULL when initiating a new Bind. The caller must free the result message after each call using ldap_msgfree().
The ldap_sasl_interactive_bind() function returns an LDAP result code. If the code is LDAP_SASL_BIND_IN_PROGRESS then the Bind is not complete yet, and  this  function  must  be
called again with the next result from the server.

REBINDING
The  ldap_set_rebind_proc function() sets the process to use for binding when an operation returns a referral. This function is used when an application needs to bind to another
server in order to follow a referral or search continuation reference.

The function takes ld, the rebind function, and the params, the arbitrary data like state information which the client might need to  properly  rebind.   The  LDAP_OPT_REFERRALS
option in the ld must be set to ON for the libraries to use the rebind function. Use the ldap_set_option function to set the value.

The rebind function parameters are as follows:

The ld parameter must be used by the application when binding to the referred server if the application wants the libraries to follow the referral.

The url parameter points to the URL referral string received from the LDAP server.  The LDAP application can use the ldap_url_parse(3) function to parse the string into its com‐
ponents.

The request parameter specifies the type of request that generated the referral.

The msgid parameter specifies the message ID of the request generating the referral.

The params parameter is the same value as passed originally to the ldap_set_rebind_proc() function.

The LDAP libraries set all the parameters when they call the rebind function. The application should not attempt to free either the ld or the url structures in the rebind  func‐
tion.

The  application  must  supply to the rebind function the required authentication information such as, user name, password, and certificates. The rebind function must use a syn‐
chronous bind method.

UNBINDING
The ldap_unbind() call is used to unbind from the directory, terminate the current association, and free the resources contained in the ld structure.  Once  it  is  called,  the
connection  to  the LDAP server is closed, and the ld structure is invalid.  The ldap_unbind_s() call is just another name for ldap_unbind(); both of these calls are synchronous
in nature.

The ldap_unbind_ext() and ldap_unbind_ext_s() allows the operations to specify  controls.

ERRORS
Asynchronous routines will return -1 in case of error, setting the ld_errno parameter of the ld structure.  Synchronous  routines  return  whatever  ld_errno  is  set  to.   See
ldap_error(3) for more information.

NOTES
If  an anonymous bind is sufficient for the application, the rebind process need not be provided. The LDAP libraries with the LDAP_OPT_REFERRALS option set to ON (default value)
will automatically follow referrals using an anonymous bind.

If the application needs stronger authentication than an anonymous bind, you need to provide a rebind process for that authentication method.  The bind method must  be  synchro‐
nous.

SEE ALSO
ldap(3), ldap_error(3), ldap_open(3), ldap_set_option(3), ldap_url_parse(3) RFC 4422 (http://www.rfc-editor.org), Cyrus SASL (http://asg.web.cmu.edu/sasl/)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                           LDAP_BIND(3)
LDAP_BIND(3)                                                                    Library Functions Manual                                                                    LDAP_BIND(3)

NAME
ldap_bind,   ldap_bind_s,   ldap_simple_bind,  ldap_simple_bind_s,  ldap_sasl_bind,  ldap_sasl_bind_s,  ldap_sasl_interactive_bind_s,  ldap_parse_sasl_bind_result,  ldap_unbind,
ldap_unbind_s, ldap_unbind_ext, ldap_unbind_ext_s, ldap_set_rebind_proc - LDAP bind routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_bind(LDAP *ld, const char *who, const char *cred,
int method);

int ldap_bind_s(LDAP *ld, const char *who, const char *cred,
int method);

int ldap_simple_bind(LDAP *ld, const char *who, const char *passwd);

int ldap_simple_bind_s(LDAP *ld, const char *who, const char *passwd);

int ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,
struct berval *cred, LDAPControl *sctrls[],
LDAPControl *cctrls[], int *msgidp);

int ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,
struct berval *cred, LDAPControl *sctrls[],
LDAPControl *cctrls[], struct berval **servercredp);

int ldap_parse_sasl_bind_result(LDAP *ld, LDAPMessage *res,
struct berval **servercredp, int freeit);

int ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn,
const char *mechs,
LDAPControl *sctrls[], LDAPControl *cctrls[],
unsigned flags, LDAP_SASL_INTERACT_PROC *interact,
void *defaults);

int ldap_sasl_interactive_bind(LDAP *ld, const char *dn,
const char *mechs,
LDAPControl *sctrls[], LDAPControl *cctrls[],
unsigned flags, LDAP_SASL_INTERACT_PROC *interact,
void *defaults, LDAPMessage *result,
const char **rmechp, int *msgidp);

int (LDAP_SASL_INTERACT_PROC)(LDAP *ld, unsigned flags, void *defaults, void *sasl_interact);

int ldap_unbind(LDAP *ld);

int ldap_unbind_s(LDAP *ld);

int ldap_unbind_ext(LDAP *ld, LDAPControl *sctrls[],
LDAPControl *cctrls[]);

int ldap_unbind_ext_s(LDAP *ld, LDAPControl *sctrls[],
LDAPControl *cctrls[]);

int ldap_set_rebind_proc (LDAP *ld, LDAP_REBIND_PROC *ldap_proc, void *params);

int (LDAP_REBIND_PROC)(LDAP *ld, LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *params);

DESCRIPTION
These routines provide various interfaces to the LDAP bind operation.  After an association with an LDAP server is made using ldap_init(3), an LDAP bind operation should be per‐
formed  before  other operations are attempted over the connection.  An LDAP bind is required when using Version 2 of the LDAP protocol; it is optional for Version 3 but is usu‐
ally needed due to security considerations.

There are three types of bind calls, ones providing simple authentication, ones providing SASL authentication, and general routines  capable  of  doing  either  simple  or  SASL
authentication.

SASL  (Simple  Authentication and Security Layer) can negotiate one of many different kinds of authentication.  Both synchronous and asynchronous versions of each variant of the
bind call are provided.  All routines take ld as their first parameter, as returned from ldap_init(3).

SIMPLE AUTHENTICATION
The simplest form of the bind call is ldap_simple_bind_s().  It takes the DN to bind as in who, and the userPassword associated with the entry in passwd.   It  returns  an  LDAP
error  indication  (see ldap_error(3)).  The ldap_simple_bind() call is asynchronous, taking the same parameters but only initiating the bind operation and returning the message
id of the request it sent.  The result of the operation can be obtained by a subsequent call to ldap_result(3).

GENERAL AUTHENTICATION
The ldap_bind() and ldap_bind_s() routines can be used when the authentication method to use needs to be selected at runtime.  They both take an extra method parameter selecting
the  authentication  method  to  use.   It  should  be  set to LDAP_AUTH_SIMPLE to select simple authentication.  ldap_bind() returns the message id of the request it initiates.
ldap_bind_s() returns an LDAP error indication.

SASL AUTHENTICATION
For SASL binds the server always ignores any provided DN, so the dn parameter should always be NULL.  ldap_sasl_bind_s() sends a single SASL bind request  with  the  given  SASL
mechanism and credentials in the cred parameter. The format of the credentials depends on the particular SASL mechanism in use. For mechanisms that provide mutual authentication
the server's credentials will be returned in the servercredp parameter.  The routine returns an LDAP error indication (see ldap_error(3)).  The ldap_sasl_bind()  call  is  asyn‐
chronous,  taking  the  same parameters but only sending the request and returning the message id of the request it sent. The result of the operation can be obtained by a subse‐
quent call to ldap_result(3).  The result must be additionally parsed by ldap_parse_sasl_bind_result() to obtain any server credentials sent from the server.

Many SASL mechanisms require multiple message exchanges to perform a complete authentication. Applications should generally use ldap_sasl_interactive_bind_s() rather than  call‐
ing  the  basic ldap_sasl_bind() functions directly. The mechs parameter should contain a space-separated list of candidate mechanisms to use. If this parameter is NULL or empty
the library will query the supportedSASLMechanisms attribute from the server's rootDSE for the list of SASL mechanisms the server supports.  The  flags  parameter  controls  the
interaction used to retrieve any necessary SASL authentication parameters and should be one of:

LDAP_SASL_AUTOMATIC
use defaults if available, prompt otherwise

LDAP_SASL_INTERACTIVE
always prompt

LDAP_SASL_QUIET
never prompt

The  interact  function uses the provided defaults to handle requests from the SASL library for particular authentication parameters. There is no defined format for the defaults
information; it is up to the caller to use whatever format is appropriate for the supplied interact function.   The  sasl_interact  parameter  comes  from  the  underlying  SASL
library. When used with Cyrus SASL this is an array of sasl_interact_t structures. The Cyrus SASL library will prompt for a variety of inputs, including:

SASL_CB_GETREALM
the realm for the authentication attempt

SASL_CB_AUTHNAME
the username to authenticate

SASL_CB_PASS
the password for the provided username

SASL_CB_USER
the username to use for proxy authorization

SASL_CB_NOECHOPROMPT
generic prompt for input with input echoing disabled

SASL_CB_ECHOPROMPT
generic prompt for input with input echoing enabled

SASL_CB_LIST_END
indicates the end of the array of prompts

See the Cyrus SASL documentation for more details.

Applications  which need to manage connections asynchronously may use ldap_sasl_interactive_bind() instead of the synchronous version.  A valid mechs parameter must be supplied,
otherwise the library will be forced to query the server for a list of supported mechanisms, and this query will be performed synchronously.  The other parameters are  the  same
as  for  the  synchronous function, with three additional parameters.  The actual SASL mechanism that was used, and the message ID for use with ldap_result() will be returned in
rmechp and msgidp, respectively.  The value in rmechp must not be modified by the caller and must be passed back on each subsequent call. The message obtained from ldap_result()
must  be  passed  in the result parameter.  This parameter must be NULL when initiating a new Bind. The caller must free the result message after each call using ldap_msgfree().
The ldap_sasl_interactive_bind() function returns an LDAP result code. If the code is LDAP_SASL_BIND_IN_PROGRESS then the Bind is not complete yet, and  this  function  must  be
called again with the next result from the server.

REBINDING
The  ldap_set_rebind_proc function() sets the process to use for binding when an operation returns a referral. This function is used when an application needs to bind to another
server in order to follow a referral or search continuation reference.

The function takes ld, the rebind function, and the params, the arbitrary data like state information which the client might need to  properly  rebind.   The  LDAP_OPT_REFERRALS
option in the ld must be set to ON for the libraries to use the rebind function. Use the ldap_set_option function to set the value.

The rebind function parameters are as follows:

The ld parameter must be used by the application when binding to the referred server if the application wants the libraries to follow the referral.

The url parameter points to the URL referral string received from the LDAP server.  The LDAP application can use the ldap_url_parse(3) function to parse the string into its com‐
ponents.

The request parameter specifies the type of request that generated the referral.

The msgid parameter specifies the message ID of the request generating the referral.

The params parameter is the same value as passed originally to the ldap_set_rebind_proc() function.

The LDAP libraries set all the parameters when they call the rebind function. The application should not attempt to free either the ld or the url structures in the rebind  func‐
tion.

The  application  must  supply to the rebind function the required authentication information such as, user name, password, and certificates. The rebind function must use a syn‐
chronous bind method.

UNBINDING
The ldap_unbind() call is used to unbind from the directory, terminate the current association, and free the resources contained in the ld structure.  Once  it  is  called,  the
connection  to  the LDAP server is closed, and the ld structure is invalid.  The ldap_unbind_s() call is just another name for ldap_unbind(); both of these calls are synchronous
in nature.

The ldap_unbind_ext() and ldap_unbind_ext_s() allows the operations to specify  controls.

ERRORS
Asynchronous routines will return -1 in case of error, setting the ld_errno parameter of the ld structure.  Synchronous  routines  return  whatever  ld_errno  is  set  to.   See
ldap_error(3) for more information.

NOTES
If  an anonymous bind is sufficient for the application, the rebind process need not be provided. The LDAP libraries with the LDAP_OPT_REFERRALS option set to ON (default value)
will automatically follow referrals using an anonymous bind.

If the application needs stronger authentication than an anonymous bind, you need to provide a rebind process for that authentication method.  The bind method must  be  synchro‐
nous.

SEE ALSO
ldap(3), ldap_error(3), ldap_open(3), ldap_set_option(3), ldap_url_parse(3) RFC 4422 (http://www.rfc-editor.org), Cyrus SASL (http://asg.web.cmu.edu/sasl/)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                           LDAP_BIND(3)
LDAP_BIND(3)                                                                    Library Functions Manual                                                                    LDAP_BIND(3)

NAME
ldap_bind,   ldap_bind_s,   ldap_simple_bind,  ldap_simple_bind_s,  ldap_sasl_bind,  ldap_sasl_bind_s,  ldap_sasl_interactive_bind_s,  ldap_parse_sasl_bind_result,  ldap_unbind,
ldap_unbind_s, ldap_unbind_ext, ldap_unbind_ext_s, ldap_set_rebind_proc - LDAP bind routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_bind(LDAP *ld, const char *who, const char *cred,
int method);

int ldap_bind_s(LDAP *ld, const char *who, const char *cred,
int method);

int ldap_simple_bind(LDAP *ld, const char *who, const char *passwd);

int ldap_simple_bind_s(LDAP *ld, const char *who, const char *passwd);

int ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,
struct berval *cred, LDAPControl *sctrls[],
LDAPControl *cctrls[], int *msgidp);

int ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,
struct berval *cred, LDAPControl *sctrls[],
LDAPControl *cctrls[], struct berval **servercredp);

int ldap_parse_sasl_bind_result(LDAP *ld, LDAPMessage *res,
struct berval **servercredp, int freeit);

int ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn,
const char *mechs,
LDAPControl *sctrls[], LDAPControl *cctrls[],
unsigned flags, LDAP_SASL_INTERACT_PROC *interact,
void *defaults);

int ldap_sasl_interactive_bind(LDAP *ld, const char *dn,
const char *mechs,
LDAPControl *sctrls[], LDAPControl *cctrls[],
unsigned flags, LDAP_SASL_INTERACT_PROC *interact,
void *defaults, LDAPMessage *result,
const char **rmechp, int *msgidp);

int (LDAP_SASL_INTERACT_PROC)(LDAP *ld, unsigned flags, void *defaults, void *sasl_interact);

int ldap_unbind(LDAP *ld);

int ldap_unbind_s(LDAP *ld);

int ldap_unbind_ext(LDAP *ld, LDAPControl *sctrls[],
LDAPControl *cctrls[]);

int ldap_unbind_ext_s(LDAP *ld, LDAPControl *sctrls[],
LDAPControl *cctrls[]);

int ldap_set_rebind_proc (LDAP *ld, LDAP_REBIND_PROC *ldap_proc, void *params);

int (LDAP_REBIND_PROC)(LDAP *ld, LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *params);

DESCRIPTION
These routines provide various interfaces to the LDAP bind operation.  After an association with an LDAP server is made using ldap_init(3), an LDAP bind operation should be per‐
formed  before  other operations are attempted over the connection.  An LDAP bind is required when using Version 2 of the LDAP protocol; it is optional for Version 3 but is usu‐
ally needed due to security considerations.

There are three types of bind calls, ones providing simple authentication, ones providing SASL authentication, and general routines  capable  of  doing  either  simple  or  SASL
authentication.

SASL  (Simple  Authentication and Security Layer) can negotiate one of many different kinds of authentication.  Both synchronous and asynchronous versions of each variant of the
bind call are provided.  All routines take ld as their first parameter, as returned from ldap_init(3).

SIMPLE AUTHENTICATION
The simplest form of the bind call is ldap_simple_bind_s().  It takes the DN to bind as in who, and the userPassword associated with the entry in passwd.   It  returns  an  LDAP
error  indication  (see ldap_error(3)).  The ldap_simple_bind() call is asynchronous, taking the same parameters but only initiating the bind operation and returning the message
id of the request it sent.  The result of the operation can be obtained by a subsequent call to ldap_result(3).

GENERAL AUTHENTICATION
The ldap_bind() and ldap_bind_s() routines can be used when the authentication method to use needs to be selected at runtime.  They both take an extra method parameter selecting
the  authentication  method  to  use.   It  should  be  set to LDAP_AUTH_SIMPLE to select simple authentication.  ldap_bind() returns the message id of the request it initiates.
ldap_bind_s() returns an LDAP error indication.

SASL AUTHENTICATION
For SASL binds the server always ignores any provided DN, so the dn parameter should always be NULL.  ldap_sasl_bind_s() sends a single SASL bind request  with  the  given  SASL
mechanism and credentials in the cred parameter. The format of the credentials depends on the particular SASL mechanism in use. For mechanisms that provide mutual authentication
the server's credentials will be returned in the servercredp parameter.  The routine returns an LDAP error indication (see ldap_error(3)).  The ldap_sasl_bind()  call  is  asyn‐
chronous,  taking  the  same parameters but only sending the request and returning the message id of the request it sent. The result of the operation can be obtained by a subse‐
quent call to ldap_result(3).  The result must be additionally parsed by ldap_parse_sasl_bind_result() to obtain any server credentials sent from the server.

Many SASL mechanisms require multiple message exchanges to perform a complete authentication. Applications should generally use ldap_sasl_interactive_bind_s() rather than  call‐
ing  the  basic ldap_sasl_bind() functions directly. The mechs parameter should contain a space-separated list of candidate mechanisms to use. If this parameter is NULL or empty
the library will query the supportedSASLMechanisms attribute from the server's rootDSE for the list of SASL mechanisms the server supports.  The  flags  parameter  controls  the
interaction used to retrieve any necessary SASL authentication parameters and should be one of:

LDAP_SASL_AUTOMATIC
use defaults if available, prompt otherwise

LDAP_SASL_INTERACTIVE
always prompt

LDAP_SASL_QUIET
never prompt

The  interact  function uses the provided defaults to handle requests from the SASL library for particular authentication parameters. There is no defined format for the defaults
information; it is up to the caller to use whatever format is appropriate for the supplied interact function.   The  sasl_interact  parameter  comes  from  the  underlying  SASL
library. When used with Cyrus SASL this is an array of sasl_interact_t structures. The Cyrus SASL library will prompt for a variety of inputs, including:

SASL_CB_GETREALM
the realm for the authentication attempt

SASL_CB_AUTHNAME
the username to authenticate

SASL_CB_PASS
the password for the provided username

SASL_CB_USER
the username to use for proxy authorization

SASL_CB_NOECHOPROMPT
generic prompt for input with input echoing disabled

SASL_CB_ECHOPROMPT
generic prompt for input with input echoing enabled

SASL_CB_LIST_END
indicates the end of the array of prompts

See the Cyrus SASL documentation for more details.

Applications  which need to manage connections asynchronously may use ldap_sasl_interactive_bind() instead of the synchronous version.  A valid mechs parameter must be supplied,
otherwise the library will be forced to query the server for a list of supported mechanisms, and this query will be performed synchronously.  The other parameters are  the  same
as  for  the  synchronous function, with three additional parameters.  The actual SASL mechanism that was used, and the message ID for use with ldap_result() will be returned in
rmechp and msgidp, respectively.  The value in rmechp must not be modified by the caller and must be passed back on each subsequent call. The message obtained from ldap_result()
must  be  passed  in the result parameter.  This parameter must be NULL when initiating a new Bind. The caller must free the result message after each call using ldap_msgfree().
The ldap_sasl_interactive_bind() function returns an LDAP result code. If the code is LDAP_SASL_BIND_IN_PROGRESS then the Bind is not complete yet, and  this  function  must  be
called again with the next result from the server.

REBINDING
The  ldap_set_rebind_proc function() sets the process to use for binding when an operation returns a referral. This function is used when an application needs to bind to another
server in order to follow a referral or search continuation reference.

The function takes ld, the rebind function, and the params, the arbitrary data like state information which the client might need to  properly  rebind.   The  LDAP_OPT_REFERRALS
option in the ld must be set to ON for the libraries to use the rebind function. Use the ldap_set_option function to set the value.

The rebind function parameters are as follows:

The ld parameter must be used by the application when binding to the referred server if the application wants the libraries to follow the referral.

The url parameter points to the URL referral string received from the LDAP server.  The LDAP application can use the ldap_url_parse(3) function to parse the string into its com‐
ponents.

The request parameter specifies the type of request that generated the referral.

The msgid parameter specifies the message ID of the request generating the referral.

The params parameter is the same value as passed originally to the ldap_set_rebind_proc() function.

The LDAP libraries set all the parameters when they call the rebind function. The application should not attempt to free either the ld or the url structures in the rebind  func‐
tion.

The  application  must  supply to the rebind function the required authentication information such as, user name, password, and certificates. The rebind function must use a syn‐
chronous bind method.

UNBINDING
The ldap_unbind() call is used to unbind from the directory, terminate the current association, and free the resources contained in the ld structure.  Once  it  is  called,  the
connection  to  the LDAP server is closed, and the ld structure is invalid.  The ldap_unbind_s() call is just another name for ldap_unbind(); both of these calls are synchronous
in nature.

The ldap_unbind_ext() and ldap_unbind_ext_s() allows the operations to specify  controls.

ERRORS
Asynchronous routines will return -1 in case of error, setting the ld_errno parameter of the ld structure.  Synchronous  routines  return  whatever  ld_errno  is  set  to.   See
ldap_error(3) for more information.

NOTES
If  an anonymous bind is sufficient for the application, the rebind process need not be provided. The LDAP libraries with the LDAP_OPT_REFERRALS option set to ON (default value)
will automatically follow referrals using an anonymous bind.

If the application needs stronger authentication than an anonymous bind, you need to provide a rebind process for that authentication method.  The bind method must  be  synchro‐
nous.

SEE ALSO
ldap(3), ldap_error(3), ldap_open(3), ldap_set_option(3), ldap_url_parse(3) RFC 4422 (http://www.rfc-editor.org), Cyrus SASL (http://asg.web.cmu.edu/sasl/)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                           LDAP_BIND(3)
LDAP_BIND(3)                                                                    Library Functions Manual                                                                    LDAP_BIND(3)

NAME
ldap_bind,   ldap_bind_s,   ldap_simple_bind,  ldap_simple_bind_s,  ldap_sasl_bind,  ldap_sasl_bind_s,  ldap_sasl_interactive_bind_s,  ldap_parse_sasl_bind_result,  ldap_unbind,
ldap_unbind_s, ldap_unbind_ext, ldap_unbind_ext_s, ldap_set_rebind_proc - LDAP bind routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_bind(LDAP *ld, const char *who, const char *cred,
int method);

int ldap_bind_s(LDAP *ld, const char *who, const char *cred,
int method);

int ldap_simple_bind(LDAP *ld, const char *who, const char *passwd);

int ldap_simple_bind_s(LDAP *ld, const char *who, const char *passwd);

int ldap_sasl_bind(LDAP *ld, const char *dn, const char *mechanism,
struct berval *cred, LDAPControl *sctrls[],
LDAPControl *cctrls[], int *msgidp);

int ldap_sasl_bind_s(LDAP *ld, const char *dn, const char *mechanism,
struct berval *cred, LDAPControl *sctrls[],
LDAPControl *cctrls[], struct berval **servercredp);

int ldap_parse_sasl_bind_result(LDAP *ld, LDAPMessage *res,
struct berval **servercredp, int freeit);

int ldap_sasl_interactive_bind_s(LDAP *ld, const char *dn,
const char *mechs,
LDAPControl *sctrls[], LDAPControl *cctrls[],
unsigned flags, LDAP_SASL_INTERACT_PROC *interact,
void *defaults);

int ldap_sasl_interactive_bind(LDAP *ld, const char *dn,
const char *mechs,
LDAPControl *sctrls[], LDAPControl *cctrls[],
unsigned flags, LDAP_SASL_INTERACT_PROC *interact,
void *defaults, LDAPMessage *result,
const char **rmechp, int *msgidp);

int (LDAP_SASL_INTERACT_PROC)(LDAP *ld, unsigned flags, void *defaults, void *sasl_interact);

int ldap_unbind(LDAP *ld);

int ldap_unbind_s(LDAP *ld);

int ldap_unbind_ext(LDAP *ld, LDAPControl *sctrls[],
LDAPControl *cctrls[]);

int ldap_unbind_ext_s(LDAP *ld, LDAPControl *sctrls[],
LDAPControl *cctrls[]);

int ldap_set_rebind_proc (LDAP *ld, LDAP_REBIND_PROC *ldap_proc, void *params);

int (LDAP_REBIND_PROC)(LDAP *ld, LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *params);

DESCRIPTION
These routines provide various interfaces to the LDAP bind operation.  After an association with an LDAP server is made using ldap_init(3), an LDAP bind operation should be per‐
formed  before  other operations are attempted over the connection.  An LDAP bind is required when using Version 2 of the LDAP protocol; it is optional for Version 3 but is usu‐
ally needed due to security considerations.

There are three types of bind calls, ones providing simple authentication, ones providing SASL authentication, and general routines  capable  of  doing  either  simple  or  SASL
authentication.

SASL  (Simple  Authentication and Security Layer) can negotiate one of many different kinds of authentication.  Both synchronous and asynchronous versions of each variant of the
bind call are provided.  All routines take ld as their first parameter, as returned from ldap_init(3).

SIMPLE AUTHENTICATION
The simplest form of the bind call is ldap_simple_bind_s().  It takes the DN to bind as in who, and the userPassword associated with the entry in passwd.   It  returns  an  LDAP
error  indication  (see ldap_error(3)).  The ldap_simple_bind() call is asynchronous, taking the same parameters but only initiating the bind operation and returning the message
id of the request it sent.  The result of the operation can be obtained by a subsequent call to ldap_result(3).

GENERAL AUTHENTICATION
The ldap_bind() and ldap_bind_s() routines can be used when the authentication method to use needs to be selected at runtime.  They both take an extra method parameter selecting
the  authentication  method  to  use.   It  should  be  set to LDAP_AUTH_SIMPLE to select simple authentication.  ldap_bind() returns the message id of the request it initiates.
ldap_bind_s() returns an LDAP error indication.

SASL AUTHENTICATION
For SASL binds the server always ignores any provided DN, so the dn parameter should always be NULL.  ldap_sasl_bind_s() sends a single SASL bind request  with  the  given  SASL
mechanism and credentials in the cred parameter. The format of the credentials depends on the particular SASL mechanism in use. For mechanisms that provide mutual authentication
the server's credentials will be returned in the servercredp parameter.  The routine returns an LDAP error indication (see ldap_error(3)).  The ldap_sasl_bind()  call  is  asyn‐
chronous,  taking  the  same parameters but only sending the request and returning the message id of the request it sent. The result of the operation can be obtained by a subse‐
quent call to ldap_result(3).  The result must be additionally parsed by ldap_parse_sasl_bind_result() to obtain any server credentials sent from the server.

Many SASL mechanisms require multiple message exchanges to perform a complete authentication. Applications should generally use ldap_sasl_interactive_bind_s() rather than  call‐
ing  the  basic ldap_sasl_bind() functions directly. The mechs parameter should contain a space-separated list of candidate mechanisms to use. If this parameter is NULL or empty
the library will query the supportedSASLMechanisms attribute from the server's rootDSE for the list of SASL mechanisms the server supports.  The  flags  parameter  controls  the
interaction used to retrieve any necessary SASL authentication parameters and should be one of:

LDAP_SASL_AUTOMATIC
use defaults if available, prompt otherwise

LDAP_SASL_INTERACTIVE
always prompt

LDAP_SASL_QUIET
never prompt

The  interact  function uses the provided defaults to handle requests from the SASL library for particular authentication parameters. There is no defined format for the defaults
information; it is up to the caller to use whatever format is appropriate for the supplied interact function.   The  sasl_interact  parameter  comes  from  the  underlying  SASL
library. When used with Cyrus SASL this is an array of sasl_interact_t structures. The Cyrus SASL library will prompt for a variety of inputs, including:

SASL_CB_GETREALM
the realm for the authentication attempt

SASL_CB_AUTHNAME
the username to authenticate

SASL_CB_PASS
the password for the provided username

SASL_CB_USER
the username to use for proxy authorization

SASL_CB_NOECHOPROMPT
generic prompt for input with input echoing disabled

SASL_CB_ECHOPROMPT
generic prompt for input with input echoing enabled

SASL_CB_LIST_END
indicates the end of the array of prompts

See the Cyrus SASL documentation for more details.

Applications  which need to manage connections asynchronously may use ldap_sasl_interactive_bind() instead of the synchronous version.  A valid mechs parameter must be supplied,
otherwise the library will be forced to query the server for a list of supported mechanisms, and this query will be performed synchronously.  The other parameters are  the  same
as  for  the  synchronous function, with three additional parameters.  The actual SASL mechanism that was used, and the message ID for use with ldap_result() will be returned in
rmechp and msgidp, respectively.  The value in rmechp must not be modified by the caller and must be passed back on each subsequent call. The message obtained from ldap_result()
must  be  passed  in the result parameter.  This parameter must be NULL when initiating a new Bind. The caller must free the result message after each call using ldap_msgfree().
The ldap_sasl_interactive_bind() function returns an LDAP result code. If the code is LDAP_SASL_BIND_IN_PROGRESS then the Bind is not complete yet, and  this  function  must  be
called again with the next result from the server.

REBINDING
The  ldap_set_rebind_proc function() sets the process to use for binding when an operation returns a referral. This function is used when an application needs to bind to another
server in order to follow a referral or search continuation reference.

The function takes ld, the rebind function, and the params, the arbitrary data like state information which the client might need to  properly  rebind.   The  LDAP_OPT_REFERRALS
option in the ld must be set to ON for the libraries to use the rebind function. Use the ldap_set_option function to set the value.

The rebind function parameters are as follows:

The ld parameter must be used by the application when binding to the referred server if the application wants the libraries to follow the referral.

The url parameter points to the URL referral string received from the LDAP server.  The LDAP application can use the ldap_url_parse(3) function to parse the string into its com‐
ponents.

The request parameter specifies the type of request that generated the referral.

The msgid parameter specifies the message ID of the request generating the referral.

The params parameter is the same value as passed originally to the ldap_set_rebind_proc() function.

The LDAP libraries set all the parameters when they call the rebind function. The application should not attempt to free either the ld or the url structures in the rebind  func‐
tion.

The  application  must  supply to the rebind function the required authentication information such as, user name, password, and certificates. The rebind function must use a syn‐
chronous bind method.

UNBINDING
The ldap_unbind() call is used to unbind from the directory, terminate the current association, and free the resources contained in the ld structure.  Once  it  is  called,  the
connection  to  the LDAP server is closed, and the ld structure is invalid.  The ldap_unbind_s() call is just another name for ldap_unbind(); both of these calls are synchronous
in nature.

The ldap_unbind_ext() and ldap_unbind_ext_s() allows the operations to specify  controls.

ERRORS
Asynchronous routines will return -1 in case of error, setting the ld_errno parameter of the ld structure.  Synchronous  routines  return  whatever  ld_errno  is  set  to.   See
ldap_error(3) for more information.

NOTES
If  an anonymous bind is sufficient for the application, the rebind process need not be provided. The LDAP libraries with the LDAP_OPT_REFERRALS option set to ON (default value)
will automatically follow referrals using an anonymous bind.

If the application needs stronger authentication than an anonymous bind, you need to provide a rebind process for that authentication method.  The bind method must  be  synchro‐
nous.

SEE ALSO
ldap(3), ldap_error(3), ldap_open(3), ldap_set_option(3), ldap_url_parse(3) RFC 4422 (http://www.rfc-editor.org), Cyrus SASL (http://asg.web.cmu.edu/sasl/)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                           LDAP_BIND(3)
LDAP_URL(3)                                                                     Library Functions Manual                                                                     LDAP_URL(3)

NAME
ldap_is_ldap_url, ldap_url_parse, ldap_free_urldesc - LDAP Uniform Resource Locator routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_is_ldap_url( const char *url )

int ldap_url_parse( const char *url, LDAPURLDesc **ludpp )

typedef struct ldap_url_desc {
char *      lud_scheme;     /* URI scheme */
char *      lud_host;       /* LDAP host to contact */
int         lud_port;       /* port on host */
char *      lud_dn;         /* base for search */
char **     lud_attrs;      /* list of attributes */
int         lud_scope;      /* a LDAP_SCOPE_... value */
char *      lud_filter;     /* LDAP search filter */
char **     lud_exts;       /* LDAP extensions */
int         lud_crit_exts;  /* true if any extension is critical */
/* may contain additional fields for internal use */
} LDAPURLDesc;

void ldap_free_urldesc( LDAPURLDesc *ludp );

DESCRIPTION
These routines support the use of LDAP URLs (Uniform Resource Locators) as detailed in RFC 4516.  LDAP URLs look like this:

ldap://hostport/dn[?attrs[?scope[?filter[?exts]]]]

where:
hostport is a host name with an optional ":portnumber"
dn is the search base
attrs is a comma separated list of attributes to request
scope is one of these three strings:
base one sub (default=base)
filter is filter
exts are recognized set of LDAP and/or API extensions.

Example:
ldap://ldap.example.net/dc=example,dc=net?cn,sn?sub?(cn=*)

URLs  that are wrapped in angle-brackets and/or preceded by "URL:" are also tolerated.  Alternative LDAP schemes such as ldaps:// and ldapi:// may be parsed using the below rou‐
tines as well.

ldap_is_ldap_url() returns a non-zero value if url looks like an LDAP URL (as opposed to some other kind of URL).  It can be  used  as  a  quick  check  for  an  LDAP  URL;  the
ldap_url_parse() routine should be used if a more thorough check is needed.

ldap_url_parse() breaks down an LDAP URL passed in url into its component pieces.  If successful, zero is returned, an LDAP URL description is allocated, filled in, and ludpp is
set to point to it.  If an error occurs, a non-zero URL error code is returned.

ldap_free_urldesc() should be called to free an LDAP URL description that was obtained from a call to ldap_url_parse().

SEE ALSO
ldap(3)
RFC 4516 &amp;lt;http://www.rfc-editor.org/rfc/rfc4516.txt&amp;gt;

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                            LDAP_URL(3)
LDAP_URL(3)                                                                     Library Functions Manual                                                                     LDAP_URL(3)

NAME
ldap_is_ldap_url, ldap_url_parse, ldap_free_urldesc - LDAP Uniform Resource Locator routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

int ldap_is_ldap_url( const char *url )

int ldap_url_parse( const char *url, LDAPURLDesc **ludpp )

typedef struct ldap_url_desc {
char *      lud_scheme;     /* URI scheme */
char *      lud_host;       /* LDAP host to contact */
int         lud_port;       /* port on host */
char *      lud_dn;         /* base for search */
char **     lud_attrs;      /* list of attributes */
int         lud_scope;      /* a LDAP_SCOPE_... value */
char *      lud_filter;     /* LDAP search filter */
char **     lud_exts;       /* LDAP extensions */
int         lud_crit_exts;  /* true if any extension is critical */
/* may contain additional fields for internal use */
} LDAPURLDesc;

void ldap_free_urldesc( LDAPURLDesc *ludp );

DESCRIPTION
These routines support the use of LDAP URLs (Uniform Resource Locators) as detailed in RFC 4516.  LDAP URLs look like this:

ldap://hostport/dn[?attrs[?scope[?filter[?exts]]]]

where:
hostport is a host name with an optional ":portnumber"
dn is the search base
attrs is a comma separated list of attributes to request
scope is one of these three strings:
base one sub (default=base)
filter is filter
exts are recognized set of LDAP and/or API extensions.

Example:
ldap://ldap.example.net/dc=example,dc=net?cn,sn?sub?(cn=*)

URLs  that are wrapped in angle-brackets and/or preceded by "URL:" are also tolerated.  Alternative LDAP schemes such as ldaps:// and ldapi:// may be parsed using the below rou‐
tines as well.

ldap_is_ldap_url() returns a non-zero value if url looks like an LDAP URL (as opposed to some other kind of URL).  It can be  used  as  a  quick  check  for  an  LDAP  URL;  the
ldap_url_parse() routine should be used if a more thorough check is needed.

ldap_url_parse() breaks down an LDAP URL passed in url into its component pieces.  If successful, zero is returned, an LDAP URL description is allocated, filled in, and ludpp is
set to point to it.  If an error occurs, a non-zero URL error code is returned.

ldap_free_urldesc() should be called to free an LDAP URL description that was obtained from a call to ldap_url_parse().

SEE ALSO
ldap(3)
RFC 4516 &amp;lt;http://www.rfc-editor.org/rfc/rfc4516.txt&amp;gt;

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                            LDAP_URL(3)
LDAP_GET_VALUES(3)                                                              Library Functions Manual                                                              LDAP_GET_VALUES(3)

NAME
ldap_get_values, ldap_get_values_len, ldap_count_values - LDAP attribute value handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

char **ldap_get_values(ld, entry, attr)
LDAP *ld;
LDAPMessage *entry;
char *attr;

struct berval **ldap_get_values_len(ld, entry, attr)
LDAP *ld;
LDAPMessage *entry;
char *attr;

int ldap_count_values(vals)
char **vals;

int ldap_count_values_len(vals)
struct berval **vals;

void ldap_value_free(vals)
char **vals;

void ldap_value_free_len(vals)
struct berval **vals;

DESCRIPTION
These  routines  are  used  to retrieve and manipulate attribute values from an LDAP entry as returned by ldap_first_entry(3) or ldap_next_entry(3).  ldap_get_values() takes the
entry and the attribute attr whose values are desired and returns a NULL-terminated array  of  the  attribute's  values.   attr  may  be  an  attribute  type  as  returned  from
ldap_first_attribute(3) or ldap_next_attribute(3), or if the attribute type is known it can simply be given.

The number of values in the array can be counted by calling ldap_count_values().  The array of values returned can be freed by calling ldap_value_free().

If  the attribute values are binary in nature, and thus not suitable to be returned as an array of char *'s, the ldap_get_values_len() routine can be used instead.  It takes the
same parameters as ldap_get_values(), but returns a NULL-terminated array of pointers to berval structures, each containing the length of and a pointer to a value.

The number of values in the array can be counted by calling ldap_count_values_len().  The array of values returned can be freed by calling ldap_value_free_len().

ERRORS
If an error occurs in ldap_get_values() or ldap_get_values_len(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the  error.   See  ldap_error(3)
for a description of possible error codes.

NOTES
These routines dynamically allocate memory which the caller must free using the supplied routines.

SEE ALSO
ldap(3), ldap_first_entry(3), ldap_first_attribute(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                     LDAP_GET_VALUES(3)
LDAP_GET_VALUES(3)                                                              Library Functions Manual                                                              LDAP_GET_VALUES(3)

NAME
ldap_get_values, ldap_get_values_len, ldap_count_values - LDAP attribute value handling routines

LIBRARY
OpenLDAP LDAP (libldap, -lldap)

SYNOPSIS
#include &amp;lt;ldap.h&amp;gt;

char **ldap_get_values(ld, entry, attr)
LDAP *ld;
LDAPMessage *entry;
char *attr;

struct berval **ldap_get_values_len(ld, entry, attr)
LDAP *ld;
LDAPMessage *entry;
char *attr;

int ldap_count_values(vals)
char **vals;

int ldap_count_values_len(vals)
struct berval **vals;

void ldap_value_free(vals)
char **vals;

void ldap_value_free_len(vals)
struct berval **vals;

DESCRIPTION
These  routines  are  used  to retrieve and manipulate attribute values from an LDAP entry as returned by ldap_first_entry(3) or ldap_next_entry(3).  ldap_get_values() takes the
entry and the attribute attr whose values are desired and returns a NULL-terminated array  of  the  attribute's  values.   attr  may  be  an  attribute  type  as  returned  from
ldap_first_attribute(3) or ldap_next_attribute(3), or if the attribute type is known it can simply be given.

The number of values in the array can be counted by calling ldap_count_values().  The array of values returned can be freed by calling ldap_value_free().

If  the attribute values are binary in nature, and thus not suitable to be returned as an array of char *'s, the ldap_get_values_len() routine can be used instead.  It takes the
same parameters as ldap_get_values(), but returns a NULL-terminated array of pointers to berval structures, each containing the length of and a pointer to a value.

The number of values in the array can be counted by calling ldap_count_values_len().  The array of values returned can be freed by calling ldap_value_free_len().

ERRORS
If an error occurs in ldap_get_values() or ldap_get_values_len(), NULL is returned and the ld_errno field in the ld parameter is set to indicate the  error.   See  ldap_error(3)
for a description of possible error codes.

NOTES
These routines dynamically allocate memory which the caller must free using the supplied routines.

SEE ALSO
ldap(3), ldap_first_entry(3), ldap_first_attribute(3), ldap_error(3)

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                     LDAP_GET_VALUES(3)
LDAP.CONF(5)                                                                       File Formats Manual                                                                      LDAP.CONF(5)

NAME
ldap.conf, .ldaprc - LDAP configuration file/environment variables

SYNOPSIS
/etc/openldap/ldap.conf, ldaprc, .ldaprc, $LDAP&amp;lt;option-name&amp;gt;

DESCRIPTION
If the environment variable LDAPNOINIT is defined, all defaulting is disabled.

The ldap.conf configuration file is used to set system-wide defaults to be applied when running ldap clients.

Users may create an optional configuration file, ldaprc or .ldaprc, in their home directory which will be used to override the system-wide defaults file.  The file ldaprc in the
current working directory is also used.

Additional configuration files can be specified using the LDAPCONF and LDAPRC environment variables.  LDAPCONF may be set to the path of a configuration file.  This path can  be
absolute  or  relative  to the current working directory.  The LDAPRC, if defined, should be the basename of a file in the current working directory or in the user's home direc‐
tory.

Environmental variables may also be used to augment the file based defaults.  The name of the variable is the option name with an added prefix of LDAP.  For example,  to  define
BASE via the environment, set the variable LDAPBASE to the desired value.

Some options are user-only.  Such options are ignored if present in the ldap.conf (or file specified by LDAPCONF).

Thus the following files and variables are read, in order:
variable     $LDAPNOINIT, and if that is not set:
system file  /etc/openldap/ldap.conf,
user files   $HOME/ldaprc,  $HOME/.ldaprc,  ./ldaprc,
system file  $LDAPCONF,
user files   $HOME/$LDAPRC, $HOME/.$LDAPRC, ./$LDAPRC,
variables    $LDAP&amp;lt;uppercase option name&amp;gt;.
Settings late in the list override earlier ones.

SYNTAX
The configuration options are case-insensitive; their value, on a case by case basis, may be case-sensitive.

Blank lines are ignored.
Lines beginning with a hash mark (`#') are comments, and ignored.

Valid  lines are made of an option's name (a sequence of non-blanks, conventionally written in uppercase, although not required), followed by a value.  The value starts with the
first non-blank character after the option's name, and terminates at the end of the line, or at the last sequence of blanks before the end of the line.  The tokenization of  the
value,  if  any, is delegated to the handler(s) for that option, if any.  Quoting values that contain blanks may be incorrect, as the quotes would become part of the value.  For
example,

# Wrong - erroneous quotes:
URI     "ldap:// ldaps://"

# Right - space-separated list of URIs, without quotes:
URI     ldap:// ldaps://

# Right - DN syntax needs quoting for Example, Inc:
BASE    ou=IT staff,o="Example, Inc",c=US
# or:
BASE    ou=IT staff,o=Example2C Inc,c=US

# Wrong - comment on same line as option:
DEREF   never           # Never follow aliases

A line cannot be longer than LINE_MAX, which should be more than 2000 bytes on all platforms.  There is no mechanism to split a long line on multiple lines, either for beautifi‐
cation or to overcome the above limit.

OPTIONS
The different configuration options are:

URI &amp;lt;ldap[si]://[name[:port]] ...&amp;gt;
Specifies the URI(s) of an LDAP server(s) to which the LDAP library should connect.  The URI scheme may be any of ldap, ldaps or ldapi, which refer to LDAP over TCP, LDAP
over SSL (TLS) and LDAP over IPC (UNIX domain sockets), respectively.  Each server's name can be specified as a domain-style name or an IP address  literal.   Optionally,
the  server's name can followed by a ':' and the port number the LDAP server is listening on.  If no port number is provided, the default port for the scheme is used (389
for ldap://, 636 for ldaps://).  For LDAP over IPC, name is the name of the socket, and no port is required, nor allowed; note that  directory  separators  must  be  URL-
encoded, like any other characters that are special to URLs; so the socket

/usr/local/var/ldapi

must be specified as

ldapi://%2Fusr%2Flocal%2Fvar%2Fldapi

A space separated list of URIs may be provided.

BASE &amp;lt;base&amp;gt;
Specifies the default base DN to use when performing ldap operations.  The base must be specified as a Distinguished Name in LDAP format.

BINDDN &amp;lt;dn&amp;gt;
Specifies the default bind DN to use when performing ldap operations.  The bind DN must be specified as a Distinguished Name in LDAP format.  This is a user-only option.

DEREF &amp;lt;when&amp;gt;
Specifies how alias dereferencing is done when performing a search. The &amp;lt;when&amp;gt; can be specified as one of the following keywords:

never  Aliases are never dereferenced. This is the default.

searching
Aliases are dereferenced in subordinates of the base object, but not in locating the base object of the search.

finding
Aliases are only dereferenced when locating the base object of the search.

always Aliases are dereferenced both in searching and in locating the base object of the search.

HOST &amp;lt;name[:port] ...&amp;gt;
Specifies  the  name(s)  of  an  LDAP server(s) to which the LDAP library should connect.  Each server's name can be specified as a domain-style name or an IP address and
optionally followed by a ':' and the port number the ldap server is listening on.  A space separated list of hosts may be provided.  HOST is deprecated in favor of URI.

NETWORK_TIMEOUT &amp;lt;integer&amp;gt;
Specifies the timeout (in seconds) after which the poll(2)/select(2) following a connect(2) returns in case of no activity.

PORT &amp;lt;port&amp;gt;
Specifies the default port used when connecting to LDAP servers(s).  The port may be specified as a number.  PORT is deprecated in favor of URI.

REFERRALS &amp;lt;on/true/yes/off/false/no&amp;gt;
Specifies if the client should automatically follow referrals returned by LDAP servers.  The default is on.  Note that the command line  tools  ldapsearch(1)  &amp;co  always
override this option.

SIZELIMIT &amp;lt;integer&amp;gt;
Specifies  a  size limit (number of entries) to use when performing searches.  The number should be a non-negative integer.  SIZELIMIT of zero (0) specifies a request for
unlimited search size.  Please note that the server may still apply any server-side limit on the amount of entries that can be returned by a search operation.

TIMELIMIT &amp;lt;integer&amp;gt;
Specifies a time limit (in seconds) to use when performing searches.  The number should be a non-negative integer.  TIMELIMIT of zero (0) specifies unlimited search  time
to  be  used.   Please note that the server may still apply any server-side limit on the duration of a search operation.  VERSION {2|3} Specifies what version of the LDAP
protocol should be used.

TIMEOUT &amp;lt;integer&amp;gt;
Specifies a timeout (in seconds) after which calls to synchronous LDAP APIs will abort if no response is received.  Also used for any ldap_result(3) calls  where  a  NULL
timeout parameter is supplied.

SASL OPTIONS
If OpenLDAP is built with Simple Authentication and Security Layer support, there are more options you can specify.

SASL_MECH &amp;lt;mechanism&amp;gt;
Specifies the SASL mechanism to use.  This is a user-only option.

SASL_REALM &amp;lt;realm&amp;gt;
Specifies the SASL realm.  This is a user-only option.

SASL_AUTHCID &amp;lt;authcid&amp;gt;
Specifies the authentication identity.  This is a user-only option.

SASL_AUTHZID &amp;lt;authcid&amp;gt;
Specifies the proxy authorization identity.  This is a user-only option.

SASL_SECPROPS &amp;lt;properties&amp;gt;
Specifies Cyrus SASL security properties. The &amp;lt;properties&amp;gt; can be specified as a comma-separated list of the following:

none   (without any other properties) causes the properties defaults ("noanonymous,noplain") to be cleared.

noplain
disables mechanisms susceptible to simple passive attacks.

noactive
disables mechanisms susceptible to active attacks.

nodict disables mechanisms susceptible to passive dictionary attacks.

noanonymous
disables mechanisms which support anonymous login.

forwardsec
requires forward secrecy between sessions.

passcred
requires mechanisms which pass client credentials (and allows mechanisms which can pass credentials to do so).

minssf=&amp;lt;factor&amp;gt;
specifies  the  minimum  acceptable security strength factor as an integer approximating the effective key length used for encryption.  0 (zero) implies no protec‐
tion, 1 implies integrity protection only, 56 allows DES or other weak ciphers, 112 allows triple DES and other strong ciphers, 128 allows RC4, Blowfish and  other
modern strong ciphers.  The default is 0.

maxssf=&amp;lt;factor&amp;gt;
specifies the maximum acceptable security strength factor as an integer (see minssf description).  The default is INT_MAX.

maxbufsize=&amp;lt;factor&amp;gt;
specifies the maximum security layer receive buffer size allowed.  0 disables security layers.  The default is 65536.

GSSAPI OPTIONS
If OpenLDAP is built with Generic Security Services Application Programming Interface support, there are more options you can specify.

GSSAPI_SIGN &amp;lt;on/true/yes/off/false/no&amp;gt;
Specifies if GSSAPI signing (GSS_C_INTEG_FLAG) should be used.  The default is off.

GSSAPI_ENCRYPT &amp;lt;on/true/yes/off/false/no&amp;gt;
Specifies if GSSAPI encryption (GSS_C_INTEG_FLAG and GSS_C_CONF_FLAG) should be used. The default is off.

GSSAPI_ALLOW_REMOTE_PRINCIPAL &amp;lt;on/true/yes/off/false/no&amp;gt;
Specifies  if  GSSAPI  based authentication should try to form the target principal name out of the ldapServiceName or dnsHostName attribute of the targets RootDSE entry.
The default is off.

TLS OPTIONS
If OpenLDAP is built with Transport Layer Security support, there are more options you can specify.  These options are used when an ldaps:// URI is selected (by default or  oth‐
erwise) or when the application negotiates TLS by issuing the LDAP StartTLS operation.

TLS_CACERT &amp;lt;filename&amp;gt;
Specifies the file that contains certificates for all of the Certificate Authorities the client will recognize.

TLS_CACERTDIR &amp;lt;path&amp;gt;
Specifies the path of a directory that contains Certificate Authority certificates in separate individual files. The TLS_CACERT is always used before TLS_CACERTDIR.  This
parameter is ignored with GnuTLS.

When using Mozilla NSS, &amp;lt;path&amp;gt; may contain a Mozilla NSS cert/key database.  If &amp;lt;path&amp;gt; contains a Mozilla NSS cert/key database and CA cert files, OpenLDAP will  use  the
cert/key database and will ignore the CA cert files.

TLS_CERT &amp;lt;filename&amp;gt;
Specifies the file that contains the client certificate.  This is a user-only option.

When using Mozilla NSS, if using a cert/key database (specified with TLS_CACERTDIR), TLS_CERT specifies the name of the certificate to use:
TLS_CERT Certificate for Sam Carter
If using a token other than the internal built in token, specify the token name first, followed by a colon:
TLS_CERT my hardware device:Certificate for Sam Carter
Use certutil -L to list the certificates by name:
certutil -d /path/to/certdbdir -L

TLS_KEY &amp;lt;filename&amp;gt;
Specifies  the  file that contains the private key that matches the certificate stored in the TLS_CERT file. Currently, the private key must not be protected with a pass‐
word, so it is of critical importance that the key file is protected carefully.  This is a user-only option.

When using Mozilla NSS, TLS_KEY specifies the name of a file that contains the password for the key for the certificate specified with TLS_CERT.  The modutil command  can
be  used  to  turn off password protection for the cert/key database.  For example, if TLS_CACERTDIR specifies /home/scarter/.moznss as the location of the cert/key data‐
base, use modutil to change the password to the empty string:
modutil -dbdir ~/.moznss -changepw 'NSS Certificate DB'
You must have the old password, if any.  Ignore the WARNING about the running browser.  Press 'Enter' for the new password.

TLS_CIPHER_SUITE &amp;lt;cipher-suite-spec&amp;gt;
Specifies acceptable cipher suite and preference order.  &amp;lt;cipher-suite-spec&amp;gt; should be a cipher specification for the TLS library in  use  (OpenSSL,  GnuTLS,  or  Mozilla
NSS).  Example:

OpenSSL:
TLS_CIPHER_SUITE HIGH:MEDIUM:+SSLv2

GnuTLS:
TLS_CIPHER_SUITE SECURE256:!AES-128-CBC

To check what ciphers a given spec selects in OpenSSL, use:

openssl ciphers -v &amp;lt;cipher-suite-spec&amp;gt;

With GnuTLS the available specs can be found in the manual page of gnutls-cli(1) (see the description of the option --priority).

In older versions of GnuTLS, where gnutls-cli does not support the option --priority, you can obtain the — more limited — list of ciphers by calling:

gnutls-cli -l

When  using  Mozilla NSS, the OpenSSL cipher suite specifications are used and translated into the format used internally by Mozilla NSS.  There isn't an easy way to list
the cipher suites from the command line.  The authoritative list is in the source code for Mozilla NSS in the file sslinfo.c in the structure
static const SSLCipherSuiteInfo suiteInfo[]

TLS_PROTOCOL_MIN &amp;lt;major&amp;gt;[.&amp;lt;minor&amp;gt;]
Specifies minimum SSL/TLS protocol version that will be negotiated.  If the server doesn't support at least that version, the SSL handshake will fail.  To require TLS 1.x
or higher, set this option to 3.(x+1), e.g.,

TLS_PROTOCOL_MIN 3.2

would  require TLS 1.1.  Specifying a minimum that is higher than that supported by the OpenLDAP implementation will result in it requiring the highest level that it does
support.  This parameter is ignored with GnuTLS.

TLS_RANDFILE &amp;lt;filename&amp;gt;
Specifies the file to obtain random bits from when /dev/[u]random is not available. Generally set to the name of the EGD/PRNGD socket.  The environment variable  RANDFILE
can also be used to specify the filename.  This parameter is ignored with GnuTLS and Mozilla NSS.

TLS_REQCERT &amp;lt;level&amp;gt;
Specifies what checks to perform on server certificates in a TLS session, if any. The &amp;lt;level&amp;gt; can be specified as one of the following keywords:

never  The client will not request or check any server certificate.

allow  The  server  certificate  is  requested. If no certificate is provided, the session proceeds normally. If a bad certificate is provided, it will be ignored and the
session proceeds normally.

try    The server certificate is requested. If no certificate is provided, the session proceeds normally. If a bad certificate is provided,  the  session  is  immediately
terminated.

demand | hard
These  keywords  are  equivalent.  The server certificate is requested. If no certificate is provided, or a bad certificate is provided, the session is immediately
terminated. This is the default setting.

TLS_CRLCHECK &amp;lt;level&amp;gt;
Specifies if the Certificate Revocation List (CRL) of the CA should be used to verify if the server certificates have not been revoked. This requires TLS_CACERTDIR param‐
eter to be set. This parameter is ignored with GnuTLS and Mozilla NSS.  &amp;lt;level&amp;gt; can be specified as one of the following keywords:

none   No CRL checks are performed

peer   Check the CRL of the peer certificate

all    Check the CRL for a whole certificate chain

TLS_CRLFILE &amp;lt;filename&amp;gt;
Specifies  the  file containing a Certificate Revocation List to be used to verify if the server certificates have not been revoked. This parameter is only supported with
GnuTLS and Mozilla NSS.

ENVIRONMENT VARIABLES
LDAPNOINIT
disable all defaulting

LDAPCONF
path of a configuration file

LDAPRC basename of ldaprc file in $HOME or $CWD

LDAP&amp;lt;option-name&amp;gt;
Set &amp;lt;option-name&amp;gt; as from ldap.conf

FILES
/etc/openldap/ldap.conf
system-wide ldap configuration file

$HOME/ldaprc, $HOME/.ldaprc
user ldap configuration file

$CWD/ldaprc
local ldap configuration file

SEE ALSO
ldap(3), ldap_set_option(3), ldap_result(3), openssl(1), sasl(3)

AUTHOR
Kurt Zeilenga, The OpenLDAP Project

ACKNOWLEDGEMENTS
OpenLDAP Software is developed and maintained by The OpenLDAP Project &amp;lt;http://www.openldap.org/&amp;gt;.  OpenLDAP Software is derived from University of Michigan LDAP 3.3 Release.

OpenLDAP 2.4.44                                                                        2016/02/05                                                                           LDAP.CONF(5)

</plainxml>
